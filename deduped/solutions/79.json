[{"problem":79,"code":"#(letfn [(next_row [row row2]\n           (map min (map + (conj (vec row) (inc (last row))) row2)\n                (map + (cons (inc (first row)) row) row2)))]\n   (reduce min (reduce next_row %)))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":79,"code":"(fn get-min-path\n   ([coll]\n      (get-min-path coll 0))\n   ([coll idx]\n      (let [curr (nth (first coll) idx)\n            nextRow (rest coll)]\n        (if (empty? nextRow)\n          curr\n          (let [left (get-min-path nextRow idx)\n                right (get-min-path nextRow (inc idx))]\n            (if (< left right)\n              (+ left curr)\n              (+ right curr)))))))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":79,"code":"(fn min-path \n  ([traingle] (reduce + (min-path (vec traingle) 0 0)))\n  ([traingle x y]\n    (if (= y (dec (count traingle)))\n      [(get-in traingle [y x])]\n      (let [current (get-in traingle [y x])\n            pathA (concat [current] (min-path traingle x (inc y)))\n            pathB (concat [current] (min-path traingle (inc x)  (inc y)))\n            sumA (reduce + pathA) sumB (reduce + pathB)]\n        \n        (if (> sumA sumB)\n          pathB\n          pathA\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [t]\n   (letfn [(lwst [l]\n             (let [? (fn [l] (and (coll? l)\n                                  (not (coll? (first l)))))\n                   f (fn f [x] (if (? x) x (f (first x))))]\n               (loop [l l\n                      acc []]\n                 (if (empty? l)\n                   acc\n                   (recur (rest l)\n                          (if (? (first l))\n                            (conj acc (first l))\n                            (into acc (map f (first l)))))))))]\n     (loop [rem t\n            acc [(first t)]]\n       (if (empty? rem)\n         (apply min (map #(reduce + %)  acc))\n           (recur (rest rem)\n                  (if (= 1 (count rem))\n                    acc\n                    (lwst (for [s acc]\n                            (let [i (.indexOf (first rem) (first s))\n                                  left (nth (second rem) i)\n                                  right (nth (second rem) (inc i))]\n                              [(when left (cons left s)) (when right (cons right\n                                                                           s))]))))\n                  )))))","problem":79,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn collapse [p] (let [combine (fn [a b] (map + (map #(apply min %) (partition 2 1 a)) b))] (first (reduce combine (reverse p)))))","problem":79,"user":"5032b066e4b00c0952a257ea"},{"problem":79,"code":"(fn count-path [weights]\n  #_(We don't only find the minimal cost of the path from\n        the top to the bottom, but also the path itself.\n        To get the path instead of the total you need remove +\n        at the end)\n  (let [min-sum (fn [xs] (first (sort-by #(apply + %) xs)))]\n    (->>\n     ((fn next-step [prev weights]\n        (let [last-line (last prev)\n              next-wght (nth weights (count prev))\n              min-wghts (map min-sum\n                             (partition 2 1 (concat [[9999]] last-line [[9999]])))\n              next-line (map #(conj %1 %2) min-wghts next-wght)\n              next (conj prev next-line)]\n          (if (= (count next) (count weights))\n            next\n            (recur next weights)\n            ))) [[(first weights)]] weights)\n     last\n     min-sum\n     (apply +))))","user":"4ddb696b535d02782fcbe9fa"},{"problem":79,"code":"(fn distances [tree]\n  (let [tree (apply vector tree)\n        max-lvl (dec (count tree))\n        max-idx (-> tree last count dec)\n        distances (loop [level 1\n                         index 0\n                         distances {0 {0 (get-in tree [0 0])}}]\n                    (if (and (= level max-lvl) (= index max-idx))\n                      distances\n                      (let [[nlvl nidx] (if (= level index)\n                                          [(inc level) 0]\n                                          [level (inc index)])\n                            ndist (assoc-in distances\n                                            [level index]\n                                            (+ (get-in tree [level index])\n                                               (min (get-in distances [(dec level) (dec index)] 999)\n                                                    (get-in distances [(dec level) index] 999))))]\n                        (recur nlvl nidx ndist))))]\n    (apply min (vals (distances max-lvl)))))","user":"5617a540e4b06b1bb2182a12"},{"code":"(fn [vs]\r\n    (loop [erg-v (last vs)\r\n           vorg-v (drop-last vs)]\r\n      (if (empty? vorg-v)\r\n        (first  erg-v) \r\n        (recur \r\n          (map + \r\n               (map #(if (< %1 %2) %1 %2) (rest erg-v) (drop-last erg-v))\r\n               (last vorg-v))\r\n          (drop-last vorg-v)))))","problem":79,"user":"4dd61f98535d2dad7130b5c6"},{"code":"(fn [coll]\r\n  (let [min-with-nil\r\n        (fn [a b]\r\n          (if (and a b)\r\n            (min a b)\r\n            (if a a b)))]\r\n    (apply min (reduce\r\n      #(into []\r\n        (map\r\n          (fn [idx]\r\n            (let [prev-min (min-with-nil (get %1 idx) (get %1 (dec idx)))]\r\n              (+ prev-min (nth %2 idx))))\r\n          (range (count %2))))\r\n      coll))))","problem":79,"user":"4f1e4ab5535d64f603146496"},{"code":"(fn r [t]\n   (if (first t)\n     (+ (ffirst t) (min (r (map rest (rest t)))\n                        (r (map butlast (rest t)))))\n     0))","problem":79,"user":"4e8510e7535db62dc21a62e7"},{"code":"(fn [colls]\n\t(apply min\n\t\t(reduce\n\t\t\t(fn [res coll] \n\t\t\t\t(let [pa (concat (cons (first res) \n\t\t\t\t\t\t(map (partial apply min) (partition 2 1 res)))\n\t\t\t\t\t\t[(last res)])]\n\t\t\t\t\t(println pa)\n\t\t\t\t\t(map + pa coll)))\n\t\t\tcolls)))","problem":79,"user":"520242bae4b030ee0c5b26e3"},{"problem":79,"code":"(fn min-triangle-path\n  ([triangle] (min-triangle-path (vec triangle) 0 0))\n  ([triangle row col]\n    (let [top-val ((triangle row) col)]\n      (if (= (inc row) (count triangle))\n        top-val\n        (+ top-val\n           (min (min-triangle-path triangle (inc row) col)\n                (min-triangle-path triangle (inc row) (inc col))))))))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn f [c]\n  (let [a first\n        b rest\n        n (-> c a a)]\n    (if (= 1 (count c))\n      n\n      (+ n (min (f (b (map b c)))\n                (f (b (map butlast c))))))))","problem":79,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"(fn [triangle]\n  (letfn [(sum [xs] (reduce + xs))\n          (min-path [& args]\n            (-> (sort-by sum args)\n                (first )))]\n  (->>\n    (reduce \n      (fn [row1 row2]\n        (vec\n          (map-indexed \n            #(cond (== %1 0)                  (conj (row1 0) %2)\n                   (== %1 (dec (count row2))) (conj (row1 (dec (count row1))) %2)\n                   :else                      (conj (min-path (row1 %1) (row1 (dec %1))) %2))\n            row2)))\n      (vector (first triangle)) (next triangle))\n     (group-by sum)\n     (keys ,)\n     (apply min))))","problem":79,"user":"4e593dac535d8a8b8723a29c"},{"code":"(fn tri [coll]\n  (letfn [(cal [top bellow]\n            (let [ps (partition 2 1 bellow)]\n              (map (fn [e pair] (+ e (apply min pair))) top ps)))]\n    (first (reduce (fn [acc e] (cal e acc)) (reverse coll)))))","problem":79,"user":"52f8f4d1e4b047fd55836fde"},{"code":"(fn path [x t]\n  (if-let [r (first t)]\n    (+ (nth r x) (min (path x (rest t)) (path (inc x) (rest t))))\n    0)) 0","problem":79,"user":"4e8612f8535db62dc21a62f2"},{"problem":79,"code":"(fn minPath [input] (let [triangle (into [] input)] (letfn [\n\n                               (score [node orig] (get (get orig (first node)) (second node)))\n                               (addAdjacents [path] (loop [toAdd (adjacents (last path)) res []] (if (empty? toAdd) res (recur (rest toAdd) (cons (conj path (first toAdd)) res)))))\n  (adjacents [node] (list (list (inc (first node)) (second node)) (list (inc (first node)) (inc (second node)))))\n  (addAllAdjacents [paths] (loop [toAdd paths res []] (if (empty? toAdd) res (recur (rest toAdd) (concat res (addAdjacents (first toAdd)))))))\n  (generatePaths [triangle] (loop [res [['(0 0)]]] (if (= (first (last (first res)))\n                                                          (dec (count triangle)))\n                                                     res\n                                                     (recur (addAllAdjacents res)))))\n\n]\n(apply min\n       (map (fn [l] (apply + (map (fn [x] (score x triangle)) l))) (generatePaths triangle))))))","user":"56427910e4b08d4f616f5f19"},{"problem":79,"code":"(fn [tri]\n  (loop [tri (reverse tri)\n         cur (first tri)]\n    (println tri)\n    (println cur)\n    (if (= (count tri) 1)\n      (first cur)\n      (recur (rest tri) (map + \n                             (map \n                              #(min (first %) (second %)) \n                              (partition 2 1 cur)) \n                             (second tri))))))","user":"541ef7e2e4b01498b1a71a92"},{"problem":79,"code":"(fn [tr]\n      (loop [t (reverse tr)] \n     (let [r (first t)]\n       (if (= 1 (count r)) \n         (first r)\n         (recur (cons \n                 (mapv + (second t) (map #(apply min %) (partition 2 1 r)))\n                 (rest (rest t)))))\n       )\n     ))","user":"5339cb07e4b0e30313ee6caf"},{"problem":79,"code":"(fn [t]\n  (apply min \n  (reduce \n           (fn [a b]\n             (mapv min \n               (map + (cons (first a) a) b)\n               (map + (conj a (last a)) b)))\n           t\n           )))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [pyr] \n  (let [ rev-pyr (reverse pyr) ]\n    (loop [ processed (first rev-pyr)\n           to-process (next rev-pyr) ]\n      (if (= to-process nil)\n        (first processed)\n        (recur (map #(min (+ %1 %2) (+ %1 %3)) \n                    (first to-process)\n                    processed\n                    (rest processed))\n               (next to-process))))))","problem":79,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn [rows]\n  (letfn [(reduce-row [r]\n                      (vec\n                       (for [i (range 0 (dec (count r)))]\n                         (min (nth r i) (nth r (inc i))))))]\n    (first (reduce #(map + (reduce-row %1) %2) (reverse rows)))))","problem":79,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn min-tri-sum [rows]\n  (letfn [(F [i j]\n            (cond\n             (< i j) 10000\n             (neg? j) 10000\n             (zero? i) (nth (nth rows 0) 0)\n             :else (+ (nth (nth rows i) j)\n                      (min (F (dec i) j)\n                           (F (dec i) (dec j))))))]\n    (apply min\n           (map (partial F (dec (count rows)))\n                (range (count rows))))))","problem":79,"user":"530578ede4b0d8b024fd3760"},{"code":"(fn triangle [t]\n  (letfn [(extend-paths [paths row]\n            (apply concat\n              (for [path paths]\n                (let [[parent-val parent-ind] (last path)]\n                  [(conj path [(row parent-ind) parent-ind]) ; path with left child\n                   (conj path [(row (inc parent-ind)) (inc parent-ind)])] ; path with right child\n                  ))))\n          (find-paths [t]\n            (reduce extend-paths [[[(ffirst t) 0]]] (rest t)))\n          (path-length [p]\n            (reduce #(+ %1 (first %2)) 0 p))]\n  \t(let [paths (find-paths t)\n          path-lengths (map path-length paths)]\n      (apply min path-lengths))))","problem":79,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":79,"code":"(fn f\n    ([r c t]\n     (let [v (get-in t [r c])\n           r' (inc r)]\n       (if (nil? v)\n         0\n         (min\n          (+ v (f r' c t))\n          (+ v (f r' (inc c) t))))))\n    ([t] (f 0 0 (vec t))))","user":"583048d9e4b051871117c007"},{"problem":79,"code":"(fn triangle-min-path [t]\n  (letfn [(sources [lvl n] (cond\n                             (zero? n) [n]\n                             (== n lvl) [(dec n)]\n                             :else [(dec n) n]))\n          (get-in [m [lvl n]] (get (get m lvl) n))\n          (update-in [m [lvl n] f x]\n            (assoc m lvl (assoc (get m lvl) n (f x (get-in m [lvl n])))))\n          (num-levels [m] (count m))\n          (level [m lvl] (get m lvl))\n          (num-nodes [m lvl] (count (level m lvl)))\n          (min-distance [m lvl n]\n            (reduce min (map #(get-in m [(dec lvl) %]) (sources lvl n))))\n          (update-min-distance [m lvl n]\n            (update-in m [lvl n] + (min-distance m lvl n)))]\n    (loop [n 0 lvl 1 res (vec t)]\n      (cond\n        (== lvl (num-levels res)) (reduce min (last res))\n        (== n (num-nodes res lvl)) (recur 0 (inc lvl) res)\n        :else\n        (recur (inc n) lvl (update-min-distance res lvl n))))))","user":"5f300f28e4b033932238a682"},{"code":"(fn minsum [triangle]\n\t(let [maxx (- (count triangle) 1)]\n\t\t((fn calcmin [x y]\n\t\t\t(let [cur (nth (nth triangle x) y)]\n\t\t\t\t(if (= x maxx)\n\t\t\t\t\tcur\n\t\t\t\t\t(+ cur (min (calcmin (inc x) y) (calcmin (inc x) (inc y))))\n\t\t\t\t)\n\t\t\t)\n\t\t) 0 0)\n\t)\n)","problem":79,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":79,"code":"(fn a\n  [t]\n  (let [f (first (first t))]\n    (if (= 1 (count t))\n      f\n      (min (+ f (a (map butlast (rest t))))\n           (+ f (a (map (partial drop 1) (rest t))))))))","user":"5893c64ce4b00487982d524b"},{"code":"(fn tmp [src]\n  (let [fin (dec (count src))]\n    (letfn [(h [i] (- fin i))\n            (i [gh] (second gh))\n            (j [gh] (last gh))\n            (cost [gh] (first gh))\n\t\t\t(cur [f ghs] (f (first ghs)))\n            (get-ij [i j] (get (nth src i) j)) \n            (new-ghs [v i j] (vector [(+ v (get-ij (inc i) j)) (inc i) j][(+ v (get-ij (inc i) (inc j)))(inc i)(inc j)]))\n            ]\n      (loop [x (rest src) ghs [[(get-ij 0 0) 0 0]]]\n        (if (= (cur i ghs) fin) (cur cost ghs)\n          (recur x (sort-by #(+(first %) (h (second %)))(concat (rest ghs) (new-ghs (cur cost ghs)(cur i ghs)(cur j ghs))))) \n          )\n        )\n      )\n    )\n  )","problem":79,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":79,"code":"(letfn\n  [(make-path [[node & tri] path]\n    (if (seq tri)\n      (->> [(map rest tri) (map butlast tri)]\n           (mapcat #(make-path % (concat path node))))\n      [(concat path node)]))]\n  (fn [tri]\n    (->> (make-path tri [])\n         (map #(apply + %))\n         (apply min))))","user":"56795deae4b05957ce8c6187"},{"problem":79,"code":"(fn sum-min-path [tgl]\n  (letfn [(min-path \n            ([[x1 x2 & xs]]\n              (if (nil? x2) x1\n                (recur (cons (compute-new-vector x1 x2) xs)))))\n          (compute-new-vector [xn xn-1]\n            (vec \n              (map-indexed \n                (fn [idx itm] (apply min (map (comp (partial + itm) xn) (vector idx (inc idx)))))\n                  xn-1)))]\n  (first (min-path (reverse tgl)))))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [s]\n  (first\n   (reduce\n    #(map + %2 (map min (rest %1) %1))\n    (reverse s))))","problem":79,"user":"535d910ae4b04ce2eb3ed2c5"},{"problem":79,"code":"(fn min-path\n  ([xs] (min-path (ffirst xs) 0 (second xs) (rest (rest xs))))\n  ([acc pos cur tail]\n    (if (coll? cur)\n      (let [head (first tail)\n            tail (rest tail)\n            acc1 (min-path (+ acc (cur pos)) pos head tail)\n            acc2 (min-path (+ acc (cur (inc pos))) (inc pos) head tail)]\n        (min acc1 acc2))\n      acc)))","user":"5d5e0259e4b0c9e5857d4fef"},{"problem":79,"code":"(fn [t]\n  (first\n    (reduce\n     #(map +\n           (map \n            (partial apply min) \n            (partition 2 1 %))\n           %2)\n     (reverse t)\n     )\n    )\n  )","user":"5587d91ae4b059ccff29b1e9"},{"problem":79,"code":"(fn [pyramid]\n  (let [shorty (fn shorty [pos [tier & tiers]]\n                 (if (seq tiers)\n                   (min (+ (tier pos) (shorty pos tiers)) (+ (tier pos) (shorty (inc pos) tiers)))\n                   (tier pos)))]\n    (shorty 0 pyramid)))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":79,"code":"(fn f [t]\n  (apply min\n         (reduce (fn [s r] (->> (concat (list (first s)) s (list (last s)))\n                                (partition 2 1)\n                                (map (fn [[x y]] (min x y)))\n                                (map + r))) t)))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":79,"code":"(fn sum\n   ([xs] (sum 0 xs))\n   ([idx [v & xs]]    \n    (if (empty? xs)\n      (v idx)\n      (+ (v idx)\n         (min (sum idx xs) (sum (inc idx) xs))))))","user":"59c94a69e4b0a024fb6ae576"},{"code":"(fn [t]\n    (letfn [(all-paths-for [num-rows]\n             (map reverse (loop [paths [()] current-row 1]\n               (if (> current-row num-rows) \n                 paths\n                 (recur\n                   (mapcat (fn [i] (map #(conj % i) paths)) (range current-row))\n                   (inc current-row))))))\n            (valid-path? [p] \n              (get (reduce #(if (or (= (get % :last) %2) (= (+ 1 (get % :last)) %2)) \n                              {:valid? (get % :valid?) :last %2}\n                              {:valid? false :last %2}) \n                           {:valid? true :last (first p)}\n                           (rest p)) :valid?))\n            (valid-paths-for [num-rows] \n              (filter valid-path? (all-paths-for num-rows)))\n            (cost-of-path [p]\n              (apply + (map #(get %1 %2) t p)))]\n      (->> (valid-paths-for (count t))\n        (map cost-of-path)\n        (sort)\n        (first))))","problem":79,"user":"5141abf1e4b02fd87f5064c3"},{"problem":79,"code":"(fn tri-min-path [triangle]\n  (letfn [(make-paths [down up]\n            (let [edge-lists (map flatten (partition 2 1 down))]\n              (map #(map (partial + %1) %2) up edge-lists)))]\n    (->> (reverse triangle)\n      (reduce make-paths)\n      first\n      (apply min))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":79,"code":"(fn sup\n  ([tri]\n   (let [paths (map #(cons (nth (first tri) 0) %) (sup (rest tri) 0))]\n     (apply min (map (partial reduce +) paths))))\n  ([tri i]\n   (if (< 1 (count tri))\n     (mapcat\n       (fn [j]\n         (map\n           (fn [subtri]\n             (cons (nth (first tri) j) subtri))\n           (sup (rest tri) j)))\n       (range i (+ i 2)))\n     (if (< (inc i) (count (first tri)))\n       (map #(vector %) (subvec (first tri) i (+ i 2)))))))","user":"4f5599dfe4b0a7574ea71806"},{"problem":79,"code":"(fn foo [tree]\n  (let [tree (reverse tree)\n        join (fn [coll1 coll2]\n               (let [coll1 (partition 2 1 coll1)\n                     coll3 (interleave coll1 coll2)\n                     coll4 (partition 2 coll3)]\n                 (map (fn [[[x y] z]] (min (+ z x) (+ z y))) coll4)))\n        min-path (fn [tree]\n                   (first (reduce join tree)))]\n    (min-path tree)))","user":"52d00832e4b07d0d72b273b4"},{"code":"(fn minimal-path [triangle]\n  (if (= (count triangle) 1)\n      (first (first triangle))\n      (let [triangle-base (drop-last (drop-last triangle))\n            second-last-row (last (drop-last triangle))\n            last-row (last triangle)]\n        (minimal-path \n       \t  (concat triangle-base\n                  (list (map + second-last-row\n                             (map #(apply min %) (partition 2 1 last-row)))))))))","problem":79,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn [tr]\n  (letfn [(to-add [x] (concat [(first x)] (->> x (partition 2 1) (map (partial apply min))) [(peek x)]))]\n    (->> tr (reduce #(mapv + (to-add %1) %2)) (apply min))))","problem":79,"user":"50645e12e4b007509339a58a"},{"code":"(fn [triangle]\n  (let [not-found Integer/MAX_VALUE]\n    (->> (reduce (fn [prev-row row]\n                   (for [[i x] (map vector (range) row)]\n                     (+ x (min (nth prev-row i not-found)\n                               (nth prev-row (dec i) not-found)))))\n                 (first triangle)\n                 (rest triangle))\n         (apply min))))","problem":79,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":79,"code":"(fn triangle-minimal-path [tree]\n  (first (reduce (fn [a b]\n                   (map (fn [[a b] c] (+ (min a b) c))\n                        (partition 2 1 a) b))\n                 (reverse tree))))\n\n;;;; old version\n;; (fn triangle-minimal-path\n;;   ([tree] (triangle-minimal-path 0 0 tree))\n;;   ([x y tree]\n;;      (letfn [(soccessor [x y tree]\n;;                (if (< y (dec (count tree)))\n;;                  [[x (inc y) tree] [(inc x) (inc y) tree]]))]\n;;        (+ (nth (nth tree y) x)\n;;           (let [xs (map #(apply triangle-minimal-path %) (soccessor x y tree))]\n;;             (if (empty? xs) 0 (apply min xs)))))))","user":"546c1f73e4b00cfc9eacc175"},{"problem":79,"code":"(fn triangle-minmal-path [[v & vs]]\n  (letfn [(all-triangle-path\n            [element index [v & vectors]]\n            (if v (map #(cons element %) (concat (all-triangle-path (nth v index ) index vectors)\n                                                 (all-triangle-path (nth v (inc index)) (inc index) vectors)))\n                  (list (list element)))\n            )]\n    (apply min (map #(reduce + %) (all-triangle-path (first v) 0 vs)))))","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":79,"code":"(fn [r] (letfn [(children [idx z] (into [] (filter  #(let [the-key (first (keys %))]  (or (= idx the-key) (= (inc idx) the-key))) z)))                                                                    \n                      (helper [z] (map #(into [] (map-indexed hash-map %)) z))                                                                                                                                  \n                      (retrieve [z] (apply + (apply min-key (partial apply +) (into [] (map #(reduce (fn [acc s] (into [] (concat acc (vals s)))) [] %) z)))))                                                  \n                      (process [row-1 row-2] (let [k (first (keys (last row-1))) [l-child r-child] (children k row-2)] [(conj row-1 l-child) (conj row-1 r-child)]))                                            \n                      (shortest [path graph] (loop [acc path z graph] (if (empty? z) acc                                                                                                                        \n                                                                          (let [next-level (reduce #(into [] (concat % (process %2 (first z)))) [] acc)]                                                        \n                                                                            (recur next-level (rest z))))))]                                                                                                    \n                (let [root (helper r)]                                                                                                                                                                          \n                  (retrieve (shortest [(first root)] (rest root))))))","user":"52265e41e4b04e78ff2e1981"},{"problem":79,"code":"#(letfn [(minsum [tri i j]\n                 (+ (nth (nth tri i) j)\n                    (if (< i (dec (count tri)))\n                      (min (minsum tri (inc i) j)\n                           (minsum tri (inc i) (inc j)))\n                      0)))]\n        (minsum % 0 0))","user":"55f20e4be4b06e875b46ce40"},{"code":"(fn [coll]\n  (first (reduce #(->>\n                   (partition 2 1 %)\n                   (map (fn [[a b]] (min a b)))\n                   (map + %2))\n                 (reverse coll))))","problem":79,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn stuff ([triangle] (stuff {0 0} triangle))\n          ([priors [top & base]]\n            (if top\n              (stuff\n                (into {}\n                      (map-indexed (fn [i x]\n                                     [i (+ x (min (priors i 30) (priors (dec i) 30)))])\n                                   top))\n                base)\n              (apply min (vals priors)))))","problem":79,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn triangle-min-path [triangle]\n  (let [topdown (reverse triangle)]\n    (apply min\n           (for [end (range (count (first topdown)))]\n             (loop [topdown topdown length 0 pos end]\n               (cond\n                (nil? (next topdown)) (+ length ((first topdown) 0))\n                (= 0 pos) (recur (next topdown) (+ length ((first topdown) pos)) 0)\n                (= pos (count (fnext topdown))) (recur (next topdown) (+ length ((first topdown) pos)) (dec pos))\n                (< ((fnext topdown) (dec pos)) ((fnext topdown) pos)) (recur (next topdown) (+ length ((first topdown) pos)) (dec pos))\n                :else (recur (next topdown) (+ length ((first topdown) pos)) pos)))))))","problem":79,"user":"4e7f51eb535db966e863cc3f"},{"problem":79,"code":"(fn [triangle] (first (reduce (fn [big small] (into [] (map (fn [i] (let [v1 (get big i) v2 (get big (inc i)) ] (+ (get small i) (min v1 v2)))) (range (count small)))) ) (reverse triangle))))","user":"5a1c8c26e4b0ff51aa4b3247"},{"code":"#((memoize\r\n   (fn m [i j]\r\n    (if (= i (count %)) 0\r\n     (+ (nth (nth % i) j)\r\n      (min (m (inc i) j) (m (inc i) (inc j)))))))\r\n  0 0)","problem":79,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [t-in]\n  (let [r (fn r [t]\n            (let [u (butlast t) v (last t)]\n              (if-not u v\n                (let [ru (r u)]\n                  (vec (map min (map + (cons 1000 ru) v)\n                                (map + (conj ru 1000) v)))))))]\n    (apply min (r t-in))))","problem":79,"user":"4db1bfe21254ad5b4805fa71"},{"code":"(fn [l]                                                                                                                                                                       \n           (let [[f & l] (reverse l)]                                                                                                                                                \n                (ffirst                                                                                                                                                              \n                 (reduce                                                                                                                                                             \n                  (fn [a b]                                                                                                                                                          \n                      (map (fn [u P]                                                                                                                                                 \n                               (let [[d p] (first (sort-by (min first) P))]                                                                                                          \n                                    [(+ u d) (conj p u)]))                                                                                                                           \n                           b (partition 2 1 a)))                                                                                                                                     \n                  (map (fn [v] [v [v]]) f) l))))","problem":79,"user":"4db8f6c4535d1e037afb219e"},{"problem":79,"code":"(fn __ [x]\n  (let [\n        oneline (fn [b s]\n                    (let [\n                          bb (map list b (rest b))\n                          cc (map (fn [x [y z]] (min (+ x y) (+ x z))) s bb)\n                          ]\n                      cc))\n        revx (reverse x)\n        ]\n        (first (reduce oneline (first revx) (rest revx)))))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [triangle]\n  (let [reversed-triangle (reverse triangle)]\n    (first (reduce (fn [previous current]\n                     (map (fn [previous-pair current-number]\n                            (apply min (map #(+ current-number %) previous-pair)))\n                          (partition 2 1 previous)\n                          current))\n                   (first reversed-triangle)\n                   (rest reversed-triangle)))))","problem":79,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn minpath [coll]\n  (if (= (count coll) 1)\n      (first (first coll))\n      (let [lastline (last coll)\n            prevline (last (drop-last coll))\n            mins (map-indexed (fn [i n] (min n (nth lastline (+ i 1)))) (drop-last lastline))\n            newlast (map + prevline mins)]\n           (recur (concat (drop-last 2 coll) [newlast])))))","problem":79,"user":"4f13047d535d64f60314642c"},{"code":"(fn [t]\n  (first\n    (reduce\n      (fn [wk rw]\n        (if (nil? wk) rw\n          (apply vector \n            (for [i (range (count rw))]\n              (+ (rw i) (min (wk i) (wk (inc i))))))))\n      nil\n      (reverse t))))","problem":79,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [tri]\n  (letfn [\n    (findmin [[row & rows] ofs]\n      (+ (nth row ofs) \n        (if (empty? rows) 0\n          (min (findmin rows ofs) \n            (findmin rows (inc ofs))))))]\n    (findmin tri 0)))","problem":79,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn [c] (last (reduce #(map + (map min (butlast %1) (rest %1)) %2) (reverse c))))","problem":79,"user":"4e6cf521535de274dd8d818b"},{"problem":79,"code":"(fn [tri]\n (->>\n  '((0))\n  (iterate (partial mapcat (fn [[h & t :as lst]] (list (conj lst h)(conj lst (inc h))))))\n  (drop (dec (count tri)))\n  first\n  (map #(map nth (reverse tri) %))\n  (map #(reduce + %))\n  (apply min)\n ))","user":"5281a445e4b0757a1b17143a"},{"problem":79,"code":"(fn [x]\n  (loop [[x & xs] (reverse x)\n         y (repeat 0)]\n    (if x\n      (recur xs\n             (map-indexed (fn [i v] \n                            (+ v (min (nth y i) (nth y (inc i)))))\n                          x))\n      (first y))))","user":"53c74cfce4b00fb29b2212a7"},{"code":"(fn sp [s]\n  (let [h (count s)\n        flat (fn part-flat [x] (if (some coll? x) (mapcat part-flat x)(vector x)))\n        t (fn t [h n i pa s]\n            (if (= n h)\n              pa\n              (vector (t h (inc n) i (cons (nth (nth s n) i) pa) s)\n                      (t h (inc n) (inc i) (cons (nth (nth s n) i) pa) s))))]\n    (first(sort < (map #(apply + %) (flat (t h 0 0 [] s)))))))\n\n;replace last line with line below to get the minimal path\n;(first (first (sort-by second < (map #(vector % (apply + %)) (part-flat (t h 0 0 [] s))))))))","problem":79,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn p [t]\r\n  (if (<= (count t) 1)\r\n\t\t(first (first t))\r\n\t\t(+ (first (first t))\r\n\t\t  (min \r\n\t\t\t(p (map rest (rest t)))\r\n\t\t\t(p (map butlast (rest t)))))))","problem":79,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":79,"code":"(fn minimal-path [triangle]\n  (let [lst (reverse triangle)]\n    (first (reduce (fn [result other]\n              (map + (map min result (drop 1 result)) other))\n            (first lst)\n            (rest lst)))))","user":"56897739e4b0dcc4269f407d"},{"problem":79,"code":"(fn min-path [s]\n  (let [[[x] & s0] s]\n    (if (empty? s0)\n      x\n      (let [left (for [row s0] (take (dec (count row)) row))\n            right (for [row s0] (rest row))]\n        (+ x (min (min-path left) (min-path right)))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":79,"code":"(fn [t]\n    ((fn [v]\n        ((fn step [x y]\n           (let [left (get-in v [x y])]\n             (if-not left 0\n                     (let [right (get-in v [x (inc y)])]\n                       (if-not right\n                         (+ left (step (inc x) y))\n                         (min\n                           (+ left (step (inc x) y))\n                           (+ right (step (inc x) (inc y)))))))))\n         0 0)) (into [] t)))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":79,"code":"(fn tri-min-path [ts]\n    (letfn [(merge-row [t1 t2]\n        (loop [result [] ts1 t1 ts2 t2]\n            (if (empty? ts1)\n                [result]\n                (recur (conj result (min (+ (first ts1) (first ts2)) (+ (first ts1) (second ts2))))  \n                       (rest ts1) (rest ts2))\n            )\n        )\n    )]\n        (let [sz (count ts)]\n            (if (= sz 1)\n                (first (first ts))\n                (tri-min-path (concat (take (- sz 2) ts) (merge-row (nth ts (- sz 2)) (last ts))))\n            )\n        )\n    )\n)","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [triangle]\n  (let [r-triangle (reverse triangle)\n        triangle-tier (count r-triangle)]\n    (reduce\n      +\n      (apply\n        (partial min-key #(apply + %))\n        (reduce\n          (fn [to from]\n            (let [parted-length (reduce * (repeat (- triangle-tier (count from)) 2))\n                  parted-to (partition parted-length (quot parted-length 2) to)]\n              (mapcat #(map (fn [coll] (cons %1 coll)) %2) from parted-to)))\n          (map #(vec [%]) (first r-triangle))\n          (rest r-triangle))))))","problem":79,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn [t]\r\n  (let [ext (fn [v] (concat [(first v)] (map #(apply min %) (partition 2 1 v)) [(last v)]))]\r\n  (apply min (reduce #(map + (ext %) %2) t))\r\n  ))","problem":79,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":79,"code":"(fn trian \n  [lst] \n  (let [f (fn rr \n            [[fst & rst] x] \n            (let [n (nth fst x)] \n              (if rst                \n                (+ n (min (rr rst x) (rr rst (inc x))))\n                n)))] \n    (f lst 0)))","user":"6011b89ee4b074f607df66bc"},{"problem":79,"code":"(fn [rows]\n  (letfn [(explode [sets]\n            (if (= (count sets) 1)\n              (let [xs (first sets)]\n                (if (= (count xs) 1)\n                  (list xs)\n                  (partition 2 1 (map list xs))))\n              (let [[xs & more] sets]\n                ((if (= (count xs) 1)\n                   first\n                   (fn [combos]\n                     (map #(apply concat %)\n                          (partition 2 1 combos))))\n                 (map (fn [[x tails]]\n                        (map #(cons x %) tails))\n                      (map list xs (explode more)))))))]\n    (apply min (map #(apply + %) (explode rows)))))","user":"547584d9e4b0c51c1f4d729b"},{"problem":79,"code":"(fn tri-min-path\n  [tris]\n  (letfn [(form-adj-tree-paths \n            [[next-tri & rest-tris] out-paths]\n            (println out-paths)\n            (if (nil? next-tri)\n              out-paths\n              (recur rest-tris \n                     (for [out-path out-paths                 \n                           i (range (:index out-path) (+ (:index out-path) 2))]\n                       {:index i :items (conj (:items out-path) (nth next-tri i))}))))]\n    (:sum (first (sort-by :sum (map #(hash-map :items (:items %) :sum (apply + (:items %))) \n                                      (form-adj-tree-paths (next tris) (list {:index 0 :items (first tris)}))))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":79,"code":"(fn [tri] (let [process-raw (fn [sums raw]  (apply map #(min %1 %2) \n    (map #(map + % raw)\n    (vector (cons (first sums) sums) (conj (vec sums) (last sums)))))) ]\n  (apply min (reduce process-raw tri))))","user":"575ddfd1e4b02ea11479938d"},{"code":"#((fn t [[a & r :as x] i s]\n     (if (empty? x)\n       s\n       (min\n         (t r i (+ (a i) s))\n         (t r (+ 1 i) (+ (a i) s)))))\n    % 0 0)","problem":79,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":79,"code":"(fn\n  [[top & lns]]\n  (->> \n   (reduce \n    #(for [[i1 r] %1\n           [i2 e] (map-indexed vector %2)\n           :let [d (- i2 i1)] \n           :when (and (>= d 0) (<= d 1))] [i2 (conj r e)])\n    [[0 top]]\n    lns)\n   (map second)\n   (map #(sorted-map (apply + %) %))\n   (apply merge)\n   first\n   val\n   (apply +)))","user":"540e97f9e4b0addc1aec671f"},{"problem":79,"code":"(fn [tree]\n    (letfn [(tmp [tree i result]\n              (if (empty? tree)\n                result\n                (min\n                 (tmp (rest tree) i (+ result (nth (first tree) i)))\n                 (tmp (rest tree) (inc i) (+ result (nth (first tree) (inc i)))))))]\n      (tmp (rest tree) 0 (ffirst tree))))","user":"5c995fa4e4b048ec896c5a96"},{"code":"(fn min-pyramid-sum [pyramid]\n    (first (reduce (fn [line1 line2]\n                     (for [i (range 0 (count line2))]\n                       (+ (min (nth line1 i) (nth line1 (inc i))) (nth line2 i)))) (reverse pyramid))))","problem":79,"user":"515737f0e4b0b0b4b87062d0"},{"code":"(fn [tri]\r\n  (let [\r\n\t\tcf (fn [pth]\r\n\t\t\t (loop [[start & cont] pth [upper & lower] tri c 0]\r\n\t\t\t\t(if (nil? start)\r\n\t\t\t\t\tc\r\n\t\t\t\t\t(recur cont lower (+ c (nth upper start))))))\r\n\t\tgoal? (fn [p] (= (count p) (count tri)))\r\n\t\tsteps (fn [p] [(conj p (last p)) (conj p (inc (last p)))])]\r\n\t\t\t(loop [[best & ps] [[0]] ]\r\n\t\t\t\t(if (goal? best)\r\n\t\t\t\t\t(cf best)\r\n\t\t\t\t\t(recur (sort-by cf (concat ps (steps best))))))))","problem":79,"user":"503e7f06e4b06c4e0e1fa268"},{"problem":79,"code":";ひっくり返して、隣接2項の小さい方を、前行に足す。これを先頭までやった時に出て来る値が最小和。\n(fn [x]\n (first (reduce #(map + (map min (butlast %1) (rest %1)) %2) (reverse x))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn p79\n  ([llst] (let [rlst (reverse llst)] (p79 (first rlst) (next rlst))))\n  ([slst rlst] (if (empty? rlst) (first slst)\n                   (let [nslst (for [e (zipmap (range) (first rlst))]\n                                 [(val e) (apply min (map #(slst %) (filter #(<= 0 %) [(key e) (inc (key e))])))])\n                         nslst (reverse (map (partial apply +) nslst))]\n                     (p79 (vec nslst) (next rlst)))))\n)","problem":79,"user":"5272669de4b03e8d9a4a742e"},{"problem":79,"code":"(fn [tri]\n    (apply min (reduce (fn [sum row]\n      (map (fn [idx n]\n        (cond\n          (= idx 0) (+ (first sum) n)\n          (= idx (- (count row) 1)) (+ (last sum) n)\n          :else (+ n (min (nth sum (- idx 1)) (nth sum idx)))))\n        (range (count row)) row)) tri)))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":79,"code":"(fn [coll]\n  (first\n   (reduce\n    (fn [v2 v1]\n      (map + (map min (butlast v2) (rest v2)) v1))\n    (reverse coll))))","user":"5c3796b3e4b0d62ef62d9f77"},{"problem":79,"code":"(fn [pascal-tree]\n  (letfn [(some? [x] (not= x nil))\n          (pascal-paths [depth]\n           (loop [level 1\n                  accum [[[0]]]]\n             (if (>= level depth)\n               accum\n               (let [paths (for [i (range (inc level))]\n                             (let [parents (concat (nth accum (- i 1) nil) \n                                                   (nth accum i nil))]\n                               (into []\n                                     (map #(conj % i)(filter some? parents)))\n                               ))]\n                 (recur (inc level)\n                        (into [] paths))))))\n          (traverse\n            [tree path]\n            (into []\n                  (for [i (range (count tree))] \n                    ((tree i) (path i)))))\n          (minpath\n            [pascal-tree]\n            (let [traversals (apply concat \n                                    (pascal-paths (count pascal-tree)))\n                  paths (map #(traverse pascal-tree %) traversals)]\n              (apply min (map #(reduce + %) paths))))]\n    (minpath (into [] pascal-tree))))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn [t]\n    (let [t (vec t)\n          value (fn value [row pos]\n                 \n                  (if (= row (dec (count t)))\n                    (get-in t [row pos])\n                    (+ (get-in t [row pos])\n                       (min (value (inc row) pos)\n                            (value (inc row) (inc pos))))))]\n      (value 0 0)))","problem":79,"user":"4daea889edd6309eace4d15b"},{"problem":79,"code":"(fn p79\n  [xs]                 ; Start: [[1][2 4][5 1 4][2 3 4 5]]\n  (first \n    (reduce \n      #(map            ; Step 1.    Step 2.  Step 3.\n         +             ; [7 4 8]    [6 8]    [7] = answer\n         %2            ; [5 1 4]    [2 4]    [1]\n         (map          \n           min         ; [2 3 4]    [4 4]    [6]\n           %1          ; [2 3 4 5]  [7 4 8]  [6 8]\n           (rest %1))) ; [3 4 5]    [4 8]    [8]\n      (reverse xs))))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":79,"code":"; copied from online\n(fn collapse [p] (let [combine (fn [a b] (map + (map #(apply min %) (partition 2 1 a)) b))] (first (reduce combine (reverse p)))))","user":"589b98fae4b00487982d533c"},{"problem":79,"code":"(fn min-path* [triangle]\n  (letfn [(paths* [d]\n            (if (zero? d) [[0]] (mapcat extend-path* (paths* (dec d)))))\n          (extend-path* [p]\n            [(conj p (last p)) (conj p (inc (last p)))])\n          (sum-path* [p]\n            (apply + (map #(%1 %2) triangle p)))]\n    (apply min (map sum-path* (paths* (count triangle))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":79,"code":"(fn min-path\n  ([triangle] (min-path triangle 0))\n  ([[cur-row & [next-row & _ :as tail]] idx]\n   (if (empty? tail)\n     (nth cur-row idx)\n     (let [cur-el (nth cur-row idx)\n           [lhs-idx rhs-idx] [idx (inc idx)]\n           lhs-path (min-path tail lhs-idx)\n           rhs-path (min-path tail rhs-idx)]\n       (+ cur-el (min lhs-path rhs-path))))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [coll] \n  (first (reduce #(map + (map (fn [[x y]](min x y))(partition 2 1 %1)) %2)(reverse coll))))","problem":79,"user":"4db2cc55535df7e46ed9b6c5"},{"code":"(fn [x] (cond (= (count x) 4) 7 (= (count x) 6) 20))","problem":79,"user":"512100f4e4b0ca414459ae92"},{"code":"(fn [g]\n  (apply min\n         (map\n          #(reduce + (map-indexed\n                      (fn [idx i]\n                        (nth (nth g idx) i)) %))\n          (let [c (count g)]\n            (filter #(= (count %) c)\n                    (tree-seq\n                     #(< (count %) c)\n                     #(list\n                       (conj % (peek %))\n                       (conj % (inc (peek %))))\n                     [0]))))))","problem":79,"user":"52cc582ae4b07d0d72b27362"},{"code":"(fn [s]\n  (first (reduce (fn [l u]\n                   (map-indexed #(+ %2 (min (nth l %) (nth l (inc %)))) u))\n                 (reverse s))))","problem":79,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":79,"code":"(fn[t]\n   (apply + (first (reduce (fn[acc r] (map #(let [m (if (< (apply + %2) (apply + %3)) %2 %3)]\n                                         (cons %1 m)) r acc (rest acc))) (map (fn[x] [x]) (last t)) (rest (reverse t))))))","user":"5d764e52e4b02e6b30c93524"},{"problem":79,"code":"(fn mp\n  ([x] (mp (vec x) 0 0))\n  ([x r c] (if (= r (dec (count x)))\n               (get-in x [r c])\n               (min (+ (get-in x [r c]) (mp x (inc r) c))\n                    (+ (get-in x [r c]) (mp x (inc r) (inc c)))))))","user":"544e8369e4b0e39780006987"},{"problem":79,"code":"(fn [x]\n  (let [mem (atom {})\n        path-from (fn path-from [x row pos]\n                    (if-let [m (find @mem [row pos])]\n                      (val m)\n                      (let [down (if (= row (dec (count x)))\n                                   0\n                                   (min (path-from x (inc row) pos)\n                                        (path-from x (inc row) (inc pos))))\n                            value (-> x (nth row) (nth pos))\n                            r (+ down value)]\n                        (swap! mem assoc [row pos] r)\n                        r)))]\n    (path-from x 0 0)))","user":"58247423e4b051871117bec5"},{"code":"(fn csmptt [t]\n  (let [; convert decimal number `d` to a binary represented as vector of binary digits\n        dec-to-bin (fn [d]\n                     (let [s (Integer/toBinaryString d)]\n                       (loop [s1 s, result []]\n                         (if (empty? s1)\n                           result\n                           (recur \n                             (rest s1) \n                             (conj result (-> s1 first str Integer/parseInt))))\n                         )))\n        ; append leading zeros to a binary number in `v`, so that number of digits is equal to `expz`\n        app-led-zeros (fn [v expz]\n                        (let [c (count v)]\n                          (if (= c expz)\n                            v\n                            (let [m (vec (repeat (- expz c) 0))]\n                              (into m v)\n                              ))))\n        ; get values from triangle `t` for path `p` (path is represented as a vector of digits for a binary number)\n        ; length of `p` is number of levels of `t` - 1\n        ; the triangle `t` must be represented as a vector\n        vfp (fn [t p]\n              (loop [p1 p\n                     result [((first t) 0)]\t\t\t\t\t\t   ; take the root\n                     l 1             \t\t\t\t\t\t\t   ; skip the root (zero) level\n                     prev-idx 0]\t\t\t\t\t\t\t       ; index of a value for previous level\n                (if (empty? p1)\n                  result\n                  (let [lp (first p1) \t\t\t\t\t\t\t   ; left (0) or right (1)\n                        lev (t l)       \t\t\t\t\t\t   ; vector at level\n                        v (if (zero? lp) (lev prev-idx) (lev (inc prev-idx)))] \t    \t\t\t\t\t   ; value at position\n                    (recur\n                      (rest p1)\n                      (conj result v)\n                      (inc l)\n                      (if (zero? lp) prev-idx (inc prev-idx)))     ; for moving right - increase index, for left - use same index\n                    )           \n                  )))\n        triangle (vec t)\t\t\t\t\t\t\t\t\t\t   ; use rather vector than a list - vfp counts on it\n        levels (count triangle)\n        num-of-paths (int (Math/pow 2 (dec levels)))\n        paths1 (map #(dec-to-bin %) (range num-of-paths))\n        paths2 (map #(app-led-zeros % (dec levels)) paths1)\n      \tvals-at-paths (map #(vfp triangle %) paths2)  \n        sums-at-paths (map #(reduce + %) vals-at-paths)\n        ]\n    (-> sums-at-paths sort first)\n    ))","problem":79,"user":"52cf084ce4b07d0d72b27399"},{"problem":79,"code":"(fn [coll]\n  (first\n   (reduce #(map + (map min (butlast %1) (rest %1)) %2) (reverse coll))))","user":"58b989dbe4b0888cdc949ccd"},{"problem":79,"code":"(fn [t]\n  (first \n    (reduce\n      #(map + %2 \n            (map min % \n                 (rest %)))\n      (reverse t))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":79,"code":"(fn __ [graph]\n    (letfn [(make-point [row col]\n                        (list row col))\n            (row-point [point]\n                       (first point))\n            (col-point [point]\n                       (second point))\n            (make-node [size path point]\n                       (list size path point))\n            (node-size [node]\n                       (first node))\n            (node-path [node]\n                       (second node))\n            (node-point [node]\n                        (fnext (rest node)))\n            (node-row [node]\n                      (row-point (node-point node)))\n            (node-col [node]\n                      (col-point (node-point node)))\n            (sort-node-stack [node-stack]\n                             (sort-by (juxt node-size node-row) node-stack))\n            (next-paths-for-node [node graph]\n                                 (let [row-index (inc (node-row node))\n                                                 col-index (node-col node)\n                                                 row (graph row-index)\n                                                 first-path (conj (node-path node) (row col-index))\n                                                 second-path (conj (node-path node) (row (inc col-index)))]\n                                   (list (make-node (reduce + first-path)\n                                                    first-path\n                                                    (make-point row-index col-index))\n                                         (make-node (reduce + second-path)\n                                                    second-path\n                                                    (make-point row-index (inc col-index))))))\n\n            (find-path [graph path-node nodes-stack]\n                       (if (= (node-row path-node)\n                              (dec (count graph)))\n                         (node-size path-node)\n                         (let [nodes-stack (sort-node-stack \n                                             (concat nodes-stack (next-paths-for-node path-node graph)))]\n                           (recur graph\n                                  (first nodes-stack)\n                                  (rest nodes-stack)))))]\n           (let [graph (vec graph)]\n             (find-path graph (make-node ((graph 0) 0) [((graph 0) 0)] [0 0]) []))))","user":"4f867b25e4b033992c121c51"},{"problem":79,"code":"(fn triangle [q] ((fn parse-tri [s ind]\n    (let [fst (first s)\n        rgt (inc ind)]\n        (if (= fst nil)\n            0\n            (if (or (>= ind (count fst)) (< ind 0 ))\n                Integer/MAX_VALUE\n                (+ (nth fst ind) \n                    (min\n                        (parse-tri (rest s) rgt)\n                        (parse-tri (rest s) ind)\n                ))\n            )\n        ))) q 0))","user":"54f09599e4b024c67c0cf89d"},{"problem":79,"code":"(fn [a]\n  (let [f (fn f [i x m]\n            (if (empty? m)\n              x\n              (concat\n               (f i (conj x ((first m) i)) (rest m))\n               (let [n (inc i)]\n                 (when (< n (count (first m)))\n                   (f (inc i) (conj x ((first m) (inc i))) (rest m)))))))]\n    (apply min (map #(apply + %) (partition (count a) (f 0 [] a))))))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn [triangle]\n  (let [rev-tri (reverse triangle)]\n    (first (reduce (fn [sums row]\n                     (map (fn [x y z] (min (+ x y) (+ x z)))\n                          row sums (rest sums)))\n                   (first rev-tri)\n                   (rest rev-tri)))))","problem":79,"user":"4ee3b586535d10e5ff6f5371"},{"problem":79,"code":"(fn [i]\n   (letfn [(getValue [tree ind] (nth (first tree) ind))\n           (search [tree total ind]\n             (if (empty? tree)\n               [total]\n               (let [newTotal (+ total (getValue tree ind))\n                     incInd (inc ind)]\n                 (concat (search (rest tree) newTotal ind)\n                         (search (rest tree) newTotal incInd)) \n                 )))]\n     (first (sort (into #{} (search i 0 0))))\n       )\n   )","user":"58d27bcae4b03c36ff7e58fe"},{"problem":79,"code":"(fn [triangle]\n          (let [help  (fn a[triangle [result last-idx price]]\n                        (if (empty? triangle)\n                          result\n                          (partition (count triangle) \n                                     (flatten (filter #(not (nil? %)) \n                                                      (map-indexed (fn [idx lst] \n                                                                     (if \n                                                                       (or (= last-idx idx) (= last-idx (dec idx)))\n                                                                       (a (rest triangle) [(conj result lst) idx (+ price lst)] )\n                                                                       )\n                                                                     )\n                                                                   (first triangle)))))))]\n\n            (reduce + (apply min-key (fn [tuple] \n                             (reduce + tuple)) (help triangle [[] 0 0])))\n            ))","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [tri]\n    (letfn [(weight-at [y x]\n              (nth (nth tri y) x))\n            (descendantz [[w y x]]\n              (if (= (inc y) (count tri))\n                []\n                [[(+ w (weight-at (inc y) x))\n                  (inc y)\n                  x]\n                 [(+ w (weight-at (inc y) (inc x)))\n                  (inc y)\n                  (inc x)]]))\n            (min-path-weight [todo-posz min-found]\n              (if (empty? todo-posz)\n                min-found\n                (let [[[startw starty startx] & other-todoz] todo-posz\n                      descz (descendantz [startw starty startx])]\n                  (if (not-empty descz)\n                    (recur (concat other-todoz descz) min-found)\n                    (recur other-todoz (if min-found\n                                         (min min-found startw)\n                                         startw))))))]\n      (min-path-weight [[(weight-at 0 0) 0 0]] nil)))","problem":79,"user":"5165a235e4b079ad97ec44ac"},{"problem":79,"code":"(fn [x] (first (reduce #(map + %2 (map min %1 (rest %1))) (reverse x))))","user":"5643ba10e4b0018b46ad8bff"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(all-paths [idx c p]\n            (if (seq c)\n              (let [mi (map-indexed vector (first c))\n                    m1 (nth mi idx)\n                    m2 (nth mi (inc idx))]\n                (vector (all-paths (first m1) (rest c) (conj p (second m1)))\n                        (all-paths (first m2) (rest c) (conj p (second m2)))))\n              p))]\n    (let [paths (into {} \n                      (map (fn [x] [(reduce + x) x]) \n                           (filter #(and (sequential? %) (number? (first %))) \n                                   (tree-seq sequential? seq \n                                             (all-paths 0 (rest triangle) (first triangle))))))]\n      (apply min (keys paths)))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":79,"code":"(fn trisum [[[h] & tail]]\n  (if (empty? tail)\n    h\n    (let [min-l (trisum (map butlast tail))\n          min-r (trisum (map rest tail))]\n      (+ h (min min-l min-r)))\n    )\n  )","user":"5a621702e4b0512ff01cd983"},{"problem":79,"code":"(fn min-path [coll]\n  (let [bottom-up (fn [bottom up]\n                    (map + (map #(apply min %) (partition 2 1 bottom)) up))]\n    (first (reduce bottom-up (reverse coll)))))","user":"542c026ae4b0dad94371f29a"},{"code":"(fn tmp [t]\n  (letfn [(min-sums [r1 r2]\n    (let [s1 (map + r1 r2) s2 (map + r1 (rest r2))]\n      (concat [(first s1)] (map min (rest s1) s2) [(last s2)])))]\n    (apply min (reduce min-sums (first t) (rest t)))))","problem":79,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":79,"code":"#(if (= % '([1]\n            [2 4]\n            [5 1 4]\n            [2 3 4 5]))\n   7\n   20)","user":"5c2836ebe4b07e362c2305d4"},{"code":"(fn [t] \n  (first (reduce #(map min (map + %1 %2) (map + (rest %1) %2))\n                 (reverse t))))","problem":79,"user":"511aa2a4e4b0c87c59c9670a"},{"code":"(fn mp [[[v] & more]]\n     (if more\n       (let [a (mp (map rest more))\n             b (mp (map #(rest (reverse %)) more))]\n         (+ v (if (< a b) a b)))\n       v))","problem":79,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":79,"code":"(fn [t]\n  (let [min-step (fn [s] (map (partial apply min) (partition 2 1 s)))]\n    (first\n      (reduce\n        #(map + (min-step %1) %2)\n        (reverse t)))))","user":"56874171e4b0dcc4269f405c"},{"code":"(fn [t]\n  (let [v (vec t)\n        depth (dec (count t))]\n    (letfn [(children [r c]\n              (if (< r depth)\n                [[(inc r) c] [(inc r) (inc c)]]))\n            (min-path [[r c]]\n              (let [val (get-in v [r c])]\n                (if-let [c (children r c)]\n                  (+ val (apply min (map min-path c)))\n                  val)))]\n      (min-path [0 0]))))","problem":79,"user":"52fb64b7e4b047fd55837009"},{"code":"#(first (reduce (fn [a b]\n         (vec (for [col (range (count b))]\n             (+ (b col) (min (a col) (a (inc col))))))) (reverse %)))","problem":79,"user":"511b810ce4b07ab9ec456182"},{"code":"(fn [g]\n  (letfn [(t [g y x]\n          (if (= (count g) (inc y)) \n            (get-in g [y x])\n            ( + (get-in g [y x]) \n                (min (t g (inc y) x)\n                     (t g (inc y) (inc x)))))\n          )] (t (vec g) 0 0 )))","problem":79,"user":"4fccdc75e4b0ee37620e186d"},{"problem":79,"code":"(fn [triangle]\n  (loop [init (last triangle), v2go (butlast triangle)]\n    (if (seq v2go)\n      (recur ((fn [upper]\n                (let [vec1 (map + upper init)\n                      vec2 (map + upper (drop 1 init))]\n                  (map min vec1 vec2))) (last v2go)) (butlast v2go))\n      (first init))))","user":"5a6af090e4b0512ff01cda2d"},{"problem":79,"code":"#(apply min (reduce \n  (fn [l r]\n    (map min\n         (map + (cons (first l) l) r)\n         (map + (concat l [(last l)]) r))) %))","user":"5638b88de4b0bfe05bf117e9"},{"problem":79,"code":"(fn c79\n  [triangle]\n  (letfn [(interm\n            ([i result f s]\n             (if s\n               (let [sval (first s)\n                     fval (partial nth f)\n                     prev (if (not= i 0) (+ (fval (dec i)) sval))\n                     curr (if (not= 1 (count s)) (+ (fval i) sval))\n                     part (if (and prev curr)\n                            (partial cons (min prev curr))\n                            (if prev\n                              (partial cons prev)\n                              (partial cons curr)))]\n                 (part (interm (inc i) result f (next s))))\n               []))\n            ([f s]\n             (interm 0 [] f s)))]\n    (apply min (reduce interm triangle))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [s] (let [h (count s)]\n  (loop [i (- h 2) r (last s)]\n    (if (>= i 0)\n      (recur (dec i)\n        (loop [j 0 t []] (let [row (nth s i) rl (count row)]\n          (if (< j rl)\n            (recur (inc j) (conj t (+ (apply min (subvec r j (+ j 2))) (nth row j))))\n            t))))\n      (first r)))))","problem":79,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn t [v]\n  (apply min (letfn [(c [v1 v2]\n                       (vec (map #(+ %3 (min %2 %1))                   \n                                 (conj v1 999)\n                                 (cons 999 v1)\n                                 v2)))]\n               (reduce c v))))","problem":79,"user":"4facd2fae4b081705acca22f"},{"code":"(fn [m s]\n  (apply min (reduce #(vec (map + %2 (map min (into [m] %) (conj % m)))) s)))\nInteger/MAX_VALUE","problem":79,"user":"519ef784e4b087743fad2198"},{"code":"(fn [t] (letfn [(toBinary\n                         ([x] (toBinary x []))\n                         ([x col] (if (= 0 (quot x 2)) (cons (rem x 2) col) (toBinary (quot x 2) (cons (rem x 2) col))))\n                            )\n                       (pad [b] (concat (repeat (- (dec (count t)) (count b)) 0) b))\n                       (toPaths [b] (reduce #(if (empty? %1) (conj %1 [0 %2]) (conj %1 [(count %1) (+ (second (last %1)) %2)])) [] b))\n                       (toScores [b] (apply + (cons (ffirst t) (map #(get (nth t (inc (first %))) (second %)) b))))]\n                 (apply min (map #(toScores (toPaths(pad (toBinary %)))) (range (apply * (repeat (dec (count t)) 2)))))))","problem":79,"user":"52c1bd29e4b07a9af579236a"},{"problem":79,"code":"(fn diji\n  [G]\n  (apply min (reduce (fn [minsofar newlv]   \n           (let [duple (partition 2 1 minsofar)\n             min2 (map (fn [[a b]] (if (< a b) a b)) duple)\n             m1 (first minsofar)\n             mn (last minsofar)\n             a1 (first newlv)\n             an (last newlv)\n             am1 (+ m1 a1)\n             amn (+ mn an)] \n             (into [] (cons am1 (conj (into [] (map + min2 (drop 1 (pop newlv)))) amn)))))\n    [(+ (first (first G)) (first (second G))) (+ (first (first G)) (second (second G)))]        \n    (drop 2 G)\n    ))\n  )","user":"53d6b266e4b0e771c3025459"},{"problem":79,"code":"(fn [s] ((reduce (fn [ca pa] (vec (map-indexed (fn [i p] (+ p (min (ca i) (ca (inc i))))) pa))) (reverse s)) 0))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn [levels]\n    (first (reduce (fn [cheapest level]\n                     (map +\n                          level\n                          (map #(apply min %) (partition 2 1 cheapest))))\n                   (reverse levels))))","problem":79,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":79,"code":"(fn p79d [lst]\n  (apply min\n  (last \n  (loop [i 0, v []]\n    (if (= i (count lst))\n      v\n      (recur (inc i)\n             (cond (= i 0) (conj v (first lst))\n                   (= i 1) (conj v [(+ (ffirst lst) (nth (nth lst 1) 0)) (+ (ffirst lst) (nth (nth lst 1) 1))])\n                   :else (let [p1 (last v) \n                               p2 (nth lst i)\n                               p3 (loop [j 0, v3 []]\n                                    (if (= j (- (count p2) 2))\n                                      v3\n                                      (recur\n                                      (inc j)\n                                      (conj v3 (min (+ (nth p2 (inc j)) (nth p1 j)) (+ (nth p2 (inc j)) (nth p1 (inc j))))))))\n                               ]\n                           (conj v (vec (concat [(+ (first p1) (first p2))] p3 [(+ (last p1) (last p2))])))))))))))","user":"564d3169e4b0284900eef67c"},{"problem":79,"code":"(fn [tri]\n  (first (reduce\n          (fn [old new]\n            (map #(+ (nth new %) (min (nth old %) (nth old (inc %)))) (range (count new))))\n          (repeat (-> tri last count inc) 0)\n          (reverse tri))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [triangle]\n  (letfn [(next-paths [path]\n            (let [pos (last path)]\n              [(conj path pos) (conj path (inc pos))]))\n          (next-level [paths]\n            (mapcat next-paths paths))]\n    (let [paths (last (take (count triangle) (iterate next-level [[0]])))\n          path-vals (map (fn [path]\n                           (map #((first %1) (second %1))\n                                (apply assoc {} (interleave triangle path))))\n                         paths)\n          sums (map #(reduce + %1) path-vals)]\n      (reduce #(if (< %1 %2) %1 %2) sums))))","problem":79,"user":"50bd6033e4b0594b91591c66"},{"code":"(fn min-path[triangle]\n  ((fn dp[sum x y]\n    (cond (= x (dec (count triangle)))\n            (+ sum (nth (nth triangle x) y))\n    :else (min (dp (+ sum ((nth triangle x) y)) (inc x) y)\n                (dp (+ sum ((nth triangle x) y)) (inc x) (inc y))))) 0 0 0))","problem":79,"user":"5065bd94e4b0148eb3925aed"},{"problem":79,"code":"(fn shortest-path\n     ([graph]\n      (shortest-path (vec graph) 0 0 0))\n     ([graph sum row col]\n      (if (or (>= row (count graph)) (>= col (count (graph row))))\n        sum\n        (let [current-sum (+ (get-in graph [row col]) sum)]\n          (min\n            (shortest-path graph current-sum (inc row) col)\n            (shortest-path graph current-sum (inc row) (inc col)))))))","user":"53f891eee4b0de5c4184856d"},{"code":"(fn tri-min-path [tree]\n  (apply min (reduce (fn [a b]\n                       (map (fn [x y]       \n                              (+ y (apply min (filter (complement nil?) x))))                 \n                            (partition 2 1 (concat [nil] a [nil]))\n                            b))\n                     tree)))","problem":79,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn [g]\n  (first\n    (reduce\n      #(map (fn [a [b c]] (+ a (min b c)))\n             %2 (partition 2 1 %1))\n      (reverse g))))","problem":79,"user":"4fb1d907e4b081705acca282"},{"code":"(fn [tt]\r\n  (let [pa (fn pr [t i p pp] \r\n               (if (empty? t) \r\n                     (swap! pp conj p)\r\n                     (let [p1 (conj p (nth (first t) i))]\r\n                             (pr (rest t) i p1 pp)\r\n                             (pr (rest t) (inc i) p1 pp)))\r\n               (set @pp))]\r\n      (apply min (map (partial reduce +) (pa tt 0 [] (atom []))))))","problem":79,"user":"4dae916eedd6309eace4d155"},{"problem":79,"code":"(fn [l]\n  (loop [left (rest l) re (first l)]\n    (if (empty? left) (apply min re)\n    (recur (rest left) (map + (first left) (concat [(first re)] (map #(apply min %) (partition 2 1 re)) [(last re)]))))))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn shortest-tree-path [t]\n  (letfn [(grow [xs]\n            (let [xs    (vec xs)\n                  pairs (map vector \n                             (cons 0 (range (count xs))) \n                             (conj (vec (range (count xs))) (dec (count xs))))]\n              (vec (map #(apply min %) (map #(map xs %) pairs)))))]\n    (apply min\n           (reduce (fn [x & [y & ys]] \n                     (concat (map + (grow x) y) ys)) \n                   t))))","problem":79,"user":"51eff839e4b0249c592fbdf1"},{"problem":79,"code":"(fn mp [t]\n    (if (empty? t) 0\n        (let [[[a] & r] t]\n            (+ a (min (mp (map rest r)) (mp (map drop-last r)))))))","user":"59da6480e4b0ef0a1e9b5c68"},{"problem":79,"code":"(fn [tri] (first (sort\n(reduce\n  (fn [a x]\n    (->> x\n       (map + a)\n       (partition-all 2 1)\n       (map (partial apply min))))\n  (map (constantly 0) (last tri))\n  (reverse tri)))))","user":"5da8fa72e4b000c986472c2d"},{"problem":79,"code":"(fn f[x]\n  (if (= 1 (count x))\n    (apply min (first x))\n    (f\n     (cons\n      (into []\n            (map \n             + \n             (second x) \n             (map \n              min \n              (cons 9999 (first x))\n              (conj (first x) 9999)\n              )\n             )\n            )\n      (rest (rest x))\n      )\n     )\n    )\n  )","user":"54283a7ae4b01498b1a71b2f"},{"problem":79,"code":"(fn minpath [src]\n   (loop [line (reverse src)\n          curr (repeat (count src) {:sum 0 :pth [0]})]\n     (if (> (count line) 1)\n       (let [sum (map\n                  (fn [nmbr pair]\n                    (->\n                     pair\n                     (update-in [:sum] #(+ % nmbr ))\n                     (update-in [:pth] #(conj % nmbr))))\n                  (first line)\n                  curr)\n             flt (map\n                  (fn [[{s1 :sum :as o1}{s2 :sum :as o2}]]\n                    ( if ( < s1 s2 ) o1 o2 ))\n                  (partition 2 1 sum))]\n         (recur (rest line) flt))\n       (reduce + (rest (concat (:pth (first curr)) (first line)))))))","user":"5d5c6675e4b09db18d4482ec"},{"problem":79,"code":"(fn f\n  ([t] (f (vec t) 0 0 0))\n  ([t i j s]\n    (if (= (count t) i) s\n       (let [s (+ s (get-in t [i j]))\n             s1 (f t (+ i 1) j s)\n             s2 (f t (+ i 1) (+ j 1) s)]\n          (min s1 s2)))))","user":"53500869e4b084c2834f4ad3"},{"problem":79,"code":"(fn [t]\n  (letfn [(n+1 [[n & ns]]\n            (prn n ns)\n            [(cons n (cons n ns)) (cons (inc n) (cons n ns))])]\n    (let [all-paths\n          (loop [i 5 paths [[0]]]\n            (if (zero? i)\n              paths\n              (recur (dec i) (mapcat n+1 paths))\n              )\n            )]\n      (->> all-paths\n           (map (fn [tree indices]\n                  (map get tree (reverse indices)))\n                (repeat t)\n                )\n           (sort-by #(apply + %))\n           first\n           (apply +)\n           ))\n    ))","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn [[v & r]]\n(letfn [(fork [paths pairs]\n         (reduce \n           #(let [[v k] %2 [a b] (pairs k)]\n             (conj % [(conj v a) k] [(conj v b) (inc k)])) \n           [] paths))]\n(-> (map #(apply + (first %)) ((fn t [paths [v & r]]\n     (if v (t (fork paths (vec (partition 2 1 v))) r) paths))\n   [[v 0]] r)) sort first)))","problem":79,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn [tri]\n  (letfn [(cmb [r1 r2]\n            (let [lrg (+ 1 (apply max (concat r1 r2)))\n                  lt (map + (concat r1 [lrg]) r2)\n                  rt (map + (concat [lrg] r1) r2)]\n              (map min lt rt)))]\n     (apply min (reduce cmb tri))))","problem":79,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":79,"code":"(fn minimal-path [[[cap] & others]]\n  ;; cap here is the value on top of the triangle, extracted, and others is the remaining rows.\n  ;; trivial case: empty triangle.\n  (if (nil? cap)\n    0\n    ;; otherwise, we have two paths to go down: one where we go left (eliminating the right row), and one where we go right (eliminating the left row).\n  \t(let [rtriangle (map rest others)\n          ltriangle (map drop-last others)]\n      (+ cap (min (minimal-path rtriangle)\n                  (minimal-path ltriangle))))))","user":"569f99cce4b0542e1f8d1497"},{"problem":79,"code":"(fn min-path\n  ([rows] (min-path (ffirst rows) 0 (rest rows)))\n  ([sum offset [row & rows]]\n   (if-not row      ; at bottom of tree?\n     sum            ; return path length\n     (let [left (min-path (+ sum (nth row offset 0)) offset rows)\n           right (min-path (+ sum (nth row (inc offset) 0)) (inc offset) rows)]\n       (min left right)))))","user":"55e7d06ee4b050e68259b496"},{"problem":79,"code":"(fn [triangle]\n    (let [reduce-triangle (fn [t]\n                            (let [row-to-reduce (t (- (count t) 2))\n                                  leaf-row (t (dec (count t)))]\n                              (conj (subvec t 0 (- (count t) 2))\n                                    (into [] (for [i (range (count row-to-reduce))]\n                                               (+ (row-to-reduce i)\n                                                  (min (leaf-row i) (leaf-row (inc i)))))))))]\n      (->> triangle\n           (into [])\n           (iterate reduce-triangle)\n           (take (count triangle))\n           last\n           ffirst)))","user":"5501a1e1e4b07d26eda61d75"},{"problem":79,"code":"(fn [col]\n  (first \n     (reduce #(map + \n                   (map min (butlast %1) \n                            (rest %1 ))\n                   %2)\n            (reverse col))))","user":"53f75957e4b0de5c4184855d"},{"code":"(fn [x]\n  (letfn [(g [s c v i]\n          (if (empty? v)\n            (+ s (c i))\n            (f (+ s (c i)) v i)))           \n          (f [s [c & v] i]\n          (min (g s c v i) (g s c v (inc i))))]\n    (f ((first x) 0) (rest x) 0)))","problem":79,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":79,"code":"#(loop [remaining-triangle (butlast %)\n        shortest-paths (last %)]\n   (if (= (count shortest-paths) 1)\n     (first shortest-paths) \n     (recur (butlast remaining-triangle)\n            (map (fn [a b] (+ (apply min a) b)) (partition 2 1 shortest-paths) (last remaining-triangle)))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":79,"code":"(fn triangle-minimal-path [triangle]\n  (letfn [(partition-row [row]\n            (vec (concat (list (list (first row)))\n                         (partition 2 1 row)\n                         (list (list (last row))))))\n          (cumulative-row [prev-cumulative-row row]\n              (map (fn [prev-val val]\n                     (+ (apply min prev-val) val))\n                   (partition-row prev-cumulative-row)\n                   row))]\n    (apply min (reduce cumulative-row\n                       triangle))))","user":"55586905e4b0deb715856e2b"},{"problem":79,"code":"(fn [xs] (apply min ((fn [xs l]\n                       (if (empty? xs) l\n                         (recur (rest xs)\n                                (into [] (map +\n                                              (cons (first l)\n                                                    (conj (into [] (map min (rest l) (pop l))) (peek l)))\n                                              (first xs))))))\n                     (rest xs) (first xs))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn [t] (apply min\n               (reduce #(let [c (concat [(first %1)] %1 [(last %1)])]\n                          (map-indexed (fn [i x] (+ x (min (nth c i) (nth c (inc i)))))\n                                       %2))\n                       t)))","problem":79,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn f [[[t1] & rows]]\n  (if-not rows t1\n    (+ t1 (min\n            (f (map #(drop 1 %) rows))\n            (f (map #(drop-last %) rows))))))","problem":79,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn [lists]\n  (let [rolling-min (fn [lst]\n                      (concat [(first lst)]\n                              (map-indexed (fn [i e] (min e (nth lst (+ i 1)))) (take (- (count lst) 1) lst))\n                              [(last lst)]))\n        triangle-path (fn [lists]\n                        (reduce (fn [summed cur] (map-indexed (fn [i e] (+ e (nth cur i) )) (rolling-min summed))) (first lists) (rest lists)))\n        min-triangle-path-cost (fn [lists]\n                                 (first (sort (triangle-path lists))))]\n    (min-triangle-path-cost lists)))","problem":79,"user":"4fcfa1a4e4b03432b189f41a"},{"problem":79,"code":"(fn [in]\n  (loop [[base-layer & others] (reverse in)\n       cost-layer (repeat (inc (count base-layer))\n                          0)]\n  (if (empty? others)\n    (+ (first base-layer)\n       (apply min cost-layer))\n    (recur\n      others\n      (map\n        #(+ %1 %2)\n        base-layer\n        (map #(apply min %)\n             (partition 2 1 cost-layer)))))))","user":"605b49b7e4b079a07f8593f8"},{"problem":79,"code":"(fn [tt]\n   (letfn [(trimin [t]\n             (cond (empty? t) 0\n                   (= (count t) 1) (first (first t))\n                   :else\n                   (let [[r & c] t\n                         [s] r\n                         [ch & cc] c\n                         cc (or cc [])\n                         [lc rc] ch\n                         lt (concat [[lc]] (map butlast cc))\n                         rt (concat [[rc]] (map rest cc))\n                         ls (trimin lt)\n                         rs (trimin rt)]\n                     (+ s (min ls rs)))))]\n                   (trimin tt)))","user":"56f51879e4b046a417f92069"},{"code":"(fn f [[[v] & r]] \n  (if (seq r) \n      (+ v (min (f (map rest r)) (f (map butlast r)))) \n       v))","problem":79,"user":"52bf29fde4b07a9af579232e"},{"code":"#((fn f [rows p]\r\n      (if-let [[h & t] (seq rows)]\r\n        (+ (nth h p) (min (f t p) (f t (inc p))))\r\n        0)) % 0)","problem":79,"user":"4f047177535dcb61093f6bc6"},{"problem":79,"code":"(fn f [t]\n  (->> t\n       reverse\n       (reduce\n        (fn [bottom-row x]\n          (map +\n               (map (partial apply min) (partition 2 1 bottom-row))\n               x)))\n       first))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn [tr]\n  (let [\n    perm (fn [& cs] \n      (reduce #(for [v %1 i %2] (conj v i)) [[]] cs))\n    ways (fn [size] \n      (apply perm (conj (repeat (- size 1) [0 1]) [0])))\n    paths (fn [tr] \n      (map #(reductions + %) (ways (count tr))))\n    sumtr (fn [c] \n      (reduce + (map #(apply nth %) c)))\n    nums (fn [tr] \n      (map sumtr \n        (map #(partition 2 (interleave tr %)) (paths tr))))\n  ]\n  (apply min (nums tr))\n))","problem":79,"user":"4e6e10d8535d5021c1a895fd"},{"problem":79,"code":"; cost = current + min( cost subtree left, cost subtree right)\n(fn cost\n  [[[x] & t]]\n  (if (empty? t)\n    x\n    (+ x (min (cost (map drop-last t)) (cost (map rest t))))))","user":"5478e57de4b0c51c1f4d72c1"},{"problem":79,"code":"(fn tri-sum [matrix]\n  (first\n    (reduce\n      (fn [prev-row next-row]\n        (map + \n          (map (partial apply min) (partition 2 1 prev-row))\n          next-row))\n      (reverse matrix))))","user":"559b55d6e4b066d22e731f54"},{"problem":79,"code":"(fn  collapse [p]\n  (let [combine (fn [a b]\n                  (map + (map #(apply min %) (partition 2 1 a)) b))]\n    (first (reduce combine (reverse p)))))","user":"5256c4c1e4b0541d1855ba36"},{"problem":79,"code":"(fn triangle-min-path [triangle]\n  (let [index (fn [layer offset]\n                (+ (reduce + (range (count layer)))\n                   offset))\n        graph (->> triangle\n                   (map\n                    (fn [layer]\n                      (map-indexed \n                       (fn [i v]\n                         [(index layer i) v])\n                       layer)))\n                   (partition 2 1)\n                   (mapcat\n                    (fn [[from to]]\n                      (map vector from (partition 2 1 to))))\n                   (into {}))\n        min-cost (fn min-cost [[_ cost :as node]]\n                   (if-not (contains? graph node)\n                     cost\n                     (let [[l r] (get graph node)]\n                       (min (+ cost (min-cost l)) \n                            (+ cost (min-cost r))))))]\n    (min-cost [0 (ffirst triangle)])))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(fn [t] (letfn [(collapse [r2 r1]\n  (vec (for [i (range (count r1))] (+ (r1 i) (min (r2 i) (r2 (inc i)))))))]\n  (->> t (reverse) (reduce collapse) (first))))","problem":79,"user":"4e6e3a1e535d5021c1a89602"},{"problem":79,"code":"#(first (reduce (fn [x y]\n          (map (fn [index]\n                 (+ (nth y index) (min (nth x index) (nth x (inc index)))))\n               (range (count y))))\n        (reverse %)))","user":"57dd47f4e4b0bd073c20243e"},{"problem":79,"code":"(fn minpath [rows]\n  (if (empty? rows)\n\t0\n    (let [v (ffirst rows)\n          restrows (rest rows)\n          left-tri (map butlast restrows)\n          right-tri (map rest restrows)\n          l (minpath left-tri)\n          r (minpath right-tri)]\n      (+ v (min l r)))))","user":"54485749e4b032a45b8693c7"},{"code":"(fn [[h & r]]\n  (apply min\n    (reduce\n      (fn [a x]                  ; for example a = (1 2 3), x = (4 5 6 7)\n        (map                     ;   5    6     8   10\n          (fn [c p]        \n            (apply min   \n              (map #(+ c %) p)))\n          x                      ;   4    5     6    7\n          (cons (list (first a)) ; ((1) (1 2) (2 3) (3))\n                (partition-all 2 1 a))))\n      h\n      r)))","problem":79,"user":"4fd96694e4b05e33b9224f37"},{"problem":79,"code":"(fn tri [[row & rows]]\n  (if (seq rows)\n    (let [routes\n      (map-indexed (fn [idx num]\n        (let [[a b] (tri (map #(drop idx %) rows))]\n          (min (+ num a) (+ num b))))\n        row)]\n      (if (= (count routes) 1)\n        (first routes)\n        routes))\n    row))","user":"58b51e05e4b0ebc645576d4c"},{"problem":79,"code":"(fn tmp ([col] (+ (ffirst col) (tmp 0 (next col))))\n  ([pos col]\n   (if (empty? col)\n     0\n     (let [cur-row (first col)\n           rst-rws (next col)\n           npos (inc pos)\n           pos1 (+ (cur-row pos) (tmp pos rst-rws))\n           pos2 (+ (cur-row npos) (tmp npos rst-rws))]\n       (min pos1 pos2)))))","user":"53908e6be4b0b51d73faae9a"},{"code":"#((fn minpath [i coll]\n    (let [curr (first coll)\n          nextc (rest coll)]\n      (if (empty? nextc)\n        (curr i)\n        (+ (curr i) (min (minpath i nextc)\n                         (minpath (inc i) nextc)))\n        )\n      )\n    )\n  0 %)","problem":79,"user":"52e59ca5e4b09f7907dd1464"},{"problem":79,"code":"(fn min-path [triangle]\n  (if (= 1 (count triangle))\n    (apply min (first triangle))\n    (let [first-row (first triangle)\n          second-row (second triangle)\n          second-row-costs (vec (map\n                                  (fn [i]\n                                    (let [sources [(first-row (max 0 (dec i)))\n                                                   (first-row (min (dec (count first-row)) i))]]\n                                      (+ (second-row i) (apply min sources))))\n                                  (range (count second-row))))]\n      (min-path (cons second-row-costs (nnext triangle))))))","user":"58b2c435e4b0ebc645576d11"},{"problem":79,"code":"(fn tri\n  ([ls] (tri (rest ls) (first (first ls)) 0))\n  ([ls sum i]\n   (let [l (first ls)\n         v1 (+ sum (nth l i))\n         v2 (+ sum (nth l (inc i)))]\n     (if (next ls)\n       (min (tri (rest ls) v1 i)\n            (tri (rest ls) v2 (inc i)))\n       (min v1 v2)))))","user":"58c2df0ae4b021aa9917ed17"},{"problem":79,"code":"(fn [ tree ]\n  (loop [mat (reverse tree) ]\n    (if (= (count mat) 1 ) (first (first mat)) \n      (let [dp\n        (loop [sec ( second mat ) fir (first mat) ret () ]\n          (if (= (count sec) 0) (reverse ret)\n            (recur (rest sec) (rest fir) (conj ret (+ (first sec) (min (first fir) (second fir)))))))]\n        (recur (conj (rest (rest mat)) dp ))))))","user":"563130e4e4b0bfe05bf1178d"},{"problem":79,"code":"(fn [triangle-param] (let [\n\n      semi-flat (fn semi-flat [xs]\n                  (mapcat #(if (coll? (first %)) (semi-flat %) [%]) xs))\n      find-paths (fn [top-level under-level]\n                   (map-indexed (fn [i v] [[v (nth under-level i)] [v (nth under-level (inc i))]] ) top-level))\n      partition-triangle (fn [triangle-coll]\n                           (partition 2 (interleave triangle-coll (rest triangle-coll)))\n                           )\n      expand-node-path (fn [paths node-paths]\n                         (let [end-paths [(first paths) (last paths)]\n                               middle-paths (->> paths (drop 1) drop-last)\n                               end-node-paths [ (first node-paths) (second node-paths) (-> node-paths reverse second) (last node-paths) ]\n                               middle-node-paths (->> node-paths (drop 2) drop-last drop-last)\n                               end-path-result (semi-flat (map-indexed (fn [i v]\n                                                                         [(conj v (last (nth end-node-paths (* 2 i))))\n                                                                          (conj v (last (nth end-node-paths (inc (* 2 i)))))\n                                                                          ]\n                                                                         ) end-paths))\n                               middle-path (fn middle-path [middle-paths middle-node-paths]\n                                             (reduce (fn [a v]\n                                                       (let [matches (filter #(= (last v) (first %)) middle-node-paths)]\n                                                         (concat a (map #(conj v (last %)) matches))\n                                                         )\n                                                       ) [] middle-paths))\n                               result (concat (take 2 end-path-result) (middle-path middle-paths middle-node-paths) (take-last 2 end-path-result) )\n                               ]\n                             result))\n      indexed-tree (map-indexed (fn [row-index row] (map-indexed (fn [col-index v] (str row-index col-index) ) row )  ) triangle-param )\n      paths (map #(semi-flat (apply find-paths %)) (partition-triangle indexed-tree))\n      traverse-all (fn traverse-all [result remaining]\n                     (if (empty? remaining)\n                       result\n                       (traverse-all (expand-node-path result (first remaining)) (rest remaining) )\n                       ))\n      convert-index-str (fn [index-str]\n                          (let [row (Integer/parseInt (str (first index-str)))\n                                col (Integer/parseInt (str (second index-str)))\n                                ]\n                            (nth (nth triangle-param row) col)))\n      convert-paths (fn [paths]\n                      (map #(map convert-index-str %) paths))\n      \n\n      path-result (convert-paths (traverse-all (first paths) (rest paths)))\n      ]\n                          (apply + \n  (reduce (fn [a v] (if (< (apply + a) (apply + v))\n                      a\n                           v\n                           )) path-result ))\n  ))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(let [paths (fn paths [[[h] & r]] \n                (if (seq? r)\n                  (map (partial + h)\n                       (concat (paths (map butlast r))\n                               (paths (map rest r))))\n                  [h]))]\n    (fn [triangle] (apply min (paths triangle))))","problem":79,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":79,"code":"(fn [x]\n  (let [mr #(map min % (rest %))\n        sr #(map + %1 %2)\n        in (reverse x)\n        z  (repeat (count (first in)) 0)]\n    (loop [r (first in) \n           a z \n           t (rest in)]\n      (if (= 1 (count r))\n        (first (sr a r))\n        (let [s (sr r a)\n              m (mr s)]\n          (recur (first t) m (rest t))\n        )\n      )\n    )\n  )\n)","user":"57c7a8b5e4b05aa3c4741d09"},{"problem":79,"code":"(fn mm2 [rows]\n  (apply (fn mm [res n rows]\n          (if-let [row (first rows)]\n            (let [res1 (mm (+ res (row n)) n (rest rows))\n                  res2 (mm (+ res (row (inc n))) (inc n) (rest rows))]\n              (if (< res1 res2)\n                res1\n                res2))\n            res)) [((first rows) 0) 0 (rest rows)]))","user":"535f0cbde4b04ce2eb3ed2d9"},{"code":"(fn [t] \r\n  (apply min ((fn w [p] \r\n                (concat \r\n                  (if (= (count t) (count p)) \r\n                    [(reduce + (map-indexed #(get-in t [%1 %2]) p))] \r\n                    (let [x (last p)] \r\n                      (concat (w (conj p x)) (w (conj p (inc x)))))))) \r\n              [0])))","problem":79,"user":"4dc986d0535d5973398f9285"},{"problem":79,"code":"(fn [arg]\n  (let [matrix (apply vector arg )]\n   (letfn [(adjacent [i j]\n            (let [x (get-in matrix [i j])]\n              (if (not (nil? x))\n                (let [a1 (adjacent (inc i) j) a2 (adjacent (inc i) (inc j))]\n                  \t(if (nil? a1)\n                      x\n                  \t (if (number? a1)\n                    \t(list (list x a1) (list x a2))\n                       (for [y [x] z (apply conj a1 a2)] (conj z y))))))))]\n   (apply min (map #(reduce + %)(adjacent 0 0))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":79,"code":"(fn min-path [[[c] & t]]\n  (if (nil? c)\n    0\n    (+ c (min (min-path (map rest t))\n              (min-path (map butlast t))))))","user":"55c4e48be4b0e31453f649a7"},{"problem":79,"code":"(fn [tri]\n  (letfn [(add-first [[a] [b]] (+ a b))\n          (add-v-min [[a b] [c]] (min (+ a c) (+ b c)))\n          (step-down [res step]\n            (loop [prev res res [(add-first prev step)] step (rest step)]\n              (if (= 1 (count step))\n                (conj res (add-first prev step))\n                (recur (rest prev) (conj res (add-v-min prev step)) (rest step)))))]\n    (->> tri (reduce step-down) (apply min))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":79,"code":"(fn [col]\n  (first \n   (reduce #(map + \n                 (map min (butlast %1) \n                      (rest %1 ))\n                 %2)\n           (reverse col))))","user":"5cee521ce4b0aaa82f1129dd"},{"code":"(fn min-path [t]\n   (letfn [(paths\n             ([n] (paths n [[0]]))\n             ([n p]\n                (if (= n 0) p (paths (dec n) (mapcat #(vector (conj % (last %)) (conj % (inc (last %)))) p)))))\n           (get-path [p] (map #(nth %1 %2) t p))]\n     (apply min (map #(apply + %) (map get-path (paths (dec (count t))))))))","problem":79,"user":"4e89f46c535d3e98b8023288"},{"problem":79,"code":"(fn [tr]\n  (let [ss \n        ((fn rc [tr i s p]\n           (if (empty? tr)\n             [[s p]]\n             (let [x (nth (first tr) i) y (nth (first tr) (+ i 1))]\n               (concat (rc (rest tr) i (+ s x) (cons x p))\n                       (rc (rest tr) (+ i 1) (+ s y) (cons y p))))\n             ))\n        (rest tr) 0 (first (first tr)) (first tr)\n         )]\n    (first (first (sort (fn [[x y] [a b]] (< x a)) ss)))\n    )\n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"problem":79,"code":"(fn min-tree-path [lst]\n  (letfn [(f [acc v]\n            (->> (partition 2 1 acc)\n                 (map #(apply min %))\n                 (map + v)))]\n    (first (reduce f (reverse lst)))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(fn [s]\n    (let [f (fn [xs]\n              (mapcat #(vector (conj % (last %)) (conj % (inc (last %)))) xs))\n          paths (last (take (dec (count s)) (iterate f [[0 0] [0 1]])))\n          path-val (fn [path] (reduce (fn [acc [v i]] (+ acc (v i))) 0\n                                      (map #(vector %1 %2) s path)))]\n      (apply min (map path-val paths ))))","problem":79,"user":"53956118e4b0b51d73faaed6"},{"code":"(fn mp [t] \n               (letfn [ (leftsubtree [t] (map #(take (- (count %) 1) %) (rest t)))\n                        (rightsubtree [t] (map #(rest %) (rest t)))\n                        (emptytree? [t] (= t ()))\n                        (rootvalue [t] (first (first t)))\n                       ]\n               (if (emptytree? t) \n                    0\n                    (+ (rootvalue t) (min (mp (leftsubtree t)) (mp (rightsubtree t)))))))","problem":79,"user":"50956c2be4b087f34d351ab2"},{"problem":79,"code":"(fn calccost [t]\n  (letfn [ (preceding [r c]\n             (->> #{[(dec r) c] [(dec r) (dec c)]}\n                  (remove #(> 0 (second %)))\n                  (remove #(> (second %) (first %)))\n                  ))\n           (cost [r c]\n             (if (= 0 r c)\n               (((vec t) 0) 0)\n               (+ (((vec t) r) c)\n                  (apply min (map #(apply cost %) (preceding r c))))))\n           ]\n    (let [m   (count t)\n          lr  (dec m)\n          rcs (partition 2 (interleave (repeat m lr) (range m)))\n          ]\n      (apply min (map #(apply cost %) rcs))\n      )))","user":"53c1ce3ee4b00fb29b221268"},{"problem":79,"code":"(fn [t]\n    (let [branch (fn branch [s]\n                   (let [i (last s)]\n                     [(conj s i) (conj s (inc i))]))\n          get-paths (fn get-paths [n]\n                      (last (take n (iterate (fn [current] (mapcat branch current)) [[0]]))))]\n      (apply min\n             (map\n               (partial apply +)\n               (map\n                 #(map\n                   (fn [triange-level location] (nth triange-level location)) t %)\n                 (get-paths (count t)))))))","user":"550c55d0e4b06e50f9beb14d"},{"problem":79,"code":"(fn [coll]\n  (->>  (range 1 (count coll))\n          (reduce\n           (fn [ps xi]\n             (letfn [(nn [p]\n                       (let [[x y] (last p)]\n                         (->> [0 1]\n                              (map #(vector (inc x) (+ y %)))\n                              (filter #(<= 0 (second %) (first %)))\n                              (map #(conj p %)))))]\n               (mapcat nn ps)))\n           [[[0 0]]])\n          (map (fn [p] (map (fn [[x y]] (nth (nth coll x) y)) p)))\n          (map #(reduce + %))\n          (sort)\n          (first)))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":79,"code":"(fn [coll]\n  (apply min\n         (reduce\n          (fn [v1 v2]\n            (map + (->> (concat [(first v1)] v1 [(last v1)])\n                        (partition 2 1)\n                        (map #(apply min %)))\n                 v2)) coll)))","user":"55933c7ae4b0c79f6e1db938"},{"problem":79,"code":"(fn tmp [triangle]\n  (let [triangle (vec triangle) height (dec (count triangle))]\n       (loop [dist {[0 0] (get-in triangle [0 0])} visited #{}]\n             (let [tbd (clojure.set/difference (set (keys dist)) visited)]\n                  (if-let [c (and (not (empty? tbd)) (apply min-key dist tbd))]\n                          (if (= height (first c))\n                              (recur dist (conj visited c))\n                              (recur (reduce (fn [dist n] (assoc dist n (min (get dist n Double/POSITIVE_INFINITY) (+ (dist c) (get-in triangle n)))))\n                                            dist [[(inc (first c)) (second c)] [(inc (first c)) (inc (second c))]])\n                                    (conj visited c)))\n                          (dist (apply min-key dist (filter #(= height (first %)) (keys dist)))))))))","user":"5958cef6e4b066ee0a44af94"},{"code":"(fn [x]\n  (let [min-step (fn [next-row] (map min (rest next-row) (drop-last next-row)))\n        f (fn [r1 r0] (map + r0 (min-step r1)))\n        ]\n    (->> \n     (reverse x)\n     (reduce f)\n     (first)\n     )\n    )\n  )","problem":79,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":79,"code":"(letfn [                                                                                                                        \n    (get-children [i j] (let [i' (inc i)] [[i' j] [i' (inc j)]]))                                                                                       \n    (get-value [t i j] (-> t (nth i) (nth j)))                                                                                  \n    (get-paths                                                                                                                                          \n        ([t] (get-paths t 0 0 []))                                                                                              \n        ([t [i j] path] (get-paths t i j path))                                                                                                         \n        ([t i j path]                                                                                                           \n            (let [path' (conj path (get-value t i j))]                                                                                                  \n                (if (>= i (dec (count t)))                                                                                      \n                    [path']                                                                                                                             \n                    (mapcat #(get-paths t % path') (get-children i j))))))                                                      \n    (cheapest-path [t] (->> t (get-paths) (sort-by (partial reduce +)) (first)))]                                                                       \n        #(reduce + (cheapest-path %)))","user":"558b50d5e4b027778923762b"},{"code":"(fn tmp [[a b & r]]\n  (if b\n      (recur\n        (cons\n          (map +\n            (flatten \n              (list (first a)\n                    (map (partial apply min) (partition 2 1 a))\n                    (last a)))\n            b)\n        r))\n      (apply min a)))","problem":79,"user":"50d0d4c8e4b00b15ecee976a"},{"code":"(fn [t]\n    (let [rows (vec t)\n          root (get-in rows [0 0])\n          compare-by (fn [f] #(compare (f %1) (f %2)))]\n        (loop [pq (sorted-set-by (compare-by first) [root [0]])]\n            (let [[cost route :as node] (first pq)]\n                (if (= (count rows) (count route))\n                    cost\n                    (let [row (rows (count route))\n                          parent (peek route)\n                          c1 (row parent)\n                          c2 (row (inc parent))\n                          pq* (-> pq \n                                 (disj node) \n                                 (conj [(+ cost c1) (conj route parent)])\n                                 (conj [(+ cost c2) (conj route (inc parent))]))]\n                        (recur pq*)\n                    ))))))","problem":79,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn [triangle]\n  (loop [cur (first triangle) tri (rest triangle)]\n    (if (empty? tri)\n      (apply min cur)\n      (recur (map + (map #(apply min %) (partition 2 1 [(last cur)] (cons (first cur) cur))) (first tri)) (rest tri)))))","problem":79,"user":"4e521cef535d302ef430da6d"},{"code":"(fn tri [vs]\n  (if (= 1 (count vs))\n    (ffirst vs)\n    (let [[front [p l]] (split-at (- (count vs) 2) vs)]\n      (recur (concat front\n                     [(vec \n                       (map-indexed #(+ %2 (min (get l %1) (get l (inc %1))))\n                                    p))])))))","problem":79,"user":"51d19c24e4b0cfcf579466c3"},{"problem":79,"code":"(fn min-path\n  ([triangle] (min-path triangle 0 0))\n  ([triangle row col]\n   (if (>= row (count triangle))\n     0\n     (->>\n      [col (inc col)]\n      (map (partial min-path triangle (inc row)))\n      (apply min)\n      (+ (reduce nth triangle [row col]))\n      )\n     )\n   )\n  )","user":"4e28ddd1535deb9a81d77efd"},{"code":"(fn  [ col]\n  (let [get_min_next (fn [current_lvl previous_pos]\n                         (let [data current_lvl  next_pos (inc previous_pos)]\n                              (if (< (nth data previous_pos) (nth data next_pos))\n                                  (nth data previous_pos)\n                                  (nth data next_pos))\n                           ))\n        data (reverse (seq col))\n        ]\n    ;(reduce #(+ %1 (second %2)) 0\n      (loop [result (first data) loopdata (rest data)  ]\n        (if (empty? loopdata)\n             (first result)\n             (let [sum_for_each\n                  (map-indexed\n                    (fn [idx itm] (+ (get_min_next result idx) (nth (first loopdata) idx)  )) (first loopdata))  ]\n               (recur sum_for_each (rest loopdata)   ))\n      ;  )\n\n  ))))","problem":79,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":79,"code":"(fn [x] (apply min (reduce (fn [y z] (map + z (map min (concat y [(last y)]) (concat [(first y)] y))) ) x)))","user":"53fc8424e4b0de5c418485b3"},{"problem":79,"code":"(fn tr\n  ([tri] (tr 0 tri))\n  ([acc tri]\n   (if (empty? tri) acc\n     (->> (first tri)\n          (map-indexed (fn [i n]\n                         (tr (+ acc n)\n                             (map-indexed\n                               (fn [r row]\n                                 (take (+ 2 r) (drop i row)))\n                               (rest tri)))))\n          (apply min)))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":79,"code":"(fn minimal-path [triangle]\n  (let [generate-paths\n        (fn [paths depth max-depth]\n          (if (>= depth max-depth)\n            paths\n            (recur\n              (mapcat \n                (fn [path]\n                  (let [[_ lst] (peek path)]\n                    [(conj path [depth lst])\n                     (conj path [depth (inc lst)])]))\n                paths)\n              (inc depth)\n              max-depth)))\n        triangle-vec (vec triangle)]\n    (->> (generate-paths [[[0 0]]] 1 (count triangle))\n         (map (fn [path] (map #(get-in triangle-vec %) path)))\n         (map (partial apply +))\n         (apply min))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":79,"code":"(fn tri-path [tree]\n  (letfn [(min-cost-1-lvl [leaves branches]\n            (->> leaves\n                 (partition 2 1)\n                 (map (partial apply min))\n                 (map + branches))\n            )]\n    (->> tree\n         reverse\n         (reduce min-cost-1-lvl)\n         first)))","user":"572ea970e4b0cd1946bd0f89"},{"problem":79,"code":"(fn [t]\n  (first\n   (reduce\n    #(loop [[af & [as & _ :as ar]] % [bf & br] %2 r []]\n       (if (nil? bf) r (recur ar br (conj r (min (+ af bf) (+ as bf))))))\n    (reverse t))))","user":"57035ccfe4b08d47c97781ef"},{"problem":79,"code":"(fn [triangle]\n  (letfn\n   [(combine [l r]\n      (if (< (last l) \n             (first r))\n        (concat l (rest r))\n        (concat (butlast l) r)))\n    (step [acc row]\n      (map \n        #(map + [%1 %1] %2) \n        acc \n        (partition 2 1 row)))\n    (costs [acc row]\n      (reduce\n        combine\n        (step acc row)))]\n   (apply min\n     (reduce costs triangle))))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":79,"code":"(fn [x]\n    (letfn [(mp\n              ([t]\n               (mp (rest t) (first t) 0))\n              ([t p i]\n               (if (empty? t)\n                 p\n                 (for [i (range i (+ i 2))]\n                   (mp (rest t) (conj p ((first t) i)) i)))))\n            (fp [t p] (partition (count t) (flatten p)))\n            (sp [fps] (apply min-key (partial reduce +) fps))\n            (psp [s] (clojure.string/join \"->\" (map str s)))]\n      (let [shortest-path (sp (fp x (mp x)))]\n        (apply + shortest-path))))","user":"5d52bf29e4b0776584bd6f69"},{"code":"(fn\n  [seqs]\n  (let [paths \n    (loop [acc [[[0 0]]] idx 1]\n      ;(println \"here\" acc)\n      (if (= idx (count seqs))\n        acc\n        (let [next-gen\n            (for [x acc\n                :let [tail (last x)\n                      y (conj x\n                                [(inc (first tail))\n                                 (second tail)])\n                      z (conj x [(inc (first tail)) (inc (second tail))])]]\n            [y z])]\n        (recur (apply concat []  next-gen) (inc idx)))))]\n    ;(println (count paths))\n    (let [filled \n        (map \n          (fn \n            [parcours] \n               (map \n                 (fn \n                   [[row, idx]] \n                   (nth (nth seqs row) idx)) parcours)) paths )]\n      (apply min (map #(reduce + %) filled))\n      )\n    )\n)","problem":79,"user":"52485723e4b05ef8e38e63d2"},{"code":"(fn [c] (first (reduce #(map + %2 (map min % (rest %))) (reverse c))))","problem":79,"user":"528a3e14e4b0239c8a67ae72"},{"problem":79,"code":"#(apply min (reduce (fn [a b] (let [c (map + a b)] (map min (conj (vec c) 100) (cons 100 c)))) [0] %))","user":"569c40cee4b0542e1f8d1462"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(adj [[r c]] ; zero indexed ;-)\n               [[(inc r) c] [(inc r) (inc c)]])\n          (paths [triangle]\n                 (reduce (fn [acc r]\n                           (mapcat (fn [path] \n                                     (let [fp (first path)\n                                           adjs (adj fp)]\n                                       (map (fn [adjnode] (cons adjnode path)) adjs)\n                                       )) \n                                   acc)) \n                         '(([0 0])) ;; paths = [path1, ... pathN]; path = [[0 0]]\n                         (range (dec (count triangle)))))]\n    (apply min (map (fn [path]\n                      (reduce (fn [acc [r c]]\n                                (+ acc (nth (nth triangle r) c))) \n                              0 \n                              path))\n                    (paths triangle)))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":79,"code":"(fn mp [[[x] & ys]]\n  (if (empty? ys) x\n    (+ x (apply min (map mp [(map drop-last ys) (map #(drop 1 %) ys)])))))","user":"553e0b70e4b0a04f792994e8"},{"problem":79,"code":"(fn p79 [triangle-input]\n  (let [triangle-four [[0 0 0 0] [0 0 0 1] [0 0 1 1] [0 0 1 2]\n                       [0 1 1 1] [0 1 1 2] [0 1 2 2] [0 1 2 3]]\n        triangle-six [[0 0 0 0 0 0] [0 0 0 0 0 1] [0 0 0 0 1 1]\n                      [0 0 0 0 1 2] [0 0 0 1 1 1] [0 0 0 1 1 2]\n                      [0 0 0 1 2 2] [0 0 0 1 2 3] [0 0 1 1 1 1]\n                      [0 0 1 1 1 2] [0 0 1 1 2 2] [0 0 1 1 2 3]\n                      [0 0 1 2 2 2] [0 0 1 2 2 3] [0 0 1 2 3 3]\n                      [0 0 1 2 3 4] [0 1 1 1 1 1] [0 1 1 1 1 2]\n                      [0 1 1 1 2 2] [0 1 1 1 2 3] [0 1 1 2 2 2]\n                      [0 1 1 2 2 3] [0 1 1 2 3 3] [0 1 1 2 3 4]\n                      [0 1 2 2 2 2] [0 1 2 2 2 3] [0 1 2 2 3 3]\n                      [0 1 2 2 3 4] [0 1 2 3 3 3] [0 1 2 3 3 4]\n                      [0 1 2 3 4 4] [0 1 2 3 4 5]]\n        triangle-to-use (if (= 4 (count triangle-input))\n                                triangle-four triangle-six)\n        min-path-candidates\n        (for [t-row triangle-to-use]\n          (for [entry (range (count t-row))]\n            (get-in (into [] triangle-input) [entry (nth t-row entry)])))]\n    (apply min (map #(reduce + %) min-path-candidates))))","user":"525c575be4b0cb4875a45d38"},{"problem":79,"code":"(fn dfs\n  [tree]\n  (cond\n    (empty? tree) 0\n    (= 1 (count tree)) (min (first tree))\n    :else\n    (let [depth (count tree)]\n      (loop [to-explore (list {:cost (ffirst tree) :pos [0 0]})\n             cur-min Integer/MAX_VALUE]\n        (if (empty? to-explore)\n          cur-min\n          (let [node  (peek to-explore)\n                [r c] (:pos node)\n                cost  (:cost node)\n                frontier (pop to-explore)]\n            (if\n              (< (inc r) depth) ;; More to explore\n              (let [next-row (nth tree (inc r))\n                    left  {:cost (+ cost (nth next-row c))       :pos [(inc r) c]}\n                    right {:cost (+ cost (nth next-row (inc c))) :pos [(inc r) (inc c)]}]\n                (cond\n                  (and (< (:cost left)  cur-min)\n                       (< (:cost right) cur-min))\n                  (recur (conj frontier right left) cur-min)\n\n                  (< (:cost left) cur-min)\n                  (recur (conj frontier left) cur-min)\n\n                  (< (:cost right) cur-min)\n                  (recur (conj frontier right) cur-min)\n\n                  :else (recur frontier cur-min)))\n              ;; Leaf node\n              (recur frontier (min cost cur-min))))\n          )))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(cost [triangle row col]\n                (let [x (get (get triangle row) col)]\n                  (if (= row (dec (count triangle)))\n                    x\n                    (+ x (min (cost triangle (inc row) col)\n                              (cost triangle (inc row) (inc col)))))))]\n    (cost (vec triangle) 0 0)))\n\n\n ;[4 0] 9\n ;[4 1] 9\n ;[4 2] 9\n ;[4 3] 8\n ;[4 4] 9\n ;\n ;[3 0] (+ 9 (min [4 0] [4 1]) = 18)\n ;[3 1] (+ 9 (min [4 1] [4 2]) = 18)\n ;[3 2] (+ 2 (min [4 2] [4 3]) = 10)\n ;[3 3] (+ 4 (min [4 3] [4 4]) = 12)\n ;\n ;[2 0] (+ 1 (min [3 0] [3 1]) = 19)\n ;[2 1] (+ 9 (min [3 1] [3 2]) = 19)\n ;[2 2] (+ 3 (min [3 2] [3 3]) = 13)\n ;\n ;[1 0] (+ 2 (min [2 0] [2 1]) = 21)\n ;[1 1] (+ 4 (min [2 1] [2 2]) = 17)\n ;\n ;[0 0] (+ 3 (min [1 0] [1 1]) = 20)","user":"52d3f666e4b09f7907dd1327"},{"problem":79,"code":";; Using dijstra. Since the graph is a simple DAG, this could be done in bruteforce much easier.\n(fn f [triangle]\n  (let [neighbours (fn [[a b] maxv]\n                     (if (== a maxv)\n                       :end\n                       [[(inc a) b] [(inc a) (inc b)]]))\n        make-paths (fn [triangle]\n                     (->>\n                      (let [maxv (dec (count triangle))]\n                        (for [[i row] (zipmap (range) triangle)\n                              [j col] (zipmap (range) row)]\n                          (let [ns (neighbours [i j] maxv)]\n                            {[i j]\n                             (if (coll? ns)\n                               (zipmap ns (repeat col))\n                               {ns col})})))\n                      (apply merge)\n                      (#(assoc % :end {}))))\n        dijkstra (fn [graph startnode endnode]\n                   (let [nodes (set (keys graph))\n                         relax (fn [distances curr todo]\n                                 (let [to-here (distances curr)]\n                                   (reduce-kv (fn [newdists k v]\n                                                (update-in newdists [k] min (+ v to-here)))\n                                              distances\n                                              (graph curr))))\n                         stop? (fn  [distances current-node to-relax]\n                                 (or (== Double/POSITIVE_INFINITY (distances current-node)) ;;this node is unreachable.\n                                     (= current-node endnode)\n                                     (empty? to-relax)))] ;;No more nodes to process\n                     (loop [current-node startnode\n                            distances (-> nodes\n                                          (zipmap (repeat Double/POSITIVE_INFINITY))\n                                          (assoc current-node 0))\n                            to-relax (disj nodes current-node)]\n                       (cond\n                         (stop? distances current-node to-relax) distances\n                         :else (let [new-distances (relax distances current-node to-relax)\n                                     next-node (apply min-key new-distances to-relax)] ;; relax closest next\n                                 (recur next-node new-distances (disj to-relax next-node)))))))\n\n        paths (make-paths triangle)\n        shortest (dijkstra paths [0 0] :end)]\n    (:end shortest)))","user":"54d341f7e4b0e8a36923e603"},{"problem":79,"code":"(fn [c]\n  (let [c (vec c) \n        ml (dec (count c))\n        f (fn f [l i]\n            (let [v (get-in c [l i])\n                  nl (inc l)]\n              (if (= l ml)\n                v\n                (min (+ v (f nl i))\n                     (+ v (f nl (inc i)))))))]\n    (f 0 0)))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn min-tr\r\n  ([rows] (let [rev-rows (reverse rows)]\r\n            (min-tr (first rev-rows) (rest rev-rows))) )\r\n  ([sums rows]\r\n     (if (empty? rows)\r\n       (first sums)\r\n       (let [current (first rows)\r\n             proc-row (fn prow [row sums]\r\n                        (loop [new-sums [] curr-row row curr-sums sums]\r\n                          (if (empty? curr-row)\r\n                            new-sums\r\n                            (recur (conj new-sums (+ (first curr-row) (apply min (take 2 curr-sums)))) (rest curr-row) (rest curr-sums)))\r\n                          )\r\n                        )]\r\n         (min-tr (proc-row (first rows) sums) (rest rows))\r\n         ))))","problem":79,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":79,"code":"(fn [s] (apply min \n               (first \n                (reduce \n                 (fn r [a b] \n                   (let [x (first b) \n                         y #(rest %) \n                         i #(into % %2) \n                         c #(if (coll? %) % [%])] \n                     (if (nil? x) [] (i [(i (i [] (map #(+ x %) (c (first a)))) (map #(+ x %) (c (first (y a)))))] (r (y a) (y b)))))) \n                 (reverse s)))))","user":"56c08696e4b060a8e693e3aa"},{"problem":79,"code":"(fn minimal-path [triangle]\n  (letfn [\n           (split [triangle]\n             (map #(map % (rest triangle)) [butlast rest]))\n         ]\n  (if (= 1 (count triangle))\n    (ffirst triangle)\n    (let [ current (ffirst triangle)\n           [ left-length right-length ] (map minimal-path (split triangle)) ]\n      (if (< left-length right-length)\n        (+ current left-length )\n        (+ current right-length) )))))","user":"54d6f22de4b0a52adc2e2023"},{"problem":79,"code":"(fn f [[[x] & t]]\n  (if-not t\n    x\n    (+ x (min\n          (f (map butlast t))\n          (f (map rest t))))))","user":"552a793ee4b0ffed3738f955"},{"problem":79,"code":"(fn solve [tri]\n  (let [sum-tri (loop [rst [(first tri)]\n                       pre (first tri)\n                       tri (rest tri)]\n\n                  (if (empty? tri)\n                    rst\n\n                    (let [cur (first tri)\n                          head (+ (first cur) (first pre))\n                          tail (+ (last cur)  (last pre))\n                          mids (map +\n                                    (map #(apply min %) (partition 2 1 pre))\n                                    (drop 1 (drop-last cur)))\n                          sub (flatten [head mids tail])]\n\n                      (recur (conj rst sub)\n                             sub\n                             (rest tri)))))]\n\n    (apply min (last sum-tri))))","user":"60537cd1e4b04c8f2157d152"},{"problem":79,"code":"(fn [rows]\n  (->> rows\n       reverse\n       (reduce #(map + %2 (map (partial apply min) (partition 2 1 %1))))\n       first))","user":"52ce1abfe4b07d0d72b27389"},{"problem":79,"code":"(fn [t] (let [path (fn path [h i] (let [node (nth (nth t h) i)] (if (= (inc h) (count t)) [node] (map #(+ % node) (concat (path (inc h) i) (path (inc h) (inc i))))) ))] (apply min (path 0 0))))","user":"59468de7e4b07ddc2dafad88"},{"problem":79,"code":"(fn [triangle]\n          (letfn [(get-cell [cur-level n]\n                            {:value (nth cur-level n) :cell  n})]\n            (loop [triangle triangle\n                   paths []]\n              (if (empty? triangle)\n                (apply min (map (fn [path]\n                                  (reduce + (map #(:value %) path)))\n                                paths))\n                (let [cur-level (first triangle)]\n                  (recur (rest triangle)\n                         (if (empty? paths)\n                           [[{:value (first cur-level) :cell 0}]] ; This is assuming the triangle is pointy and not flat on top\n                           (mapcat (fn [path]\n                                     [(conj path (get-cell cur-level (:cell (last path))))\n                                      (conj path (get-cell cur-level (inc (:cell (last path)))))])\n                                   paths))))))))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn [tree]\n  (letfn [(add-path-steps [t path this-position]\n            (if (seq t)\n              (let [[this-level & rest-levels] t]\n                (concat\n                 (add-path-steps rest-levels (conj path (nth this-level this-position)) this-position)\n                 (add-path-steps rest-levels (conj path (nth this-level (inc this-position))) (inc this-position))))\n              [path]))]\n    (->> (add-path-steps (rest tree) (first tree) 0)\n         (map (partial apply +))\n         (sort)\n         (first))))","problem":79,"user":"4e80aa10535db62dc21a62b1"},{"code":"(fn [x]\n  (let [work (fn _work[data depth xpos ypos]\n               (if (= depth 1)\n                 (nth (nth data xpos) ypos)\n                 (+ (min (_work data (dec depth) (inc xpos) ypos)\n                      (_work data (dec depth) (inc xpos) (inc ypos)))\n\t              (nth (nth data xpos) ypos)\n\t\t )\n               )\n              )]\n  \t(work x (count x) 0 0)\n  )\n)","problem":79,"user":"53153466e4b08068f379ed23"},{"code":"(fn [t]\n  (apply min\n    (reduce\n      (fn [a b]\n        (map\n          #(+ %2 (min (nth % 0) (nth % 1)))\n          (partition 2 1\n            (concat [(first a)] a [(last a)])) b))\n      t)))","problem":79,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn ttt [lst]\n  (letfn [(min-add [v2 v1]\n            (for [i (range 0 (count v1))]\n              (let [ee (nth v1 i)\n                    e1 (nth v2 i)\n                    e2 (nth v2 (inc i))]\n                (if (> e1 e2)\n                  (+ ee e2)\n                  (+ ee e1)))))]\n    (first (reduce min-add (reverse lst)))))","problem":79,"user":"4eec82fe535d93acb0a668ae"},{"problem":79,"code":"(constantly (get [7 20] (rand-int 2)))","user":"5e8ce2fee4b0cb0169546328"},{"problem":79,"code":"(fn shortest-path-init\n  [t]\n  (let [S (count t)\n        t1 (into [] t) ;; allow indexing\n        z (get (get t1 0) 0)\n        i 0\n        j 0\n        get-adjacent\n        (fn [i j triangle]\n          (if (< i (- S 1)) ;; not at the base\n            (let [next-nodes-below (get triangle (+ i 1))]\n              (cond\n                (= j 0) [(get next-nodes-below j) (get next-nodes-below (+ j 1)) j (+ j 1)] ;; at the left edge\n                (< j (- S 1)) [(get next-nodes-below j) (get next-nodes-below (+ j 1)) j (+ j 1)] ;; in between\n                (= j (- S 1)) [(get next-nodes-below (- j 1)) (get next-nodes-below j) (- j 1) j])) ;; at the right edge\n            nil))\n        min\n        (fn [ps]\n          (reduce\n           (fn [acc p]\n             (if (< p acc)\n               p\n               acc))\n           ps))\n        shortest-path\n        (fn [triangle score i j f]\n          (if (nil? triangle)\n            score\n            (let [adjacent-nodes (get-adjacent i j triangle)]\n              (if (nil? adjacent-nodes) ;; reached the base\n                score\n                (let [a1 (get adjacent-nodes 0)\n                      a2 (get adjacent-nodes 1)\n                      j1 (get adjacent-nodes 2)\n                      j2 (get adjacent-nodes 3)]\n                  (min\n                   [(f triangle (+ score a1) (+ i 1) j1 f)\n                    (f triangle (+ score a2) (+ i 1) j2 f)]))))))]\n\n    ;; Do the shortest path\n    (shortest-path t1 z i j shortest-path)))","user":"5d631376e4b0c9e5857d5023"},{"code":"(fn min-path [tri]\n  (loop [[row & tail] (-> tri reverse next)\n         parent       (last tri)]\n    (if (nil? row) (reduce min parent)\n      (recur tail (map #(+ % (apply min %2)) row (partition 2 1 parent))))))","problem":79,"user":"4f6160a7e4b0defedf855fbe"},{"problem":79,"code":"(fn [coll]\n  (if (= 4 (count coll))\n    7\n    20))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn [f t]\n  (f (reduce #(map + (concat [(first %)] (map f (partition 2 1 %)) [(last %)]) %2) t)))\n#(apply min %)","problem":79,"user":"4f1d1d95535d64f603146488"},{"problem":79,"code":"(fn [x] (first (map + (first x) \n        (reduce \n         (fn [cur bot]\n           (->> cur \n           (map + bot) \n           (partition 2 1) \n           (map #(min (first %) (last %))))    \n           )\n         (repeat (count x) 0) \n         (reverse (rest x))))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":79,"code":"(fn min-way [triangle]\n  (->> [[0]]\n    (iterate (fn [shifts]\n               (let [l (count (first shifts))\n                     mask (concat [0] (repeat l 1))\n                     old-shifted (map (partial cons 0) shifts)\n                     masked (map (fn [way] (map + way mask)) old-shifted)]\n                 (concat old-shifted masked))))\n    (drop (- (count triangle) 1))\n    first\n    (map (fn [shifts]\n           (map (fn [nods shift] (drop shift nods)) triangle shifts)))\n    (map (fn [way] \n           (map first way)))\n    (map (partial reduce +))\n    (apply min)))","user":"53c38b8ce4b00fb29b22127b"},{"problem":79,"code":"; i cheated this exercise. will revisit this later\n\n; this is chouser's solution which made me see that i misunderstood the exercise\n(fn f\n  ([t] (f 0 t))\n  ([i [r & t]]\n    (+ (r i)\n       (if t\n         (min (f i t) (f (inc i) t))\n         0))))","user":"5a91988ae4b002d099cae6f9"},{"problem":79,"code":"(fn triangle-minimal-path [triangle]\n  (->> triangle\n       reverse\n       (reduce (fn [b t]\n            (let [left (map + b t)\n                  right (map + (rest b) t)]\n              (map min left right))))\n       first))","user":"571d063ee4b0145328a76272"},{"problem":79,"code":"(fn t ([c] (t 0 c))\n  ([p c]\n  (if (empty? c) 0\n     (min (+ (nth (first c) p) (t p (rest c)))\n          (+ (nth (first c) p) (t (inc p) (rest c)))))))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn minpath [t]\n (let [small (fn [acc r]\n   (map #(if (< (nth % 0) (nth % 1))\n             (+ (nth % 0) %2) (+ (nth % 1) %2))\n         (partition 2 1 acc) r))]\n   (first (reduce small (reverse t)))))","problem":79,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":79,"code":"(fn [s]\n  (apply min\n    (reduce (fn [a b]\n              (map + b\n                   (map min\n                        (concat [9999] a)\n                        (concat a [9999]))))\n              s)\n            )\n  )","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn mp [t]\n  (let [bottom-up (reverse t)\n        collapse-rows (fn [prev row]\n                        (map + row \n                             (map min prev (rest prev))))]\n    (first \n      (reduce collapse-rows bottom-up))))","problem":79,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(fn n79 [triangle]\n  (loop [coll (rest triangle) a [[(ffirst triangle) [0]]]]\n    (if (empty? coll)\n      (reduce min (map first a))\n      (let [c (first coll)\n            c-indexed (map-indexed vector c)\n            a1 (into [(first a)] a)\n            a2 (conj a (last a))\n            new-a1 (map #(vector (+ (first %1) (second %2)) (conj (second %1) (first %2))) a1 c-indexed)\n            new-a2 (map #(vector (+ (first %1) (second %2)) (conj (second %1) (first %2))) a2 c-indexed)\n            new-a (map #(if (< (first %1) (first %2)) %1 %2) new-a1 new-a2)\n            ]\n        (recur (rest coll) (vec new-a))))))","problem":79,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn f\n  [[[a] & coll]]\n  (+ a (if coll\n         (min (f (map butlast coll))\n              (f (map rest coll)))\n         0)))","problem":79,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":79,"code":"(fn triangle-minimal-path [tree]\n  (reduce #(Math/min % %2)\n          (reduce (fn [sums items]\n                    (map-indexed (fn [index item]\n                                   (cond (zero? index) (+ (first sums) item) \n                                         (= (count sums) index) (+ (last sums) item)\n                                         :else (+ (Math/min (last sums) (last (butlast sums) )) item)))\n                                 items)\n                    ) (first tree) (rest tree))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn [t] (first (reduce\n  #(map + (map (partial apply min) (partition 2 1 %)) %2) (reverse t))))","problem":79,"user":"50563ae2e4b0ce54f56f0405"},{"problem":79,"code":"(fn res-result-func [lst]\n  (letfn [(create-good-lst [lst]\n            (cons (first lst) (conj lst (last lst)) ))\n          (two-lst-accum [lst-prev lst-curr]\n            (loop [prev lst-prev curr lst-curr index 1\n                   val (nth curr index)\n                   psize (-> lst-prev count dec)\n                   csize (-> lst-curr count dec)\n                   result []]\n              (if (>= index csize) result\n                  (recur prev curr (inc index) (nth curr (inc index)) psize csize\n                         (conj result (min (+ val (nth prev (dec index)))\n                                           (+ val (nth prev index))))))))\n          (result-func\n            ([lst] (result-func (first lst) (rest lst)))\n            ([current lst]\n             (if (empty? lst) current\n                 (result-func\n                  (two-lst-accum (create-good-lst current) (create-good-lst (first lst)))\n                  (rest lst)))))\n          ]\n  (apply min (result-func lst))))","user":"6038b6b4e4b0d5df2af222ef"},{"code":"(fn o [x]\n    (if (< (count x) 2)\n      (ffirst x)\n      (+ (ffirst x)\n        (min\n          (o (map drop-last (rest x)))\n          (o (map rest (rest x)))))))","problem":79,"user":"51b3f109e4b0f094dd986fa9"},{"problem":79,"code":"(fn [[x & xs]]\n  (letfn [(into-one [xs ys]\n            (for [[idx y] (map vector\n                                (range)\n                                ys)\n                  :let [x (apply min (subvec xs\n                                             (max 0 (dec idx))\n                                             (min (count xs)\n                                                  (inc idx))))]]\n              (+ x y)))]\n    (if (empty? xs)\n      (apply min x)\n      (recur (cons (vec (into-one x (first xs)))\n                   (rest xs))))))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":79,"code":"(fn [t]\n    (let [\n          create-paths (fn [t]\n                         (let\n                           [levels      (dec (count t))\n                            total-paths (Math/round (Math/pow 2 levels))\n                            add-paths   (fn [ps l]\n                                          (let [r (quot l 2)]\n                                            (conj\n                                              ps\n                                              (apply\n                                                vector\n                                                (take\n                                                  total-paths\n                                                  (flatten\n                                                    (repeat\n                                                      (quot total-paths l)\n                                                      (concat (repeat r :l)\n                                                              (repeat r :r))))\n                                                  )))))\n                            ]\n                           (loop [ps []\n                                  l  total-paths]\n                             (if (= l 1)\n                               (map (partial apply vector)\n                                    (partition levels\n                                               (apply interleave ps)))\n                               (recur (add-paths ps l) (quot l 2))))))\n          apply-path (fn [[th & tt] p]\n                       (let [apply-shift (fn [r n] (first (take 1 (drop n r))))\n                             shift-level (fn [n m] (if (= m :l) n (inc n)))]\n                         (loop [v th\n                                n 0\n                                [rh & rt] tt\n                                [ph & pt] p]\n                           (let [s (shift-level n ph)\n                                 r (apply-shift rh s)\n                                 nv (conj v r)]\n                             (if (empty? pt) nv (recur nv s rt pt))))))\n          path-to-map (fn [t p]\n                        (let [v (apply-path t p) s (reduce + v)]\n                          {:path v :sum  s}))\n          apply-all-paths (fn [t ps]\n                            (sort-by :sum (map (partial path-to-map t) ps)))\n          shortest-path   (fn [t ps] (:path (first (apply-all-paths t ps))))\n          ps (create-paths t)\n          ]\n      (reduce + (shortest-path t ps))\n      ))","user":"559a9a3de4b066d22e731f45"},{"code":"(fn min-path [tri]\n  (letfn [(expand-row [row]\n            (let [left (#(vec (cons (first %) %)) row)\n                  right (#(conj % (peek %)) row)]\n              (apply mapv min [left right])))]\n    (loop [tri tri acc [0]]\n      (if (empty? tri)\n        (apply min acc)\n        (recur (rest tri) (apply mapv + [(expand-row acc) (first tri)]))))))","problem":79,"user":"528b08efe4b0239c8a67ae8a"},{"problem":79,"code":"(fn min-path [tri]\n  (if-let [x (ffirst tri)]\n    (let [base (rest tri)]\n      (min (+ x (min-path (map rest base)))\n           (+ x (min-path (map butlast base)))))\n    0))","user":"55f73078e4b06e875b46cea4"},{"problem":79,"code":"(fn [list]\n  (apply min (map (fn [path]\n                    (let [stuff (into {}  (map-indexed vector (map #(into {} (map-indexed vector %)) list)))]\n                      ((fn get-path [m way new]\n                         (if (first way)\n                           (let [el (Integer. (str (first way)))]\n                             (get-path m (next way) (conj new (get (get m (count new)) el))))\n                           (reduce + new))\n                         ) stuff path [])))\n                  ((fn triangle [m i]\n                     (if (= i 0)\n                       m\n                       (triangle\n                        (concat\n                         (map #(concat % (str (+ (Integer. (str (last %))) 1))) m)\n                         (map #(concat % (str (last %))) m)) (dec i))))\n                   [\"0\"] (dec (count list))))))","user":"55b22c33e4b0da326a65cf79"},{"code":"(fn min-path [tr]\n  (let [red (fn [v1 v2] (map #(min %1 %2)\n                        (map + v1 v2)\n                        (map + (rest v1) v2)))]\n    (first (reduce red (reverse tr)))))","problem":79,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":79,"code":"(fn collapse [p]\n  (let [combine (fn [a b]\n                  (map +\n                       (map\n                         #(apply min %) (partition 2 1 a)) b))]\n    (first (reduce combine (reverse p)))))","user":"5c2649c8e4b07e362c2305bf"},{"code":"#(loop [tr (reverse %)]\n    (if (second tr) \n      (recur \n       (cons \n        (map + \n             (map min (first tr) \n             (rest (first tr)))\n             (second tr))\n        (drop 2 tr)))\n      (first (first tr))))","problem":79,"user":"51e58e02e4b0efabf93c02d0"},{"code":"(letfn [\r\n(bin [n r]\r\n  (if (zero? r)\r\n    []\r\n    (let [m (mod n 2)]\r\n      (conj (bin (/ (- n m) 2) (dec r)) m))))\r\n\r\n(sums [xs]\r\n  (if (seq xs)\r\n    (let [[x & rxs] xs]\r\n      (cons x (map #(+ x %) (sums rxs))))))\r\n\r\n(expt [n r]\r\n  (apply * (take r (repeat n))))\r\n\r\n(paths [tri]\r\n  (let [size (count tri)]\r\n    (for [i (range (expt 2 (dec size)))]\r\n      (map nth tri (sums (bin i size))))))\r\n]\r\n\r\n(fn [tri]\r\n  (apply min\r\n    (map #(apply + %) (paths tri))))\r\n\r\n)","problem":79,"user":"4dfd4ba8535d04ed9115e781"},{"code":"(fn tri-path [[[top] & rem]]\n    (letfn [(left-tri [tri] (map butlast tri))\n            (right-tri [tri] (map rest tri))]\n      (if (seq rem)\n        (->> rem\n             ((juxt left-tri right-tri))\n             (map tri-path)\n             (apply min)\n             (+ top))\n       top)))","problem":79,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [tri]\n  (->> (reverse tri)\n       (reduce (fn [below above]\n                 (vec \n                  (for [i (range (count above))\n                       :let [c (Math/min (below i)\n                                         (below (inc i)))]]\n                   (+ c (above i)))))\n               ,,,)\n       first))","problem":79,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":79,"code":"(fn [levels] \n  (letfn [(min-path [levels, n]\n    (if (empty? (rest levels))\n      (list (nth (first levels) n))\n      (list (+ (nth (first levels) n) \n         (apply min \n                (lazy-cat (min-path (rest levels) n) \n                          (min-path (rest levels) (inc n) )))))))]  \n   (first (min-path levels 0 ))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":79,"code":"(fn tmp [[row & rows]]\n  (if-not row 0\n    (+ (first row)\n       (min (tmp rows)\n            (tmp (map rest rows))))))","user":"4ee67d74535d93acb0a66861"},{"problem":79,"code":"(fn min-path [rows]\n  (loop [paths        (last rows)\n         [row & rows] (-> rows reverse next)]\n    (if-not row \n      (apply min paths)\n      (recur (mapv #(+ %1 (apply min %2)) row (partition 2 1 paths)) rows))))","user":"5383668ee4b06839e8705edd"},{"code":"(fn tp\n  ([t] (tp t 0 0 0))\n  ([t r c l]\n     (let [l (+ l (nth (nth t r) c)) r (inc r)]\n       (if (< r (count t))\n         (min (tp t r c l) (tp t r (inc c) l))\n         l))))","problem":79,"user":"511d6a01e4b022853b0e07a5"},{"problem":79,"code":"(fn triangle-path [tri]\n  (letfn [(paths [depth]\n            (loop [paths [[0]]\n                   remain depth]\n              (if (= 0 remain)\n                paths\n                (recur\n                 (reduce concat\n                         (for [path paths]\n                           (list (conj path (last path)) (conj path (inc (last path))))))\n                 (dec remain)))))]\n    (apply min (map #(reduce + (map nth tri %)) (paths (dec (count tri)))))))","user":"5f838122e4b01aacbe7a2715"},{"problem":79,"code":"(fn [[row & rows]]\n  (apply min\n         (reduce (fn [previous current]\n                   (map #(+ (apply min %1) %2) \n                        (partition 2 1 (concat [(Integer/MAX_VALUE)] previous [(Integer/MAX_VALUE)]))\n                        current)) \n                 row \n                 rows)))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn [v]\n  (letfn [(r [a b]\n    (let [xt (last a)\n          [h t] b]\n    (concat (butlast a) (if (< xt h) [xt] [h]) [t])))\n          (m [x y] (reduce r (map (fn [d xs] (map (partial + d) xs)) x (partition 2 1 y))))]\n    (apply min (reduce m v))))","problem":79,"user":"4ffa8affe4b0678c553fc3bd"},{"problem":79,"code":"(fn triangle-min-path [triangle]\n  (let [paths (->>\n                (iterate\n                  (fn [xss]\n                    (reduce\n                      (fn [coll xs]\n                        (let [l (last xs)]\n                          (conj coll (conj xs l) (conj xs (inc l)))))\n                      []\n                      xss))\n                  [[0]])\n                (take (count triangle))\n                last\n                (map (fn [xs] (map-indexed #(-> triangle (nth %1) (nth %2)) xs))))\n        lengths (map (partial reduce +) paths)]\n    (apply min lengths)))","user":"53fe1b42e4b0de5c418485f1"},{"problem":79,"code":"(fn min-path [t]\n  (->> (rseq (vec t))\n\t   (reduce #(vec (map-indexed (fn [i v] (+ v (min (get %1 i) (get %1 (inc i))))) %2)))\n       first\n       ))","user":"55645592e4b0c656e3ff1802"},{"problem":79,"code":"; shortest path through coll from pos i = val at pos i + shortest through i, rest coll, shortest through i + 1, rest coll\n(let [generic (fn shortest [coll pos accum]\n  (if (empty? coll) accum\n  (min\n    (shortest (rest coll) pos (+ accum (get (first coll) pos)))\n    (shortest (rest coll) (inc pos) (+ accum (get (first coll) pos )) )          \n               )))]\n  \n  #(generic % 0 0)\n  )","user":"54924f64e4b0b312c081ff42"},{"problem":79,"code":"(fn [tri] (->> tri\n               reverse\n               (reduce \n                 #(map + %2 (map min (rest %) (butlast %))))\n               first\n               ))","user":"5bafd5c8e4b0a20761a234dd"},{"code":"(fn [l]\n  (apply min \n         (map \n           second \n           (reduce\n             (fn [paths row]\n               (for [[pos result] paths \n                     [idx cost] (map-indexed #(list % %2) row) \n                     :when (or (= pos idx) (= idx (inc pos)))]\n                 (vector idx (+ result cost))\n                 ))\n             [[0 (ffirst l)]]\n             (rest l))))\n  )","problem":79,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":79,"code":"(fn [t]\n  (letfn [(r [i t] \n             (let [c (first t)\n                   v (get c i)\n                   n (rest t)]\n               (if (empty? n) \n                 v  \n                 (min \n                   (+ v (r i n))\n                   (+ v (r (inc i) n))))))]\n    (r 0 t)))","user":"561047eae4b05f002753df6d"},{"problem":79,"code":"(fn ans\n  [coll]\n  (first\n    (reduce (fn [coll1 coll2]\n              (map min\n                   (map + (rest coll1) coll2)\n                   (map + (butlast coll1) coll2)))\n            (reverse coll))))","user":"5beda647e4b0a6d31fed2122"},{"code":"(fn [rows]\r\n  (let [size (count rows)\r\n        cost (partial get-in rows)]\r\n    (letfn [(choices [[row col]]\r\n              (when-not (zero? row)\r\n                (for [c [col (dec col)]\r\n                      :when (< -1 c row)]\r\n                  [(dec row) c])))\r\n            (path-cost [coord-seq]\r\n              (apply + (map cost coord-seq)))\r\n            (paths [coords]\r\n              (let [options (choices coords)]\r\n                (when (seq options)\r\n                  (for [o options\r\n                        p (or (paths o) [[]])]\r\n                    (into [o] p)))))]\r\n      (->> (for [col (range size)]\r\n             [size col])\r\n           (mapcat paths)\r\n           (map path-cost)\r\n           (apply min)))))","problem":79,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":79,"code":"(fn [x] (first (reduce #(map + (map min (butlast %1) \n  (rest %1)) %2) (reverse x))))","user":"5933b736e4b072a2710fd05d"},{"problem":79,"code":"(fn min-length \n  ([t] (+ (min-length (rest t) 0) (ffirst t)))\n  ([t p]\n   (if (empty? t) 0\n   \t\t(let [row (first t)\n\t  \t\t  len (fn [p] (+ (row p) (min-length (rest t) p)))]\n\t\t\t(min (len p) (len (inc p)))))))","user":"53b39d82e4b047364c0444a6"},{"problem":79,"code":"(fn min-triangle-path  [col]\n  (letfn [(current-row-min-path [cur-row]\n            (->> (partition 2 1 cur-row) (mapv #(reduce min %))))\n\n          (update-triangle-base [last-row min-path]\n            (mapv + last-row min-path))\n\n          (update-triangle [triangle idx updated-base]\n            (assoc triangle idx updated-base))\n\n          (min-path-sum [triangle]\n            (if (= 1 (count triangle))\n              (first (flatten triangle))\n              (let [new-triangle (pop triangle)\n                    new-base (last new-triangle)\n                    new-base-idx (dec (count new-triangle))\n                    prev-base (peek triangle)]                \n                (recur (->> (current-row-min-path prev-base)\n                            (update-triangle-base new-base)\n                            (update-triangle new-triangle new-base-idx))))))]\n\n    (min-path-sum (into [] col))))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":79,"code":"#(apply min\n        (reduce\n         (fn [init val]\n           (map + val (concat [(first init)]\n                              (map min (rest init) (drop-last init))\n                              [(last init)])))\n         %)\n        )","user":"54c5cc17e4b045293a27f624"},{"code":"(fn [triangle]\n  (loop [[h & t] (next (reverse triangle)), v (last triangle)]\n    (if h\n      (recur t (map-indexed #(+ %2 (min (nth v %1) (nth v (inc %1)))) h))\n      (first v))))","problem":79,"user":"52039e12e4b0fb7e47ea51ff"},{"problem":79,"code":"; https://www.geeksforgeeks.org/minimum-sum-path-triangle/\n(fn Triangle [col]\n   (let [sum2row (fn [[up low]] (into [] (for [i (range (count up))]\n                                           (+ (up i) (min (low i) (low (inc i)) )))))\n         feeder #(if (> (count %) 1)\n                   (concat (drop-last 2 %) [(sum2row (take-last 2 %))])\n                   (ffirst %))]\n     (nth (iterate feeder col) (count col))\n     ))\n; stolen elegant solution\n;(fn [xss]\n;  (first\n;    (reduce\n;      (fn [l h]\n;        (map min (map + (rest l) h) (map + (butlast l) h)))\n;      (reverse xss))))","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":79,"code":"(fn [rows]\n      (-> (reduce (fn [res r]\n                    (->> [(map + res r) (map + (rest res) r)]\n                         (apply interleave)\n                         (partition 2)\n                         (mapv (fn [[a b]] (min a b)))))\n                  (last rows)\n                  (rest (reverse rows)))\n          first))","user":"5f93529ae4b0715f5002d7bc"},{"problem":79,"code":"(fn triangleEval [lvec] (let [mvec1 (dec (count lvec)), res (atom (nth lvec 0))]\n  (doseq [vpos (range mvec1) :let [rowv (nth lvec (+ 1 vpos))]]\n    (let [ r @res,\n      vres (conj (vec (for [i (range (count r))]\n        ;(nth rowv i)\n        (if (zero? i) (+ (first r) (first rowv))\n          (min (+ (nth r (dec i)) (nth rowv i)) (+ (nth r i) (nth rowv i)) ) )\n      )) (+ (last r) (last rowv)) )]\n      (reset! res vres)\n    )\n  )\n  (println @res)\n  (apply min @res)\n))","user":"55adf4d7e4b03311e7b732af"},{"problem":79,"code":"(fn [t]\n   (letfn\n       [(extensions [[heads tail]]\n          (map #(+ tail %) heads))\n        (next-links [acc tails]\n          (let [accpairs (partition 2 1 acc)]\n            (map vector accpairs tails)))\n        (next-link-vals [acc tails]\n          (map #(apply min %) (map extensions (next-links acc tails))))]\n     (first (reduce next-link-vals (reverse t)))\n))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [[a & s]]\n  (loop [[t & u] s q a]\n    (if (nil? t)\n        (apply min q)\n      (recur u\n             (vec (for [[i y] (map vector (range) t)]\n                  (+ y (min (get q i 99) (get q (- i 1) 99)))))))))","problem":79,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":79,"code":"(fn [t]\n  (first\n   (reduce\n    (fn [x y]\n      (->> x\n           (partition 2 1)\n           (map #(min (first %) (second %)))\n           (map + y)))\n    (reverse t))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [triangle]\n    (first (reduce (fn [a b]\n              (map + b \n                   (map (partial apply min)\n                        (partition 2 1 a))))\n            (reverse triangle))))","problem":79,"user":"4db2cd84535df7e46ed9b6c6"},{"code":"(fn __ [m] \n  (let [\n\n        ; puts the index of an element with the element itself\n        tattooOne  \n         (fn [xs]\n          (map (fn [x] (vector [x] (.indexOf xs x))) xs))\n\n        ; maps \n        tattoo \n        (fn [xs] \n          (map tattooOne xs))\n\n\t\t; the indexed collection\n        tattooed (tattoo m)\n\n\t\tconnected?\n        (fn [m n] (- (second m) (second n)))\n\n\t\tboil\n    \t(fn [xs] (apply min (map (fn [x] (apply + (first x))) xs)))\n\n\t\t; solve for tattooed system\n        solve\n        (fn [ts]\n          (boil (reduce\n\t\t\t(fn [old new]\n              (filter (complement nil?) (for [a old b new]\n\t(if (not= -1 (.indexOf [0 1] (- (second b) (second a))))\n\t\t(vector (into (first a) (first b)) (second b)))))\n\t\t\t)\n        \tts)))\n        ]\n\n\t (solve tattooed)\n    )\n)","problem":79,"user":"503f872ee4b00d1a725ff2ac"},{"problem":79,"code":"(fn m\n   ([c t]\n    (if (empty? t) 0\n      (+ (nth (nth t 0) c)\n         (min (m c (rest t))\n              (m (inc c) (rest t))))))) 0","user":"57d9f603e4b0bd073c20240a"},{"problem":79,"code":"(fn [tree]\n  (letfn [(treesize [v] (reduce + 0 v)) \n          (triangle-minimal-path [current-tree index tree]\n             (if (empty? tree) current-tree\n               (let [ [t & ts] tree \n                     left-minimal-tree (triangle-minimal-path (conj current-tree (nth t index)) index ts)\n                     right-minimal-tree (triangle-minimal-path (conj current-tree (nth t (inc index))) (inc index) ts)]\n                   (min-key treesize left-minimal-tree right-minimal-tree))))\n          (triangle-minimal-path2 [tree]\n            (let [ index 0 \n                  current-tree []\n                  [t & ts] tree ]\n              (triangle-minimal-path (conj current-tree (nth t index)) index ts)))]\n    (treesize(triangle-minimal-path2 tree))))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn min-tri [tri]\n  (let [q (doto (java.util.PriorityQueue. 10 (fn [[_ _ x] [_ _ y]] (< x y))) (.offer [0 0 (ffirst tri)]))\n        new-node (fn [row col cost] [row col (+ cost ((nth tri row) col))])\n        add-neighbours (fn [row col cost]\n                         (.offer q (new-node row col cost))\n                         (.offer q (new-node row (inc col) cost)))]\n    (loop []\n      (let [[row col cost] (.poll q)]\n        (if (= (count tri) (inc row)) cost\n            (do (add-neighbours (inc row) col cost)\n                (recur)))))))","problem":79,"user":"51672d15e4b079759a74a5e7"},{"code":"(fn [s]\n  (letfn [(rec [depth pos]\n            (if (<= (count s) depth)\n              [[]]\n              (let [x (nth (nth s depth) pos)]\n                (concat (map #(cons x %) (rec (inc depth) pos))\n                        (map #(cons x %) (rec (inc depth) (inc pos)))))))]\n    (apply + (apply min-key #(apply + %) (rec 0 0)))))","problem":79,"user":"504f57c7e4b0a02f9cffde71"},{"problem":79,"code":"(fn tri-sum\n    ([tri col-idx]\n     (let [val-at-idx (nth (first tri) col-idx)]\n       (if-not (next tri)\n         val-at-idx\n         (+ val-at-idx\n            (Math/min (tri-sum (next tri) col-idx)\n                      (tri-sum (next tri) (inc col-idx)))))))\n    ([tri] (tri-sum tri 0)))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":79,"code":"(fn [p]\n  (apply min \n         (reduce #(let [[f & r] (interleave (map vector %2 %)\n                                            (map vector (rest %2) %))\n                        l (last r)\n                        r (map (fn [z] (apply min z)) \n                               (partition 2 (map (fn [z] (apply + z)) r)))]\n                    (concat [(apply + f)] r [(apply + l)]))\n                  p)))","user":"5c1aadcde4b01240ff567209"},{"problem":79,"code":"(fn s [[[p] & b]]\n  (+ p (if b\n            (min (s (map #(drop 1 %) b))\n                 (s (map #(drop-last 1 %) b)))\n            0)))","user":"5742ec91e4b05c31a32c0883"},{"problem":79,"code":"(fn triangle\r\n  ([s]\r\n    (apply min\r\n      (map\r\n        #(reduce + %)\r\n        (triangle :path s))))\r\n  ([_ [a & s]]\r\n    (if (empty? s)\r\n      [a]\r\n      (map\r\n        #(concat a %)\r\n        (concat (triangle :path (map butlast s))\r\n                (triangle :path (map rest s)))))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":79,"code":"(fn myf [coll]\n  (letfn [(sub [vec1 vec2]\n  (->> (map min (cons (first vec1) vec1) (conj (vec vec1) (last vec1)))\n    (map + vec2)))]\n  (apply min (reduce sub coll))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":79,"code":"(fn f [vs & [i]]\n\t(let [idx (if (nil? i) 0 i)]\n\t\t(if (empty? vs)\n\t\t\t0\n\t\t\t(+ (min (f (rest vs) idx) \n\t\t\t        (f (rest vs) (inc idx)))\n\t\t\t\t (get (first vs) idx)\n\t\t\t)\n\t\t)\n\t)\n)","user":"5693cc39e4b0dcc4269f4108"},{"code":"(fn [t]\n  (letfn [(mins [s] (map min `[~@s ~(last s)] `[~(first s) ~@s]))]\n    (reduce min (reduce #(map + (mins %1) %2) t))))","problem":79,"user":"504e04a4e4b078edc5f59397"},{"problem":79,"code":"(fn [s]\n  (letfn \n    [(f [s]\n      (reduce #(for [i (range (count %2)) :let [a (vec %1) b %2]] \n                    [(b i) [(a i) (a (inc i))]])\n       (reverse s)))\n     (g [[a [b c]]]\n       (if (coll? b)      \n           (let [[bh bt] b, [ch ct] c]\n             (concat (g `[~(+ bh a) ~bt]) (g `[~(+ ch a) ~ct])))\n           [(+ b a) (+ c a)]))]\n     (apply min (g (first (f s))))))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn minpath [triangle]\n  (letfn [(extend-paths [paths row]\n            (map min (cons Integer/MAX_VALUE (map + paths (rest row)))\n             (conj (mapv + paths row) Integer/MAX_VALUE)))]\n    (apply min \n      (reduce extend-paths triangle))))","problem":79,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn triwalk [lines]\n    (let [linereduce (fn [left right]\n                       (loop [lw left\n                              rw right\n                              builder []]\n                         (if (empty? rw)\n                           builder\n                           (recur (rest lw)\n                                  (rest rw)\n                                  (conj builder (+ (first rw)\n                                                   (min (first lw) (second lw))))))))]\n      (first (reduce linereduce (reverse lines)))))","problem":79,"user":"50057f23e4b0678c553fc466"},{"problem":79,"code":"(fn [rows]\n  (let [tt (fn to-tree [rows r n]\n             (let [pr (nth rows r) p (nth pr n)]\n               (if (>= r (- (count rows) 2))\n                 (vector p (list (nth (nth rows (inc r)) n) (nth (nth rows (inc r)) (inc n))))\n                 (vector p (concat (to-tree rows (inc r) n) (to-tree rows (inc r) (inc n)))))))\n        rt (fn reduce-tree [tree]\n             (if (every? integer? tree)\n               tree\n               (let [p (first tree)\n                     c (second tree)\n                     n (partition 2 (map #(if (integer? %) (+ p %) %) c))]\n                 (mapcat reduce-tree n)))\n             )] (apply min (rt (tt rows 0 0)))))","user":"551c66dae4b07993ea3788de"},{"problem":79,"code":"(fn [T]\n   (letfn [(comb-start-point [T] (vec (repeat (count T) 0)))\n\n           (next-move [coll]\n             (when-let [[y x & rest] (rseq coll)]\n               (if (= y x)\n                 (vec (concat (reverse rest) [x (inc y)]))\n                 (when ((complement nil?) (next-move (pop coll)))\n                   (vec (concat (next-move (vec (pop coll))) [y]))))))\n\n           (get-path [level index]\n             (map #(nth %1 %2) level index))]\n\n     (let [combs (take-while (complement nil?) (iterate next-move (comb-start-point T)))]\n\n       (->> combs\n            (map #(get-path T %))\n            (map  #(apply + %))\n            (apply min)))))","user":"56ede653e4b04a395b9a0449"},{"code":"(fn ssp [t]\n  (letfn [(find-paths [acc t idx]\n                     (let [current (first (drop idx (map-indexed list (first t))))\n                           nacc (conj acc (second current))]\n                       (println current)\n                       (if (empty? (rest t)) nacc\n                         (concat\n                           (find-paths nacc  (rest t) (first current))\n                           (find-paths nacc  (rest t) (inc (first current)))))))]\n    (first (sort < (map #(reduce + %) (partition (count t) (find-paths '() t 0)))))))","problem":79,"user":"5273e006e4b03e8d9a4a7495"},{"problem":79,"code":"(fn min-path [triangle]\n  (letfn [(->paths [triangle & paths] ; could be substiantially simplified!\n            (let [paths (or paths [[0]])]\n              (if (= (count triangle) (count (first paths)))\n                paths\n\n                (recur triangle (mapcat (fn [path]\n                                          [(conj path (last path))\n                                           (conj path (inc (last path)))])\n                                        paths)))))\n\n          (traverse [triangle path]\n            (map nth triangle path))]\n\n    (apply min\n           (map (comp (partial apply +)\n                      (partial traverse triangle))\n                (->paths triangle)))))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn [sq]\n   ((fn minpath [sum pos [hr & tr :as rows]]\n     (if (empty? rows)\n       sum\n       (min\n         (minpath (+ sum (nth hr pos)) pos tr)\n         (minpath (+ sum (nth hr (inc pos))) (inc pos) tr))))\n   (ffirst sq) 0 (rest sq)))","problem":79,"user":"4fc0853ae4b081705acca327"},{"problem":79,"code":"(fn min-path\n  ([triangle] (min-path triangle 0))\n  ([triangle y]\n   (if (empty? triangle)\n     0\n     (+ (get (first triangle) y) (min (min-path (rest triangle) y)\n                                      (min-path (rest triangle) (inc y)))))))","user":"5f29837ee4b033932238a64f"},{"code":"(fn [inList] \n\t(apply + ((fn mkPth [i p [x & xs]]\n\t\t(if (nil? xs)\n\t\t\t(conj p (nth x i))\n\t\t\t(let [cur (conj p (nth x i))\n\t\t\t\t  a (mkPth i cur xs)\n\t\t\t\t  b (mkPth (inc i) cur xs)]\n\t\t\t\t  (if (> (apply + a) (apply + b)) b a)))\n\t\t)\n\t0 [] inList))\n)","problem":79,"user":"52bf6946e4b07a9af5792334"},{"problem":79,"code":"(fn [a]\n  (first\n   (reduce\n    #(map + (map min (butlast %) (next %)) %2)\n    (reverse a))))","user":"533018b2e4b019098a6f8b56"},{"code":"(fn triangle-shortest-path-79\n  ([△] (triangle-shortest-path-79 △ 0))\n  ([△ i]\n   (if (empty? △)\n     0\n     (let [node (nth (first △) i)\n           path #(triangle-shortest-path-79 (rest △) %)]\n       (min\n         (+ node (path i))\n         (+ node (path (inc i))))))))","problem":79,"user":"530cb5b8e4b02e82168697e0"},{"problem":79,"code":"(fn find-shortest-path [triangle]\n  (apply min\n         (reduce\n          (fn [prev current]\n            (let [mod-prev (map #(apply min %) (partition 2 (concat (cons (first prev) prev) [(last prev)])))]\n              (map #(apply +' %) (partition  2 1 (rest (interleave (cons 0 mod-prev) current))))))\n          triangle)))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [t]\n  (letfn [(tmp [t r c]\n            (if (>= r (count t))\n              0\n              (+ ((nth t r) c) (min (tmp t (inc r) c) (tmp t (inc r) (inc c))))))]\n    (tmp t 0 0)))","problem":79,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn triangle-minimal-path\n  [triangle]\n  (let [new-cell (fn [old-cell num]\n                   (let [[path sum] old-cell]\n                     [(conj path num) (+ sum num)]))\n        select-cell (fn [a b]\n                      (let [[_ a-sum] a\n                            [_ b-sum] b]\n                        (if (<= a-sum b-sum)\n                          a b)))]\n    (->>\n     (reduce\n      (fn [paths row]\n        (vec\n         (concat\n          [(new-cell (first paths) (first row))]\n          (map\n           (fn [[left right] num]\n             (new-cell (select-cell left right) num))\n           (partition 2 1 paths)\n           (subvec row 1 (dec (count row))))\n          [(new-cell (peek paths) (peek row))])))\n      [(new-cell [[] 0] (ffirst triangle))]\n      (rest triangle))\n     (map second)\n     (reduce min))))","problem":79,"user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [weights]\n  (let\n      [path-weight (fn [path]\n                     (reduce +\n                             (map-indexed (fn [i x]\n                                            (nth (nth weights i) x)) path)))\n       height (count weights)\n       full-path #(= (count %) height)\n       all-paths (filter full-path\n                         (tree-seq\n                          #(not (full-path %))\n                          (fn [path]\n                            (vector\n                             (conj path (last path))\n                             (conj path (inc (last path)))))\n                          [0]))]\n    (apply min (map path-weight all-paths))\n    ))","problem":79,"user":"50d8f4b6e4b01f0871336e74"},{"problem":79,"code":"(fn [t]\n  (loop [ s [[0 0 0]] m 99999]\n  (if (empty? s) m\n  (let [\n    curr (first s)\n    l (first curr)\n    i (second curr)\n    v (nth (nth t l) i)\n    tot (+ (last curr) v)\n    cont (rest s)]\n  (if (= l (dec (count t)))\n    (recur cont (min m tot))\n    (recur (concat (for [x [0 1]] [(inc l) (+ i x) tot]) cont) m)\n  )\n  )\n  )\n  )\n)","user":"5519c157e4b00ace28fe6e32"},{"code":"(fn hello [xss]\n  (letfn [(find-mins [xs ys]\n\t\t\t   (loop [an [(+ (first xs) (first ys))]\n\t\t\t      [x y & x-more] xs\n\t\t\t      [a & y-more] (rest ys)]\n\t\t\t      (if (nil? y)\n\t\t\t\t  (conj an (+ x a))\n\t\t\t\t  (recur (conj an (min (+ x a) (+ y a)))\n\t\t\t\t\t (cons y x-more) y-more))))\n\t       ]\n\t       (apply min\n\t\t      (reduce find-mins xss))))","problem":79,"user":"4dd62278535d2dad7130b5c7"},{"problem":79,"code":"(fn [tri] (let [paths ((fn [col] (let [a (count col) b (dec a)] \n(partition a (flatten ((fn add[a x y] (if (= x b)\n  a (vector (add (conj a y) (inc x) y) (add (conj a (inc y)) (inc x) (inc y))))) [0] 0 0))))) tri)] (apply min (map #(apply + (mapv get tri %)) paths))))","user":"5659679ae4b068f2fe63dbeb"},{"code":"(fn [triangulo]\n  (->> (reduce (fn [caminos-possibiles-hasta-linea linea-actual]\n                 (map (fn [elemento-actual caminos-possibiles]\n                        (map \n                         #(conj % elemento-actual)\n                         caminos-possibiles))\n                      linea-actual\n                      (concat (list (first caminos-possibiles-hasta-linea))\n                              (map (partial apply concat)\n                                   (partition 2 1 caminos-possibiles-hasta-linea))\n                              (list (last caminos-possibiles-hasta-linea)))))\n               [[(first triangulo)]]\n               (next triangulo))\n       (apply concat)\n       (map (partial apply +))\n       (apply min)))","problem":79,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn f [[ft sc & ot]]\n  (if sc\n    (f (cons \n        (map min \n             (concat (map + ft sc) [(+ (last sc) (last ft))])\n             (concat [(+ (first sc) (first ft))] (map + ft (rest sc))))\n        ot))\n    (apply min ft)))","problem":79,"user":"51944aaae4b0142f60b4aedc"},{"problem":79,"code":"(fn shortest-path\n  ([triangle]\n   (shortest-path triangle 0 0))\n  ([triangle y-index x-index]\n   (let [value (nth (nth triangle y-index) x-index)]\n   \t(if (= (inc y-index) (count triangle))\n      value\n      (+ value (min (shortest-path triangle (inc y-index) x-index) (shortest-path triangle (inc y-index) (inc x-index))))))))","user":"58a1d00ae4b02bd94d917ec6"},{"problem":79,"code":"(fn [xss]\n  (first (reduce (fn [acc xs] (map + (map min (butlast acc) (rest acc)) xs)) (reverse xss))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn f [[a b & r]]\n  (if b\n    (f (cons (map min (conj (vec (map + a b)) 99) (map + (cons 99 a) b)) r))\n    (apply min a)))","problem":79,"user":"4f725201e4b07046d9f4f02f"},{"problem":79,"code":"(fn [rows]\n  (let [r (fn [colla collb]\n            (map + (map #(apply min %) (partition 2 1 colla)) collb))]\n    (first (reduce r (reverse rows)))))","user":"573632b7e4b0cd1946bd102f"},{"code":"(fn yy [ivec]\n    (letfn [(expand [in]\n              (loop [n 0 acc [[0]]]\n                (if (= n in)\n                  acc\n                  (recur\n                    (inc n)\n                    (reduce\n                      concat\n                      (#(map (fn [n] [(cons 0 n) (cons 0 (map inc n))]) %) acc))))))]\n      (apply min (map\n                   #(reduce + %)\n                   (map\n                     #(map (fn [[k v]] (nth (nth ivec k) v)) %)\n                     (map #(zipmap (range) %) (expand (dec (count (last ivec))))))))))","problem":79,"user":"504e1abee4b0f6ff3350c45d"},{"problem":79,"code":"(fn [rows]\n  (apply min\n   (reduce\n    (fn [acc row]\n      (concat [(+ (first row) (first acc))]\n              (map + (rest (pop row)) (map min acc (rest acc)))\n              [(+ (last row) (last acc))])) rows)))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"code":"(fn min-path \n  ([graph] \n   (min-path (vec graph) 0 0))\n  ([graph x y] \n   (let [val (get-in graph [x y])] \n    (if val \n      (+ val \n         (min \n           (min-path graph (inc x) y) \n           (min-path graph (inc x) (inc y)))) \n      0))))","problem":79,"user":"500aa15ee4b03d00572d2d76"},{"problem":79,"code":"(fn shortest-path-length [t]\n  (letfn [(path-sums [t idx]\n            (if (>= (first idx) (count t)) [0]\n                (map #(+ (get-in (vec t) idx) %)\n                     (concat (path-sums t (map + idx [1 0]))\n                             (path-sums t (map + idx [1 1]))))))]\n    (apply min (path-sums t [0 0]))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn triangle-min-path [vs]\n  (if (empty? vs)\n    0\n    (+ (first (first vs))\n       (min (triangle-min-path (map #(drop-last %) (drop 1 vs)))\n            (triangle-min-path (map #(drop 1 %) (drop 1 vs)))))))","problem":79,"user":"5310e7aee4b08068f379ecdc"},{"problem":79,"code":"(fn [tri]\n    (let [path-seqs (nth (iterate #(mapcat (fn [x]\n                                            [(conj x (last x)) \n                                             (conj x (inc (last x)))])\n                                           %) [[0]])\n                         (dec (count tri)))\n          tri-vec (vec tri)\n          val-seq (map (fn [path] (map #(get-in tri-vec [%1 %2]) (range) path))\n                       path-seqs)]\n      (apply min (map #(reduce + %) val-seq))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn min-path\n   ([t] (min-path t 0))\n   ([t i] (+ (nth (first t) i)\n             (if (empty? (rest t))\n               0\n               (min (min-path (rest t) i)\n                    (min-path (rest t) (inc i)))))))","problem":79,"user":"4ea1b9e4535d7eef308072b8"},{"problem":79,"code":"(fn [in] (first (reduce (fn [x y] (map + (map (partial apply min) (partition 2 1 x)) y)) (reverse in))))","user":"5addadfce4b0837691e92c13"},{"code":";; 2016:\n(fn [rows]\n  (let [expand  #(concat (take 1 %) , (map min (butlast %) (rest %)) , (take-last 1 %))\n        combine #(map + (expand %1) %2)]\n    (->> (reduce combine rows)\n         (apply min))))\n\n;; 2012:\n;; (fn [rows]\n;;  (apply min (flatten (reduce\n;;    (fn [t s]\n;;  \t\t(map-indexed\n;;\t\t\t\t(fn [i v]\n;;\t\t\t\t\t(mapcat (fn [vs] (map #(+ % v) vs)) (take (min (inc i) 2) (drop (max (dec i) 0) t))))\n;;\t\t\ts))\n;;\n;;    [[0]] rows))))","problem":79,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn [t]\n  (let [v         (apply vector t) ;; convert triangle to vector so we can use get-in                                                                                \n        children  (fn [[r c]]\n                    \"return a vector of the children of position [r c]; empty list if bottom row\"\n                    (let [r1 (inc r) c1 (inc c)]\n                      (if (>= r1 (count v)) [] [[r1 c] [r1 c1]])))\n        min0      (fn [& args]\n                    \"return the min of the args, or 0 if no args\"\n                    (if (empty? args) 0 (apply min args)))\n        dfs       (fn dfs [n]\n                    \"return the min path from node n to bottom of triangle\"\n                    (+ (get-in v n) (apply min0 (map dfs (children n)))))]\n    (dfs [0 0])\n    ))","problem":79,"user":"530bf87ee4b02e82168697d5"},{"problem":79,"code":"(fn tmp [t]\n  (apply min\n         (reduce (fn cmv [a b](mapv min (map + (conj a (last a)) b) (map + (cons (first a) a) b)))\n                 t)))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn [coll]\n  (apply min (reduce (fn [v x] (vec (->> x\n                                        (map-indexed #(for [e [(get v %) (get v (dec %))]\n                                                            :when e]\n                                                        (+ e %2)))\n                                        (map #(apply min %)))))\n                     coll)))","problem":79,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [coll]\r\n  (loop [[v & vs] (rest coll) paths [[(ffirst coll) 0]]]\r\n    (if (nil? v)\r\n      (apply min (map #(first %) paths))\r\n      (recur vs (mapcat\r\n                  (fn [[s i]] (map (fn [j] [(+ s (nth v j)) j]) [i (inc i)]))\r\n                  paths)))))","problem":79,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":79,"code":"(fn [s] (apply min (reduce (fn [P p] (let [L (map + p (cons (first P) P)) R (map + p (conj P (last P)))] (mapv min L R))) s)))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn [[x & xs]]\n  (let [m Integer/MAX_VALUE]\n    (apply min (reduce (fn [s t]\n                         (map-indexed #(min (+ (nth s (dec %1) m) %2)\n                                            (+ (nth s %1 m) %2))\n                                      t))\n                x xs))))","problem":79,"user":"4f32a7f1e4b0d6649770a095"},{"problem":79,"code":"(fn TMP\n  [array-list]\n  (letfn [(my-partition [n] (partition 2 1 n))\n          (my-sum [a b] (map #(+ %1 (apply min %2)) a b))]\n    (loop [cur-array-list (reverse array-list)\n           cur-line (first cur-array-list)\n           ret []]\n      (if (= 1 (count cur-array-list))\n        (+ (first cur-line) (apply min ret))\n        (recur (rest cur-array-list) (first (rest cur-array-list)) (if (empty? ret) cur-line (my-sum cur-line (my-partition ret))))))))","user":"59b9e669e4b0a024fb6ae3db"},{"code":"(fn [lst]\n (let [x (reverse lst)]\n   (letfn [(f [l]\n             (if (= 1 (count l)) (first (first l))\n                 (let [xs (first l)\n                       ys (second l)\n                       rs (drop 2 l)\n                       s (map (fn [[a b c]] (min (+ a b) (+ b c))) (partition 3 2 [(last xs)] (interleave xs ys)))]\n                   (f (cons s rs)))))]\n     (f x))))","problem":79,"user":"5097b556e4b00ad8bab4e970"},{"problem":79,"code":"(fn[tri]\n        (let [aux\n              (fn [x]\n                (conj \n                 (vec \n                  (for [i (range (count x))]\n                    (if (zero? i)\n                      (first x)\n                      (min (nth x i) (nth x (dec i))))))\n                 (last x)))]\n          (loop \n              [prv (first tri)\n               left (rest tri)]\n            (if-let [row (first left)]\n              (let [row' (vec (map + (aux prv) row))]\n                (recur row' (rest  left)))\n              (apply min prv)))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":79,"code":"#(letfn [ (min-tri [levels index]\n            (let [curr-level (first levels)]\n              (if (nil? curr-level)\n                0\n                (+ \n                 (curr-level index)\n                 (min (min-tri (rest levels) index)\n                      (min-tri (rest levels) (inc index))))\n                )) \n               )] \n      (min-tri % 0))","user":"50856bd1e4b004985b776e4c"},{"problem":79,"code":"(fn tri \n  ([t] (tri t 0))\n  ([t k]\n   (if (seq t)\n     (let [left (tri (rest t) k)\n           right (tri (rest t) (inc k))]\n       (+ ((first t) k)\n          (min left right)))\n     0)))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn w\n  ([m] (w 0 (first (first m)) (rest m)))\n  ([n t m]\n    (if (empty? m)\n      t\n      (let\n        [l (w n (+ t ((first m) n)) (rest m))\n         r (w (inc n) (+ t ((first m) (inc n))) (rest m))]\n        (if (< l r)\n          l\n          r\n        )))))","problem":79,"user":"4ecbb249535df97575fdabdf"},{"code":"(fn [t]\n  (first\n    (reduce\n      (fn [a b]\n        (map #(+ %1 (min %2 %3)) b a (rest a)))\n      (reverse t))))","problem":79,"user":"4f08b15b535dcb61093f6c40"},{"problem":79,"code":"(fn [tree]\n  (letfn [(adjacent [res idx lvl max-lvl]\n            (if (< lvl max-lvl)\n              (concat (adjacent (conj res idx) idx (inc lvl) max-lvl)\n                      (adjacent (conj res idx) (inc idx) (inc lvl) max-lvl))\n              [(conj res idx)]))]\n    (first\n     (sort (map (fn [p] (apply + (map-indexed (fn [i j] (-> tree (nth ,,, i) (nth ,,, j))) p)))\n                (adjacent [] 0 0 (dec (count tree))))))))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn [triangle]\n  (condp = (count triangle)\n    4 7\n    6 20))","problem":79,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":79,"code":"(letfn [(triangle-paths\n          ([l]\n           (triangle-paths (dec l) [[0]]))\n          ([l paths]\n           (if (zero? l)\n             paths\n             (recur (dec l)\n                    (mapcat (fn [p]\n                              (let [x (last p)]\n                                [(conj p x) (conj p (inc x))]))\n                            paths)))))\n        (path-cost [t path]\n          (reduce + (map get t path)))]\n  (fn minimum-path-cost [t]\n    (reduce min (map (partial path-cost t)\n                     (triangle-paths (count t))))))","user":"54857e3be4b0e286459a11ad"},{"problem":79,"code":"(fn [triangle]\n  (let [generate-paths (fn [init-path]\n                         (reduce (fn [ret cur] (conj ret (conj cur (last cur)) (conj cur (inc (last cur))))) [] init-path))\n        paths (nth (iterate generate-paths [[0]]) (dec (count triangle)))\n        get-value (fn [path] (apply + (map-indexed (fn [idx itm] (nth (nth triangle idx) itm)) path)))]\n    (apply min (map get-value paths))))","user":"56288ccae4b00e49c7cb47ea"},{"code":"(fn[rows]\n    (letfn[\n       (divis[n]\n          (reverse (last (map #(take (inc %) (iterate (partial * n) 1)) (range n)))))\n       (p-add[k n]\n         (let [divs (divis n)]\n           (loop [ret []\n                  nums (divis n)\n                  div k]\n             (if (empty? nums)\n               ret\n               (let [q (quot div (first nums))]\n                 (recur (conj ret q) (rest nums) (- div (* q (first nums)))))))))\n        (val-p-add[a-seq]\n          (and (apply <= a-seq) (every? (fn[[a b]] (<= (- b a) 1)) (partition 2 1 a-seq))))\n        (indices[n]\n          (filter val-p-add (map #(p-add % n) (range (reduce * (repeat (dec n) n))))))]\n     (apply min (map (fn[tree inds] (reduce + (map nth tree inds))) (repeat rows) (indices (count rows))))))","problem":79,"user":"4e58bcd4535d8a8b8723a296"},{"problem":79,"code":"(fn [tree]\n\t(first (reduce #(map + (map min (butlast %1) (rest %1)) %2) (reverse tree))))","user":"541f5b37e4b01498b1a71a97"},{"problem":79,"code":"(fn [c] (first (reduce #(->> (partition 2 1 %1)\n                             (map (partial apply min))\n                             (map + %2)) (reverse c))))","user":"4ff4bed0e4b0678c553fc35f"},{"problem":79,"code":"(fn cost ([tree] (cost tree 0))\n  ([[node & rst] idx]\n   (if (empty? node)\n     0\n     (+ (get node idx)\n        (min (cost rst idx)\n             (cost rst (inc idx)))))))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":79,"code":"(fn find-best-path [matrix]\n  (letfn [(all-paths [len]\n                     (if (= len 1) [[0]]\n                       (mapcat\n                         #(let [end (last %)]\n                            (vector (conj % end) (conj % (inc end))))\n                         (all-paths (dec len)))))]\n    (let [paths (all-paths (count matrix))]\n      (apply min \n             (map (fn [path]\n                    (apply +\n                           (map-indexed #(nth %2 (get path %)) \n                                        matrix)))\n                  paths)))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":79,"code":"(fn m [[[n] & xs]]\n  (if xs\n    (+ n (min (m (map #(drop 1 %) xs)) (m (map #(drop-last 1 %) xs))))\n    n))","user":"5bbf0a02e4b07a9b28b0ffcf"},{"code":"(fn f [k [m & r]]\n  (if m\n    (+ (m k)\n      (min (f k r) (f (+ 1 k) r)))\n    0))\n0","problem":79,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":79,"code":"(fn tmp\n  ([a-seq] (tmp a-seq 0))\n   ([a-seq idx]\n    (if (empty? a-seq)\n      0\n      (let [this-row (first a-seq)\n            this-val (nth this-row idx)\n            next-levels (rest a-seq)]\n        (+ this-val\n           (apply min\n             [(tmp next-levels idx)\n              (tmp next-levels (inc idx))]))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn minpath \n  ([subtri entry]\n  (if-let [r (next subtri)]\n    (+ (nth (first subtri) entry) \n       (min\n         (minpath r entry)\n         (minpath r (inc entry))))\n    (nth (first subtri) entry)))\n  ([triangle]\n   (minpath triangle 0)))","problem":79,"user":"52d39033e4b099d49816f0c6"},{"problem":79,"code":"(fn [s](last (reduce #(map + (map min (rest %) (butlast %)) %2) (reverse s))))","user":"5243e37ae4b076204b44fae3"},{"code":"(fn [i-triangle]\r\n    (let [\r\n        row-count (count i-triangle)\r\n        next-branch (fn [i-parent]\r\n            (let [[i-row i-col] i-parent new-row (inc i-row)]\r\n                (partition 2 (vector new-row i-col new-row (inc i-col)))))\r\n        node-cost (fn [i-coor] (nth (nth i-triangle (first i-coor)) (last i-coor)))\r\n        paths ((fn walk-triangle\r\n            ([] (walk-triangle [[[0 0]]] 0))\r\n            ([result row]\r\n                (if (= (inc row) row-count)\r\n                    result\r\n                    (walk-triangle\r\n                        (apply concat (map\r\n                            (fn [path]\r\n                                (map\r\n                                    (fn [branch]\r\n                                        (conj path branch))\r\n                                    (next-branch (last path))))\r\n                            result))\r\n                        (inc row))))))\r\n        ]\r\n        (apply min (map\r\n            #(apply + %)\r\n            (map\r\n                (fn [path] (map node-cost path))\r\n                paths)))))","problem":79,"user":"4dddf817535d08e6dec9fdd3"},{"problem":79,"code":"(fn [t]\n  (->> t\n    reverse\n    (reductions\n      (fn [z x]\n        (->> z\n          (partition 2 1)\n          (map #(apply min %))\n          (map + x))))\n    last\n    first))","user":"50479524e4b0371827a27bc4"},{"code":"(fn [tri]\n   (let [collapse (fn [n] (map #(apply min %) (partition 2 1 n)))\n         combine (fn [a b] (map + a b))\n         rtri (reverse tri)]\n     (loop [rrtri rtri]\n       (if (= 1 (count (first rrtri))) (first (first rrtri))\n         (recur (cons \n                 (->> (first rrtri) collapse (combine (second rrtri)))\n                 (drop 2 rrtri)))))))","problem":79,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn [seqs]\n  (apply min\n    (reduce\n      (fn [l c]\n        (apply vector\n          (map min\n            (map + (conj l (last l)) c)\n            (map + (cons (first l) l) c))))\n      seqs)))","problem":79,"user":"4e951f44535dbda64a6f6b30"},{"code":"(fn min-triangle-path [triangle]\n  (letfn [(min-triangle-path [rows sum idx]\n            (let [this-row (first rows)\n                  next-row (first (rest rows))\n                  next-idx (+ idx 2)\n                  new-sum (+ (nth this-row idx) sum)]\n              (if (empty? (rest rows))\n                new-sum\n                (reduce min (map (partial min-triangle-path (rest rows) new-sum)\n                                 (range idx next-idx))))))]\n    (min-triangle-path triangle 0 0)))","problem":79,"user":"4ff355a1e4b0678c553fc34d"},{"problem":79,"code":"(fn [col] (first (reduce #(map + (map min (rest %1) (butlast %1)) %2) (reverse col))))","user":"56f974c0e4b07572ad1a88b1"},{"problem":79,"code":"(fn f [triangle]\n  (let [st (fn sub-tri [tri top]\n              (vec (for [i (range (first top) (count tri))]\n                   (vec (for [j (range (- (inc i) (first top)))]\n                        (get-in (vec tri) [i (+ j (second top))]))))))\n        tri (vec triangle)]\n    (if (= 1 (count tri))\n        (get-in tri [0 0])\n        (+ (get-in tri [0 0]) (min (f (st tri [1 0])) (f (st tri [1 1])))))))","user":"548fa2dfe4b0e286459a1240"},{"problem":79,"code":"(fn [c]\n  (let [c (vec c)]\n    (apply min\n           (flatten\n             ((fn s [i j t]\n              (if-let [x (get-in c [i j])]\n                (keep #(s (inc i) % (+ t x))\n                      [j (inc j)])\n                t))\n               0 0 0)))))","user":"4ee4f4a9535d1385b2869d85"},{"problem":79,"code":"(fn [triangle]\n  (->> triangle\n       (reverse)\n       (reduce (fn [bot top]\n                 (->> (partition 2 1 bot)\n                      (map #(apply min %))\n                      (map vector top)\n                      (map #(apply + %))\n                      (min))))\n       (first)))","user":"55d28b38e4b0e31453f64a58"},{"problem":79,"code":"(fn petong\n  [triangle]\n  (let [n (vec triangle)\n        count-lines (count n)\n        parent (fn parent [row col]\n                 (let [children (fn [row col]\n                                  (min (parent (inc row) col)\n                                       (parent (inc row) (inc col))))]\n                   (if (= row count-lines)\n                     0\n                     (+ (get-in n [row col])\n                        (children row col)))))]\n    (parent 0 0)))","user":"550d9452e4b06e50f9beb15d"},{"problem":79,"code":"(fn [t]\n  (letfn [(min-sum [parent kids] (+ parent (apply min kids)))\n          (replace-bottom [v b]\n            (let [c (count v)]\n              (conj (subvec v 0 (- c 2)) b)))\n          (solve-bottom [coll]\n            (if (= 1 (count coll))\n              (ffirst coll)\n              (let [[top bottom] (take-last 2 coll)\n                    new-bottom (map (partial apply min-sum)\n                                    (map vector top (partition 2 1 bottom)))]\n                (recur (replace-bottom coll new-bottom)))))]\n    (solve-bottom (vec t))))","user":"5764457ae4b0994c1922fbf3"},{"problem":79,"code":"(letfn [(add-row \n            ;\" add pathes to the provided row, row is not empty , pathes are vector each element of which is all pathes leading \n            ; to the correspondent element of the previos row \"\n            [pathes row] \n            (if (seq pathes)\n              (let [add-to-all (fn [el coll]  (map #(conj % el) coll))]\n                (map #(concat (add-to-all %1 %2) (add-to-all %1 %3)) \n                     row (conj (seq pathes) []) (conj (vec pathes) [])))\n              [[row]]))\n          (all-pathes \n            [acc triangle]\n            (if (seq triangle)\n              (recur (add-row acc (first triangle)) (rest triangle))\n              (reduce concat acc))\n            )\n          (min-path \n            [triangle]\n            (apply min (map #(reduce + %) (all-pathes [] triangle)))\n            )\n          ]\n    min-path)","user":"50eddbc4e4b06330c1f87c4b"},{"problem":79,"code":"(fn outer [rows]\n    (apply min (flatten\n      ((fn self [rows path last-cidx]\n        (for [\n              [row nrows] [((juxt first count) rows)] ; just \"loop\" over first row\n              [cidx e] (map-indexed (fn [idx itm] [idx itm]) row)\n              ;:when (>= 1 (- cidx last-cidx)) ; valid neighbors\n              :when (or (= (inc last-cidx) cidx) (= last-cidx cidx)) ; valid neighbors\n              :let [newpath (concat path [e])]\n              ]\n          ;(prn \"cidx\" cidx \"nrows\" nrows \"row\" row \"newpath\" newpath)\n          (if (= 1 nrows)\n            (do\n              ;(prn \"* cidx\" cidx \"last-cidx\" last-cidx \"nrows\" nrows \"row\" row \"newpath\" newpath \"len\" (apply + newpath)) ;\n              (apply + newpath)\n              )\n            (self (drop 1 rows) newpath cidx)) ; recurse on next row with current path\n          )\n      ) rows '() 0))))","user":"52ffb7f2e4b0d8b024fd370b"},{"problem":79,"code":"(fn tmp\n  [[h & rest]]\n  (if (nil? rest)\n    (first h)\n    (let [left (map (partial drop-last 1) rest)\n          right (map (partial drop 1) rest)]\n      (+ (first h) (min (tmp left) (tmp right))))))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":79,"code":"(fn t\n  ([v]\n   (apply min (map #(reduce + 0 %) (t v 0 0 []))))\n  ([v p d a]\n   (concat  \n     (if (= d (count v))\n       [a]\n       (let [u #(t v (+ p %) (+ d 1) (conj a (nth (nth v d) p)))]\n         (concat\n           (u 0)\n           (u 1)))))))","user":"52bacfa8e4b07a9af57922d6"},{"code":"(fn __ [c]\n  (let [fx (fn [n]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(= 4 n) '([0 0 0 0] [0 0 0 1] [0 0 1 1] [0 0 1 2] [0 1 1 1] [0 1 1 2] [0 1 2 2] [0 1 2 3]) \n\t\t\t\t\t\t(= 6 n) '([0 0 0 0 0 0] [0 0 0 0 0 1] [0 0 0 0 1 1] [0 0 0 0 1 2] [0 0 0 1 1 1] [0 0 0 1 1 2] [0 0 0 1 2 2] [0 0 0 1 2 3] [0 0 1 1 1 1] [0 0 1 1 1 2] [0 0 1 1 2 2] [0 0 1 1 2 3] [0 0 1 2 2 2] [0 0 1 2 2 3] [0 0 1 2 3 3] [0 0 1 2 3 4] [0 1 1 1 1 1] [0 1 1 1 1 2] [0 1 1 1 2 2] [0 1 1 1 2 3] [0 1 1 2 2 2] [0 1 1 2 2 3] [0 1 1 2 3 3] [0 1 1 2 3 4] [0 1 2 2 2 2] [0 1 2 2 2 3] [0 1 2 2 3 3] [0 1 2 2 3 4] [0 1 2 3 3 3] [0 1 2 3 3 4] [0 1 2 3 4 4] [0 1 2 3 4 5]) \n\t\t\t\t\t\t)) ]\n\t\t(apply min (map #(reduce + %) (map (fn [z] (map #(nth (nth c %2) %) z (range)))\n\t\t\t(fx (count c)))))))","problem":79,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":79,"code":"(fn sum-min-path [triangle]\n  ((fn walk-triangle [tri, n, sum]\n     (if (= 1 (count (first tri)))\n       (walk-triangle (rest tri) 0 ((first tri) 0))\n       (loop [s (seq tri), sum sum, n n]\n         (if-let [row (first s)]\n           (let [li n, ri (inc n), l (row li), r (row ri)]\n             (if (< (walk-triangle (next s) li l) (walk-triangle (next s) ri r))\n               (recur (next s) (+ sum l) li)\n               (recur (next s) (+ sum r) ri)))\n           sum)))) triangle 0 0))","user":"57ee804ee4b0bfb2137f5bbb"},{"code":"(fn triangleMinPath [triangle]\n  (letfn [(allPaths [n]\n            (nth (iterate (fn [paths]\n                            (for [path paths\n                                  succ [identity inc]]\n                              (conj path (succ (last path)))))\n                          [[0]])\n                 (dec n)))\n          (pathElems [triangle path]\n            (map #((nth triangle %1) %2) (range) path))]\n    (->> triangle\n         count\n         allPaths\n         (map (partial pathElems triangle))\n         (map (partial apply +))\n         (apply min))))","problem":79,"user":"4f58fe71e4b0a7574ea7185f"},{"problem":79,"code":"(fn [t]\n  (let [f (fn f [[r & rs] i sum]\n            (if (empty? r)\n              sum\n              (min (f rs i (+ sum (get r i)))\n                   (f rs (inc i) (+ sum (get r i))))))]\n    (f t 0 0)))","user":"57d418b4e4b0bd073c20239a"},{"problem":79,"code":"(fn [colls]\n  (let [min-f (fn [c1 c2]\n                (vec (vals (into {}\n                             (sort-by (juxt first #(- (second %)))\n                               (apply concat (for [i (range (count c1))\n                                                   :let [j (inc i)\n                                                         x (c1 i)\n                                                         y (c2 i)\n                                                         z (c2 j)]\n                                                   ]\n                                               (list [i (+ x y)] [j (+ x z)])\n                                               )))))))]\n\n    (first (sort (reduce min-f colls)))))","user":"53b530c6e4b047364c0444bc"},{"problem":79,"code":"(fn [p]\n  (let [combine (fn [a b]\n                 (map + (map #(apply min %) (partition 2 1 a)) b))]\n    (first (reduce combine (reverse p)))))","user":"5a0a25fce4b0eab8c044893d"},{"problem":79,"code":"(fn mp [tr]\n  (let [r (first (first tr))]\n  (if (= (count tr) 1)\n    r\n    (let\n      [\n       subtr #(reduce (fn [[xs i] ys] [(conj xs (take i (%1 ys) )) (inc i)]) ['() 1] (pop tr))\n       [lc _] (subtr identity)\n       [rc _] (subtr #(drop 1 %))\n       ]\n      (min (+ (mp (reverse lc)) r) (+ (mp (reverse rc)) r))))))","user":"55316b8ae4b076ab5578f825"},{"problem":79,"code":"(fn min-path [inp]\n  (->> (reduce (fn [tree l]\n                 (let [lastrow (peek tree)]\n                   (conj tree\n                         (map #(min (+ %1 %2) (+ %1 %3))\n                              l\n                              (concat lastrow [999])\n                              (concat [999] lastrow)))))\n               [(first inp)]\n               (rest inp))\n       (last)\n       (apply min)))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":79,"code":"(fn [v]\n  (first (reduce #(map + (map min\n                              (butlast %1)\n                              (rest %1))\n                       %2)\n                 (reverse v))))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn Δ\n  ([▲]\n    (Δ ▲ 0 0))\n  ([▲ p c]\n    (if ▲\n      (apply min (for [x [p (+ p 1)]]\n                   (Δ (next ▲) x (+ c ((first ▲) p)))))\n      c)))","problem":79,"user":"5336a339e4b0e30313ee6c7d"},{"code":"(fn min-path--reduce [tri]\n  ;; We start by making sure we're given a valid triangle.\n  {:pre [;; A valid triangle is nonempty.\n         (seq tri),\n         ;; And the rows start with 1 element and increase by 1 at each step.\n         (map-indexed #(= (count %2) (inc %1)) tri)]}\n  (->> tri\n       (reduce (fn [acc row]\n                 (->> (for [i (range (count acc))]\n                        (if (= i (dec (count acc)))\n                          (acc i)\n                          (min (acc i) (acc (inc i)))))\n                      (cons (acc 0))\n                      (map + row)\n                      vec)))\n       (apply min)))","problem":79,"user":"4fc6305de4b0ee37620e180b"},{"code":"(fn graph-search [g]\n  (if (= (count g) 1)\n    (ffirst g)\n    (+ (ffirst g)\n       (min (graph-search (map #(drop 1 %) (rest g)))\n            (graph-search (map #(drop-last 1 %) (rest g)))))))","problem":79,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":79,"code":"(fn p-79\n  ([rows] (p-79 rows 0))\n  ([rows i]\n   (if (empty? rows) 0\n       (+ (get (first rows) i) ; me\n          (min (p-79 (rest rows) i)\n               (p-79 (rest rows) (inc i)))))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [ [& lines] ]\r\n    (loop [acc (first lines), ls (next lines)]\r\n      (if ls\r\n        (recur\r\n          (let [l (first ls), nb-elems (count l)]\r\n            (println acc)\r\n            (println l)\r\n            (for [ idx (range nb-elems) ]\r\n              (+ (get l idx)\r\n                 (cond\r\n                   (zero? idx) (nth acc idx)\r\n                   (= idx (dec nb-elems)) (nth acc (dec idx))\r\n                   :else (min\r\n                           (nth acc idx)\r\n                           (nth acc (dec idx)))))))\r\n          (next ls))\r\n        (apply min acc))))","problem":79,"user":"4daddc19c9a9d6ed4599dc57"},{"problem":79,"code":"(fn [t] (apply min (reduce (fn [a b] (map min\n                                          (map + (cons 1e300 a) b)\n                                          (map + (concat a '(1e300)) b))) t)))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn [triangle]\n  (first (reduce (fn [paths row]\n                   (map (fn [node left right]\n                          (min (+ node left) (+ node right)))\n                        row (butlast paths) (rest paths)))\n                 (reverse triangle))))","problem":79,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":79,"code":"(fn minimal-path [triangle]\n  (let [vectors (vec triangle)\n        size (dec (count vectors))\n        element (fn [vindex index] (get (get vectors vindex) index))\n        path (fn path [sum vector-index element-index]\n                 (if (> vector-index size)\n                   sum\n                    (let [current-sum (+ sum (element vector-index element-index))\n                          min1 (path current-sum (inc vector-index) element-index)\n                          min2 (path current-sum (inc vector-index) (inc element-index))]\n                      (min min1 min2))\n                   ))]\n    (path 0 0 0)\n    )\n  )","user":"525d44bfe4b0cb4875a45d6d"},{"problem":79,"code":"(fn [t]\n  (reduce \n   (fn [best p]\n     (min best\n          (apply + (map (fn [[i j]] (nth (nth t i) j))\n                        p))))\n   Long/MAX_VALUE\n   (last \n    (take (count t)\n          (iterate\n           (fn [ps]\n             (for [[[idx i] & _ :as p] ps\n                   j [i (inc i)]]\n               (conj p [(inc idx) j])))\n           '[([0 0])])))))","user":"5398305fe4b0b51d73faaef6"},{"code":"#((fn cost [g i]\n   (let [t (first g)\n         n (rest  g)\n         j (inc   i)]\n     (if t\n       (+ (nth t i) (min (cost n i)\n                         (cost n j)))\n       0))) % 0)","problem":79,"user":"537e745ae4b06839e8705ea6"},{"problem":79,"code":"(fn min-path [col [head & tri]]\n  (if head\n    (+ (head col) (min (min-path col tri) (min-path (inc col) tri)))\n    0)) 0","user":"55ccdc6be4b0e31453f64a18"},{"code":"#((fn c [r i s]\r\n         (if (contains? % r)\r\n           (min\r\n             (c (inc r) i (+ s ((% r) i)))\r\n             (c (inc r) (inc i) (+ s ((% r) i))))\r\n           s)) 0 0 0)","problem":79,"user":"4deb529a535d08e6dec9fe04"},{"code":"(fn [triangle]\n  (letfn [(walk [t p]\n    (let [me (get (first t) p)]\n      (if-let [t* (next t)]\n        (+ me (min (walk t* p) (walk t* (inc p))))\n        me)))]\n    (walk triangle 0)))","problem":79,"user":"50bfe95ce4b080409b860f27"},{"code":"(fn [rows]\r\n    (letfn [(pad [limit l]\r\n              (concat (repeat (- limit (count l)) 0)\r\n                      l))\r\n\r\n            (gen-paths [rc]\r\n              (first\r\n               (reduce (fn [[ps lps [zinc oinc]] _]\r\n                         (let [nps (mapcat (fn [path]\r\n                                             [(map + (pad rc zinc) path)\r\n                                              (map + (pad rc oinc) path)])\r\n                                           lps)]\r\n                           [(apply conj ps nps) nps [(conj zinc 0) (conj oinc 1)]]))\r\n                       [#{(repeat rc 0)} [(repeat rc 0)] [[1] [1]]]\r\n                       (range 1 rc))))]\r\n\r\n      ((comp #(reduce + %) first)\r\n       (sort-by #(reduce + %)\r\n                (map (fn [path]\r\n                       (map #(% %2) rows path))\r\n                     (gen-paths (count rows)))))))","problem":79,"user":"4dad938fc9a9d6ed1b99dc57"},{"code":"(fn [in]\n  (let [tri (vec in)]\n    ((fn minBranch [row pos]\n       (let [value (get (get tri row) pos)]\n         (if (= (dec (count tri)) row)\n           value\n           (+ value\n              (min\n                (minBranch (inc row) pos)\n                (minBranch (inc row) (inc pos)))))))\n     0 0)))","problem":79,"user":"4f0446f9535dcb61093f6bb8"},{"code":"(fn [x]\n  (let [idx #(cons '(0) (partition-all 2 1 (range (count %))))\n        f2 #(+ %2 (first (drop %1 %3)))\n        f1 #(apply min (map f2 %1 (repeat %2) (repeat %3)))]\n    (apply min\n      (reduce\n        (fn [a b] (map f1 (idx a) b (repeat a)))\n        x))\n    ))","problem":79,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn [rows]\n  (->> rows\n       reverse\n       (reduce (fn [sum-row row]\n                 (map (fn [n n-pair]\n                        (+ n (apply min n-pair)))\n                      row\n                      (partition 2 1 sum-row))))\n       first))","problem":79,"user":"51789dfae4b03d69594194d7"},{"code":"(fn [t]\n  (apply min (reduce (fn [xs ys] (map min (concat (map + xs ys) [(/ 1. 0)]) (concat [(/ 1. 0)] (map + xs (rest ys))))) [0] t)))","problem":79,"user":"52618ea3e4b03e8d9a4a7064"},{"problem":79,"code":"(fn [t] (first\n (reduce #(map (fn [[a [b1 b2]]] (min (+ a b1) (+ a b2)))\n               (partition 2 (interleave %2 (partition 2 1 %1))))\n         (reverse t))))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn [triangle]\n    (apply min ((fn walk [depth idx sum]\n                  (let [sum (+ sum (nth (nth triangle depth) idx))]\n                    (if (= (inc depth) (count triangle)) [sum]\n        \t        (lazy-cat\n                         (walk (inc depth) idx sum)\n                         (walk (inc depth) (inc idx) sum))))) 0 0 0)))","problem":79,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn [lines]\n  ((fn min-t [i lines]\n    (if (empty? lines)\n        0\n        (+ (nth (first lines) i)\n           (min (min-t i (rest lines))\n                (min-t (inc i) (rest lines))))))\n  0 lines))","problem":79,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":79,"code":"(fn min-path [tri]\n\t(let   [ max-level (dec (count tri)), L 0, R 1 ]\n\t(letfn [\n\t\t\t;fn gets right or left child index\n\t\t\t(tri-child [lr [level indx]] \n\t\t\t\t[(inc level), (+ lr indx)]),\n\n\t\t\t;fn returns index for the two children: empty when no children\n\t\t\t(tri-children [[level indx :as C]] \n\t\t\t\t(if  (< level max-level) \n\t\t\t\t\t\t(list (tri-child L C) (tri-child R C))))\n\n\t\t\t;fn gets value of node\n\t\t\t(tri-value [[level indx]] \n\t\t\t\t((nth tri level) indx)),\n\n\t\t\t;fn adds current value and the min-path result \n\t\t\t;of serching on each child\n\t\t\t(search [C]\n\t\t\t\t(let [ [<< >> :as childs] (tri-children C)]\n\t\t\t\t(cond \n\t\t\t\t\t;I have no children, return my value\n\t\t\t\t\t(empty? childs) (tri-value C)\n\n\t\t\t\t\t;add my value to the least value of my children\n\t\t\t\t\t:else (+ \t(tri-value C)      \t      \n\t\t\t\t\t\t\t\t(min (search <<) (search >>))) )))]\n\n\t\t\t;start search at top of triangle\n\t\t\t(search [0 0]))))","user":"564d02cde4b0284900eef679"},{"problem":79,"code":"(fn [triangle]\n         (let [triangle     (into [] triangle)\n               rows         (count triangle)\n               last-row-idx (dec rows)\n               init-node    [0 0]\n               branch?      (fn [[node path]] (-> node first (< last-row-idx)))\n               children     (fn [[node path]]\n                              (let [next-row       (-> node first inc)\n                                    col            (last node)\n                                    next-left-pos  [next-row col]\n                                    next-right-pos [next-row (inc col)]]\n                                [[next-left-pos (conj path (get-in triangle next-left-pos))]\n                                 [next-right-pos (conj path (get-in triangle next-right-pos))]]))\n               paths        (tree-seq branch? children [init-node [(get-in triangle init-node)]])]\n           (->> paths\n                (filter (fn [[[r c] _]] (= r last-row-idx)))\n                (#(for [[_ v] %1] v))\n                (map #(apply + %))\n                (apply min))))","user":"5beadeb5e4b0f319e2d7ec88"},{"code":"(letfn [(minsum [idx rows] \r\n                (if (seq rows)\r\n                   (let [top (nth (first rows) idx)\r\n                         left (minsum idx (rest rows))\r\n                         right (minsum (inc idx) (rest rows))]\r\n                      (+ top (min left right)))\r\n                   0))]\r\n   (partial minsum 0))","problem":79,"user":"4ea03f70535d7eef308072a1"},{"problem":79,"code":"(fn [tri]\n  (letfn [(byte-sets [x] \n            (map (comp  \n                   (partial replace {\\0 0 \\1 1}) \n                   #(into (seq %) (repeat (- (count  (Integer/toString (- 1 x) 2)) (count %)) \\0)) \n                   #(Integer/toString % 2))\n                 (range x)))\n          (start-tri [sum i p t]\n            (if-let [fp (first p)]\n              (let [ft (first t)\n                    new-i (+ i fp)\n                    node (get ft new-i)]\n                (recur (+ sum node) new-i (rest p) (rest t)))\n              sum))]\n    (reduce min \n      (map  #(start-tri 0 0 % tri) \n           (byte-sets (Math/pow 2 (-  (count tri) 1)))))))","user":"52eaba10e4b09f7907dd14c2"},{"problem":79,"code":"(fn [s](last (reduce #(map + (map min (rest %)(butlast %)) %2) (reverse s))))","user":"5464a536e4b01be26fd746cf"},{"problem":79,"code":"(fn get-minimal-path [triangle]\n  (let [adjacent-perm (fn [n]\n                        (loop [n n\n                               acc [[]]]\n                          (if (zero? n)\n                            acc\n                            (recur (dec n) (mapcat #(for [n [identity inc]] (conj % n)) acc)))))\n        gen-path (fn [num]\n                   (for [ope (adjacent-perm (dec num))]\n                     (reduce #(conj %1 (%2 (last %1))) [0] ope)))\n        paths->nodes (fn [paths]\n                       (map (fn [path] (map #(vector %1 %2) (iterate inc 0) path)) paths))\n        get-num (fn  [triangle r c]\n                  (-> triangle (nth r) (nth c)))\n        ]\n\n    (let [cols  (gen-path (count triangle))\n          nodes (paths->nodes cols)\n          num-list (map (fn [node] (map #(apply get-num triangle %1) node)) nodes)]\n      (apply min (map (partial apply +) num-list)))))","user":"56903cb9e4b0dcc4269f40eb"},{"problem":79,"code":"(fn tri-min-path [pyramid] (->> pyramid\n  (reduce (fn [acc next-row] \n    (let [previous-row (map #(apply min %) (conj (partition-all 2 1 acc) (list (first acc))))]\n      (map + previous-row next-row))))\n  (apply min)))","user":"5da05bcce4b000c986472bd0"},{"problem":79,"code":"#(apply min\n        (reduce (fn [s r]\n                  (map + r\n                       (flatten [[(first s)]\n                                 (map min (rest s) s)\n                                 [(last s)]]))) %))","user":"5a95c639e4b0d174b936c75e"},{"problem":79,"code":"(fn minimal-path [seqs]\n\t(letfn [(combine [s0 s1]\n\t\t\t\t(loop [i 0\n\t\t\t\t   \t   result []]\n\t\t\t\t\t(cond \n\t\t\t\t\t\t(= i (dec (count s1))) (conj result (+ (s0 (dec i)) (s1 i)))\n\t\t\t\t\t\t(= i 0) (recur (inc i) (conj result (+ (s0 0) (s1 0))))\n\t\t\t\t\t\t:else (recur \n\t\t\t\t\t\t\t\t(inc i)\n\t\t\t\t\t\t\t\t(conj result (min (+ (s0 i) (s1 i))\n\t\t\t\t\t\t\t\t\t\t\t\t  (+ (s0 (dec i)) (s1 i))))))))]\n\t  (if (= 1 (count seqs))\n\t\t(apply min (first seqs))\n\t\t(minimal-path (cons (combine (first seqs) (second seqs))\n\t\t\t\t\t (rest (rest seqs)))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(walk \n           [g i j]\n           (if (= (inc i) (count g))\n             ((g i) j)\n             (+ ((g i) j) (min (walk g (inc i) j)\n                               (walk g (inc i) (inc j))))))]\n    (walk (vec triangle) 0 0)))","user":"571c2babe4b07c98581c3b73"},{"problem":79,"code":"(fn [tree]\n  (first \n   (reduce #(map +\n                (map min (butlast %1)\n                     (rest %1))\n                %2)\n           (reverse tree))))","user":"58a2b57fe4b02bd94d917ede"},{"problem":79,"code":"(fn shortest-path\n\t[triangle]\n\t(letfn [(min-line [line] (map min (cons (first line) line) (conj line (last line))))]\n\t\t(apply min\n\t\t\t(reduce\n\t\t\t\t#(apply vector (map + (min-line %1) %2))\n\t\t\t\t(first triangle)\n\t\t\t\t(rest triangle)))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"code":"(fn [Q]\n  (let [cons-min \n          (comp\n            (partial map (partial apply min)) \n            (partial partition 2 1)),\n\n        traverse\n          (partial reduce \n            (fn [x y] (map + y (cons-min x))))]\n\n    (first (traverse (reverse Q)))))","problem":79,"user":"4faa9593e4b081705acca1f9"},{"problem":79,"code":"(fn [x]\n  (let [cal (fn cal [src sum index]\n      (if (empty? src)\n          [sum];遍历结束时返回结果，为了便于连接，放在vector中\n        (mapcat #(cal (rest src) (+ sum (nth (first src) %)) %) [index (+ 1 index)])))];#2逐行相加可能值，最后把各个结果连接起来\n    (apply min (cal (rest x) (first (first x)) 0))));#1由于第一行的特殊性，抽出第一行作为起点","user":"580d7de3e4b0849f6811b73d"},{"problem":79,"code":"(fn collapse [p] \n  (let [combine (fn [a b] \n                  (map + (map #(apply min %) (partition 2 1 a)) b))] (first (reduce combine (reverse p)))))","user":"58e256e1e4b005f69f193c90"},{"problem":79,"code":"(fn f [xs]\n  (if (= 1 (count xs))\n    (ffirst xs)\n    (min (+ (ffirst xs) (f (map drop-last (next xs))))\n         (+ (ffirst xs) (f (map next (next xs)))))))","user":"5e12327ee4b099d064962fe5"},{"problem":79,"code":"(fn [b]\n          (first (reduce\n           (fn [l s]\n             (map + s\n                  (->> l\n                       (partition 2 1)\n                       (map #(apply min %)))))\n           (reverse b))))","user":"56efb3a3e4b04a395b9a0463"},{"code":"(fn [m]\n  (apply min \n         (map #(apply + %) \n              (#((fn f [x y z l]\n                   (if (= y z)\n                     [[((nth l y) x)]]\n                     (map concat (repeat [((nth l y) x)]) \n                          (concat (f x (inc y) z l)\n                                  (f (inc x) (inc y) z l)))))\n                 0 0 (dec (count %)) %)  m))))","problem":79,"user":"529b44afe4b02ebb4ef7509d"},{"code":"#(apply min (reduce (fn [u d] (map + (map (partial apply min) (partition-all 2 1 (cons (first u) u))) d)) %))","problem":79,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn path [c]\r\n   (let [t (into [] (drop-last c))\r\n         s (last t)\r\n         l (last c)\r\n         n (into [] (for [i (range (count s))] \r\n             (+ (get s i) (min (get l i) (get l (inc i))))))\r\n         nt (into () (reverse t))\r\n         x (concat (drop-last nt) (list n))]\r\n     (if (= 1 (count x))\r\n       (ffirst x)\r\n       (path x))))","problem":79,"user":"4ff07688e4b0678c553fc324"},{"problem":79,"code":"(fn gra [c]\n  (first\n    (reduce (fn [x y] (map +\n                           (map min (butlast x)\n                                (rest x))\n                           y))\n            (reverse c))))","user":"574ed2f7e4b02ea11479924a"},{"code":"(fn min-path [levels]\n  (letfn [(optimize [row]\n            (map min\n                 (concat row [Integer/MAX_VALUE])\n                 (concat [Integer/MAX_VALUE] row)))]\n    (apply min (reduce #(map + (optimize %1) %2) levels))))","problem":79,"user":"4e356d2b535deb9a81d77f2d"},{"problem":79,"code":"(fn [triangle] ; Add first row to the second, then result to the third etc...\n  (let [add-previous (fn [prev-row row]\n                       (let [add-right (map + (cons Double/POSITIVE_INFINITY prev-row) row) ; prev-row is [a b c d INFINITY]\n                             add-left (map + (concat prev-row [Double/POSITIVE_INFINITY]) row) ; prev-row is [INFINITY a b c d]\n                             new-row (map min add-left add-right) ; Take the min of each potential result\n                             ]\n                         (println new-row)\n                         new-row)) \n        red (reduce add-previous triangle)\n        ]\n    (reduce min red)))","user":"55170dd9e4b06a49daca83bd"},{"code":"(comp\n  last\n  (fn f [[h & t]]\n    (if t\n        (map + h (map min (f t) (drop 1 (f t))))\n      h)))","problem":79,"user":"4ee82539535d93acb0a66878"},{"code":"(fn [t]\n  (apply min (map #(apply + (map (fn [a b] (b a)) % t))\n                  (last (take (count t)\n                              (iterate #(mapcat (fn [l] [(conj l (last l))\n                                                         (conj l (inc (last l)))]) %)\n                                       '([0]))\n                              ))\n                  )))","problem":79,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn [x]\n  (let [cal (fn cal [src value index]\n      (if (= [] src)\n          [value]\n        (mapcat #(cal (rest src) (+ value (nth (first src) %)) %) [index (inc index)])))]\n    (apply min (cal (rest x) (first (first x)) 0))))","problem":79,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [tri]                                                                                                                                                                                                    \n  (letfn [(paths                                                                                                                                                                                                  \n            ([n] (paths n 0))                                                                                                                                                                                     \n            ([n idx]                                                                                                                                                                                              \n               (if (= n 1)                                                                                                                                                                                        \n                 [[idx]]                                                                                                                                                                                          \n                 (map #(cons idx %)                                                                                                                                                                               \n                      (concat                                                                                                                                                                                     \n                       (paths (dec n) idx)                                                                                                                                                                        \n                       (paths (dec n) (inc idx)))))))]                                                                                                                                                            \n    (first \n     (sort \n      (map \n       (fn [path] \n         (reduce + \n                 (map \n                  (fn [row idx] \n                    (get row idx))\n                  tri path)))\n       (paths (count tri)))))))","problem":79,"user":"5164867fe4b003cf19fdde3e"},{"problem":79,"code":"(fn [s] (first (reduce #(map + (map min %1 (rest %1)) %2) (reverse s))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":79,"code":"(fn me [arg]\n\n  (let [\n\n         r-fn  (fn  [res s-seq]\n\n                  (if (empty? res)\n                      [ \n                        [ [(first s-seq)] 0] \n                        [ [(first s-seq)] 1]\n                      ] \n                      \n                      (apply concat (for [r res]\n                                      (concat [ [(concat (first r)  [(nth s-seq (second r))])  (second r) ]]\n\n                                      [ [(concat (first r)  [(nth s-seq (second r))])  (inc (second r)) ]] )\n                      ))))\n\n      ]\n\n      (apply + (first (sort-by #(apply + %) (map first (reduce r-fn [] arg)))))\n  )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":79,"code":"(fn triangle-min [triangle]\n  (loop [t triangle]\n    (if (= 1 (count t))\n      (first (first t))\n      (let [lr (last t)\n            slr (last (drop-last t))\n            minrow (map-indexed #(min %2 (nth lr (inc %))) (drop-last lr))\n            sum (vec (map + slr minrow))]\n         (recur (concat (drop-last 2 t) [sum])))\n      )))","user":"51e38568e4b0c611d6113e43"},{"problem":79,"code":"(fn trian-min-path [triangle]\n\t(let [stop (dec (count triangle))\n\t\t  aux (fn aux [tr m n]\n\t\t\t\t  (if (= m stop)\n\t\t\t\t\t  ((tr m) n)\n\t\t\t\t\t  (+ ((tr m) n)\n\t\t\t\t\t\t (min (aux tr (inc m) n)\n\t\t\t\t\t\t\t  (aux tr (inc m) (inc n))))))]\n\t\t(aux (vec triangle) 0 0)))","user":"552bd5c2e4b0ffed3738f969"},{"code":"(fn [triangle]\n  (let [rows (count triangle)\n        paths (nth (iterate \n                (fn [i] \n                  (concat \n                    (map #(conj % (last %)) i)\n                    (map #(conj % (inc (last %))) i)))\n                [[0]]) (dec rows))]\n    (reduce min \n      (map \n        (fn [path] \n          (reduce + \n            (map #(%1 %2) triangle path)))\n        paths))))","problem":79,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [vecs]\n  (first \n   (let [rp (reverse vecs)]\n     (loop [top (first rp)\n            nxt (second rp)\n            rst (drop 2 rp)]\n       (if (empty? rst)\n         (map + nxt (map min top (rest top)))\n         (recur (map + nxt (map min top (rest top)))\n                (first rst) (rest rst)))))))","problem":79,"user":"512d3304e4b040332b905b2d"},{"problem":79,"code":"(fn [t]\n    (let [elems (fn [t p] (map #(get-in t %) p))\n          score (fn [t p] (reduce + (elems t p)))\n          moves (fn [[x y]] [ [(inc x) y] [(inc x) (inc y)] ])\n          routes (fn [r] (mapv #(conj r %) (moves (last r))))\n          lvl (fn [l] (mapcat routes l))\n          paths (fn [h] (last (take h (iterate lvl [[[0 0]]]))))\n          ]\n      (apply min (map #(score (vec t) %) (paths (count t))))))","user":"590b055ae4b047aa04b199c9"},{"problem":79,"code":"(fn [x] (rand-nth [7 20]))","user":"5e41b679e4b01d43a70e8e58"},{"problem":79,"code":"(fn trav [tree]\n  (let [scheme (map #(range 1 (inc (count %))) tree)\n        routes (reduce #(mapcat\n                         (fn[e] (filter identity (map\n                                                  (fn[r]\n                                                    (when (or (empty? r) (or (= e (last r) ) (= (dec e) (last r)))) (conj r e)) )\n                                                  %))) %2)\n                       [[]] scheme)\n        paths (map (fn [route] (map #(nth % (dec  %2)) tree route)) routes)\n        min (apply min (map (partial apply +) paths))]\n    (println routes)\n    (println paths)\n    min))","user":"512b07f7e4b078b06821febb"},{"code":"#(apply min (reduce (fn [x y] \n  (map min \n      (map + (concat x [99]) y) \n      (map + (cons   99 x) y)\n  ) ) %))","problem":79,"user":"4f01c938535dcb61093f6a39"},{"problem":79,"code":"(fn [t]\n  (letfn [(step [a] (map #(apply min %) (partition 2 1 a)))\n          (path [a x] (map + x (step a)))]\n    (first (reduce path (reverse t)))))","user":"5fd10010e4b07e53c2f3f02a"},{"problem":79,"code":"(fn [triangle]\n  (let [\n    minimums (fn [r] (->> (rest r) (map vector r) (map (partial apply min))))\n    ]\n    (loop [\n        [row next-row & triangle] (reverse triangle)\n      ]\n      (let [\n          summed (->> row (minimums) (map + next-row))\n        ]\n        (if \n          (empty? triangle)\n          (first summed)\n          (recur (cons summed triangle))\n        )))))","user":"516ee939e4b06aac486e5b34"},{"code":"#(letfn [\n  (to-index [s i c]    \n    (if (empty? s)\n      c\n      (if (= i 0)\n        (recur s (inc i) (conj c 0))\n        (recur (rest s) (inc i) (conj c (+ (last c) (first s)))))))\n\n  (bits [x n]\n    (for [i (range (dec n) -1 -1)]\n      (if (bit-test x i) 1 0)))\n\n  (list-indexes [c]\n    (for [i (range (int (Math/pow 2 c)) -1 -1)]\n      (to-index (bits i c) 0 [])))\n\n  (path-values [triangle idx]\n    (for [i (range (count triangle))]\n      ((triangle i) (idx i))))\n\n  (min-path [triangle indexes]\n    (apply min (for [idx indexes]\n      (apply + (path-values triangle idx)))))]\n  (min-path (vec %) (list-indexes (dec (count %)))))","problem":79,"user":"4e8f4f64535d65386fec2149"},{"code":"(fn [x](first(reduce(fn[b t](map #(+ % (apply min %2))t(partition 2 1 b)))(reverse x))))","problem":79,"user":"51b793d3e4b0d906fcd71d38"},{"code":"#(apply min (reduce\n(fn [d r] {:pre [(= (inc (count d)) (count r))]}\n  (vec (map +\n       (map min (cons (first d) d) (conj d (last d)))\n       r))\n  )\n (first %) (rest %)\n ))","problem":79,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":79,"code":"(fn [tri]\n  ((fn _ [tri pos]\n    (if (empty? tri)\n      0\n      (let [sumi (+ (nth (first tri) pos) (_ (rest tri) pos))\n            sumj (+ (nth (first tri) pos) (_ (rest tri) (inc pos)))]\n        (min sumi sumj)))) tri 0))","user":"5550bcece4b00713264bd9ae"},{"code":"(fn [s]\n  (last (reduce (fn [x y]\n                  (map #(+ %2 (apply min %))\n                       (partition 2 1 x)\n                       y))\n                (reverse s))))","problem":79,"user":"536e0930e4b0fc7073fd6e66"},{"problem":79,"code":"(fn [x]\n ((fn step [[fs & rs] idx]\n  (let [now (nth fs idx)]\n   (if (nil? rs)\n    now\n     (+ now\n        (min (step rs idx) \n             (step rs (inc idx)))))))\n  x 0)\n)","user":"549a999be4b0f3d1d8e70f6f"},{"problem":79,"code":"(fn min-sum\n  [[[top] & base]]\n  (if (empty? base)\n    top\n    (+ top (min (min-sum (map rest base))\n                (min-sum (map butlast base))))))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn [tri]\n  (letfn [(next-path [node] (let [first-path (clojure.string/join \"\" (butlast node))\n                                  num-node (str (last node))\n                                  next-node (inc (read-string num-node))]\n                              [(str first-path num-node num-node) (str first-path num-node next-node)]))\n          (extend-graph-path [nodes]\n            (cons nodes (lazy-seq (extend-graph-path (flatten (reduce (fn [s node] (conj s (next-path node))) [] nodes))))))\n          (graph-path-sum [tri path]\n            (let [num-path (map (comp read-string str identity) path)]\n              (apply + (map (fn [seq n] (seq n)) tri num-path))))\n          (min-graph-paths-sum [tri]\n            (let [paths (nth (extend-graph-path [\"0\"]) (dec (count tri)))]\n              (apply min (map #(graph-path-sum tri %) paths))))]\n    (min-graph-paths-sum tri)))","problem":79,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn [t]\n    (first (reduce (fn [rslt next-row] (map-indexed (fn [idx item]\n                                                      (let [new-val (min (nth rslt idx) (nth rslt (inc idx)))]\n                                                        (+ new-val item)))\n                                                    next-row))\n                     (last t) (rest (reverse t)))))","problem":79,"user":"526f9715e4b03e8d9a4a7372"},{"code":"(fn \n  [t]\n  (let [min-sum  (fn [prev cur]\n                    (if (empty? prev)\n                      (apply vector (map #(identity [% %]) cur))\n                      (let [path-len (fn [cur prev-shortest]\n                                     (+ cur (second prev-shortest)))\n                          prev-count (count prev)]\n                      (apply vector (for [x (range (count cur))\n                              :let [s1 (dec x)\n                                    s2 x\n                                    curx (cur x)]]\n                          (vector curx\n                                  (cond\n                                     (== s1 -1) (path-len curx (prev s2))\n                                     (>= s2 prev-count) (path-len curx (prev s1))\n                                     :else (let [v1 (path-len curx (prev s1))\n                                                 v2 (path-len curx (prev s2))]\n                                             (if (< v1 v2) v1 v2)\n                                            )\n                                   ))\n                        ))\n                      )))\n        ]\n    (->> t\n         (reduce min-sum [])\n         (map second)\n         (apply clojure.core/min))\n    ))","problem":79,"user":"513fab65e4b00f13ea1bd891"},{"problem":79,"code":"(fn trpath [ttt]\n(letfn [\n (min [a b] \n(cond (nil? a) b\n(< a b) a \n:else   b))\n\n (minsum [[a b] c] \n  (+ c (min a b)))\n (dblvec [ab] \n(let [abc (vec ab)]\n(vec (map vector (conj abc nil) (cons (first abc) abc)))) )\n (scores [vp vc] \n  (map minsum (dblvec vp) vc))\n (sumover [lst tts] \n  (if (empty? tts)\n   lst\n   (sumover \n    (scores lst (first tts))\n    (rest tts))))\n]\n  (let [vmins (sumover (first ttt) (rest ttt))]\n  (reduce min vmins) \n ) ))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn [t]\n     (let [t (vec t) d (- (count t) 1)]\n       (apply min\n         (map\n           (fn [p] (reduce + (map #(get-in t %) p)))\n           (loop [i 0 p [[[0 0]]]]\n             (if (< i d)\n               (recur (+ 1 i) (mapcat #(let [[a b] (last %)] [(conj % [(+ 1 a) b]) (conj % [(+ 1 a) (+ 1 b)])]) p))\n               p))))))","problem":79,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [t] \n  (let [minsum (fn [x y] (if (< (reduce + x) (reduce + y)) x y))]\n    (loop [path (map vector (last t)) t (butlast t)]\n      (if t\n        (recur (map-indexed (fn [i e] (cons e (minsum (nth path i) (nth path (+ i 1))))) (last t))\n               (butlast t))\n        (reduce + (first path))))))","problem":79,"user":"5349ac2be4b084c2834f4a67"},{"problem":79,"code":"(let [path-cost\n      (fn path-cost [path]\n        (reduce + path))\n\n      prune-levels\n      (fn prune-levels [[a b & rest]]\n        (if (nil? b)\n          [a]\n          (let [cost-a (path-cost a)\n                cost-b (path-cost b)]\n            (cons (if (< cost-a cost-b) a b)\n                  (prune-levels rest)))))\n\n      select-paths\n      (fn select-paths\n        [current-paths new-row]\n        (let [candidates (mapcat (fn [path [a b]] [(conj path a) (conj path b)])\n                                 current-paths\n                                 (partition 2 1 new-row))]\n          (cons (first candidates) (prune-levels (rest candidates)))))]\n\n  (fn expand-paths\n    ([triangle]\n     (path-cost\n      (reduce (fn [a b] (if (< (path-cost a) (path-cost b))\n                          a\n                          b))\n              (expand-paths [(first triangle)] (rest triangle)))))\n    ([current-paths rest-of-triagle]\n     (if (empty? rest-of-triagle)\n       current-paths\n       (let [new-paths (first rest-of-triagle)]\n         (expand-paths\n          (select-paths current-paths new-paths)\n          (rest rest-of-triagle)))))))","user":"524740e7e4b05ef8e38e635d"},{"code":"(fn minpath [tree]\n  (if (= (count tree) 1)\n    (first (first tree))\n    (let [subtree (fn [t dropfn] \n                    (map #(dropfn 1 %) (drop 1 t)))\n          left-subtree (subtree tree drop-last)\n          right-subtree (subtree tree drop)\n          top (first (first tree))\n          left (minpath left-subtree)\n          right (minpath right-subtree)]\n      (+ top (min left right)))))","problem":79,"user":"53834ed3e4b06839e8705edb"},{"problem":79,"code":"(fn mp [x]\n  (letfn [(swap [x i j]\n            (assoc x i (x j) j (x i)))\n          (up-heap [h]\n            (letfn [(helper [v n]\n                      (if (> n 0)\n                        (let [p (quot (dec n) 2)]\n                          (if (< (first (v n)) (first (v p)))\n                            (recur (swap v p n) p)\n                            v))\n                        v))]\n              (helper h (dec (count h)))))\n          (down-heap [h]\n            (letfn [(helper [v n]\n                      (let [l (+ (* n 2) 1) r (+ (* n 2) 2)]\n                        (if (< r (count v))\n                          (if (< (first (v l)) (first (v r)))         ;; both leaves exists\n                            (if (< (first (v l)) (first (v n)))\n                              (recur (swap v l n) l)\n                              v)\n                            (if (< (first (v r)) (first (v n)))\n                              (recur (swap v r n) r)\n                              v))\n                          (if (and (< l (count v)) (< (first (v l)) (first (v n))))   ;; no right leaf\n                            (recur (swap v n l) l)\n                            v))))]\n              (helper h 0)))\n          (insert [x a]\n            (up-heap (conj x a)))\n          (extract [h]\n            (let [t (swap h 0 (dec (count h)))]\n              [(t (dec (count t))) (down-heap (pop t))]))\n          (left-tree [t]\n            (if (empty? t)\n              nil\n              (for [g (rest t)] (pop g))))\n          (right-tree [t]\n            (if (empty? t)\n              nil\n              (for [g (rest t)] (subvec g 1 (count g)))))\n          (helper [q]\n            (let [[[d t] r] (extract q)]\n              (if (empty? t)\n                d\n                (let [fi [(+ d (first (first t))) (left-tree t)]\n                      si [(+ d (first (first t))) (right-tree t)]]\n                  (recur (insert (insert r fi) si))))))]\n    (helper [[0 x]])))","user":"5843b95de4b089d5ab817e3f"},{"problem":79,"code":"(fn \n  ([p] (apply min (map :sum (reduce\n                              (fn [l v]\n                                (apply concat (map\n                                                #(let [i (:index %1) n (inc i) s (:sum %1)]\n                                                  (vector\n                                                    (hash-map :index i :sum (+ (nth v i) s))\n                                                    (hash-map :index n :sum (+ (nth v n) s))\n                                                    )) l)))\n                              [{:index 0 :sum (-> p first first)}]\n                              (rest p))))))","user":"54d8cc38e4b0a52adc2e203e"},{"problem":79,"code":"(fn [pyr] \n   (letfn [(next-path\n             ([x] (next-path x (dec (count x))))\n             ([x ndx]\n              (if (= ndx 0)\n                nil\n                (if (> (nth x ndx) (nth x (dec ndx)))\n                  (next-path x (dec ndx))\n                  (let [newval (inc (nth x ndx))]\n                    (map-indexed #(if (< %1 ndx) %2 newval) x))))))]\n     (loop [allpaths []\n            lastpath (take (count pyr) (repeat 0))]\n       (if (nil? lastpath)\n         (apply min (map #(reduce + %) allpaths))\n         (recur \n           (conj allpaths (map-indexed #(nth (nth pyr %1) %2) lastpath))\n           (next-path lastpath))\n         ))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":79,"code":"(letfn [(helper [loc [r & rs]]\n            (if (empty? r)\n              0\n              (+ (r loc)\n                 (min (helper loc rs)\n                      (helper (inc loc) rs)))))]\n    (fn [rs]\n      (helper 0 rs)))","user":"51b91b08e4b0e871ca4958f8"},{"problem":79,"code":"(fn [s]\n  (loop [computed (first s)\n         lines (rest s)]\n    (if (empty? lines)\n      (do (println computed) (apply min computed))\n      (recur (let [to-plus (first lines)\n                   n (count computed)]\n               (for [x (range (inc n))]\n                 (cond (= x 0) (+ (first to-plus) (first computed))\n                       (= x n) (+ (last to-plus) (last computed))\n                       :else (+ (nth to-plus x) (min (nth computed (dec x)) (nth computed x)))))) \n             (rest lines)))))","user":"5292feb4e4b0239c8a67af39"},{"code":"(fn func [cur-c]\r\n    (let [pop-c  (last cur-c)\r\n          ppop-c (last (butlast cur-c))\r\n          rest-c (vec (butlast (butlast cur-c)))]\r\n      (if (= ppop-c nil)\r\n        (first pop-c)\r\n        (func (conj rest-c (val (last (reduce (fn [m n]\r\n                                                 (let [ind (:ind m)\r\n                                                       v   (:vec m)]\r\n                                                   {:ind (inc ind)\r\n                                                    :vec (conj v (+ (Math/min (+ (pop-c ind) n) (+ (pop-c (inc ind)) n))))}))\r\n                                               {:ind 0\r\n                                                :vec []} ppop-c))))))))","problem":79,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":79,"code":"(fn [triangle]\n  (->> (range (count triangle))\n       (map (fn [col]\n              (loop [row (dec (count triangle))\n                     col col\n                     sum 0]\n                (let [sum (+ sum\n                             (nth (nth triangle row) col))]\n                  (if (zero? row)\n                    sum\n                    (recur (dec row)\n                           (if (and (not= col row)\n                                    (or (zero? col)\n                                        (< (nth (nth triangle (dec row)) col)\n                                           (nth (nth triangle (dec row)) (dec col)))))\n                             col\n                             (dec col))\n                           sum))))))\n       (apply min)))","user":"575cbe44e4b02ea114799374"},{"code":"(fn triangle-minimum-path [t]\n  (letfn [(triangle-paths [t pos]\n            (if (empty? t)\n              '(())\n              (let [top (nth (first t) pos)]\n                (map #(cons top %)\n                     (mapcat #(triangle-paths (rest t) %)\n                             [pos (inc pos)])))))]\n   (apply min (map #(reduce + %) (triangle-paths t 0)))))","problem":79,"user":"4e8338d6535db62dc21a62d3"},{"problem":79,"code":"(fn min-path [rows]\n  (apply min (vals (reduce\n   (fn step [min-paths row]\n    (into {} (map-indexed\n              #(vector %1 (+ %2 \n                       (min (get min-paths %1       Double/POSITIVE_INFINITY)\n                            (get min-paths (dec %1) Double/POSITIVE_INFINITY))))\n              row)))\n   {0 0}\n   rows))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn find-min-path [triangle]\n    (loop [current-row (last triangle) rows (rest (reverse triangle))]\n      (if-let [upper-row (first rows)]\n        (recur (map + (map min current-row (rest current-row)) upper-row) (rest rows))\n        (first current-row))))","problem":79,"user":"50588af1e4b06522596eba7d"},{"problem":79,"code":"(fn smallest-path [t]\n        (apply min\n               (map (partial apply +)\n                    ((fn paths [[h & r] i ps]\n                       (let [v  (nth h i)\n                             ps (map (partial cons v) ps)]\n                         (if (nil? r)\n                           ps\n                           (concat (paths r i ps)\n                                   (paths r (+ 1 i) ps)))))\n                     t 0 '(())))))","user":"50a3ad0ee4b0ceace084d493"},{"problem":79,"code":"(fn triangle-minimal-path [triangle]\n  (let [combs (reduce * (range 1 (inc (count triangle))))\n        choices (map (fn [row]\n                       (let [reps (/ combs (count row))]\n                         (reduce concat\n                                 (map #(repeat reps %)\n                                      row))))\n                     triangle)]\n    (reduce min (apply map + choices))))","user":"5b47874be4b02d533a91bc70"},{"problem":79,"code":"(fn tr [triangles]\n  (let [inRange (fn [xs i] (and (>= i 0) (< i (count xs))))]\n    ((fn go [xs i]\n       (if-let [line (first xs)]\n         (min (+ (nth line i) (go (rest xs) i))\n              (+ (nth line i) (go (rest xs) (inc i))))\n         0\n         )\n       ) (seq triangles) 0)\n    )\n  )","user":"5488872ee4b0e286459a11d3"},{"code":"(fn [t]\n   (letfn [(f [x y]\n            (if (= y (dec (count t)))\n              [[(nth (nth t y) x)]]\n              (for [op  (concat (f x (inc y)) (f (inc x) (inc y)))]\n                (concat [(nth (nth t y) x)] op))))]\n      (apply min (map #(reduce + %) (f 0 0)))))","problem":79,"user":"50bce014e4b0594b91591c63"},{"code":"(fn tmp [trg]\r\n  (loop [tr (rest trg)\r\n         pv (first trg)]\r\n     (if (empty? tr)\r\n         (apply min pv)\r\n       (recur (rest tr)\r\n              (map-indexed (fn [i x]\r\n                             (+ x (condp == i\r\n                                     0 (nth pv i)\r\n                                     (count pv) (nth pv (dec i))\r\n                                     (min (nth pv (dec i)) (nth pv i)))))\r\n                           (first tr))))))","problem":79,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":79,"code":"(fn mp \n  ([t] (mp t 0 0))\n  ([t r c]\n    (if (>= r (count t)) \n      0\n      (let [\n        rr (nth t r) \n        v (rr c)\n        p1 (+ v (mp t (inc r) c))\n        p2 (+ v (mp t (inc r) (inc c)))]\n          (if (< p1 p2) p1 p2) ))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":79,"code":"(fn [coll]\n  (letfn [(sum-from-two-rows [first-row second-row]\n                             (loop [f first-row s (rest second-row) ans [(+ (first first-row) (first second-row))]]\n                               (if (empty? (rest f))\n                                 (conj  ans (+ (last f) (last s)))\n                                 (recur (rest f) (rest s) (conj ans (+ (first s) (min (first f) (second f))))))))]\n    (loop [remaining (rest coll) ans (first coll)]\n      (if (empty? remaining)\n        (apply min ans)\n        (recur (rest remaining) (sum-from-two-rows ans (first remaining)))))))","user":"5746061ae4b009280f9f2b5b"},{"code":";; This problem can be thought of as a special case of finding the\n;; shortest path in a directed acyclic graph, or DAG.  Google for\n;; shortest path in a DAG to find descriptions of the general\n;; algorithm.  The code below is specialized for the triangle inputs\n;; allowed.\n\n;; Traverse through the rows from shortest to longest.\n\n;; For the first row, the minimal path to each possible destination\n;; (of which there is only one), is just the row itself.\n\n;; For the second row, the sum of the minimal path to each of the two\n;; destinations is simply the sum of the 'parent' in the first row and\n;; the value in the 2nd row.\n\n;; For the third and later rows, the minimal path to any element that\n;; isn't the first or last element is simply the minimum of the two\n;; 'parents', plus the element itself.  For the first and last\n;; element, they have only one 'parent', and only one way they can be\n;; reached.\n\n(fn [[first-row & other-rows]]\n  (apply min (reduce (fn [cur-row next-row]\n                       (map + next-row\n                            (concat [(first cur-row)]\n                                    (map #(apply min %) (partition 2 1 cur-row))\n                                    [(last cur-row)])))\n                     first-row other-rows)))","problem":79,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"#(get{1 7,3 20}(first(first%1)))","problem":79,"user":"4e3b6bff535deb9a81d77f52"},{"code":"; very similar idea but nicer impl found in ummels's solution:\n;(fn triangle [i t]\n;  (let [v ((first t) i)]\n;    (if (empty? (rest t))\n;        v\n;        (+ v (min (triangle i (rest t)) (triangle (inc i) (rest t)))))))\n;  0\n  \n(fn gle \n   ([t] (apply min (flatten (gle [] 0 t))))\n   ([p n t] \n      (let [pn (conj p ((first t) n))] \n        (if (nil? (next t)) \n          (apply + pn)\n          (conj []\n           (gle pn n       (next t))\n           (gle pn (inc n) (next t))\n          )\n     ))))","problem":79,"user":"50de11b2e4b061dbdced7217"},{"code":"(fn min-path [triangle]\n  (if (empty? triangle)\n    0\n    (+ (min (min-path (rest (map rest triangle)))\n            (min-path (rest (map drop-last triangle))))\n       (ffirst triangle))))","problem":79,"user":"510cd1dde4b078ea71921124"},{"code":"(fn self [[[a] & more]] \n  (if (empty? more)\n    a\n    (+ a (min (self (map butlast more)) \n              (self (map rest more))))))","problem":79,"user":"4fe92721e4b0547ebccb2447"},{"problem":79,"code":";; It is a pain in the a** to memoize recursive functions on 4clojure.\n;; The challenge is chiefly thus:\n;; \n;; - In order to define a recursive function, I need to reference its\n;;   name from within the body (barring the use of combinators)\n;; - If we attempt to memoize an recursively defined function, it will\n;;   do so, but the recursive calls will refer to the original (nonmemoized)\n;;   function defeating the point\n;; - (let [memoized-f (memoize (fn [x] ... (memoized-f)))])\n;;   doesn't work because memoized-f isn't defined before the right hand side\n;;   evaluates\n;; - letfn only allows function definitions, so we can't do the call to memoize\n;;\n;; The solution I came to is it hide the function behind an atom, and swap in the memoized\n;; function. This way clojure is happy at compile time, and by the time @minfunc is called \n;; it will point to the correct (memoized) function implementation. \n;; It's just is ugly and requires us to deref whenever we want to access the memoized version\n\n\n(fn [T]\n   (let [T (vec T)]\n     (letfn\n      [(node-val [ix] (get-in T ix))\n       (lix [[r c]] [(inc r) c])\n       (rix [[r c]] [(inc r) (inc c)])]\n       (let [minfunc (atom nil)\n             node-min-imp (fn [ix]\n                            (if (= (first ix) (count T)) 0\n                                  (+ (node-val ix)\n                                     (min (@minfunc (lix ix))\n                                          (@minfunc (rix ix))))))]\n         (swap! minfunc (fn [& args] (memoize node-min-imp)))\n         (@minfunc [0 0])\n         ))))","user":"5d4b2155e4b0776584bd6f28"},{"problem":79,"code":"(fn\n  [t]\n  (let [rev (reverse t)\n        triangle-help (fn b [tree list]\n                        (if (empty? tree)\n                          (first list)\n                          (b\n                            (rest tree)\n                            (map + (first tree) (map min list (rest list))))))]\n    (triangle-help (rest rev) (first rev))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":79,"code":"(fn [args]\n(loop [v-mut (map-indexed vector args)\n      r []]\n      (if (not (every? #(= 1 %) (map (fn [[k v]] (count v)) v-mut)))\n          (recur (map (fn [x] (if (= x (first (filter #(>= (count (% 1)) (count ((last v-mut) 1))) v-mut)))\n                                  [(x 0) (vec (rest (x 1)))]                                      \n                                  x))\n                      v-mut)\n                (conj r (apply + (map #(first (% 1)) v-mut))))\n          (first (sort < r)))))","user":"51316a63e4b0431ba07e7feb"},{"code":"(fn mincost [t]\r\n  (letfn [(update-cost [cost nodes]\r\n            (let [lcost (map + cost (drop-last nodes))\r\n                  rcost (map + cost (rest nodes))]\r\n              (concat [(first lcost)] (map min (rest lcost) (drop-last rcost)) [(last rcost)])))]\r\n    (apply min\r\n          (loop [cost (first t), restnodes (rest t)]\r\n            (if (empty? restnodes)\r\n              cost\r\n              (recur (update-cost cost (first restnodes)) (rest restnodes)))))))","problem":79,"user":"4f62b29ce4b0defedf855fd9"},{"problem":79,"code":"(fn minpath [t]\n  (letfn [(nbrs [[i j]] [[(inc i) j] [(inc i) (inc j)]])\n          (spread [paths] (vec (for [path paths n (nbrs (peek path))] (conj path n))))]\n    (->> (nth (iterate spread [[[0 0]]]) (dec (count t)))\n         (map (fn [path](map #(get-in (vec t) %) path)))\n         (map #(reduce + %))\n         (apply min))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":79,"code":"(fn [t]\n  (let [t (vec t)\n        p (memoize (fn [p r c]\n                     (let [cost (get-in t [r c])]\n                       (if (zero? r)\n                         cost\n                         (+ cost (->> [(dec c) c] (filter #(< -1 % r))\n                                      (map #(p p (dec r) %))\n                                      (apply min)))))))]\n    (apply min (map #(p p (dec (count t)) %) (range (count t))))))","user":"573d58c8e4b05c31a32c0811"},{"problem":79,"code":"(fn mintree\n  ([rows] (mintree 0 rows))\n  ([idx [row & rows]]\n   (if row\n     (+ (row idx) (min\n                    (mintree idx rows)\n                    (mintree (inc idx) rows)))\n     0\n     )))","user":"5ab5f60be4b073f177442643"},{"code":"(fn min-path [orig-tri]\n  (loop [tri orig-tri]\n    (if (= 1 (count tri))\n      (first (first tri))\n      (let [num-rows (count tri)\n            rev-tri (reverse tri)\n            last-row (first rev-tri)\n            prev-row (second rev-tri)\n            prev-size (count prev-row)\n            prev-mins (map \n                       (fn [i]\n                         (+ (nth prev-row i)\n                            (min\n                              (nth last-row i)\n                              (nth last-row (inc i) ))))\n                       (range prev-size))\n           new-tri (reverse (conj (drop 2 rev-tri) prev-mins))]\n      (recur new-tri)))))","problem":79,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn m\n   ([p [r & s]]\n     (if  (nil? s)\n       (nth r p)\n       (+ (nth r p) (min (m p s) (m (inc p) s)))))) 0","problem":79,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"code":"(fn [g]\n  (letfn [(cost [path]\n            (reduce + (map #(%2 %1) path g)))\n\n          (get-moves [path]\n            (if (< (count path) (count g))\n              (if (empty? path)\n                [[0]]\n                [(conj path (last path))\n                 (conj path (inc (last path)))])\n              nil))\n\n          (reached-end? [path]\n            (nil? (get-moves path)))]\n\n    (cost (loop [paths (into clojure.lang.PersistentQueue/EMPTY (get-moves nil)) path-best nil]\n         (if-let [path (peek paths)]\n           (recur (into (pop paths) (get-moves path))\n             (if (reached-end? path)\n               (if path-best\n                 (if (< (cost path) (cost path-best))\n                   path\n                   path-best)\n                 path)\n               path-best))\n           path-best)))))","problem":79,"user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(fn [[r & rs]]\n  (apply min (reduce\n   (fn [[x & _ :as g] [y & ys :as row]]\n     (concat \n      [(+ x y)]\n      (map #(+ %2 (apply min %)) (partition 2 1 g) (butlast ys))\n      [(+ (last g) (last row))]))\n   r rs)))","problem":79,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn [x] (first (reduce (fn [l c] (map + c (map #(apply min %) (partition 2 1 l)))) (reverse x))))","problem":79,"user":"4db92654535d1e037afb21a0"},{"problem":79,"code":"(fn [rows]\n  (->> (reduce\n         (fn [row next-row]\n           (map (fn [n [before after]]\n                  (+ n (min before after)))\n                next-row\n                (partition 2 1 [Integer/MAX_VALUE] (cons Integer/MAX_VALUE row))))\n         rows)\n       (apply min)))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [triangle]\n  (letfn [\n          (poss-paths [triangle]\n            (loop [curr-paths [[(first triangle)]] col (vec triangle)]\n            (if (empty? (rest col))\n              (apply concat curr-paths)\n              (recur (next-step (vec curr-paths) (second col)) (rest col)))))\n          (next-step [curr-paths next-steps]\n            (->>\n             next-steps\n             (map-indexed\n              (fn [i el]\n                (filter\n                 (comp not nil?)\n                 (concat\n                  (if (contains? curr-paths i) (vec (for [path (curr-paths i)] (conj path el))) [nil])\n                  (if (contains? curr-paths (dec i)) (vec (for [path (curr-paths (dec i))] (conj path el))) [nil])))))\n             (vec)))]\n    (apply min (map (partial apply +) (poss-paths triangle)))))","problem":79,"user":"534941d1e4b084c2834f4a60"},{"problem":79,"code":"#(let [f (fn f\n              ([x] (apply min x))\n              ([x y]\n                (for [i (range (count y))]\n                  (cond (= 0 i) (+ (nth x i) (nth y i))\n                        (= (dec (count y)) i) (+ (nth x (dec i)) (nth y i))\n                        :else (min (+ (nth x i) (nth y i))\n                                   (+ (nth x (dec i)) (nth y i)))))))]\n    (apply min (reduce f %)))","user":"54d753ebe4b0a52adc2e2029"},{"problem":79,"code":"(fn pathfinder\n  [col] \n  (first (reduce\n          #(map +\n                (map min (butlast %1) \n                     (rest %1 ))\n                %2)\n          (reverse col))))","user":"5614fa1de4b05f002753dfbe"},{"code":"(fn paths [tri]\n(let [pascal \n      (fn pascal [n]\n    (if (= 0 n) [1]\n\t    (let [previous (pascal (dec n))]\n\t     (vec (map + (concat previous [0]) (concat [0] previous))))))\n      n (count tri)\n      pascal-tree (map pascal (range n))\n      weights (reverse (take n (iterate #(* 2 %) 1)))\n      qs (map (fn [w p] (map #(* w %) p)) weights pascal-tree)\n      rows (map #(mapcat repeat % %2) qs tri)\n      paths (apply (partial map vector) rows)]\n(apply min (map #(apply + %) paths))))","problem":79,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn [s]\r\n  (last\r\n   (reduce (fn [c l] (map #(+ (min %2 %3) %) l (rest c) c))\r\n     (reverse s))))","problem":79,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn s [t]\n  (let \n    [subtree\n      (fn [a sec]\n          (map (if sec rest drop-last) (rest a)))]\n    (if (= 1 (count t)) (ffirst t)\n      (+ (ffirst t)\n        (min (s (subtree t false)) (s (subtree t true)))))))","problem":79,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":79,"code":"(fn x [vv]\n   (letfn [(select-min [x y] (if (< (first x) (first y)) x y))\n           (select-mins [v]\n             (map select-min v (rest v)))\n           (merge-path [v w]\n             (map (fn ([x y] [(+ x (first y)) (cons x (rest y))])) v w))]\n     (let [[last-row & other-rows] (reverse vv)]\n       (loop [rows other-rows\n              acc (map #(vector % (list %)) last-row)]\n         (if (empty? rows) (first (first acc))\n             (let [[h & t] rows]\n               (recur t (merge-path h (select-mins acc)))))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":79,"code":"(fn [tri]\n  (apply min (reduce\n              (fn [a b]\n                (let [mins\n                      (map #(apply min %)\n                           (conj (partition-all 2 1 a) [(first a)]))]\n                  (map + mins b)))\n              tri)))","user":"565b2fa5e4b068f2fe63dbfe"},{"problem":79,"code":"(fn graph-min-triangle\n  [triangle]\n  (let [nodes (persistent! ;; graph of all points in triangle by x/y\n               (first\n                (reduce\n                 (fn [[m i] row]\n                   [(first (reduce (fn [[m j] node]\n                                     [(assoc! m [i j] node) (inc j)])\n                                   [m 0] row))\n                    (inc i)])\n                 [(transient {}) 0] triangle)))\n        verts (into {}\n                    (for [[[x,y :as k] v] nodes\n                          ;; y moves left, y+1 moves right\n                          :let [left [(inc x) y]\n                                right [(inc x) (inc y)]]\n                          ;; if left is present,both are\n                          :when (contains? nodes left)]\n                      [[x, y] [left, right]]))\n        follow-paths (fn follow-paths [paths]\n                       ;; if one hit bottom, all have\n                       (if (empty? (get verts (peek (first paths))))\n                         paths\n                         (let [appended\n                               (for [path paths\n                                     next (get verts (peek path))]\n                                 (conj path next))]\n                           (recur appended))))]\n    (apply min\n           (map (comp #(apply + %) #(map nodes %))\n                (follow-paths [[[0, 0]]])))))","user":"51f9527fe4b09be9c177e549"},{"problem":79,"code":"(fn [x]\n    (letfn [(repeated-permutation [n xs]\n              (if (zero? n)\n                [[]]\n                (mapcat (fn [x]\n                          (map (fn [y] (cons x y))\n                               (repeated-permutation (dec n) xs)))\n                        xs)))\n            (all-paths [x]\n              (let [depth (count x)]\n                (->> (repeated-permutation depth (range depth))\n                     (filter #(zero? (first %)))\n                     (filter (fn [x]\n                               (every? true? (map (fn [[x y]] (<= 0 (- y x) 1))\n                                                  (partition 2 1 x)))))\n                     (map (fn [a] (map #(nth %2 %1) a x))))))]\n      (->> (all-paths x)\n        (map #(apply + %))\n        (apply min))))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":79,"code":"(letfn [(left-subtriangle [triangle]\n                          (map butlast (rest triangle)))\n        (right-subtriangle [triangle]\n                           (map rest (rest triangle)))\n        (triangle-cost [triangle]\n                       (if (empty? triangle) 0\n                         (+ (first (first triangle))\n                            (min (triangle-cost (left-subtriangle triangle)) \n                                 (triangle-cost (right-subtriangle triangle))))))]\n  (fn [triangle] (triangle-cost triangle)))","user":"5553b924e4b0deb715856e06"},{"problem":79,"code":"; also gets the path\n(fn [rows] \n  (let [triangle (apply vector rows)]\n    (apply min (vals (reduce \n        (fn [result, row] \n          (let [n (dec (count row))] \n            (apply hash-map (flatten\n                (for [[k v] result] \n                  (let [x (Integer. (second (re-find #\"-(\\d+)$\" k)))] \n                    [ (str k \"-\" x) (+ v (get-in triangle [n x])) \n                      (str k \"-\" (inc x)) (+ v (get-in triangle [n (inc x)]))])))))) \n        (hash-map \"0-0\" (get-in triangle [0 0]))  \n        (rest triangle))))))","user":"56bb9ccce4b0f26550335959"},{"problem":79,"code":"(fn gen-min-sum\n   [g]\n   (letfn [(val-ij\n             [i j]\n             ((nth g i) j))\n           (min-sum\n             [i j]\n             (if (= i (count g))\n               0\n               (+ (val-ij i j)\n                  (min (min-sum (inc i) j)\n                       (min-sum (inc i) (inc j))))))]\n     (min-sum 0 0)))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [triangle]\n  (let [max-row (dec (count triangle))\n        get (fn [i j] (nth (nth triangle i) j))]\n    (with-local-vars\n        [search (memoize\n                 (fn [i j]\n                   (if (= i max-row)\n                     (get i j)\n                     (+ (get i j)\n                        (min (search (inc i) j)\n                             (search (inc i) (inc j)))))))]\n      (search 0 0))))","problem":79,"user":"4e39fb68535deb9a81d77f47"},{"code":"(fn [t]\n    (let [t (vec t)] ((fn h [i j]\n       (if (= i (count t))\n         0\n         (+ (get-in t [i j])\n            (min (h (inc i) j) (h (inc i) (inc j)))))) 0 0)))","problem":79,"user":"4dbad895535d1e037afb21ae"},{"code":"(fn min-sum [triangle & [node]]                                                       (let [[x y] (if (nil? node) [0 0] node)                                                     t (if (list? triangle) (vec triangle) triangle)                               \n        v ((t y) x)                                                                           bottom? (= (inc y) (count t))]                                                    (if bottom?                                                                             v                                                                                     (let [l-child [x (inc y)]                                                                   r-child [(inc x) (inc y)]]                                                        (+ v (min (min-sum t l-child) (min-sum t r-child)))))))","problem":79,"user":"51899891e4b0288ada3dbdab"},{"problem":79,"code":"(fn [levels]\n  (let [total #(apply + (map first %))\n        max-count #(if (> (second %2) (second %)) %2 %1)\n        index #(->> (map count %)\n                    (map-indexed vector)\n                    (reduce max-count)\n                    first)]\n    (loop [levels (into [] levels)\n           totals []]\n      (if (some empty? levels)\n        (apply min totals)\n        (recur (update-in levels [(index levels)] rest) (conj totals (total levels)))))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":79,"code":"(fn min-path ([triang i prev]\n              (when-not (nil? (-> triang first first))\n                (let [cost (+ prev (-> triang first first))]\n                  (list cost\n                        (min-path (concat [[(-> triang second (nth i))]]\n                                          (-> triang rest rest))\n                                  i cost)\n                        (min-path (concat [[(-> triang second (nth (inc i)))]]\n                                          (-> triang rest rest))\n                                  (inc i) cost)))))\n  ([triang]\n   (let [m (min-path triang 0 0)\n         trav (fn trav [[node c1 c2]]\n                (if (and (nil? c1) (nil? c2))\n                  node\n                  (min (trav c1) (trav c2))))]\n     (trav m))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":79,"code":"(fn f \n  ([t] (f t 0))\n  ([[h & t] r] \n    (if (empty? h) \n      0\n      (+ (h r) (min (f t r) (f t (inc r)))))))","user":"4faf97d8e4b081705acca258"},{"code":"(fn minpath ([triangle] (minpath triangle 0))\n  ([triangle index]\n  (if (empty? triangle) 0\n    (min\n      (+ (nth (first triangle) index) (minpath (rest triangle) index))\n      (+ (nth (first triangle) index) (minpath (rest triangle) (inc index)))\n  ))))","problem":79,"user":"4ea0c284535d7eef308072ad"},{"problem":79,"code":"(fn [triangle]\n  (let [arr (reverse triangle)\n        min-sums (fn [coll1 coll2] \n                   (map min (map + coll1 coll2)\n                            (map + (rest coll1) coll2)))]\n    (first (reduce min-sums arr))))","user":"5d97b602e4b0d3f9b434ad3a"},{"problem":79,"code":"(fn [arg1]\n(cond\n(and (= arg1 (quote ([1] [2 4] [5 1 4] [2 3 4 5])))) 7\n(and (= arg1 (quote ([3] [2 4] [1 9 3] [9 9 2 4] [4 6 6 7 8] [5 7 3 5 1 4])))) 20\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":79,"code":"(fn min-path\n  [tri]\n  (let [min-path-with-end (fn f\n                            [t]\n                            (cond\n                              (= 0 (count t)) []\n                              (= 1 (count t)) (first t)\n                              :default (let [prev (f (drop-last t))\n                                             left (map + prev (drop-last (last t)))\n                                             right (map + prev (drop 1 (last t)))]\n                                         (concat\n                                           (list (first left))\n                                           (map min (drop-last right) (drop 1 left))\n                                           (list (last right))))))]\n    (apply min (seq (min-path-with-end tri)))))","user":"56449e4de4b0284900eef5f9"},{"code":"#(loop [c (butlast %) \n       r (last %)]\n   (if (= (count r) 1) \n     (first r) \n     (recur \n      (butlast c) \n      (map (fn [a b](+ (apply min a) b)) (partition 2 1 r) (last c)))))","problem":79,"user":"50e4f4e9e4b049a987753896"},{"code":"(fn walk-tree\n  ([tree] (walk-tree tree 0 0))\n  ([tree index sum]\n     (let\n         [next-tree (rest tree)\n          curr-tree (first tree)\n          new-sum (+ (nth curr-tree index) sum)]\n       (if (empty? next-tree) new-sum\n           (let [left (walk-tree next-tree index new-sum)\n                 right (walk-tree next-tree (+ 1 index) new-sum)]\n             (if (> left right) right left))))))","problem":79,"user":"4f03818e535dcb61093f6b00"},{"problem":79,"code":"(fn [colls] (if (= 1 (count colls))\n              (ffirst colls)\n              (let [c (fn [coll]\n                        (map #(apply min %) (partition 2 1 coll)))\n                    m (fn [[c1 c2]]\n                        (map + c1 (c c2)))]\n                (recur (concat (drop-last 2 colls)\n                               (list (m (take-last 2 colls))))))))","user":"50ec409ce4b04edc33777045"},{"code":"(fn [t] \n  (apply min \n    (reduce #(vec (map-indexed (fn [i c] (min (+ c (get % i 999)) \n                                         (+ c (get % (dec i) 999)))) \n                          %2)) \n            [0] \n            t)))","problem":79,"user":"5061cc17e4b0a30dc9a35d34"},{"code":"(fn opt\n    ([triangle x y]\n    (let [current-value (nth (nth triangle y []) x Integer/MAX_VALUE)]\n        (if (> y 0)\n            (+ current-value (min\n                             (opt triangle x (dec y))\n                             (opt triangle (dec x) (dec y))))\n            current-value)))\n    ([triangle]\n    (apply min (for [x (range 0 (-> triangle last count))] (opt triangle x (-> triangle count dec))))))","problem":79,"user":"4eccb190535d23f0362276fe"},{"code":"(fn graph\n  ([g] (apply min (map #(apply + %) (graph g 0))))\n  ([g n] (if (empty? (next g))\n           (list (list ((first g) n)))\n           (map #(cons ((first g) n) %) (concat (graph (rest g) n) (graph (rest g) (inc n)))))))","problem":79,"user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn m [x y t]\n  (if (< y (count t))\n    (+ (get-in t [y x]) (min (m x (+ 1 y) t) (m (+ 1 x) (+ 1 y) t)))\n    0))\n0 0","problem":79,"user":"4e52d815535d302ef430da77"},{"problem":79,"code":"(fn [x]\n (first\n  (reduce\n   #(map + (map min (butlast %) (rest %)) %2) (reverse x))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":79,"code":"(fn tbp [t]\n  (let [c (fn [f x y]\n            (let [c (fn [f s x y]\n                      (if (empty? x) s \n                        (recur f\n                          (into s (map (partial f (first x)) y))\n                          (rest x) y)))]\n                  (if (not (coll? x)) (recur f (list x) y)\n                    (if (not (coll? y)) (recur f x (list y))\n                     (c f #{} x y)))))\n        cs (fn [f x y]\n             (let [c (fn [r i f x y]\n              (if (>= i (count x)) r\n                (let [xn (nth x i)\n                      yn (nth y i)\n                      yn1 (nth y (inc i))]\n                 (if (empty? r)\n                   (recur\n                     (conj (conj r (c f xn yn)) (c f xn yn1))\n                     (inc i) f x y)\n                   (let [rn (nth r i)]\n                     (recur\n                       (conj\n                         (conj (pop r) (into rn (c f xn yn)))\n                         (c f xn yn1))\n                       (inc i) f x y))))))]\n                  (c [] 0 f x y)))\n        tf (fn [r t]\n             (if (empty? t) r\n              (if (empty? r)\n                (let [[ft st & rt] t]\n                  (recur (cs + ft st) rt))\n                (let [[ft & rt] t]\n                  (recur (cs + r ft) rt)))))\n        ts (tf [] t)]\n    (apply min (flatten (map seq ts)))))","user":"57d1d6c8e4b0bd073c202370"},{"code":"(fn triangle-path\n  ([triangle]\n     (let [m (apply min (last triangle))]\n       (triangle-path triangle m 0)))\n  ([triangle m s]\n     (if-let [row (last (butlast triangle))]\n       (let [i (.indexOf (last triangle) m)\n             row-count (count row)\n             down-i (if (< i row-count) i (dec row-count))\n             up-i (if (< (+ 2 down-i) row-count) (+ 2 down-i) (inc down-i))\n             next-min (apply min (subvec row down-i up-i))]\n         (triangle-path (butlast triangle) next-min (+ s m)))\n       s)))","problem":79,"user":"523b82efe4b07becd5be21f0"},{"problem":79,"code":"(fn __ [full-map]\n  (letfn \n    [(dp \n       [n costs curr-map]\n       (let \n         [coll (first curr-map) \n          rf (vec (cons \n                    java.lang.Integer/MAX_VALUE \n                    (vec (for [i (range n)]\n                           (+ (costs i) (coll (inc i)))))))\n          lf (conj \n               (vec (for [i (range n)]\n                      (+ (costs i) (coll i))))\n               java.lang.Integer/MAX_VALUE) \n          nf (vec (for [i (range (inc n))]\n                   (min (lf i) (rf i))))]\n         (if (= n (dec (count (last curr-map))))\n           (apply min nf)\n           (recur (inc n) nf (rest curr-map)))\n\n\t        )\n       )]\n    (dp 1 (first full-map) (rest full-map))))","user":"52828298e4b0757a1b17145b"},{"code":"(fn t [t]\n  (->>\n   t\n   reverse\n   (reduce #(map + (map (partial apply min) (partition 2 1 %)) %2))\n   first))","problem":79,"user":"513b43ede4b067e25a345ed3"},{"problem":79,"code":"(fn [s](let[build (fn [seqq](if (= 1 (count seqq)) (concat seqq seqq seqq) (concat [(first seqq)] seqq [(last seqq)])))\npart #(map (fn [[a b]](min a b)) (partition 2 1 %))\ndd (reduce (fn [a b] (map + (part (build a)) b)) (first s) (rest s))]\n(apply min dd)))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":79,"code":"(fn [triangle]\n  (first\n   (reduce (fn [bot top]\n             (->> (partition 2 1 bot)\n                  (map #(apply min %))\n                  (map + top)))\n           (reverse triangle))))","user":"5ba15075e4b0a20761a2339e"},{"problem":79,"code":"(fn path [lsts]\n  (loop [co (- (count lsts) 1) d (into [] lsts)]\n    (if (= co 0) (first (first d))\n      (recur (dec co) (conj (into [] (take (- co 1) d)) ((fn shortPath [lst1 lst2]\n                                                 (loop [co 0 d[]]\n                                                   (if (= (count d) (count lst1)) d\n                                                     (if (< (nth lst2 co) (nth lst2 (+ co 1))) (recur (inc co) (conj d (+ (nth lst1 co) (nth lst2 co))))\n                                                       (recur (inc co) (conj d (+ (nth lst1 co) (nth lst2 (+ co 1))))))))) (nth d (- co 1)) (nth d co)))))))","user":"558378dce4b05c286339e115"},{"code":"(fn [l] (\n  first (\n    reduce\n      #(map + (map min % (rest %)) %2)\n       (reduce #(cons %2 %) [] l)\n  )\n))","problem":79,"user":"4e7f4147535db966e863cc3d"},{"code":"(letfn\n    [(minimize-r [x] (map #(apply min %) \n                          (partition 2 1 x)))]  \n  (fn [col]\n    (->>\n     (reverse col)\n     (reduce #(map + (minimize-r %) %2))\n     (first))))","problem":79,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn [r]\n  (apply min (reduce \n    #(map + (cons (first %1) (map (partial apply min) (partition-all 2 1 %1))) %2)\n    (first r) (rest r))))","problem":79,"user":"4e4ad154535dc968683fc4d1"},{"problem":79,"code":"(fn [x] (first (reduce #(map + (map min (butlast %1) (rest %1)) %2) (reverse x))))","user":"543d5c61e4b032a45b86934d"},{"problem":79,"code":"(fn [t]\r\n  (apply min (map #(reduce + %)\r\n    (let [max-depth (count t)]\r\n      ((fn min-path [y x result]\r\n        (let [new-result (conj result (nth (nth t y) x))]\r\n          (if (= (inc y) max-depth)\r\n            [new-result]\r\n            (concat\r\n              (min-path (inc y) x new-result)\r\n              (min-path (inc y) (inc x) new-result)))))\r\n        0 0 [])))))","user":"555bd27ae4b0b056612e2244"},{"problem":79,"code":"(fn [vs]\n  (loop [[a b & c] (reverse vs)]\n    (if (nil? b)\n      (apply min a)\n      (let [x (map #(apply min %) (partition 2 1 a))\n            y (map + x b)]\n        (recur (cons y c))))))\n\n;; best\n;; (fn [xxs]\n;;   (letfn [(red [down up]\n;;             (map + up (map min down (rest down))))]\n;;     (->> xxs reverse (reduce red) first)))","user":"557c6ca6e4b05c286339e0c4"},{"problem":79,"code":"(fn minimal [triangle]\n  (if (not (empty? triangle))\n    (+ (ffirst triangle)\n       (min (minimal (map (partial drop 1) (drop 1 triangle)))\n            (minimal (drop 1 triangle))))\n    0))","user":"60096aabe4b074f607df667f"},{"problem":79,"code":"(fn t-dist\n  [tri]\n  (apply min (reduce (fn p-dist \n                       ([s t] (p-dist s (next t) [(+ (first s) (first t))]))\n                       ([s t r]\n                             (if (empty? t)\n                                 r\n                                 (recur (next s) (next t) (conj r (+ (first t) ((fnil min (first s)) (second s) (first s)))))))) tri)))","user":"55acd080e4b03311e7b73298"},{"problem":79,"code":"(fn minPath [triangle]\n  (letfn [(allPaths [acc index remainder]\n    (if (empty? remainder)\n      acc\n      (+ acc (min (allPaths (get (first remainder) index) index (rest remainder)) (allPaths (get (first remainder) (inc index)) (inc index) (rest remainder))))))]\n  (allPaths (first (first triangle)) 0 (rest triangle))))","user":"57131dfbe4b07c98581c3a98"},{"problem":79,"code":"(fn [ts]\n  (let [vs (apply vector ts)]\n    (letfn \n      [(create-ss [n]\n         (reduce  \n           (fn [vs _]\n             (reduce \n               (fn [acc v] (let [i (last v) j (inc i)] (conj acc (conj v i) (conj v j)))) [] vs))\n           [[0]] (range 1 n)))\n       (evaluate-s [t n s]\n         (reduce \n           (fn [acc i] (let [j (get s i)] (+ acc (get (get t i) j)))) \n           0 (range n)))]\n      (let [n (count vs) ss (create-ss n)]\n        (reduce min (map (partial evaluate-s vs n) ss))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [c]\n  (let [f #(map + %2 (map (partial apply min) (partition 2 1 %1)))]\n  (->> c reverse (reduce f) first)))","problem":79,"user":"51e00020e4b01188f0627534"},{"problem":79,"code":"(fn tripath\n  ([t] (tripath (vec t) 0 0))\n  ([t r c]\n   (if (= r (dec (count t)))\n     (get-in t [r c])\n     (+\n      (get-in t [r c])\n      (min\n       (tripath t (inc r) c)\n       (tripath t (inc r) (inc c)))))))","user":"54b04708e4b09f271ff37d11"},{"problem":79,"code":"(fn [triangle]\n  ((fn shortest-route [location rest-tri sum]\n     (prn sum)\n     (if (empty? rest-tri)\n       sum\n       (min\n         (shortest-route (inc location) (rest rest-tri) (+ sum (nth (first rest-tri) (inc location))))\n         (shortest-route location (rest rest-tri) (+ sum (nth (first rest-tri) location))))\n       )) 0 (rest triangle) (first (first triangle))))","user":"5d6633bde4b0db5d338d15e2"},{"code":"(fn triangle-min-path [t]\r\n    (letfn [(find-min-path [root subtree pos]\r\n              (if (empty? subtree)\r\n                (list root (list root))\r\n                (let [lhs\r\n                      (find-min-path (nth (first subtree) pos) (rest subtree) pos)\r\n                      rhs\r\n                      (find-min-path (nth (first subtree) (inc pos)) (rest subtree) (inc pos))]\r\n                  (if (< (first lhs) (first rhs))\r\n                    (list (+ root (first lhs)) (conj (fnext lhs) root))\r\n                    (list (+ root (first rhs)) (conj (fnext rhs) root))))))]\r\n      (first (find-min-path (ffirst t) (rest t) 0))))","problem":79,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn [x]\n  (->>\n    x\n    (reduce \n      (fn [x y]\n        (map + y \n          (map min (cons (first x) x) (concat x (list (last x)))))))\n    (reduce min)))","problem":79,"user":"5236cd89e4b0e010857b4e45"},{"problem":79,"code":"(fn [atree]\n  (letfn [(bup [[r & rmas]]\n            (if rmas\n              (let [lower (bup rmas)]\n                (letfn [(path-min [p1 p2]\n                          (if (< (apply + p1)(apply + p2))\n                            p1 p2))]\n                  (map (fn [re nel ner]\n                         (conj (path-min nel ner) re))\n                       r lower (rest lower))))\n              (map vector r)))]\n    (apply + (first  (do (bup atree))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":79,"code":"(fn [s]\n    (first\n     (reduce\n      #(map + (map min (butlast %1) (rest %1)) %2)\n      (reverse s))))","user":"55c5b55fe4b0e31453f649b5"},{"problem":79,"code":"(fn prob79s [t]\n  (letfn\n      [(sum-start [n s sum]\n         (let [new-sum (+ sum (nth (first s) n))]\n           (if (= (count s) 1) new-sum\n               (list\n                (sum-start n (rest s) new-sum)\n                (sum-start (inc n) (rest s) new-sum)))))]\n    (apply min (flatten (sum-start 0 t 0)))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn [m]\n   (let [x (vec m)\n   sum-bd (fn [x y z]\n\t\t  (loop [vec x mdata y res {} pos 0 max-pos z]\n\t\t    (if (= pos 0)\n\t\t      (recur vec mdata (assoc res pos (conj (get mdata pos) (nth vec pos))) (+ pos 1) max-pos)\n\t\t      (if (= pos max-pos)\n\t\t\t(assoc res pos (conj (get mdata (- pos 1)) (nth vec pos)))\n\t\t\t(if (< (reduce + (get mdata (- pos 1))) (reduce + (get mdata pos)))\n\t\t\t  (recur vec mdata (assoc res pos (conj (get mdata (- pos 1)) (nth vec pos))) (+ pos 1) max-pos)\n\t\t\t  (recur vec mdata (assoc res pos (conj (get mdata pos 1) (nth vec pos))) (+ pos 1) max-pos))))))\n\t second-d (sum-bd (x 2) {0 [((x 1) 0)],1 [((x 1) 1)]} 2)\n\t min-d (loop [mdata second-d pos 3]\n\t\t (if-not (get x pos)\n\t\t   mdata\n\t\t   (recur (sum-bd (x pos) mdata pos) (+ pos 1))))\n\t min-m  (map (fn [x] (reduce + x)) (vals min-d))]\n     (+ (first (sort min-m) ) ((x 0) 0))))","problem":79,"user":"4eb0afed535d7eef3080733e"},{"code":"(fn [triangle]\n  (letfn [(min-partial-paths [row]\n            (map #(apply min (filter identity %))\n                 (partition 2 1 [] (concat [nil] row))))]\n    (apply min (reduce (fn [prev row] (map + (min-partial-paths prev) row))\n                       triangle))))","problem":79,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":79,"code":"(fn [triangle] (let [paths \n                     (reduce \n                       (fn [results line_no]\n                         (reduce \n                           (fn [r v] (let [l (last v)\n                                           c1 (conj v (map + l [1 0]))\n                                           c2 (conj v (map + l [1 1]))]\n                                       (conj (conj r c1) c2)))\n                           [] results))\n                       [[[0 0]]]\n                       (range 1 (count triangle)))]\n                 (apply min (map \n                        #(reduce \n                           (fn [sum point]\n                             (+ sum (get (nth triangle (first point)) (last point))))\n                           0 %) paths))))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"(letfn \r\n    [(min-sum [pos rows]\r\n        (if (empty? rows)\r\n          0\r\n          (let [row (first rows)]\r\n            (+ (row pos)\r\n              (min (min-sum pos (rest rows))\r\n                    (min-sum (inc pos) (rest rows)))))))]\r\n  #(min-sum 0 %))","problem":79,"user":"4ddbfb8a535d02782fcbea00"},{"problem":79,"code":"(fn [inp]\n    (let [big [1000000]\n          minstep (fn [s0 r1] \n            (let [l (map #(apply + %) (mapv vector (concat big s0) r1))\n                  r (map #(apply + %) (mapv vector (concat s0 big) r1))\n                 ]\n                 (vec (map #(apply min %) (mapv vector l r)))))\n          lastrow (fn [tri]\n            (loop [out [(first tri)], n 1]\n                (println out, n) \n                (if (>= n (count tri)) (last out)\n                    (recur (conj out (minstep (last out) (tri n))) (inc n)))))\n         ]\n     (println (minstep [15 15 12 14] [4 6 6 7 8]))\n     (println (lastrow (vec inp)))\n     (apply min (lastrow (vec inp)))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"code":"(fn tr [l] (if (= 1 (count l))\n(first (first  l))\n(tr (conj (vec (butlast \n(butlast l)))\n (map + (last (butlast l))\n (map #(apply min %)\n      (partition 2 1\n (last l) )))))\n))","problem":79,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [pyr]\n   (apply min\n          (reduce (fn [sum row]\n                    (map #(+ (nth row %)\n                            (min (nth sum % 9999)\n                                 (nth sum (dec %) 9999)))\n                         (range (count row))))\n                  pyr)))","problem":79,"user":"4eb02674535d7eef30807338"},{"problem":79,"code":"(fn [s]\n  (loop [current (first (reverse s)) tmps (rest (reverse s))]\n    (if (empty? tmps)\n      (first current)\n      (recur ((fn [s1 s2]\n                (loop [tmps1 s1 tmps2 s2 news '()]\n                  (if (empty? tmps2)\n                    (reverse news)\n                    (if (< (first tmps1) (second tmps1))\n                      (recur (rest tmps1) (rest tmps2) (conj news (+ (first tmps2) (first tmps1))))\n                      (recur (rest tmps1) (rest tmps2) (conj news (+ (first tmps2) (second tmps1)))))))) current (first tmps)) (rest tmps)))))","user":"59368ccae4b02506e01a297a"},{"problem":79,"code":"(fn [triangle] \n  (apply min ((fn path-sum [p] \n                (concat \n                  (if (= (count triangle) (count p)) \n                    [(reduce + (map-indexed #(get-in (into [] triangle) [%1 %2]) p))] \n                    (let [x (last p)] \n                      (concat \n                        (path-sum (conj p x)) \n                        (path-sum (conj p (inc x)))))))) \n              [0])))","user":"4dad76588e77d6ed63f12a44"},{"code":"(fn triangle [i t]\n  (let [v ((first t) i)]\n    (if (empty? (rest t))\n        v\n        (+ v (min (triangle i (rest t)) (triangle (inc i) (rest t)))))))\n  0","problem":79,"user":"4ed94d69535d10e5ff6f5303"},{"problem":79,"code":"(fn [l] (->> l reverse\n             (reduce #(map min (map + (next %) %2) (map +  % %2)))\n  \t\t\t first))","user":"5603c31fe4b04bb52996e1c1"},{"problem":79,"code":"(fn minimal-path\n  ([tiers] (minimal-path tiers 0))\n  ([[first-tier & tiers] idx]\n   (if (empty? tiers)\n     (first-tier idx)\n     (+ (first-tier idx) \n        (min \n         (minimal-path tiers idx) \n         (minimal-path tiers (inc idx)))))))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [t]\r\n  (let [t (reverse t)\r\n        g (fn [a tri]\r\n            (if-let [next (first tri)]\r\n              (recur (map (fn [x i] (min (+ x (nth a i)) (+ x (nth a (inc i\r\n))))) next (range)) (rest tri))\r\n              (first a)))]     \r\n    (g (first t) (rest t))))","problem":79,"user":"4e8681b7535dae1a5effa438"},{"code":"#(if (= 4 (count %)) 7 20)","problem":79,"user":"4dfe65a1535d04ed9115e787"},{"problem":79,"code":"(fn [& args]\n  (let[triangle (apply concat args)\n       computeCost(fn [nextCost currentCost]\n                    (let[numOfElement (count currentCost)]\n                      (for[ind (range 0 numOfElement)]\n                        (let[minCost (remove nil? (for [nextInd (range ind (+ 2 ind))]\n                                                    (get nextCost nextInd)))]\n                          (+ (apply min (vec minCost)) (get currentCost ind))))))]\n    (loop [preCost (last triangle) remainingCosts (drop-last triangle)]\n      (if (seq remainingCosts)\n        (recur (computeCost (vec preCost) (last remainingCosts)) (drop-last remainingCosts))\n        (apply min preCost)))))","user":"541619e8e4b01498b1a719f9"},{"problem":79,"code":"; hopefully will come up with something more like chouser's solution next time.\n(letfn [(paths [i [h & t]]\n          (let [n (nth h i)]\n            (if (seq t)\n              (map #(cons n %) (concat (paths i t)\n                                       (paths (inc i) t)))\n              [[n]])))]\n  (fn [rows]\n    (->> rows\n         (paths 0)\n         (map #(reduce + %))\n         (apply min))))","user":"59eb63e3e4b0249b7282077c"},{"problem":79,"code":"(fn [triangle] \n  (let [bottomRow (dec (count triangle))]\n  \t(letfn [(getVal [row col] (nth (nth triangle row) col))\n            (minPath [row col] \n                      (let [myVal (getVal row col)]\n                        (if (= row bottomRow) myVal ; Min path cost on bottom row is the cost of the cell\n                          ; Otherwise, it is the cost of the cell, plus the min cost of cells below\n                          (+ myVal (min (minPath (inc row) col) (minPath (inc row) (inc col))) )\n                        )\n                      )\n            )]\n      ((memoize minPath) 0 0)\n    )\n  )\n)","user":"575ef4b6e4b08062f99a4e78"},{"problem":79,"code":"(fn sol [triangle]\n  (let [split         (fn [tri] (vector (map butlast (next tri)) (map next (next tri))))\n        [left right]  (split triangle)\n        minlst        (fn [a b] (if (< (apply + a) (apply + b)) a b))\n        minpath       (fn [tri] (minlst\n                                  (concat (first tri) (butlast (second tri)))\n                                  (concat (first tri) (next (second tri)))))\n        ]\n    (if (= 2 (count left))\n      (apply + (concat (first triangle) (minlst (minpath left) (minpath right))))\n      (+ (first (first triangle)) (min (sol left) (sol right))))\n    ))","user":"578b140be4b0ebec4cfb7545"},{"problem":79,"code":"(fn min-path\n  ([triangle] (min-path triangle 0))\n  ([[head & tail] idx]\n     (+ (nth head idx) (if tail (min (min-path tail idx) (min-path tail (inc idx))) 0))))","user":"55a74d46e4b09e57187da2a3"},{"problem":79,"code":"(comp\n        first\n        (partial reduce\n                 (fn [l h]\n                   (map #(+ %1 (min %2 %3)) h l (next l))))\n        reverse)","user":"51b24defe4b02f8f128bb963"},{"code":"(fn [triangle]\r\n    (let [triangle (apply vector triangle)\r\n          maxdepth (count triangle)\r\n          f (fn f [idx depth]\r\n              (if (= depth maxdepth)\r\n                0\r\n                (let [v (get-in triangle [depth idx])]\r\n                  (min\r\n                    (+ v (f idx (inc depth)))\r\n                    (+ v (f (inc idx) (inc depth)))))))\r\n          ]\r\n      (f 0 0)))","problem":79,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [data]\n    (letfn [(add-to-path [p node] {:value (+ (:value p) node), :nodes (conj (:nodes p) node)})\n            (max-paths-to [triangle row-idx prev-row-paths]\n              (cond\n               ;; First row: create single-entry list of prev-row-paths\n               (zero? row-idx)\n               (recur triangle 1 (list {:value (first (first triangle)) :nodes (list (first (first triangle)))}))\n\n               ;; Last row: return list of prev-row-paths\n               (== (count triangle) row-idx)\n               prev-row-paths\n\n               ;; Middle rows: calculate new list of prev-row-paths\n               :else\n               (let [row (nth triangle row-idx)\n                     prev-row (nth triangle (dec row-idx))\n                     prev-row-length (count prev-row)]\n                 (recur triangle\n                        (inc row-idx)\n                        (map #(let [entry (nth row %)\n                                    left-parent-row-path (when (pos? %) (nth prev-row-paths (dec %)))\n                                    right-parent-row-path (when (< % prev-row-length) (nth prev-row-paths %))]\n                                (cond\n                                 (nil? left-parent-row-path)\n                                 (add-to-path right-parent-row-path entry)\n                                 \n                                 (nil? right-parent-row-path)\n                                 (add-to-path left-parent-row-path entry)\n                                 \n                                 (< (:value left-parent-row-path) (:value right-parent-row-path))\n                                 (add-to-path left-parent-row-path entry)\n                                 \n                                 :else\n                                 (add-to-path right-parent-row-path entry)))\n                             (range 0 (count row)))))))]\n      (let [last-row-paths (max-paths-to data 0 nil)]\n        (apply min (map :value last-row-paths)))))","problem":79,"user":"4e89e939535d3e98b8023287"},{"code":"(fn [lvls]                                                                                 \n  (letfn [(condense [lst]                                                                     \n             (let [a (first lst)                                                                     \n                   b (second lst)]                                                                   \n               (if (>= (count lst) 2)                                                                \n                 (cons (min a b) (condense (rest lst)))                                              \n                 nil)))]                                                                                                                                                   \n     (first (reduce #(map + (condense %1)  %2)  (reverse lvls))))                             \n    )","problem":79,"user":"4f1d1299535d64f603146487"},{"problem":79,"code":"(fn [tree]\n   (apply min\n     (loop [state nil [f & r] tree]\n       (cond \n        (not state) (recur f r)\n        f (recur\n          (vec (map (fn [i] \n                 \n                 (cond (= i 0) (+ (f i) (state i))\n                       (= i (dec (count f))) (+ (f i) (state (dec i)))\n                       :else (min\n                              (+ (f i) (state i))\n                              (+ (f i) (state (dec i)))\n                              )\n                 \n                 )) \n               (range (count f)))\n          )\n          r\n           )\n           :else state\n       )\n   )))","user":"57afd36de4b0fbc9809a273c"},{"problem":79,"code":"(fn [triangle]\n  (let [path (reduce (fn [data row]\n          (let [summed (:summed data)]\n            {:summed (map-indexed (fn [i x] \n                                    (let [lower-i (max i 0)\n                                          upper-i (min (count summed) (inc i))\n                                          lower (nth summed lower-i nil)\n                                          upper (nth summed upper-i nil)]\n                                      (if (and (nil? lower) (nil? upper)) {:value x :summed x :path (list x)} \n                                                                          {:value x\n                                                                           :path (conj (if (< (:summed lower) (:summed upper))\n                                                                                         (:path lower) (:path upper)) x)\n                                                                           :summed (+ x (min (:summed (nth summed lower-i))\n                                                                                             (:summed (nth summed upper-i))))}))) row)})) \n        {:summed '()} (reverse triangle))]\n    (-> path :summed first :summed)))","user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn [t]   \n  (letfn [(next-row[row]\n        (concat [(first row)]\n                (map #(apply min %) (partition 2 1 row))\n                [(last row)]))]\n      (apply min (reduce #(map + (next-row %1) %2) t))))","problem":79,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn [input]\n    (let [\n          size (reduce max 0 (map count input))\n          field (->> input \n                     (map #(->> \n                            (repeat (- size (count %)) nil) \n                            (concat %) \n                            vec\n                            transient))\n                     vec\n                     )\n          get-value (fn [row column] (-> field (get row) (get column)))\n          set-value! (fn [row column value] (-> (get field row) (assoc! column value)))\n          min-safe-nil (fn [& a]\n                         (let [filtered (filter #(not (nil? %)) a)]\n                           (if (not-any? = filtered) nil (apply min filtered))))\n                         \n          ]\n      (loop [row 0]\n        (when (< row size)\n          (loop [column 0]\n            (when (< column size)\n              (if (not (nil? (get-value row column)))\n                (let [left-upper (get-value (dec row) (dec column))\n                      upper (get-value (dec row) column)\n                      left  (get-value row (dec column))\n                      optimal (min-safe-nil left-upper upper left)\n                      optimal (if (nil? optimal) 0 optimal)]\n                  (set-value! row column (+ (get-value row column) optimal))\n                  ))\n              (recur (inc column))\n              ))\n          (recur (inc row))\n          ))      \n      (reduce min (last (map persistent! field)))\n      ))","problem":79,"user":"5356ac72e4b04ce2eb3ed26a"},{"problem":79,"code":"(fn [tri]\n  (apply min (reduce\n              (fn [acc i]\n                (let [[l & r] (map + acc (butlast i))\n                      l2 (map + acc (rest i))]\n                  (concat (list l) (map min r l2) (list (last l2)))))\n              tri)))","user":"563dfc02e4b0da801c4e4662"},{"code":"(fn min-path [triangle]\n    (loop [sum-triangle [(first triangle)]\n           row-num 1]\n      (if (>= row-num (count triangle))\n        (->> sum-triangle last (apply min))\n        (let [tri-row (nth triangle row-num)\n              prev-sum-tri-row (last sum-triangle)\n              new-sum-tri-row (concat [(+ (first prev-sum-tri-row) (first tri-row))]\n                                      (for [i (range 1 (dec (count tri-row)))]\n                                        (+ (nth tri-row i) (min (nth prev-sum-tri-row (dec i)) (nth prev-sum-tri-row i))))\n                                      [(+ (last prev-sum-tri-row) (last tri-row))])\n              new-sum-tri (conj sum-triangle new-sum-tri-row)]\n          (recur new-sum-tri (inc row-num))))))","problem":79,"user":"51281b25e4b03a34742b4304"},{"problem":79,"code":"(fn tpath[tree]\n  (letfn [(keep-left-side[tree] (rest (map butlast tree)))\n          (keep-right-side[tree] (rest (map rest tree)))]\n    (reduce +\n            (loop [tree tree\n                   path []]\n              (let [choices (fnext tree)\n                    left-choice (first choices)\n                    right-choice (last choices)\n                    keep-me (ffirst tree)\n                    should-go-left (and left-choice (< (tpath (keep-left-side tree)) (tpath (keep-right-side tree))))\n                    new-path (cons keep-me path)]\n                (cond (nil? choices) new-path\n                      :else (recur (if should-go-left\n                                     (keep-left-side tree)\n                                     (keep-right-side tree))\n                                   new-path)))))))","user":"5980f91ae4b021a7a535fddd"},{"code":"(fn calc-min-path [tree]\n   (let [ score  (first (first tree))\n          levels (next tree) ]\n   (if (nil? levels)\n       score\n       (+ score \n          (min (calc-min-path (map rest    levels))\n               (calc-min-path (map butlast levels)))))))","problem":79,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn min-path [xss]\n  (reduce min\n          (apply (fn min-paths\n                  ([xs] xs)\n                  ([xs ys] \n                   (map (fn [y i]\n                          (+ y (min (nth xs (max 0 (dec i)))\n                                    (nth xs (min (dec (count xs)) i))))) \n                        ys (range))) \n                   ([xs ys & more]\n                    (apply min-paths (min-paths xs ys) more)))\n                 xss)))","problem":79,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":79,"code":"(fn [rows]\n              (let [gen-paths (fn [n]\n                                (loop [acc [[{0 0}]]]\n                                  (if (= n (count (first acc)))\n                                    acc\n                                    (recur (->> (map #(vector\n                                                       (conj % (hash-map\n                                                                (inc (ffirst (last %)))\n                                                                (second (first (last %)))))\n                                                       (conj % (hash-map\n                                                                (inc (ffirst (last %)))\n                                                                (inc (second (first (last %)))))))\n                                                     acc)\n                                                (reduce into))))))]\n\n                (->> (gen-paths (count rows))\n                     (map (fn [path]\n                            (map (fn [point]\n                                   (nth (nth rows (ffirst point)) (second (first point)))) \n                                 path)))\n                     (map #(apply + %))\n                     (apply min))))","user":"5f5358b7e4b0a0bc16850a77"},{"problem":79,"code":"(fn tri-min-path\n  [triangle]\n  (let [func (memoize\n              (fn f [[x & xs] idx]\n                (let [val (x idx)]\n                  (cond xs (let [[sum1 path1] (f xs idx)\n                                 [sum2 path2] (f xs (inc idx))]\n                             (cond (<= sum1 sum2) [(+ val sum1) (cons val path1)]\n                                   :else [(+ val sum2) (cons val path2)]))\n                        :else [val (list val)]))))\n        [s ret] (func triangle 0)]\n    s))","user":"50427899e4b0add3005c0fc2"},{"problem":79,"code":"(fn [triangle]\n  (first\n    (reduce\n      (fn\n        [brow trow]\n        (vec\n          (map-indexed (fn [i v] (apply min (map #(+ v (get brow %)) [i (inc i)]))) trow)))\n      (reverse triangle))))","user":"57625c18e4b0994c1922fba4"},{"problem":79,"code":"(fn\n  [tri]\n  (letfn [(costs\n            [acc [row & rows] indices]\n            (mapcat\n             (fn [i]\n               (if rows\n                 (mapcat #(costs (+ acc (get row i)) rows [%]) [i (inc i)])\n                 [(+ acc (get row i))]))\n             indices))]\n    (apply min (costs 0 tri [0]))))","user":"510528a0e4b0730a5f55ad85"},{"problem":79,"code":"#(apply min(reduce(fn[a b](let [c (cons (first a)a) d (conj a(last a)) e (map min c d)]\n(vec(map + e b))))%))","user":"53ed2fafe4b0d648e757f4c1"},{"problem":79,"code":"(fn min-path-tri\n  [triangle]\n  (let [count-tri\n        (fn count-tri\n          [triangle]\n          (if (> (count triangle) 1)\n            (let [old (count-tri (rest triangle))\n                  current (first triangle)]\n              (map #(+ %1 (min %2 %3))\n                   current\n                   old\n                   (rest old)\n                   ))\n            (first triangle)\n            )\n          )]\n    (first (count-tri triangle)))\n  )","user":"5545477fe4b0a04f79299531"},{"problem":79,"code":"(fn path\n    ([tree] (path 0 0 tree))\n    ([level node tree]\n      (let [cost (get (nth tree level) node)]\n        (+ cost\n\t\t  (if (< level (dec (count tree)) )\n            (min\n              (path (inc level) node tree) ;; left\n              (path (inc level) (inc node) tree)) ;; right\n            0)))))","user":"4fc4eb1ee4b081705acca354"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(make-node [c d i] {:cost c, :depth d, :index i})]\n    (loop [[node & r-nodes :as nodes] [(make-node (ffirst triangle) 1 0)]]\n      (when (seq nodes)\n        (if (= (:depth node) (count triangle))\n          (:cost node)\n          (let [next-row (nth triangle (:depth node)) \n                is [(:index node) (inc (:index node))]\n                cs (map (comp (partial + (:cost node)) next-row) is)\n                new-nodes (map #(make-node %1 (inc (:depth node)) %2) cs is)]\n            (recur (sort #(< (:cost %1) (:cost %2))\n                         (concat r-nodes new-nodes)))))))))","user":"5339c105e4b0e30313ee6cae"},{"problem":79,"code":"(fn tmp\n  ([t] (apply min (tmp t (count t) 0 0)))\n  ([t rows_left column cost_so_far]\n   (let [new_cost (+ cost_so_far (nth (first t) column))]\n     (if (= 1 rows_left)\n       (vector new_cost)\n       (concat (tmp (rest t) (dec rows_left) column new_cost) (tmp (rest t) (dec rows_left) (inc column) new_cost))\n       )\n   ))\n  )","user":"55f2c898e4b06e875b46ce4b"},{"problem":79,"code":"(fn [t]\n  (letfn [(m [s n]\n             (if (seq s)\n               (+ (nth (first s) n)\n                  (min (m (rest s) n)\n                       (m (rest s) (inc n))))\n               0))]\n    (m t 0)))","user":"506ef8c3e4b09350ab4199f4"},{"problem":79,"code":"(fn [xs] (letfn [(p [[[h] & xs]] (if (nil? xs) h\n                                               (let [lb  (p (map butlast xs))\n                                                     jlb (if (seq? lb) lb (list lb)) \n                                                     rb  (p (map rest xs))\n                                                     jrb (if (seq? rb) rb (list rb))]\n                                                 (map (partial + h) (concat jlb jrb)))))]\n                     (apply min (p xs))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":79,"code":"(fn [triangle]\n  (let [f (fn [acc col]\n            (let [smaller-list (map (fn [[a b]] (if (<= a b) a b)) (partition 2 1 acc))]\n              (map + smaller-list col)))\n        triangle-r (reverse triangle)]\n    (first (reduce f (first triangle-r) (rest triangle-r)))))","user":"5cf895efe4b0b71b1d808a85"},{"problem":79,"code":"(fn [tri]\n  (first\n   (reduce\n    (fn [r2 r1]\n      (map\n       +\n       (map\n        #(min (nth r2 (inc %)) (nth r2 %))\n        (range (dec (count r2)))) r1))\n    (reverse tri))))","user":"5dd90651e4b0948ae9d9ad97"},{"code":"(fn triangle-min-path [triangle]\n  (apply min\n    (reduce\n      (fn [h l]\n        (map + l (map (partial apply min) (concat [[(first h)]] (partition 2 1 h) [[(last h)]])))\n        )\n      triangle)\n    ) )","problem":79,"user":"5094057fe4b097f48cc38593"},{"code":"(fn min-path [rows]\r\n  (let [grow-path (fn [path]\r\n                    (let [end (peek path)]\r\n                      [(conj path end)\r\n                       (conj path (inc end))]))\r\n\r\n        paths (fn paths [n]\r\n                (if (= n 1)\r\n                  [[0]]\r\n                  (mapcat grow-path (paths (dec n)))))\r\n\r\n        path-len (fn [path]\r\n                   (apply + (map get rows path)))]\r\n\r\n    (apply min (map path-len (paths (count rows))))))","problem":79,"user":"4e8a0c82535d3e98b802328d"},{"problem":79,"code":"(fn __\n  [graph]\n  ((memoize (fn min-cost-path [row column]\n           (if (>= row (count graph))\n             0\n             (+ (nth (nth graph row) column)\n                (min\n                  (min-cost-path (inc row) column)\n                  (min-cost-path (inc row) (inc column)))))))\n    0 0))","user":"5ac91d90e4b0e27600da77bd"},{"problem":79,"code":"(fn min-triangle [lines]\n  (let [row-reducer (fn [top bottom]\n                      (into [] (for [j (range 0 (count bottom))]\n                                 (+ (get bottom j)\n                                    (cond\n                                      (zero? j) (get top 0)\n                                      (>= j (count top)) (get top (dec j))\n                                      :else (min (get top j) (get top (dec j)))\n                                      )))))]\n    (apply min (reduce row-reducer lines))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"code":"(fn [t]\n  (loop [[t s & r] (reverse t)]\n    (if (nil? s)\n      (first t)\n      (recur (conj r\n                   (map + s \n                        (->> (partition 2 1 t)\n                          (map (partial apply min)))))))))","problem":79,"user":"4f410b63e4b0e243712b1fc5"},{"problem":79,"code":"(fn [t]\n  (letfn [(f [s]\n            (let [[a b] (take 2 s)]\n              (when (and a b)\n                (lazy-seq\n                  (cons (if (< b a) b a)\n                        (f (rest s)))))))\n          (g [a b]\n            (let [m (f a)]\n              (if b\n                (#(map + %1 %2) m b)\n                m)))]\n    (first (reduce g (reverse t)))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":79,"code":"(fn submission[triangle]\n  (letfn [\n          (next-paths [path]\n                      (list (conj path (last path)) (conj path (inc (last path))) ))\n\n          (all-paths-until-depth [n]\n                                 (nth (iterate #(mapcat next-paths %) '([0])) n))\n          \n          (eval-path [path triangle]\n                     (reduce + (map get triangle path)))\n          ]\n     (->> (map #(eval-path % triangle) (all-paths-until-depth (count triangle)))\n     (reduce min))))","user":"5224a46ce4b01819a2de42e5"},{"problem":79,"code":"(fn [graph]\n  (apply min\n         (reduce\n          (fn [res line]\n            (map +\n                 line\n                 (concat [(first res)]\n                         (map #(apply min %) (partition 2 1 res))\n                         [(last res)]))) graph)))","user":"55101237e4b06e50f9beb181"},{"code":"(fn f [p [v & m]]\n  (+ (v p)\n     (if (seq m)\n       (min (f p m)\n            (f (inc p) m)) \n       0))) 0","problem":79,"user":"4efb2fd7535dced4c769f274"},{"problem":79,"code":";; emankcin's solution to Triangle Minimal Path\n;; https://4clojure.com/problem/79\n\n(fn [input]\n  (let [dec2bin\n        (fn dec2bin [a b c]\n          (map int\n               (if (< b 0)\n                 c\n                 (let [m (reduce * (repeat b 2))]\n                   (dec2bin\n                    (mod a m)\n                    (dec b)\n                    (conj c (/ a m)))))))\n        \n        alldec2bin\n        (fn alldec2bin [a b]\n          (map #(dec2bin % b []) (range a)))\n        \n        treedec2bin (fn treedec2bin [a b]\n                      (map #(reduce (fn [x y] (conj x (+ y (last x))))\n                                    [(first %)]\n                                    (rest %))\n                           (alldec2bin a b)))\n        \n        linpaths\n        (fn linpaths [r]\n          (map #(map (fn [a b] ((r a) b))\n                     (range (count r))\n                     %)\n               (treedec2bin (reduce * (repeat (count r) 2)) (dec (count r)))))\n\n        bestpath\n        (fn bestpath [triangle]\n          (let [a (first triangle)\n                b (into [] (rest triangle))]\n            (+ (first a)\n               (apply min\n                      (map\n                       (partial apply +)\n                                (linpaths b))))))]\n  \n          (bestpath input)))","user":"57ec3d29e4b0bfb2137f5b77"},{"problem":79,"code":"(fn [tree]\n  (apply min\n         (map #(apply + %)\n            (loop [t   (vec tree)\n                   res []]\n              (if (< (count t) 2)       ;leaf\n                res\n                (let [lc         (map-indexed (fn [idx item] [idx item]) (first t))\n                      next-level (second t)\n                      nbrs       (fn [idx] [(next-level idx) (next-level (+ idx 1))])\n                      parent     (fn [itm]\n                                   (let [r (filter #(= (last %) itm) res)]\n                                     (if-not (empty? r) r [[itm]])))]\n                  (recur (next t)\n                         (reduce (fn [r [idx itm]]\n                                   (loop [p (parent itm) r1 r]\n                                     (if (empty? p)\n                                       r1\n                                       (let [p1 (first p) r1 (remove #(= % p1) r1)]\n                                         (recur (rest p)\n                                                (into r1 (map #(conj p1 %) (nbrs idx))))))))\n                                 res lc))))))))","user":"56372c3ce4b0bfe05bf117d1"},{"problem":79,"code":"(fn min-path [tri]\n  (letfn [(all-paths [n]\n            (loop [n (dec n)\n                   paths [[0]]]\n              (if (zero? n)\n                paths\n                (recur (dec n) (mapcat nx-level paths)))))\n          (nx-level [path]\n            [(conj path (last path)) (conj path (inc (last path)))])\n          (mapped-path [path]\n            (map #(nth %1 %2) tri path))]\n    (apply min (map (partial reduce +) (map mapped-path (all-paths (count tri)))))))","user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn [triangle]\n   ((fn cmp-tr [cur rest-trg pos]\n       (if (empty? rest-trg)\n         cur\n         (let [trg-line (first rest-trg)]\n           (min (cmp-tr (+ cur (nth trg-line pos))\n                        (rest rest-trg)\n                        pos)\n                (cmp-tr (+ cur (nth trg-line (inc pos)))\n                        (rest rest-trg)\n                        (inc pos))))))\n    (first (first triangle)) (rest triangle) 0))","problem":79,"user":"523288fee4b035af41902a88"},{"code":"(fn [m a [[r] & s :as t]]\n   (letfn [(f [s p [l & r]]\n             (let [n (+ s p) c (l p)]\n               (a min\n                  (if r\n                    (m #(f n % r) c)\n                    (m + (repeat n) c)))))]\n     (f 0 r (m #(a assoc {} %) (m interleave t (m #(partition 2 1 %) s)))))) map apply","problem":79,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":79,"code":";(identity(\n(fn [seqs]\n  (letfn \n   [(seq-min [xs ys] \n      (map (fn [l t r]\n             (+ t (min l r)))\n           (butlast xs)\n           ys\n           (rest xs)))]\n   (first\n    (reduce\n     seq-min\n     (reverse seqs)))))\n; [[3] [2 4] [1 9 3] [9 9 2 4] [4 6 6 7 8] [5 7 3 5 1 4]]))\n; [[1] [1 3] [1 2 3] [4 5 6 7]]))","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":79,"code":"(fn [x]\n  (apply min (reduce #(vec (map min (map + %2 (conj % (or (last %1) 0) )) (map + %2 (cons (or (first %1) 0) %1)))) [] x)))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":79,"code":"(fn minpath [triangle]\n       (let [history (atom {})]\n       (letfn [(get-neighbours [level position]\n                  (let [ln [position (nth (nth triangle (+ level 1)) position)] \n                        rn [(+ position 1) (nth (nth triangle (+ level 1)) (+ position 1))]]\n                 (vector ln rn))  )\n                (worker [level1 position1 cost history1]\n                        (if (> (- (count triangle) 1) level1)\n                            (let [newnodes (get-neighbours  level1 position1)]\n                                 (worker (+ level1 1) (get-in newnodes [0 0]) (+ cost (get-in newnodes [0 1])) (conj history1 (get-in newnodes [0])))\n                                 (worker (+ level1 1) (get-in newnodes [1 0]) (+ cost (get-in newnodes [1 1])) (conj history1 (get-in newnodes [1])))) \n                                 (swap! history assoc cost history1))) \n                                 ;; into history map cost -> history\n                ]\n                 (worker 0 0 (nth (nth triangle 0) 0) [(nth triangle 0)])\n                 (apply min (keys @history))\n                 )))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"problem":79,"code":"(fn tri-min-path [[head & tail]]\n\n    (letfn [\n\n        (mins [row]\n            (if (> (count row) 1)\n                (map min row (drop 1 row))\n                (first row)))\n\n        (sums [row1 row2]\n            (map + row1 row2))]\n\n    (if tail\n        (mins (sums head (tri-min-path tail)))\n        (mins head))))","user":"54e540c1e4b024c67c0cf7f9"},{"problem":79,"code":"(fn f\n  [triangle]\n  (first (sort\n  (loop [remaining triangle\n         result []]\n    (let [current (first remaining)]\n    (if (empty? remaining)\n      result\n      (recur\n       (rest remaining)\n       (if (= (count current) 1)\n         current\n         (loop [i 0\n                r []]\n           (if (>= i (count current))\n             r\n             (recur\n              (inc i)\n              (conj r\n                (+\n                 (nth current i)\n                 (if (= i 0)\n                   (first result)\n                   (if (= i (count result))\n                     (last result)\n                     (min (nth result (dec i)) (nth result i))\n      )))))))))))))))","user":"54021f13e4b0df28a13c62cc"},{"problem":79,"code":"(fn [le-tree]\n   (letfn [(tree-min [[top bottom]]\n             (+\n              top\n              (reduce min bottom)))\n\n           (group-siblings [layer]\n             (partition 2 1 layer))\n\n           (find-children [upper lower]\n             (partition 2 2 (interleave\n                              upper\n                              (group-siblings lower))))\n\n           (reduce-children [upper lower]\n             (map\n               tree-min\n               (find-children upper lower)))\n\n           (fold [f tree]\n             (loop [[front end] ((juxt butlast last) tree)]\n               (if\n                 (empty? front)\n                 (first end)\n                 (recur\n                   (cons\n                     (butlast front)\n                     (list (f\n                            (last front)\n                            end)))))))\n\n           (reduce-tree [tree]\n             (fold\n               (fn [a b]\n                 (reduce-children a b))\n               tree))]\n     (reduce-tree le-tree)))","user":"586a657de4b0f14aab7c88bd"},{"problem":79,"code":"(comp first (partial reduce #(mapv (fn [n p] (+ n (apply min p))) %2 (partition 2 1 %))) reverse)","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn get-max-path [colls]\n  (let [almost-flatten (fn almost-flatten  [x]\n                        (filter #(and (sequential? %) (not-any? sequential? %))\n                          (rest (tree-seq #(and (sequential? %) (some sequential? %)) seq x))))\n                              \n        make-graph (fn make-graph [colls]\n                    (reduce #(apply merge %1 (map-indexed (fn [k v]\n                                                      (let [x (* 10 (count %2))\n                                                            x+k (+ x k)\n                                                            x+k+10 (+ x+k 10)\n                                                            edges (if (= (count %2) (count colls)) #{} #{x+k+10 (inc x+k+10)})]\n                                                        (hash-map x+k \n                                                                  (hash-map :edges edges\n                                                                            :value v)))) %2)) {} colls))\n        easy-bfs (fn easy-bfs \n                  ([graph start]\n                   (almost-flatten (mapcat (partial easy-bfs graph [start]) ((graph start) :edges))))\n                  ([graph paths start ]\n                   (if (empty? ((graph start) :edges))\n                       (conj paths start)\n                       (map (partial easy-bfs graph (conj paths start)) ((graph start) :edges) ))))\n        graph (make-graph colls)\n        paths (easy-bfs graph 10)]\n  (apply + (map #((graph %) :value) (first (sort-by #(reduce (fn [x1 x2] (+ x1 ((graph x2) :value))) 0 %) paths))))))","problem":79,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn f\n  ([t] (f 0 t))\n  ([i [r & t]]\n    (+ (r i)\n       (if t\n         (min (f i t) (f (inc i) t))\n         0))))","problem":79,"user":"4db858d1535d1e037afb218c"},{"problem":79,"code":"(fn [graph]\n    (let [g (vec graph)\n          nodes\n          (->> g\n               (map #(-> % count range))\n               (map (fn [y v]\n                      (map (fn [x] [y x]) v))\n                    (range)))\n          paths\n          (loop [paths [ [[0 0]] ]\n                 ns (rest nodes)]\n            (if-not ns\n              paths\n              (recur\n               (apply concat\n                      (map (fn [path]\n                             (let [[px py] (last path)]\n                               (->> (first ns)\n                                    (map (fn [[x y]]\n                                           (when (or (= y py) (= y (inc py)))\n                                             (conj path [x y]))))\n                                    (filter identity))))\n                           paths))\n               (next ns))))]\n      (apply min\n       (map (fn [path] (apply + (map\n                                (fn [[x y]] (get (get g x) y))\n                                path)))\n            paths))))","user":"4f57c913e4b0a7574ea7183f"},{"code":"(fn [x] (apply min (reduce (comp #(map min (concat % [100000]) (concat [100000] %)) (partial map +)) [0] x)))","problem":79,"user":"51cbdee1e4b08d8387cbede1"},{"problem":79,"code":"(fn min-path [triangle]\n  (letfn [(compactor\n            [row]\n            (let [compacted (flatten (map\n                                      #(min (first %) (second %))\n                                      (partition 2 (rest (butlast row)))))]\n              (conj (vec (cons (first row) compacted)) (last row))))\n          (pathsums\n            [rowA rowB]\n            (compactor (flatten (map\n                                 #(list (+ % (first %2)) (+ % (second %2)))\n                                 rowA\n                                 (partition 2 1 rowB)))))]\n    (apply min (reduce pathsums triangle))))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn min-sum-path [t]\n        (letfn [(sub-tri [t [r i]]\n                  (vec (for [x (range (- (count t) r))]\n                         (subvec (t (+ r x)) i (+ i x 1)))))]\n          (let [t (vec t) f (get-in t [0 0])]\n            (if (empty? (rest t))\n              f\n              (+ f (min (min-sum-path (sub-tri t [1 0]))\n                        (min-sum-path (sub-tri t [1 1]))))))))","problem":79,"user":"4f031eac535dcb61093f6a67"},{"problem":79,"code":"(fn [p]\n    (let [paths (last (take (count p) (iterate \n                   (fn [a] (mapcat #(vector (conj %1 (last %1)) (conj %1 (inc (last %1))) ) a))\n                   [[0]])))]\n      \n      (->> (for [path paths] (map get p path))\n           (map (partial apply +))\n           (apply min))))","user":"4f3b5219e4b0e243712b1f2a"},{"code":"(fn compute-tree\n  [tree]\n  (let [init-root #(repeat 2 {:sum (first %) :path %})\n        get-min #(apply min-key :sum %)\n        compute-row (fn compute-row [prev curr]\n                    ; chose min and conj path to that node\n                    (map #(let [[v [p1 p2]] %\n                                best (min-key :sum p1 p2)]\n                            (assoc best \n                              :sum (+ (:sum best) v) \n                              :path (cons v (:path best))))\n                    ; align options from top with next row\n                    (partition 2\n                      (interleave \n                        curr\n                        (partition 2 1 (cons (first prev) (concat prev (list (last prev)))))))))\n        root (init-root (first tree))\n        rows (rest tree)]\n    (:sum (get-min (reduce compute-row root rows)))))","problem":79,"user":"502a5fa4e4b09e8f859a9fbd"},{"problem":79,"code":";; Dijkstra's algorithm. Probably overkill.\n\n(letfn [(rowlen [idx]\n          (first (drop-while #(<= (* % (inc %)) (* 2 idx)) (range))))\n\n        (left-child [idx]\n          (+ idx (rowlen idx)))\n\n        (right-child [idx]\n          (inc (left-child idx)))\n\n        (bottom-row [flat-triangle]\n          (let [len (count flat-triangle)]\n            (range (- len (rowlen (dec len))) len)))]\n\n  (fn triangle-minimal-path [triangle]\n    (let [triangle (vec (flatten triangle))]\n      (loop [dist (into {} (map-indexed\n                            (fn [idx v]\n                              [idx (if (zero? idx) (first triangle) Integer/MAX_VALUE)])\n                            triangle))\n             verts (set (keys dist))]\n        (if (empty? verts)\n          (apply min (map dist (bottom-row triangle)))\n          (let [u (apply min-key dist verts)\n                l (left-child u)\n                r (right-child u)]\n            (if (>= l (count triangle))\n              (recur dist (disj verts u))\n              (let [new-dist (-> dist\n                                 (update-in [l] min (+ (dist u) (triangle l)))\n                                 (update-in [r] min (+ (dist u) (triangle r))))]\n                (recur new-dist (disj verts u))))))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [coll]\n  (letfn [(min-add [v1 v2]\n                   (let [fst (+ (first v1) (first v2)) lst (+ (last v1) (last v2))]\n                   (if (< (count v2) 3) [fst lst]\n                   (concat [fst] (map + (map #(apply min %) (partition 2 1 v1)) (drop-last (rest v2))) [lst]))))]\n    (apply min (reduce min-add coll))))","problem":79,"user":"51780f88e4b03d69594194c9"},{"problem":79,"code":"(fn shortest-path [triangle]\n  (let [expand-row (fn [numbers]\n                     (let [first-element (first numbers)\n                           last-element (last numbers)]\n                       (concat [[first-element]]\n                               (partition 2 1 numbers)\n                               [[last-element]])))\n        combine-rows (fn [row-1 row-2]\n                       (let [expanded-row-1 (expand-row row-1)]\n                         (map (fn [possible-values fixed-value]\n                                (->> possible-values\n                                     (map #(+ % fixed-value))\n                                     (apply min)))\n                              expanded-row-1\n                              row-2)))]\n    (->> triangle\n         (reduce combine-rows)\n         (apply min))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn [triangle] (apply min (first\n               (reduce (fn [path row]\n                         (map-indexed #(map (partial + %2) (concat (nth path %1) (nth path (inc %1)))) row)) \n                       (repeat ((comp inc count) (last triangle)) [0]) \n                       (reverse triangle)))))","problem":79,"user":"5244a10de4b0d8acf9ed6ab3"},{"problem":79,"code":"(fn [t]\n  (let [m (fn [i b t] (+ (nth t i) (min (nth b i) (nth b (inc i)))))]\n    (loop [p (last t)\n           c (butlast t)]\n      (if (empty? c)\n        (first p)\n        (recur (map #(m % p (last c)) (range (dec (count p)))) (butlast c))))))","user":"55205564e4b08d5046aa8a60"},{"problem":79,"code":"(fn triangle-path ([triangle] (triangle-path triangle 0 0))\n  ([triangle depth col]\n    (let [max-depth (dec (count triangle))\n          path-elt (nth (nth triangle depth) col)]\n      (if (= depth max-depth)\n        path-elt \n        (let [leftpath (triangle-path triangle (inc depth) col)\n              rightpath (triangle-path triangle (inc depth) (inc col))\n              minpath (min leftpath rightpath)]\n          (+ path-elt  minpath))))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":79,"code":"(fn [t]\n   (let [min-step (fn [s] (map (partial apply min) (partition 2 1 s)))]\n     (first\n       (reduce\n         #(map + (min-step %1) %2)\n         (reverse t)))))","user":"4f05ea25535dcb61093f6c02"},{"problem":79,"code":"(fn step\n  ([pyramid]\n   (step pyramid 0 0))\n  ([[f & r] n i]\n   (let [value\n         (f i)\n         \n         new-n\n         (+ n value)]\n     \n     (if (empty? r)\n       new-n\n       (min (step r new-n i) (step r new-n (inc i)))))))","user":"5b759ca8e4b047b03b2036d0"},{"code":"(fn fx\n  ([t] (fx t 0))\n  ([t i]\n     (cond\n       (seq t) (+ ((first t) i)\n                  (min (fx (rest t) i)\n                       (fx (rest t) (inc i))))\n       :else 0)))","problem":79,"user":"4f40ccd9e4b0e243712b1fc0"},{"code":"(fn path\n  ([rows] (+ (ffirst rows)\n             (path (next rows) 0)))\n  ([rows i]\n    (if (seq rows)\n      (apply min (for [i [i (inc i)]]\n                   (+ (nth (first rows) i)\n                      (path (next rows) i))))\n      0)))","problem":79,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn [s]\r\n  (apply min\r\n    (reduce #(map + %2\r\n                   (map min (concat % [99]) (concat [99] %)))\r\n    s)))","problem":79,"user":"4deff9f9535d08e6dec9fe15"},{"problem":79,"code":"(fn [rows]\n    (let [indexed (mapv (partial mapv vector (range)) rows)\n          paths (reduce (fn [acc row]\n                          (mapcat (fn [path]\n                                    (let [[i v] (last path)]\n                                      [(conj path (get row i))\n                                       (conj path (get row (inc i)))]))\n                                  acc))\n                        [(first indexed)]\n                        (rest indexed))]\n      (->> (map (partial map second) paths)\n           (map (partial apply +))\n           (apply min))))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn min-path [triangle]\n  (letfn [(extend-paths [paths line]\n            (reduce (fn [epaths [p index]]\n                      (into epaths\n                            [[(conj p (line index)) index]\n                             [(conj p (line (inc index))) (inc index)]]))\n                    [] paths))]\n    (->> (rest triangle)\n         (reduce extend-paths [[(first triangle) 0]])\n         (map first)\n         (map #(apply + %))\n         (apply min))))","problem":79,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":79,"code":"(fn triangle-min-path [t]\n\t(reduce min\n\t\t(reduce (fn [prev cur]\n\t\t\t\t\t(map \n\t\t\t\t\t\t(fn [[a b] c] (+ c (min a b))) \n\t\t\t\t\t\t(partition 2 1 (concat [10000] prev [10000])) \n\t\t\t\t\t\tcur))\n\t\t\t\t(first t)\n\t\t\t\t(rest t))))","user":"54448e84e4b032a45b869393"},{"problem":79,"code":"(fn minpath [tri & reversed]\n  (if reversed\n    (if \n      (> (count tri) 1)\n      (minpath (conj\n        (rest (rest tri))\n        (\n          map-indexed \n          #(+ %2 (min ((vec (first tri)) %1) ((vec (first tri)) (inc %1)) ) )\n          (first (rest tri)) \n        )\n      ) true)\n      (first (first tri))\n    )\n    (minpath (reverse tri) true)\n  )\n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"problem":79,"code":"(fn triangle-minimal-path [rows]\n    (let\n      [\n        hash-map-with-keys\n        (fn [keys default-value]\n          (apply hash-map\n            (mapcat\n              (fn [k]\n                [k default-value]\n              )\n              keys\n            )\n          )\n        )\n\n        key-with-smallest-value\n        (fn [distances]\n          (key\n            (apply min-key\n              val\n              distances\n            )\n          )\n        )\n\n        bottom-row-index (dec (count rows))\n\n        get-neighbors\n        (fn [[x y]]\n          (if\n            (>= y bottom-row-index)\n            []\n            [\n              [x (inc y)]\n              [(inc x) (inc y)]\n            ]\n          )\n        )\n\n        value-at\n        (fn [[x y]]\n          (nth\n            (nth rows y)\n            x\n          )\n        )\n\n        coordinates\n        (set\n          (mapcat\n            (fn [row y]\n              (map\n                (fn [x]\n                  [x y]\n                )\n                (range (count row))\n              )\n            )\n            rows (range)\n          )\n        )\n\n        handle-neighbors\n        (fn [u distances previous-nodes]\n          (let\n            [\n              neighbors (get-neighbors u)\n              distance-u (get distances u)\n            ]\n            (loop\n              [\n                neighbors neighbors\n                distances distances\n                previous-nodes previous-nodes\n              ]\n              (if (empty? neighbors)\n                [distances previous-nodes]\n                (let\n                  [\n                    neighbor (first neighbors)\n                    neighbors' (rest neighbors)\n\n                    distance-u->neighbor (value-at neighbor)\n\n                    alternative-distance\n                    (+ distance-u distance-u->neighbor)\n\n                    distance-neighbor (get distances neighbor)\n                  ]\n                  (if\n                    (< alternative-distance distance-neighbor)\n                    (recur\n                      neighbors'\n                      (assoc distances neighbor alternative-distance)\n                      (assoc previous-nodes neighbor u)\n                    )\n                    (recur neighbors' distances previous-nodes)\n                  )\n                )\n              )\n            )\n          )\n        )\n\n        first-coordinate [0 0]\n\n        initial-distances\n        (assoc\n          (hash-map-with-keys coordinates Integer/MAX_VALUE)\n          first-coordinate 0\n        )\n\n        initial-previous-nodes\n        (hash-map-with-keys coordinates nil)\n\n        initial-q coordinates\n\n        target-with-smallest-distance\n        (fn [distances]\n          (key\n            (apply min-key\n              val\n              (into {}\n                (filter\n                  (fn [[[x y] v]]\n                    (= y bottom-row-index)\n                  )\n                  distances\n                )\n              )\n            )\n          )\n        )\n\n        path-to\n        (fn path-to [c previous-nodes]\n          (let\n            [\n              previous (get previous-nodes c)\n            ]\n            (if (nil? previous)\n              [c]\n              (conj\n                (path-to previous previous-nodes)\n                c\n              )\n            )\n          )\n        )\n\n        path-sum\n        (fn [cs]\n          (apply +\n            (map value-at cs)\n          )\n        )\n      ]\n      (loop\n        [\n          q initial-q\n          distances initial-distances\n          previous-nodes initial-previous-nodes\n        ]\n        (if (empty? q)\n          (path-sum\n            (path-to\n              (target-with-smallest-distance distances)\n              previous-nodes\n            )\n          )\n          (let\n            [\n              distances-for-q\n              (select-keys distances q)\n\n              u (key-with-smallest-value distances-for-q)\n\n              q' (disj q u)\n\n              [distances' previous-nodes']\n              (handle-neighbors u distances previous-nodes)\n            ]\n            (recur q' distances' previous-nodes')\n          )\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn m [[[f] & r]]\n   (if f\n     (+ f (min (m (map drop-last r))\n               (m (map rest r))))\n     0))","problem":79,"user":"50acbd15e4b071b89ef26234"},{"problem":79,"code":"(fn minimal-path [tri]\n  (let [to-tree (fn to-tree [vecs i]\n                  (if (empty? vecs) ()\n                    (cons (nth (first vecs) i) (list (to-tree (rest vecs) i) (to-tree (rest vecs) (inc i))))))\n        sum-branches (fn sum-branches [tree cur-sum]\n                       (let [left (second tree)\n                             right (last tree)\n                             value (first tree)\n                             sum (+ cur-sum value)]\n                         (if (and (empty? left) (empty? right)) sum\n                           ((comp flatten concat) (list (sum-branches left sum)) (list (sum-branches right sum))))))]\n    (-> tri\n     (to-tree 0)\n     (sum-branches 0)\n     ((partial apply min)))))","user":"5396c94be4b0b51d73faaee3"},{"problem":79,"code":"(fn g [[[f] & r]]\n  (if r\n    (+ f (min (g (map butlast r)) (g (map rest r))))\n    f))","user":"53973e7be4b0b51d73faaee6"},{"problem":79,"code":"(fn triangle-minimal-path [triangle]\n  (letfn [(next-paths [paths]\n            (vec\n             (mapcat (fn [path]\n                       [(conj path (last path))\n                        (conj path (inc (last path)))])\n                     paths)))]\n   (let [paths (nth (iterate next-paths [[0]])\n                    (dec (count triangle)))\n         vals (for [path paths]\n                (map (fn [a b] (a b))\n                     triangle\n                     path))\n         sums (map (fn [xs] (reduce + xs)) vals)]\n     (apply min sums))))","user":"60460824e4b02d28681c77bc"},{"code":"#(first (reduce (fn [cur nex]\r\n          (map + (map min cur (rest cur)) nex))\r\n        (reverse %)))","problem":79,"user":"4dd4034a535dae65d5c462df"},{"code":"(fn r [a] (letfn [(x [a [h & t]] (+ (h a) (if (seq t) (min (x a t) (x (+ 1 a) t)) 0)))] (x 0 a)))","problem":79,"user":"4ede8789535d10e5ff6f5337"},{"problem":79,"code":"(fn [triangle]\n  (let [sum (fn [tree path] (apply + (map get tree path)))]\n    ((fn max-path [idx path tree] \n       ( if (>= (count path) (count tree)) \n         (sum tree path)\n         (min \n          (max-path idx (conj path idx) tree ) \n          (max-path (inc idx) (conj path idx) tree))  )) \n     0 [] triangle)))","user":"567798afe4b05957ce8c6169"},{"problem":79,"code":"(fn __\n  ([t]\n   (-> (__ (rest t) (ffirst t) 0)\n      (flatten)\n      (sort)\n      (first)))\n  ([t v i]\n   (if (> (count t) 0)\n     (let [row (first t)\n           ii (inc i)\n           rt (rest t)\n           va (+ v (nth row i))\n           vb (+ v (nth row ii))\n           x (list (__ rt va i) (__ rt vb ii))]\n       x)\n     v)))","user":"53d5a63be4b0e771c3025449"},{"code":"(fn triangle-min[graph]\n   (letfn [(calc-next-layer-len [curr-min-path-len next-layer]\n\t(let [layer-size (count next-layer) prev-layer-size (count curr-min-path-len)]\n\t\t(into [] (map \n\t\t\t\t\t(fn [idx] \n\t\t\t\t\t\t(+ (nth next-layer idx)\n\t\t\t\t\t\t\t(if (> idx 0)\n\t\t\t\t\t\t\t\t(if (< idx prev-layer-size)\n\t\t\t\t\t\t\t\t\t(min (nth curr-min-path-len (dec idx)) \n\t\t\t\t\t\t\t\t\t\t (nth curr-min-path-len idx)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t; at the end\n\t\t\t\t\t\t\t\t\t(nth curr-min-path-len (dec idx))\t\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t(nth curr-min-path-len 0)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t) \n\t\t\t\t\t(range layer-size)\n\t\t\t\t)\n\t\t)\n\t)\n)]\n\t\t(apply min (reduce calc-next-layer-len graph))\n\t)\n)","problem":79,"user":"52763696e4b03e8d9a4a74d7"},{"problem":79,"code":"(fn [triangulo]\n  (apply min (reduce\n               (fn [a b] (let [s (flatten (map (fn [x y] (map #(+ x %) y)) a (partition 2 1 b)))]\n                           (map #(apply min %) (partition 2 (concat [(first s)] s [(last s)])))))\n               triangulo)))","user":"534fa9dae4b084c2834f4acf"},{"code":"(fn myTriangleMinPath\n  [triangle]\n  (let [vecTriangle (into [] triangle)\n        pathLength (count triangle)\n        collectAllPaths (fn collectPaths [path] \n                          (if (= pathLength (count path))\n                            (conj [] (map-indexed #(get-in vecTriangle [%1 %2]) path))\n                            (let [lastP (last path)]\n                              (concat\n                                (collectPaths (conj path lastP))\n                                (collectPaths (conj path (inc lastP)))))))]\n    (apply min (map #(reduce + %) (collectAllPaths [0])))))","problem":79,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [x]\n  (first\n    (reduce\n      #(map + %2 (map min %1 (next %1)))\n      (reverse x))))","problem":79,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":79,"code":"(fn tmp [[[x] & xss]]\n  (if-not x 0\n    (+ x\n       (min (tmp xss)\n            (tmp (map rest xss))))))","user":"562cd94ee4b0a45d2ff83015"},{"problem":79,"code":"(comp {4 7 6 20} count)","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn [t] (loop [vt (vec t)\n                 dph (dec (count vt))\n                 res (vec (repeat (inc (count (last t))) 0))]\n            (let [nres (vec (map-indexed #(+ %2 (min (res %1) (res (inc %1))))\n                                         (vt dph)))]\n              (if (zero? dph) (first nres)\n                  (recur vt (dec dph) nres)))))","problem":79,"user":"4efd8b67535de96065cf5085"},{"code":"(fn triangle-minimal-path [triangle] \n  (letfn [(indexed [s] (map vector (iterate inc 0) s))\n          (next-min-sums [min-sums ints]\n            (let [n (count ints) \n                  min-sum (fn [[i e]] (+ e (cond (zero? i) (min-sums 0) (= i (dec n)) (min-sums (- n 2))\n                                          :else (min (min-sums (dec i)) (min-sums i)))))]\n              (->> (indexed ints) (map min-sum) vec)))]\n    (apply min (reduce next-min-sums triangle))))","problem":79,"user":"51729002e4b044b2ef48a850"},{"problem":79,"code":"(fn [triangle]\n  (->> (reduce\n        (fn [result level]\n          (mapcat\n           identity\n           (for [item result]\n             [{:idx (:idx item)\n               :data (conj (:data item) (nth level (:idx item)))}\n              {:idx (inc (:idx item))\n               :data (conj (:data item) (nth level (inc (:idx item))))}])))\n        [{:idx 0 :data (first triangle)}]\n        (rest triangle))\n       (map #(apply + (:data %)))\n       (apply min)))","user":"5cbb0436e4b026601754b9cc"},{"problem":79,"code":"(fn min-path2 [triangle]\n  (->>\n    (reduce (fn [acc line]\n              (map + line\n                   (cons (first acc) (map #(apply min %) (partition-all 2 1 acc)))))\n            (first triangle) (rest triangle))\n    (apply min)))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn [t]\n  ((fn self [i j]\n    (if (= i (dec (count t)))\n      (-> t (nth i) (nth j))\n      (let [v   (-> t (nth i) (nth j))\n            op1 (self (inc i) j)\n            op2 (self (inc i) (inc j))]\n        (min (+ v op1) (+ v op2))))) 0 0))","problem":79,"user":"524b90fae4b09eba1c0223df"},{"problem":79,"code":"(fn minitria [xss]\n   (letfn [\n           \n          (mini2 [xs ys]  ;xs shorter \n  (let [x1 (first xs) y1 (first ys) y2 (second ys) ]\n   (if x1\n      ( cons (min (+ x1 y1 ) (+ x1 y2) )  (mini2 (rest xs) (rest ys)))\n      ()\n     )\n  \n)\n  )\n \n           \n           ]\n   (let [rv (reverse xss)]\n   (first  (reduce #(mini2 %2 %1) rv) )\n     )\n  )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn tmp [xs]\n  ((fn ! [last-item second-last remains]\n     (if\n       (empty? second-last) (first last-item)\n       (let [min-cost (map #(apply min %) (partition 2 1 last-item))\n             next-last (map + min-cost second-last)]\n         (recur next-last (last remains) (drop-last remains)))))\n   (last xs) (last (drop-last xs)) (drop-last 2 xs)))","problem":79,"user":"501c1492e4b086d93747d180"},{"problem":79,"code":"(fn tmp [v]\n   (letfn [(fold [[h & t]]\n               (if (seq t)\n                  (concat (fold (conj (next t) (map + (butlast h) (first t))))\n                          (fold (conj (next t) (map + (rest h) (first t)))))\n                  h))]\n      (apply min (fold (reverse v)))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [t]\n\t(apply min (reduce\n          \t   (fn [a b] (mapv #(+ %2 (apply min %)) (partition 2 1 [] (into [(a 0)] a)) b))\n          \t   t)))","problem":79,"user":"514d8084e4b019235f6c0588"},{"code":"(fn min-tri-path [t]\n  (first (reduce (fn [a s] (map + s (map #(apply min %) (partition 2 1 a))))\n            (reverse t))))","problem":79,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn trpath\n         ([triangle] (trpath (vec triangle) 0))\n         ([triangle n]\n            (if (empty? triangle) 0\n                (+ (get-in triangle [0 n]) \n                   (min (trpath (vec (rest triangle)) n)\n                        (trpath (vec (rest triangle)) (inc n)))))))","problem":79,"user":"5294e44de4b02ebb4ef75016"},{"code":"(fn [triangle]\n  (let [\n        triangleNext (fn [vectorCoord]\n  (if (<= (count vectorCoord) 1) nil\n    (loop [coord vectorCoord\n           pos (dec (count vectorCoord))]\n      (let [b (nth coord pos)\n            a (nth coord (dec pos))]\n        (if (= a b)\n          (vec (assoc coord pos (inc b)) )\n          (if (<= pos 1)\n            nil\n            (recur\n               coord\n               (dec pos))\n            )\n          )\n        )\n      )\n    ))\n        triangleCoordsSeq (fn [coord]\n                            (take-while (complement nil?) (iterate triangleNext coord))\n                            )\n        triangleValues (fn [triangle coord]\n                         (let [sz (count triangle)]\n                           (loop [pos 0 acc []]\n                             (if (>= pos sz)\n                               acc\n                               (recur (inc pos) (conj acc (nth (nth triangle pos) (nth coord pos))))\n                               )\n                             )\n                           )\n                         )\n        initCoord (vec (take (count triangle) (repeat 0)))\n        triseq (triangleCoordsSeq initCoord)\n        trivals (map (partial triangleValues triangle) triseq)\n        pathCosts (map (partial reduce +) trivals)\n\n        ]\n    (apply min pathCosts)\n    )\n  )","problem":79,"user":"52d8e23ae4b09f7907dd139b"},{"problem":79,"code":"(fn __ [tri]\n  (first (reduce\n          (fn [aggr row]\n            (map\n             #(+ %1 (apply min %2))\n             row (partition 2 1 aggr)))\n          (reverse tri))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":79,"code":"(fn f [t]\n  (letfn [(go-left [t]\n                   (map #(drop-last %) (rest t)))\n          (go-right [t]\n                    (map #(rest %) (rest t)))]\n    (if (seq (rest t))\n      (+ (first (first t)) (min (f (go-left t)) (f (go-right t))))\n      (first (first t)))))","user":"5799ff45e4b05b1deef9add1"},{"problem":79,"code":"(fn [tree]\n   (let [depth (dec (count tree))\n         rtree (reverse tree)\n         br (fn [[& xs]]\n              (for [x xs\n                    f [#(conj % (first %))\n                       #(conj % (inc (first %)))]]\n                (f x)))]\n     (apply min (for [idx (nth (iterate br '((0))) depth)]\n        (apply + (mapv #(get %1 %2) rtree idx))\n        ))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":79,"code":"(fn minimal-path [t]\n  (first (reduce\n          (fn [r i]\n            (map + i (for [e (partition 2 1 r)]\n                       (apply min e))))\n          (reverse t))))","user":"5492164ee4b0b312c081ff3e"},{"code":"(fn [s]\n  (letfn [\n    (f [ofs s]\n      (if (empty? s) 0\n        (+ \n          (nth (first s) ofs)\n          (min \n            (f ofs (rest s))\n            (f (inc ofs) (rest s))))))]\n  (f 0 s)))","problem":79,"user":"4f569218e4b0a7574ea71826"},{"problem":79,"code":"(fn [colls]\n  (loop [res-seq [[0 (first (first colls))]]\n         rest-colls (rest colls)]\n    (if (empty? rest-colls)\n      (apply min (map #(second %) res-seq))\n      (recur (apply concat (map (fn [rec]\n                                  (let [no (first rec)\n                                        s (second rec)\n                                        coll (first rest-colls)]\n                                    [[no (+ s (nth coll no))]\n                                     [(inc no) (+ s (nth coll (inc no)))]]))\n                                res-seq))\n             (rest rest-colls)))))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn __\n  [t]\n  (letfn [(neighbors\n            ([g n] (get g n {}))\n            ([g n uv] (select-keys (neighbors g n) uv)))\n\n          (update-costs\n            [g costs curr unvisited]\n            (let [curr-cost (costs curr)]\n              (reduce\n                (fn [c [nbr nbr-cost]] (update-in c [nbr] (partial min (+ curr-cost nbr-cost))))\n                costs\n                (neighbors g curr unvisited))))\n\n          (dijkstra\n            [g src & {:keys [target]}]\n            (loop [costs (assoc (zipmap (keys g) (repeat Integer/MAX_VALUE)) src 0)\n                   curr src\n                   unvisited (disj (apply hash-set (keys g)) src)]\n              (if (or (empty? unvisited) (= Integer/MAX_VALUE (costs curr)))\n                costs\n                (let [costs' (update-costs g costs curr unvisited)\n                      curr' (first (sort-by costs' unvisited))]\n                  (if (= target curr')\n                    (costs' target)\n                    (recur costs'\n                           curr'\n                           (disj unvisited curr')))))))]\n\n    (let [h (first (first t))\n          m (apply merge\n                   (mapcat (fn [[i r]]\n                              (map (fn [[j c]]\n                                     {[i j] c}) (map-indexed vector r))) (map-indexed vector t)))\n          graph (reduce (fn [res [[i j] v]]\n                          (let [l [(inc i) j]\n                                r [(inc i) (inc j)]]\n                            (if (nil? (m l))\n                              (assoc res [i j] {})\n                              (assoc res [i j] {l (m l) r (m r)}))))\n                        {} m)\n          last-row (map (fn [e] [(dec (count t)) e]) (range (count (last t))))]\n    \n      (+ h\n         (apply min\n                (map (fn [target-vertex]\n                       (dijkstra graph [0 0] :target target-vertex))\n                     last-row)))\n    )))","problem":79,"user":"5348cab4e4b084c2834f4a5e"},{"problem":79,"code":"(fn min-tri-path [rows]\n  (apply min\n         (reduce\n           (fn [min-sums row]\n             (vec (map-indexed\n                    (fn [i n]\n                      (+ n (apply min (remove nil? [(get min-sums (dec i)) (get min-sums i)]))))\n                    row)))\n           (first rows)\n           (rest rows))))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn [rows]\n   (let [rows (reverse rows)]\n     (apply min\n       (flatten\n         (reduce\n           (fn [sums row]\n             (let [pairsums (map (partial apply concat) (partition 2 1 sums))]\n               (map\n                 (fn [pairsum value]\n\n                   (map (partial + value) pairsum))\n                 pairsums\n                 row)))\n           (map vector (first rows))\n           (drop 1 rows)\n\n           )))))","problem":79,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":79,"code":"(fn [triangle]\n    (letfn [(min-path [i trapezoid]\n                (let [n (nth (first trapezoid) i)\n                      trapezoid' (rest trapezoid)]\n                    (if (empty? trapezoid')\n                        n\n                        (+ n (min (min-path i trapezoid') (min-path (inc i) trapezoid'))))))]\n        (min-path 0 triangle)))","user":"600ae927e4b074f607df6689"},{"problem":79,"code":"(fn min-triangle [rows]\n   (letfn [(walk [[row & rows] path index]\n             (if (nil? row) \n               (apply + path)\n               (min (walk rows (conj path (nth row index)) index)\n                    (walk rows (conj path (nth row index)) (inc index)))))]\n     (walk rows [] 0)))","user":"5eee7311e4b07c55ae4a0510"},{"problem":79,"code":"(fn [coll]\n  (cond\n   (= (first coll) [1]) 7\n   :else 20))","user":"5374adc3e4b06d7f452d9e27"},{"code":"(fn mintrianglesum [q]\n        (let [v (vec q)\n              f (fn [x p]\n                  (let [w (vec p)]\n                   (+ (first (first w)) (apply + (map-indexed #(get (get w (+ 1 %1)) %2) x)))))\n              g (fn [z]\n                  (vec (map #(Integer/parseInt (str %)) z)))\n              h (fn [n]\n                  (map #(str (apply str (repeat (- (- n 1) (count %)) 0)) %) (map #(Integer/toString % 2) (range (Math/pow 2 (- n 1))))))\n              ]\n        (apply min (map #(f % v) (map (fn [y]\n                                   (loop [counter 1, result y]\n          (if (< counter (count y))\n            (if (= (get result counter) 0)\n              (recur (inc counter) (assoc result counter (get result (- counter 1))))\n              (recur (inc counter) (assoc result counter (inc (get result (- counter 1))))))\n            result)))\n                             (vec (map g (map vec (h (count v))))))))))","problem":79,"user":"532727bae4b09d4e7a9b54fa"},{"problem":79,"code":"(fn [data]\n  (loop [data (reverse data)]\n    (cond\n      (= 1 (count data)) (ffirst data)\n      :else\n      (let [new-row ((fn\n    \t\t\t\t  [row prev-row]\n  \t\t\t\t\t\t(vec (for [x (range (count row))]\n         \t\t\t\t\t(+\n           \t\t\t\t\t\t(get row x)\n           \t\t\t\t\t\t(min (get prev-row x)\n                \t\t\t(get prev-row (inc x)))))))\n                     (second data) (first data))]\n        (recur (conj (drop 2 data) new-row)))))\n)","user":"53bc10f5e4b047364c04450d"},{"code":"#(\r\n  (fn w [r c t]\r\n    (if (< r (count t))\r\n      (+ \r\n        (nth (nth t r) c)\r\n        (min \r\n          (w (+ 1 r) c t)\r\n          (w (+ 1 r) (+ 1 c) t)))\r\n        0))\r\n  0 0 %)","problem":79,"user":"4e03c616535d04ed9115e796"},{"problem":79,"code":"(fn triangle-min [triangle]\n  (let [triangle (apply vector triangle)\n        gen-path (fn gen-path [row column triangle]\n                   (let [value (get-in triangle [row column])]\n                     (if (= (inc row) (count triangle))\n                       [[value]]\n                       (map #(conj % value)\n                            (into (gen-path (inc row) column triangle)\n                                  (gen-path (inc row) (inc column) triangle))))))]\n    (->> (gen-path 0 0 triangle)\n         (map #(apply + %))\n         sort\n         first)))","user":"58fed70de4b0438e51c2cfdd"},{"problem":79,"code":"(fn [coll]\n  (letfn [(min-add [bc lc]\n                   (->> (partition 2 1 bc)\n                        (map #(apply min %))\n                        (map + lc)))]\n    (first (reduce min-add (reverse coll)))))","user":"54848141e4b0e286459a119e"},{"problem":79,"code":"(fn min-path ([board] (min-path 0 0 board))\n  ([row col board]\n   (if (= row (dec (count board)))\n     ((nth board row) col)\n     (+ ((nth board row) col)\n        (min (min-path (inc row) col board)\n             (min-path (inc row) (inc col) board))))))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn [t]\n  (first\n    (reduce \n      (fn [s p]\n        (map\n          #(+ %1 (min %2 %3)) \n         p s (next s))) \n      (reverse t))))","problem":79,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [triangle]\n  (letfn [(dist-map [prev-dist-map row]\n            (loop [k 1 m {0 (map #(+ (first row) %) (prev-dist-map 0))}]\n              (if (< k (dec (count row)))\n                (let [n (nth row k)\n                      d1 (map #(+ n %) (prev-dist-map (dec k)))\n                      d2 (map #(+ n %) (prev-dist-map k))]\n                  (recur (inc k) (assoc m k (concat d1 d2))))\n                (assoc m k (map #(+ (nth row k) %) (prev-dist-map (dec k)))))))]\n    (apply min (flatten (vals (reduce dist-map {0 (first triangle)} (rest triangle)))))))","problem":79,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn [t]\r\n  (first\r\n    (reduce \r\n      (fn [s p]\r\n        (map\r\n          #(+ %1 (min %2 %3)) \r\n         p s (next s))) \r\n      (reverse t))))","problem":79,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":79,"code":"(fn [tri]\n  (let [len (count tri)]\n    ((fn nxtlvl [level place n]\n       (if (= len (inc level))\n         n\n         (min\n          (nxtlvl\n           (inc level)\n           place\n           (+ n (get (nth tri (inc level)) place)))\n          (nxtlvl\n           (inc level)\n           (inc place)\n           (+ n (get (nth tri (inc level)) (inc place)))))))\n     0 0 (ffirst tri))))","user":"5705e404e4b0b0fb43fd0676"},{"problem":79,"code":"(fn minPathWeight [nodes]\n  (letfn [\n           (parentWeights [idx parents]\n                          (vec (filter (complement nil?) [(get parents (dec idx)) (get parents idx)])))\n           (weights [prev, nodesList]\n                    (vec (map-indexed (fn [idx w] (+ w (apply min (parentWeights idx prev)))) nodesList)))\n           (lastweigts [tree]\n                       (reduce weights [0] tree))]\n    (apply min (lastweigts nodes))))","user":"52570aeae4b0541d1855ba42"},{"problem":79,"code":"(fn collapse\n  [p]\n  (let [combine (fn [a b]\n                (map + (map #(apply min %) (partition 2 1 a)) b))]\n    (first (reduce combine (reverse p))))\n  )","user":"5cd4e1b2e4b0ccb061962927"},{"problem":79,"code":"(fn t [trn]\n   (apply min (reduce (fn [prev cur]\n                  (map-indexed (fn [idx elem] \n                                 (cond \n                                   (zero? idx) (+ elem (first prev))\n                                   (= (count cur) (inc idx )) (+ elem (last prev))\n                                   :else \n                                   (+ elem (min (nth prev (dec idx)) (nth prev idx))\n                                      )))\n                               cur))\n                (first trn) (rest trn))))","user":"5e44c804e4b01d43a70e8e89"},{"problem":79,"code":"(fn [tr]\n        (let [calc-row (fn [cr row]\n                         (vec (concat [(+ (first row) (first cr))]\n                                      (map #(+ (row %) (min (cr (dec %))\n                                                            (cr %)))\n                                           (range 1 (dec (count row))))\n                                      [(+ (last row) (last cr))])))]\n          (loop [cr (first tr) rows (rest tr)]\n            (if (empty? rows)\n              (apply min cr)\n              (let [nr (calc-row cr (first rows))\n                    _ (prn nr)]\n                (recur nr (rest rows)))))))","user":"546c4377e4b00cfc9eacc177"},{"problem":79,"code":"(fn [ts]\n  (letfn [(bp [ps rows n]\n            (if (seq rows)\n              (concat (bp (conj ps (nth (first rows) n))\n                          (rest rows) n)\n                      (bp (conj ps (nth (first rows) (inc n)))\n                          (rest rows) (inc n)))\n              [ps]))]\n    (apply min (map #(apply + %) (bp [(ffirst ts)] (rest ts) 0)))))","user":"55201d18e4b08d5046aa8a5d"},{"problem":79,"code":"(fn t132 [triangle]\n  (let [ update (fn [ans pos row]\n                  [[(conj ans (nth row pos)) pos]\n                   [(conj ans (nth row (+ 1 pos))) (+ 1 pos)]])]\n  (loop [ answers [ [ (first triangle) 0 ] ] current (rest triangle) ]\n    (if (empty? current) \n      (apply + (first (sort #(compare (apply + %1) (apply + %2)) (map first answers))))\n      (let [new_answers (for [ans answers]\n                          (update (first ans) (second ans) (first current)))]\n        (recur (apply concat new_answers) (rest current)))))))","user":"5046f909e4b03b02161376b5"},{"problem":79,"code":"(fn [t-r]\n  (letfn [(p-1-2 [r1 r2 lst]\n            (reduce (fn [l i]\n                      (cons [(nth r1 i) (nth r2 (inc i))]\n                            (cons [(nth r1 i) (nth r2 i)] l)))\n                    lst\n                    (range (count r1))))\n          (p-a [& r]\n            (loop [l () [r1 & ro] r]\n              (cond (empty? ro) l :else (recur (p-1-2 r1 (first ro) l) ro))))\n          (lvs [ & r]\n            (let [lv (map (partial * 2) (range 1 (count r)))\n                  pths (reverse (apply p-a r))]\n              (loop [res [] pths pths lv lv]\n                (if (empty? lv)\n                  res\n                  (recur (conj res (take (first lv) pths))\n                         (drop (first lv) pths) (rest lv))))))\n          (asm [& r]\n            (let [[base & rst :as levels] (reverse (apply lvs r))\n                  cnt (count levels)]\n              (if (= cnt 1)\n                (first levels)\n                (loop [res base rst rst]\n                  (cond\n                   (empty? rst) res\n                   :else (recur\n                          (map\n                           (fn [it]\n                             (cons (apply min (map first (filter\n                                                  (fn [i] (= (last i) (first it)))\n                                                  (first rst))))\n                                   it)) res) (rest rst)))))))]\n\n\n    (->> (apply asm t-r)\n            (map (partial reduce +))\n            (apply min))))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn [col]\n(first\n(reduce #(map +\n(map min (butlast %1)\n(rest %1 ))\n%2)\n(reverse col))))","problem":79,"user":"5132c6f0e4b021281ec7b6d3"},{"problem":79,"code":"(fn triangle-min-path-sum [vectors] \n  (letfn[(combine [a b] \n           (map + (map #(apply min %) (partition 2 1 a)) b))]\n    (first (reduce combine (reverse vectors)))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn triangle [t]\n  (let [solution  (reduce \n                  (fn [sol row]\n                  (conj sol (vec \n                  (for [i (range (count row))]\n                  (if-let [h (first sol)]\n                  (+ (row i) (min (h i) (h (inc i))))\n                  (row i))))))\n                  '() (reverse t))]\n   (first (first solution))))","problem":79,"user":"4eb0a757535d7eef3080733d"},{"problem":79,"code":"(partial (fn mp [c T]\n    (if (empty? T) 0\n        (+ ((first T) c) (min (mp c (rest T)) (mp (inc c) (rest T))))))\n        0)","user":"559c13c5e4b066d22e731f61"},{"problem":79,"code":"#(if (>(count %) 4) 20 7)","user":"5c683fb5e4b0fca0c16226d5"},{"problem":79,"code":"(fn [tri]\n  (first\n    (reduce\n      (fn [sum row]\n        (map-indexed\n          (fn [i v]\n            (+ v (min (nth sum i) (nth sum (inc i)))))\n          row))\n      (reverse tri))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn m [[[r] & t]]\n  (if (nil? r) 0\n      (+ r (min\n            (m (map rest t))\n            (m (map butlast t))))))","problem":79,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn p79\n  ([rows] (p79 rows 0))\n\t([[row & rows] start-pos]\n\t\t(let [rowval (nth row start-pos)]\n\t\t\t(if rows\n\t\t\t\t(->> [start-pos (inc start-pos)]\n\t\t\t\t\t (map (partial p79 rows))\n\t\t\t\t\t (apply min)\n\t\t\t\t\t (+ rowval))\n\t\t\t\trowval))))","problem":79,"user":"4f7f0827e4b06e829148e1d5"},{"problem":79,"code":"(fn [nums]\n  (let [red (fn [a c]\n              (let [s (map + a c)\n                    p (partition 2 1 s)\n                    m (map (partial apply min) p)]\n                (if (= 1 (count s)) (first s) m)))]\n    (reduce red (repeat 0) (reverse nums))))","user":"4f037faf535dcb61093f6af8"},{"problem":79,"code":"(fn z[x] \n  (let [ a ((fn path[lvl ind] \n    (if (= (count x) (+ lvl 1) )\n                  [[ (nth (nth x lvl) ind) ]]\n                  (concat \n                  (for [ i (path (+ lvl 1) ind)]  (conj i (nth (nth x lvl) ind)))\n                  (for [ i (path (+ lvl 1) (+ ind 1))]  (conj i (nth (nth x lvl) ind)))\n                  )\n    )\n  ) 0 0)] \n  (apply min (map #(apply + %) a))\n)\n)","user":"5b3aa98be4b02d533a91bbca"},{"problem":79,"code":"(fn minpath \n  ([t] (minpath 0 t))\n  ([i t]\n    (if-not t\n        0\n        (let [[this-row & next-rows] t\n              el (nth this-row i)\n              p1 (minpath i next-rows)\n              p2 (minpath (inc i) next-rows)]\n          (+ el (min p1 p2))))))","user":"54cc313de4b057c6fda3a28b"},{"problem":79,"code":"(fn [tree]\n     (letfn [(sub-paths [subtree col parent-path] ;subtree is a (take N tree); col is a 0-based index in the first row\n               (let [entry ((first subtree) col)\n                     my-path (conj parent-path entry)]\n                 \n                 (if (= (count subtree) 1)\n                   (apply + my-path)\n                   (let [sub-subtree (rest subtree)]\n                     (min\n                       (sub-paths sub-subtree col my-path)\n                       (sub-paths sub-subtree (inc col) my-path))))))]\n       \n       (sub-paths tree 0 [])))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":79,"code":"(fn trikotnik [trikot]\n  (letfn [\n  (naslednja-pot-trikot [x]\n   (let [sekv (partition-by identity x)]\n    (if (= (count (last sekv)) 1)\n      (vec (flatten (conj (vec (drop-last sekv)) (- (first (last sekv)) 1))));; zadnji se zmanjsa za ena\n      (vec (flatten (conj (vec (drop-last sekv)) (take (count (last sekv)) (iterate inc (dec (first (last sekv)))))  )))\n    )))\n (vse-poti [n]\n  (take (Math/pow 2 (dec n)) (iterate naslednja-pot-trikot (vec (range n)))))\n (ena-vsota-trikot [trikot pot]\n  (apply + (map nth trikot pot)))]\n;; sedaj pa izracunam najlazjo pot\n  (apply min (map #(ena-vsota-trikot trikot %) (vse-poti (count trikot))))\n))","user":"584d99c5e4b0b7285a6f4e42"},{"code":"(fn [g]\n  (apply \n    min\n    (reduce\n      (fn [v w]\n        (map\n          (fn [x y z] (if (nil? y) (+ x z) (if (nil? z) (+ x y) (min (+ x y) (+ x z)))))\n          w\n          (concat v [nil])\n          (concat [nil] v))) g)))","problem":79,"user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn [x] \n  ((fn r [i y] \n     (if (empty? y) \n       0 \n       (+ (nth (first y) i) (min (r i (rest y)) (r (inc i) (rest y)))))) \n   0 x))","problem":79,"user":"513b77f3e4b00f740c76c403"},{"problem":79,"code":"(fn [col]\n  (first \n     (reduce #(map + (map min (butlast %1) (rest %1)) %2)\n             (reverse col))))","user":"54e5bdf2e4b024c67c0cf7fe"},{"code":"(fn expand [l]\n  \t\"This actually finds the path because I midread the problem\"\n  (letfn [(calc-join [v]\n            (concat [[(first v)]] (partition 2 1 v) [[(last v)]]))\n          (expand-paths [v1 v2]\n            (map (fn [xs x] (first (sort-by #(apply + %) (map #(conj % x) xs))))\n                 (calc-join v1) v2))]\n    (apply + (first (sort-by #(apply + %) (reduce expand-paths [[]] l))))))","problem":79,"user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn [l]\n  (apply min\n         (reduce #(vec (for [i (range (count %2))]\n                         (cond (= i 0) (+ (% 0) (%2 0))\n                               (= i (dec (count %2))) (+ (% (dec i)) (%2 i))\n                               :else (+ (%2 i) (min (% (dec i)) (% i))))))\n                 (first l)\n                 (rest l))))","problem":79,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [triangle] \n  (first (reduce (fn [lower-row higher-row]\n          (map\n            (fn [i]\n              (let [higher-item (nth higher-row i)\n                    lower-item1 (nth lower-row i)\n                    lower-item2 (nth lower-row (+ i 1))]\n                (if (< lower-item1 lower-item2)\n                  (+ lower-item1 higher-item)\n                  (+ lower-item2 higher-item))))\n            (range (count higher-row))))\n        (reverse triangle))))","problem":79,"user":"52a55adee4b0c58976d9abe7"},{"code":"(fn [g] \n  (apply min\n  (reduce \n    (fn [a b] \n        (map + \n          (map #(apply min %)\n            (partition 2 1 (concat [(first a)] a [(last a)])))\n          b))\n    g)))","problem":79,"user":"528652fbe4b0239c8a67ae14"},{"problem":79,"code":"(fn path-sum\n  ([triangle]\n   (path-sum triangle 0))\n\n  ([triangle root]\n   (when-let [[f & remain] (seq triangle)]\n     (if remain\n       (let [[l r]    [root (inc root)]\n             root-val (get f root)\n             left     (path-sum remain l)\n             right    (path-sum remain r)]\n         (min (+ root-val left)\n              (+ root-val right)))\n       (get f root)))))","user":"5cf1d9e3e4b0aaa82f112a18"},{"code":"(fn [triangle]\n  (let [directions (nth (iterate (fn [s] (mapcat #(list (conj %1 0) (conj %1 1)) s)) [[0]])\n                        (count triangle))\n        paths (map (partial reductions +) directions)]\n    (reduce min (for [path paths] \n                 (reduce + (map get triangle path))))))","problem":79,"user":"5329cee2e4b09d4e7a9b551a"},{"code":"(fn [triangle]\r\n  (let [mkpaths (fn mkpaths [triangle vert tpath]\r\n\t\t(if (nil? (get-in triangle [(+ (first vert) 1) (last vert)]))\r\n\t\t\t[(conj tpath (get-in triangle vert))]\r\n\t\t\t(concat (mkpaths triangle [(+ (first vert) 1) (last vert)] (conj tpath (get-in triangle vert)))\r\n\t\t\t\t\t(mkpaths triangle [(+ (first vert) 1) (+ (last vert) 1)] (conj tpath (get-in triangle vert))))\r\n\t\t))]\r\n\t\t(first (sort (map #(apply + %) (mkpaths (vec triangle) [0 0] []))))\r\n\t)\r\n)","problem":79,"user":"504e685fe4b0f6ff3350c4ae"},{"code":"(fn [t]\n   (letfn [(min-path-sum [r i]\n             (if (>= r (count t))\n               0\n               (+ (nth (nth t r) i)\n                  (min\n                   (min-path-sum (inc r) i)\n                   (min-path-sum (inc r) (inc i))))))]\n     (min-path-sum 0 0)))","problem":79,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":79,"code":"(fn [xs]\n  (letfn [(comb [[fi & nxt]]\n            (if nxt\n              (let [r (comb nxt)]      \n                (map (fn [el a b] (concat  (map #(cons el %) a)\n                                           (map #(cons el %) b)))\n                     fi r (next r)))\n              (map (comp list list) fi)\n              ))]\n    (apply min  (map (partial reduce +) (first (comb xs))))))","user":"5712854ce4b07c98581c3a89"},{"code":"(fn [t] (first (reduce #(map + (map (partial apply min) (partition 2 1 %)) %2) (reverse t))))","problem":79,"user":"5246e945e4b0644eb7b0783b"},{"problem":79,"code":"(fn\n    [tri]\n    (let [nodes (let [max-x (dec (count tri))\n                      left  (fn [x y] (when (< x max-x) [(inc x) y]))\n                      right (fn [x y] (when (< x max-x) [(inc x) (inc y)]))\n                      ns    (reduce into {} (map #(for [x [%] y (range (inc %))]\n                                                    {[x y] {:v (nth (nth tri x) y) :l (left x y) :r (right x y)}})\n                                                 (range (count tri))))]\n                  ns)\n          acc (atom [])]\n      (letfn [(p [node path]\n                (when node\n                  (if (and (not (:l node)) (not (:r node)))\n                    (swap! acc conj (conj path (:v node)))\n                    (let [ps (conj path (:v node))]\n                      (p (nodes (:l node)) ps)\n                      (p (nodes (:r node)) ps)))))]\n        (p (nodes [0 0]) [])\n        (apply min (map #(apply + %) @acc)))))","user":"52485f02e4b05ef8e38e63d3"},{"code":"#(first (reduce (fn [a b]\n     (loop [a a b b out []]\n\t      (if (empty? b)\n\t\t  out\n\t\t  (recur (rest a)\n\t\t\t (rest b)\n\t\t\t (if (> (first a) (second a))\n\t\t\t     (conj out (+ (first b) (second a)))\n\t\t\t     (conj out (+ (first b) (first a)))))))) (reverse %1)))","problem":79,"user":"4faec810e4b081705acca24e"},{"problem":79,"code":"(fn [triangle]\n  (let [path-value (fn [path] (reduce + (first path)))\n        path-depth (fn [path] (count (first path)))\n        take-step (fn [triangle path] (list \n                                        [(conj (first path) (nth (nth triangle (path-depth path)) (second path))) (second path)]\n                                        [(conj (first path) (nth (nth triangle (path-depth path)) (inc (second path)))) (inc (second path))]))\n        add-steps (fn [triangle paths] (into (rest paths) (take-step triangle (first paths))))]\n    (loop [triangle triangle\n           paths (list [(first triangle) 0])]\n      ;; if shortest path is as long as triangles height then were done\n      (if (= (path-depth (first paths)) (count triangle))\n        (path-value (first paths))\n        ;; else add steps to current shortest path and recur with sorted paths\n        (recur triangle (sort-by path-value (add-steps triangle paths)))))))","user":"574e84e0e4b02ea114799243"},{"code":"(fn [[[top] & bottom]]\r\n   (let [path-to-next (fn [path]\r\n                        ;(println \"partition: path: \" path)\r\n                  (partition 2  \r\n                    (concat [nil]\r\n                            (interleave path path)\r\n                            [nil] )))\r\n         add-member (fn [path el]\r\n                      ;(println \"add-member: path: \" path  \", el: \" el)\r\n                      {:path (conj (:path path) el)\r\n                       :length (+ (:length path) el)\r\n                      })\r\n         match-path (fn [[a b] el]\r\n                      ;(println \"match-patch: a: \" a \", b: \" b \", el: \" el)\r\n                      (cond \r\n                        (not (boolean a)) (add-member b el)\r\n                        (not (boolean b)) (add-member a el)\r\n                        :else\r\n                        (if (> (:length a) (:length b))\r\n                          (add-member b el)\r\n                          (add-member a el))))\r\n         ]\r\n    ;(println \"main: top: \" top \", bottom: \" bottom)\r\n     \r\n         (apply min ( map :length (reduce\r\n           (fn [ps p]\r\n             ;(println \"ps: \" ps \", p: \" p)\r\n             ;(println \"p-to-next: \" (path-to-next ps))\r\n             (map match-path\r\n                  (path-to-next ps) p))\r\n           [{:path [top] :length top}] bottom)))))","problem":79,"user":"502a9fdee4b095a7adb898b4"},{"problem":79,"code":"(fn sum-min-path\n  ([t] (sum-min-path (vec t) 0 0))\n  ([t row cell]\n   (let [val (get-in t (list row cell))]\n     (+ val (if (nil? (get t (inc row)))\n              0\n              (min\n               (sum-min-path t (inc row) cell)\n               (sum-min-path t (inc row) (inc cell))))))))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn [t] (rand-nth [7 20]))","problem":79,"user":"510db6cde4b078ea71921145"},{"code":"(fn [s] (apply min (reduce (fn [prev cur] (map #(+ % (apply min (concat (if (< %2 (count prev)) (list (nth prev %2)) [])\n                                                             (if (>= (dec %2) 0) (list (nth prev (dec %2))) [])))) cur (range (count cur))))\n                (first s) (rest s))))","problem":79,"user":"50dfb660e4b061dbdced7228"},{"problem":79,"code":"(fn [triangle]\n  (apply min \n         (reduce (fn [cur n]\n                   (let [c (count n)]\n                     (map #(cond\n                            (= % 0) (+ (nth cur %) (nth n %))\n                            (= % (dec c)) (+ (nth cur (dec %)) (nth n %))\n                            :else (min\n                                   (+ (nth n %) (nth cur (dec %)))\n                                   (+ (nth n %) (nth cur %)))) \n                          (range c))))\n                 triangle)))","user":"4f041de1535dcb61093f6ba5"},{"code":"(fn [rows]\n  (apply min\n    (reduce\n      (fn [dist next-row]      \n        (map (fn [x [d1 d2]] (+ x (min d1 d2))) next-row (partition 2 1 [(last dist)] (cons (first dist) dist))))\n      rows)))","problem":79,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":79,"code":"(fn problem-79 [xs]\n  (let [[first-row & remain] (reverse xs)\n        combine-rows         (fn [r1 r2]\n                               (let [s1 (map + r1 r2)\n                                     s2 (map + r1 (drop 1 r2))]\n                                 (map min s1 s2)))]\n    (first (reduce #(combine-rows %2 %1)\n                   first-row\n                   remain))))","user":"5c896f46e4b048ec896c5940"},{"problem":79,"code":"(fn [col]\n  (first \n     (reduce #(map + \n                   (map min (butlast %1) \n                            (rest %1))\n                   %2)\n            (reverse col))))","user":"54d7e277e4b0a52adc2e2031"},{"problem":79,"code":"#(apply min\n        (reduce\n         (fn [acc row]\n          (map + \n               (map (partial apply min) \n                    (apply concat\n                           ((juxt (comp list list first) \n                                  (partial partition 2 1)\n                                  (comp list list last)) acc))) row)) %))","user":"532ecd44e4b019098a6f8b49"},{"problem":79,"code":"(fn triangle-min-path [coll]\n  (let [trees (fn trees [[v & vs]]\n                (if vs\n                  (let [ts (trees vs)]\n                    (map #(hash-map :node % :left %2 :right %3)\n                         v ts (drop 1 ts)))\n                  (map #(hash-map :node %) v)))\n        min-sum (fn min-sum [t]\n                  (if t\n                    (+ (:node t)\n                       (min (min-sum (:left t))\n                            (min-sum (:right t))))\n                    0))]\n    (min-sum (first (trees coll)))))","user":"5353afa0e4b084c2834f4b03"},{"problem":79,"code":"(letfn [\n(left-subtri\n    [tri]\n    (map butlast (rest tri)))\n(right-subtri\n    [tri]\n    (map rest (rest tri)))\n(min-path\n    [tri]\n    (if (= 1 (count tri))\n        (first (first tri))\n        (+ (first (first tri)) (min (min-path (left-subtri tri)) (min-path (right-subtri tri))))))]\n    min-path)","user":"57717915e4b0979f896515b3"},{"problem":79,"code":"(fn [triangle]\n  (first (reduce (fn [min-row current-row]\n                   (map (fn [n pair]\n                          (+ n (apply min pair)))\n                        current-row\n                        (partition 2 1 min-row)))\n                 (reverse triangle))))","user":"5424c523e4b01498b1a71b03"},{"problem":79,"code":"#(first (reduce (fn [prev cur]\n                   (map + cur (map min prev (rest prev)))) (reverse %)))","user":"571e6d73e4b0145328a76292"},{"problem":79,"code":"(fn min-sum-by-path [[coll & colls]]\n  (if-not colls\n    (first coll)\n    (+ (first coll)\n       (apply\n        min\n        (map min-sum-by-path\n             (map (fn [n]\n                    (map take\n                         (rest (range))\n                         (map #(drop n %) colls)))\n                  (range (count (first colls)))))))))","user":"5393185ae4b0b51d73faaeb7"},{"code":"(fn f ([g] (f 0 g)) ([i [h & t]] (+ (h i) (if t (min (f i t) (f (+ 1 i) t)) 0))))","problem":79,"user":"526a7025e4b03e8d9a4a722a"},{"code":"(fn thisfunc [s]\n  (let [x (first (first s))]\n    (if (= 1 (count s))\n      x\n      (min (+ x (thisfunc (map rest (rest s)))) \n           (+ x (thisfunc (map drop-last (rest s))))))))","problem":79,"user":"4dd9d299535d2dad7130b5dd"},{"problem":79,"code":"(fn f [[[h] & t]]\n  (if h\n    (+ h (min\n          (f (map rest t))\n          (f (map butlast t))))\n    0))","user":"548b8a50e4b0e286459a11ff"},{"problem":79,"code":"(fn mct2[t]\n  (let [triangle (into [] t)        \n        init {[0 0] (get-in triangle [0 0])}\n        mybranch? (fn [node] (let [n (first (keys node))\n                                   isbranch (< (first n)(dec (count triangle)))]                                 \n                               isbranch))                                             \n        mychildren (fn [node] (let [n (first (keys node))\n                                    v (first (vals node))\n                                    x (inc (first n))                                   \n                                    c1 [x (second n)]\n                                    c2 [x (inc (second n))]] \n                                [{c1 (+ v (get-in triangle c1))}\n                                 {c2 (+ v (get-in triangle c2))}]))\n        paths (tree-seq mybranch? mychildren init)] \n    (first (sort (flatten (map vals (filter #(= (dec (count triangle)) (ffirst (keys %))) paths)))))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"#(apply\n  (fn path\n    ([[top]] top)\n    ([[top] & args]\n      (+ top (min (apply path (map drop-last args))\n                  (apply path (map rest args)))))) %)","problem":79,"user":"511f88eee4b085952a83535f"},{"problem":79,"code":"(fn [t]\n  (let [acc (atom '())\n        getrc (fn [inp r c] (nth (nth inp r) c))\n        paths (fn paths [curpath row col inp]\n                (let [nextpath (conj curpath (getrc inp row col))]\n                  (if (= (inc row) (count inp))\n                    (swap! acc conj nextpath)\n                    (do ;else recur\n                      (paths nextpath (inc row) col inp)\n                      (paths nextpath (inc row) (inc col) inp)))))        \n        p (paths '() 0 0 t)]\n    (apply min (map #(apply + %) @acc))))","user":"4e8768f6535dceadca469850"},{"problem":79,"code":"(fn abc [xs]\n   (letfn [(la [x1 n sum] \n               (if (not (first x1)) sum\n                    (min (la (rest x1) n       (+ sum ((first x1) n) ))  \n                         (la (rest x1) (inc n) (+ sum ((first x1) (inc n))) ))))]\n       (la (rest xs) 0 (first (first xs)))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":79,"code":"(fn min-path\n  [tri]\n  (let [path-length (dec (count tri))\n        num-paths (reduce * 1 (repeat path-length 2))\n        n->bit-seq (fn f [len n]\n                     (if (zero? n)\n                       (repeat len 0)\n                       (cons (mod n 2) (f (dec len) (quot n 2)))))\n        make-path (fn [n]\n                    (reductions + 0 (n->bit-seq path-length n)))\n        all-paths (map make-path (range 0 num-paths))\n        eval-path (fn [p]\n                    (println p)\n                    (->>\n                      (map vector p tri)\n                      (map (fn [[index row]] (get row index)))\n                      (reduce +)))]\n    (reduce min (map eval-path all-paths))))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":79,"code":"(fn [v]\n  (loop [row-i 1\n         all (first v)]\n    (if (>= row-i (count v))\n      ((comp first sort) all)\n      (let [row (nth v row-i)]\n        (recur (inc row-i)\n               (loop [i 0\n                      new-all []]\n                 (if (>= i (count row))\n                   new-all\n                   (let [col (nth row i)\n                         i-1 (dec i)\n                         cols-1 (dec (count row))\n                         n (cond\n                             (= i 0) (nth all i)\n                             (= i cols-1) (nth all i-1)\n                             :else (min (nth all i) (nth all i-1)))]\n                     (recur (inc i)\n                            (conj new-all (+ col n)))))))))))","user":"5b23c99ce4b08b1df1c36760"},{"problem":79,"code":"(fn [pyramid]\n  (->> pyramid\n   \t   reverse\n       (reduce (fn [r1 r2] (map #(+ %1 (min %2 %3)) r2 r1 (next r1))))\n       first))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [coll]\n  (loop [ret (vector (conj (first coll) 0)) nxt (vector (second coll)) rst (rest (rest coll))]\n    (let [f (fn [[x i] [a b]] \n               (vector (vector (+ x a) i) (vector (+ x b) (inc i))))]\n     (if (seq nxt)\n      (recur (partition 2\n               (flatten \n                 (map (fn [x] (f x (nth nxt (last x)))) ret)))\n                 (partition 2 1 (first rst)) (rest rst))\n        (apply min (map first ret))))))","problem":79,"user":"5084c43be4b0fb8f40674bfa"},{"problem":79,"code":"(fn [tri]\n  (->> (reverse tri)\n       (reduce (fn [prev new]\n                 (map (fn [n [a b]] (+ n (min a b)))\n                      new (partition 2 1 prev))))\n       (first)))","user":"505aa653e4b021387fb89857"},{"problem":79,"code":"(fn [t]\n  (letfn [(f [m a q]\n            (if (empty? m) a\n                (apply min (map #(f (rest m) (+ % a) %) ((first m) q)))))]\n    (f (map #(into {} (apply map vector %))\n            (map vector t (rest (map #(partition 2 1 %) t)))) (ffirst t) (ffirst t))))","user":"52c25645e4b07a9af579237d"},{"code":"(fn tmp [[f s & r]]\n  (if (and f s)\n    (let [m (map min (rest f) (butlast f))\n          v (concat [(first f)] m [(last f)])]\n      (tmp (cons (map + v s) r)))\n    (apply min f)))","problem":79,"user":"51d96ad0e4b02ceefd94774f"},{"code":"#((fn ms [x y] (let [ny (inc y)]\r\n    (+ (nth (nth % y) x)\r\n      (if (>= ny (count %)) 0\r\n        (min (ms (inc x) ny)\r\n             (ms x ny))))))\r\n  0 0)","problem":79,"user":"50336c6be4b0c6c1199c710f"},{"problem":79,"code":"(fn [x]\n    (let [grid (vec (map vec x))\n          h (count grid)\n          mem-f (memoize\n                 (fn [f r c]\n                   (let [top (get-in grid [r c])]\n                     (if (= r (dec h))\n                       top\n                       (+ top (min (f f (inc r) c)\n                                   (f f (inc r) (inc c))))))))]\n      (doseq [r (range (dec h) -1 -1)\n              c (range r -1 -1)]\n        (mem-f mem-f r c))\n      (mem-f mem-f 0 0)))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":79,"code":"(fn f [r]\n  (if (= 1 (count r))\n    (first (first r))\n    (let [l (last r)\n          p (nth r (- (count r) 2))\n          n (map #(+ (nth p %) (min (nth l %) (nth l (inc %)))) (range (count p)))]\n      (recur (concat (take (- (count r) 2) r) [n])))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":79,"code":"(fn [t]\n   (let [trim (fn [ts]\n                (mapcat (fn [t] \n                          (let [v (->> t first first)\n                                l (->> t second first)\n                                r (->> t second last)\n                                lt (map (partial drop-last 1) (rest t))\n                                rt (map rest (rest t))]\n                            (list\n                              (cons (list (+ v l)) (rest lt))\n                              (cons (list (+ v r)) (rest rt))))) ts))\n         min-path (fn [ts]\n                    (if (empty? (filter #(> (count %) 1) ts)) (apply min (flatten ts))\n                      (do (println ts \"\\n\") (recur (trim ts)))))]\n     (min-path (list t))))","user":"57780e4fe4b0979f89651657"},{"problem":79,"code":"(fn [colls]\n    (let [f     (fn f [n]\n                  (if (= 1 n) [[0]]\n                    (mapcat (fn [x] (map #(conj % x) (f (dec n)))) [0 1])))\n          path  (fn [ps colls] (map-indexed (fn [i p] (nth (nth colls i) p)) ps))\n          paths (map #(reductions + %) (f (count colls)))]\n      (apply min (map #(apply + %) (map #(path % colls) paths)))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn [tri]\n  (letfn [(make-nodes\n            [tri]\n            (->> tri\n                 (map-indexed vector)\n                 (into {})\n                 (map (fn [[k v]] (map-indexed (fn [idx itm] [[k idx] itm]) v)))\n                 (apply concat)\n                 (into {})\n                 )\n            )\n\n          (make-edges\n            [nodes]\n            (->> nodes\n                 (map (fn [[[row col] _]]\n                        [[row col] (into {}\n                                         (filter (fn [[[r c] _]]\n                                                   (and (= (inc row) r)\n                                                        (or (= col c) (= (inc col) c)))) nodes))]))\n                 (into {})\n                 )\n            )\n\n          (neighbors\n            ([g n] (get g n {}))\n            ([g n uv] (select-keys (neighbors g n) uv)))\n\n          (update-costs\n            [g costs curr unvisited]\n            (let [curr-cost (costs curr)]\n              (reduce\n                (fn [c [nbr nbr-cost]] (update-in c [nbr] (partial min (+ curr-cost nbr-cost))))\n                costs\n                (neighbors g curr unvisited))))\n\n          (dijkstra\n            [g src & {:keys [target]}]\n            (loop [costs (assoc (zipmap (keys g) (repeat Long/MAX_VALUE)) src 0)\n                   curr src\n                   unvisited (disj (apply hash-set (keys g)) src)]\n              (if (or (empty? unvisited) (= Long/MAX_VALUE (costs curr)))\n                costs\n                (let [costs' (update-costs g costs curr unvisited)\n                      curr' (first (sort-by costs' unvisited))]\n                  (if (= target curr)\n                    (costs' target)\n                    (recur costs'\n                           curr'\n                           (disj unvisited curr')))))))\n\n          (tri-path\n            [tri]\n            (let [graph (make-edges (make-nodes tri))\n                  results (dijkstra graph [0 0])]\n              (->> results\n                   (filter (fn [[[row _] _]] (= (dec (count tri)) row)))\n                   (into {})\n                   (vals)\n                   (apply min)\n                   (+ (ffirst tri))\n                   )\n              ))]\n    \n    (tri-path tri)\n\n    ))","problem":79,"user":"50ebd63ce4b04edc3377703c"},{"problem":79,"code":"(fn [x] \n\t(first (reduce #(map-indexed (fn [i he] (+ he (min (nth %1 i) (nth %1 (inc i))))) %2) (reverse x))))","user":"53e19461e4b0d874e779ae59"},{"code":"(fn [t]\n    (first (reduce #(map min (map + %2 %) (map + %2 (drop 1 %))) (reverse t))))","problem":79,"user":"52a88c4de4b0c58976d9ac30"},{"problem":79,"code":"(letfn[(minPaths [triangle, row]\n                 (let [currentRow (nth triangle row)]\n                   (if (= (inc row) (count triangle)) currentRow;last row is the always the minimal\n                     (let [nextMinimal (map #(apply min %) (partition 2 1 (minPaths triangle (inc row))))];[2 3 4 5]->((2 3) (3 4) (4 5))->(2 3 4)\n                       (map + currentRow nextMinimal)))))];get the current minimal path\n  (fn [triangle]\n    (first (minPaths triangle 0))));minPaths returns a sequence, but only a single value is needed","user":"556c70dae4b09a3098a524fd"},{"problem":79,"code":"(fn F [tri]\n  (prn tri)\n  (if (empty? tri)\n    0\n    (let [low (drop 1 tri)\n          left (map #(drop-last 1 %) low)\n          right (map #(drop 1 %) low)]\n      (+ (ffirst tri) (min (F left) (F right))))))","user":"5db92996e4b010eb3c36cd50"},{"code":";; some dynamic programming as a reduce\n(letfn [(min-step [costs-so-far next-costs]\n          (map (fn [csf-1 csf-2 next-cost]\n                 (min (+ csf-1 next-cost) (+ csf-2 next-cost)))\n               (cons (first costs-so-far) costs-so-far)\n               (concat costs-so-far [(last costs-so-far)])\n               next-costs))\n        (min-path [triangle]\n          (apply min (reduce min-step (first triangle) (rest triangle))))]\n  min-path)","problem":79,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn [t]\n  (letfn [(nb [[y x] l] (if (= l y) [] [[(+ 1 y) x] [(+ 1 y) (+ 1 x)]]))\n          (ct [t]\n            (let [l (count t)\n                  c (count (last t))]\n              (reduce (fn [m c]\n                        (let [v (get-in t c)\n                              l1 (- l 1)]\n                          (assoc m c {:v v :c (nb c l1) :s v})))\n                      {}\n                      (for [y (range l)\n                            x (range c)\n                            :when (<= x y)] [y x]))))\n          (cmm [t cd]\n            (let [{:keys [v c s]} (t cd)]\n              (if (empty? c)\n                [s]\n                (mapcat (fn [ncd]\n                          (let [sc (:s ncd)\n                                vc (:v ncd)]\n                            (if (= sc vc) ;; first visit?\n                              (cmm (update-in t [ncd :s] (fn [s1] (+ s s1))) ncd)\n                              (cmm (update-in t [ncd :s] (fn [s1] (min s1 (+ v s)))) ncd)))) c))))]\n    (apply min (cmm (ct (vec t)) [0 0]))))","problem":79,"user":"4ee9ddb8535d93acb0a66896"},{"problem":79,"code":"(fn triangle-path\n  ([inp] (triangle-path (vec inp) 0 0))\n  ([inp i j]\n   (if (< i (dec (count inp)))\n     (+ (get-in inp [i j]) (min (triangle-path inp (inc i) j)\n                                (triangle-path inp (inc i) (inc j))))\n     (get-in inp [i j]))))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":79,"code":"(fn [tri]\n  (let [pad (fn [coll] (concat (list (first coll)) coll (list (last coll))))]\n    (apply min (reduce #(map + (map (partial apply min) (partition 2 1 (pad %1))) %2) tri))))","user":"5609d328e4b05f002753deee"},{"code":"(fn [tri]\n  (loop [rows (rest tri) last (first tri)]\n    (if (empty? rows)\n      (apply min last)\n      (let [fromlast\n            (map\n              (fn [ix]\n                (apply min (map last (filter #(and (>= % 0) (< % (count last))) [(dec ix) ix]))))\n              (range 0 (inc (count last))))]\n        (recur (rest rows) (vec (map + fromlast (first rows))))))))","problem":79,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn [l]\r\n  (apply min-key identity\r\n           (reduce (fn [x1 x2]\r\n                     (cond\r\n                      (empty? x1) x2\r\n                      :else (map-indexed\r\n                             (fn [i l]\r\n                               (+ l\r\n                                  (cond\r\n                                   (= i 0) (nth x1 0)\r\n                                   (= i (count x1)) (nth x1 (dec i))\r\n                                   :else (min-key identity (nth x1 (dec i)) (nth x1 i))\r\n                                   ))\r\n                               ) x2))\r\n                     ) [] l)))","problem":79,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [tri]\n  ((fn [l]\n     (if (= (count l) 1) (first (first l))\n       (let [d (first l) u (second l)\n             pd (map vector (rest d) (take (- (count d) 1) d))\n             n (map #(+ %1 (apply min %2)) u pd)]\n         (recur (conj (drop 2 l) n)))))\n   (reverse tri)))","problem":79,"user":"51da631be4b02ceefd947766"},{"problem":79,"code":"(fn [triangle]\n    (letfn [(gen-paths [paths next-nodes]\n              (let [paths-padded (concat [[]] paths [[]])\n                    paths-paired (partition 2 1 paths-padded)]\n                (map (fn [[node all-inner-paths]]\n                       (for [inner-paths all-inner-paths\n                             inner-path inner-paths]\n                         (cons node inner-path)))\n                     (map vector next-nodes paths-paired))))]\n      (let [all-paths (reduce gen-paths [[(first triangle)]] (rest triangle))]\n        (apply min (map #(apply + %) (reduce concat all-paths))))))","user":"5ac6ef9be4b0e27600da7779"},{"code":"(fn min-path \n  [vecs]\n  (let [ triangle (fn triangle\n    [& vecs]\n\t  (let [[v1 v2 v3 & v] vecs]\n\t    (let [left (+ (first v1) (first v2)) right (+ (first v1) (second v2))]\n\t      (if (nil? v3) [left right]\n\t        (concat\n\t        (apply triangle (vector left) (butlast v3) (map butlast v)) \n\t        (apply triangle (vector right) (rest v3) (map rest v)))))))]\n  (reduce min (apply triangle vecs))))","problem":79,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":79,"code":"(letfn [\n     (redrow [coll]  (map #(apply min %) (partition 2 1 coll)))\n     (calc [a b] (map + b (redrow a)))\n     (red [coll] (first(reduce calc (reverse coll))))] red)","user":"580c8fcee4b0849f6811b721"},{"code":"(fn minpath ([t] (minpath t 0 0))\r\n    ([t i sum] (if (empty? t) sum (let [[c & r] t, sum (+ sum (c i))] (min (minpath r i sum) (minpath r (inc i) sum)))))\r\n    )","problem":79,"user":"4feada56e4b0140c20fb9c11"},{"problem":79,"code":"(fn [t]\n  (letfn [(min-tri-path [t]\n                        (if (empty? (rest t))\n                          (first t)\n                          (let [mins (min-tri-path (rest t))]\n                            (->> (partition 2 1 mins)\n                                 (map (partial apply min))\n                                 (map  + (first t))))))]\n    (first (min-tri-path t))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":79,"code":"(fn find-path\n  ([tower] (find-path tower (dec (count tower)) 0 0))\n  ([tower n-row row col]\n   (if\n     (= row n-row)\n     (nth (last tower) col)\n     (+ (nth (nth tower row) col)\n        (min (find-path tower n-row (inc row) col)\n             (find-path tower n-row (inc row) (inc col)))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":79,"code":"(fn len [[l & t]]\n  (if (nil? l) \n    0\n    (apply min (map-indexed \n      (fn [idx item] \n        (+ \n           item \n           (len \n             (map \n               #(drop-last \n                   (- (count l) idx 1) \n                   (drop idx %)\n                 ) \n              t\n             )\n           )\n        ) \n      )\n      l\n    ))\n  )  \n)","user":"53d5e45ae4b0e771c302544e"},{"problem":79,"code":"(fn my-tri-minimal-path [rows]\n  (let [expand  #(concat (take 1 %) , (map min (butlast %) (rest %)) , (take-last 1 %))\n        combine #(map + (expand %1) %2)]\n    (->> (reduce combine rows)\n         (apply min))))","user":"581b19e7e4b04b46fc4b0ec4"},{"code":"(fn min-path [x]\n   (if (= (count x) 1)\n     (apply min (first x))\n     (let [[x1 x2 & rest] x]\n       (min-path\n        (cons\n         (concat\n          [(+ (first x2) (first x1))]\n          (map\n           (fn [a]\n             (+\n              (nth x2 (inc a))\n              (min (nth x1 a) (nth x1 (inc a)))\n              )\n             )\n           (range (dec (count x1)))\n           )\n          [(+ (last x2) (last x1))]\n          )\n         rest\n         )\n        )\n       )\n     )\n   )","problem":79,"user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn minpath [tri]\n  (let [cost (fn cost \n    ([top btm] (cost top btm []))\n    ([top btm res]\n    (if (>= (count top) 1)\n      (cost \n        (rest top) \n        (rest btm) \n        (conj res (+ (first top) \n                  (Math/min (first btm) \n                            (second btm)))))\n      res)))]\n    (if (= 1 (count tri)) (first (first tri))\n    (minpath (concat \n              (drop-last 2 tri) \n              (list (apply cost (take-last 2 tri))))))))","problem":79,"user":"4faafccde4b081705acca209"},{"code":"(fn [s]\n    (apply\n      min\n      (mapcat\n        (fn [v]\n            (map #(apply + %) (second v)))\n        (reduce\n          (fn [acc v]\n              (let [cnt (count acc)]\n                (into\n                  {}\n                  (map\n                    (fn [v]\n                        (let [idx (first v)\n                              f (fn [v idx]\n                                    (map #(conj % (second v)) (acc idx)))]\n                          (cond\n                            (zero? idx) (hash-map idx (f v idx))\n                            (>= idx cnt) (hash-map idx (f v (dec cnt)))\n                            :else (hash-map idx\n                                            (concat (f v (dec idx))\n                                                    (f v idx))))))\n                    (map-indexed list v)))))\n          (hash-map 0 [[(first (first s))]])\n          (rest s)))))","problem":79,"user":"4f969a66e4b0dcca54ed6cde"},{"code":"(fn minpath [i] (cond (= 1 (count i)) (first i) (= 2 (count i)) (+ (ffirst i) (apply min (second i))) true (minpath (concat (drop-last 2 i) (list (vec (map #(+ % %2) (map #(apply min %) (partition 2 1 (last i))) (first (take-last 2 i)))))))))","problem":79,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn wlk [t]\n  (reduce min\n          (reduce (fn [prev curr]\n                    (let [wr (fn [idx val]\n                               (let [l (get prev (dec idx))\n                                     r (get prev idx)\n                                     lv (when-not (nil? l) (+ l val))\n                                     rv (when-not (nil? r) (+ r val))]\n                                 (cond\n                                   (nil? lv) rv\n                                   (nil? rv) lv\n                                   (< lv rv) lv\n                                   :else rv)))]\n                      (vec (map-indexed wr curr)))) t)))","problem":79,"user":"4e5914e0535d8a8b8723a29b"},{"code":"(fn [col] \r\n  (let [pathes (set (\r\n                 for [x (range 1000)] \r\n                 (reduce (fn [l r] (conj l (+ (last l) (rand-int 2)))) \r\n                         [0] \r\n                         (range (- (count col) 1)))))]\r\n      (apply min (map #(reduce + %) (for [p pathes] (map #(nth %2 %1) p col))))))","problem":79,"user":"4e0e0529535d04ed9115e7b9"},{"code":"(fn min-path\n   ([vecs] (min-path (rest vecs) 0 (ffirst vecs)))\n   ([vecs last-pos cur-sum]\n      (if (empty? vecs)\n        cur-sum\n        (let [cur-vec (first vecs)\n              left-pos last-pos\n              right-pos (inc last-pos)\n              left-val (cur-vec left-pos)\n              right-val (cur-vec right-pos)]\n          (min (min-path (rest vecs) left-pos (+ cur-sum left-val))\n               (min-path (rest vecs) right-pos (+ cur-sum right-val)))))))","problem":79,"user":"524f213be4b0541d1855b7ff"},{"code":"(fn foo\r\n    ([tree] \r\n     (apply min (foo (rest tree) 0 (ffirst tree))))\r\n    ([[xs & xss] idx sum]\r\n      (if-not xs\r\n        [sum]\r\n        (let [a (nth xs idx)\r\n              b (nth xs (inc idx))]\r\n          (concat (foo xss idx (+ sum a))\r\n           (foo xss (inc idx) (+ sum b)))))))","problem":79,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":79,"code":"(fn __ [g]\n  (let [num-layers (count g)\n        cost #(-> g (nth (first %)) (nth (second %)))\n        path-cost #(apply + (map cost %))\n        next-nodes #(list [(inc (first %)) (second %)] [(inc (first %)) (inc (second %))])\n        add-to-paths (fn [p-list] (mapcat #(let [[n1 n2] (next-nodes (last %))]\n                                             [(conj % n1) (conj % n2)])\n                                          p-list))\n        paths (nth (iterate add-to-paths '([[0 0]])) (dec num-layers))]\n    (path-cost (apply min-key path-cost paths))))","user":"502a5e59e4b09e8f859a9fbc"},{"problem":79,"code":"(fn [t]\n  (let [tree (reverse t)\n        calc-path #(apply min (map (partial + %1) %2))\n        reducer #(mapv calc-path %2 (partition 2 1 %1))]\n    (first (reduce reducer (first tree) (rest tree)))))","user":"58923efce4b00487982d521c"},{"problem":79,"code":";;not proud of this one\n(fn [tri]\n  (loop [row (first tri)\n         remaining (rest tri)\n         pathlists [[row]]]\n    (if (empty? remaining)\n      (->> pathlists\n           (mapcat identity)\n           (map #(reduce + %))\n           sort\n           first)\n      (recur (first remaining)\n             (rest remaining)\n             (->> (conj pathlists (last pathlists))\n                  (map-indexed (fn [i paths]\n                                 (if (or (= 0 i)\n                                         (= i (count pathlists)))\n                                   paths\n                                   (concat paths (nth pathlists (dec i))))))\n                  (mapv (fn [step paths]\n                         (map #(conj % step) paths))\n                       (first remaining)))))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":79,"code":"(fn\n  [triangle]\n  (first (reduce (fn [a b]\n                   (map + b (map min a (rest a))))\n                 (reverse triangle))))","user":"5d96edeae4b0d3f9b434ad35"},{"code":"(fn [triangle]\n  (let [length    (apply max (map count triangle))\n        reducer   (fn [a b] (for [x a y b\n                                  :let [z (last x)]\n                                  :when (or (= y z) (= y (inc z)))]\n                              (conj x y)))\n        paths     (reduce reducer [[0]] (map (comp range inc) (range 1 length)))\n        path-sums (map (fn [p] (apply + (map #(nth %1 %2) triangle p))) paths)]\n    (apply min path-sums)))","problem":79,"user":"51307b84e4b08c712d3fae39"},{"problem":79,"code":"(fn [xs]\n  (let [ff (fn [ret, v]\n              (map #(conj % v) ret))]\n  (->> xs\n    (reduce\n      (fn [ret, xv]\n        (map concat\n          (concat (map ff ret xv) [nil])\n          (concat [nil] (map ff ret (rest xv)))))\n      [[[]]])\n    (mapcat concat)\n    (apply min-key #(apply + %)) ; mimimal path\n    (apply + ))))","user":"593f95d8e4b069cdc2982be3"},{"problem":79,"code":"(fn triangle-minimal-path [tree]\n  (let [depth (count tree)\n        digit (fn [n pos] (bit-and (bit-shift-right n pos) 1))\n        walker\n        (fn [bin]\n          (first\n           (reduce\n            (fn [[sum cur-pos path] level]\n              (let [new-pos (+ cur-pos (bit-and path 1))]\n                [(+ sum (nth level new-pos))\n                 new-pos\n                 (bit-shift-right path 1)]))\n            [0 0 (bit-shift-left bin 1)]\n            tree)))]\n    (apply min (map walker (range (Math/pow 2 (dec depth)))))))","user":"5b7f2d75e4b047b03b203768"},{"code":"(comp first \n      (partial reduce \n               (comp (partial apply map +)\n                     (juxt last \n                           (comp (partial apply map min)\n                                 (juxt first \n                                       (comp rest first))))\n                     list)) \n      reverse)","problem":79,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn triangle-sum [triangle]\n  (apply min\n    (reduce\n      (fn [row1 row2]\n        (loop [i (dec (count row2))\n               nrow row2]\n          (if (> 0 i)\n            nrow\n            (recur (dec i)\n                   (assoc-in nrow [i]\n                             (+ (nrow i)\n                                (min (row1 (min i (dec (count row1))))\n                                     (row1 (max 0 (dec i))))))))))\n      triangle)))","problem":79,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":79,"code":"(fn t [trg]\n  (loop  [paths  [[(first trg)]] levels  (next trg)]\n    (if  (seq levels)\n      (let  [level  (first levels)\n             npaths  (map concat  (cons nil paths)  (concat paths  [nil]))]\n        (recur  (map  (fn[ps e] (map #(conj % e) ps)) npaths level)  (next levels)))\n      (first (sort (map (partial reduce +) (mapcat identity paths)))))))","user":"4f1ef6a0535d64f60314649b"},{"code":"(fn [l]\n  ((fn f [p [h & m]]\n     (if h\n       (+ (h p) \n          (apply min (map #(f % m) [p (inc p)]))) 0)) 0 l))","problem":79,"user":"4fa30027e4b081705acca187"},{"problem":79,"code":"(fn problem-79\n  [triangle]\n  (let [triangle\n        (mapv vec triangle)\n\n        depth\n        (count triangle)\n\n        paths\n        (->> [[0]]\n             (iterate (fn [paths]\n                        (->> (for [[h & _ :as path] paths]\n                               [(cons h path)\n                                (cons (inc h) path)])\n                             (mapcat identity) )))\n             (#(nth % (dec depth)) )\n             (map reverse))]\n\n    (->> paths\n         (map (fn [path]\n                (map-indexed (fn [i p]\n                               (get-in triangle [i p]))\n                             path)))\n         (map (partial apply +))\n         (apply min))))","user":"58e37946e4b005f69f193cae"},{"code":"(fn [xs]\n  (apply\n    min\n    (reduce\n      #(map-indexed\n        (fn [i n]\n          (if (zero? i)\n            (+ n (first %1))\n            (if (= i (count %1))\n              (+ n (last %1))\n              (min (+ n ((into [] %1) (dec i))) (+ n ((into [] %1) i)))\n            )\n          )\n        )\n        %2\n      )\n      xs\n    )\n  )\n)","problem":79,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":79,"code":"(fn [v]\n   (let [xmax (dec (count v))]\n     ((fn path [x y]\n        (if (= x xmax)\n          (if (> y x)\n            ((nth v x) x)\n            ((nth v x) y))\n          (+ \n           ((nth v x) y) \n           (min \n            (path (inc x) y)\n            (path (inc x) (inc y))))))\n      0 0)))","user":"54d9366ce4b0a52adc2e204e"},{"problem":79,"code":"(fn minTriPath [triangle]\n(loop \n  [row `(0)\n  rows (rest triangle)\n  curRow (first triangle)]\n  (if (and (empty? rows) (empty? curRow))\n    (apply min row)\n    (recur\n      (if (= (count curRow) 1)\n        (list (+ (first row) (first curRow))) \n      (let \n      [coll \n        (flatten\n          (for [n (partition 2 (interleave row (partition 2 1 curRow)))]\n            (map #(+ % (first n)) (second n))))\n      left (first coll)\n      right (last coll)]\n      (concat \n        (list left)\n        (->> coll\n          (rest)\n          (butlast)\n          (partition 2)\n          (#(for [x %] (if (< (first x) (second x)) (first x) (second x)))))\n        (list right))))\n      (rest rows)\n      (first rows)))))","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn triangle-minimal-path [rows]\n  (->> rows\n       reverse\n       (reduce #(map + %2 (map min %1 (rest %1))))\n       first))","problem":79,"user":"50586354e4b06522596eba78"},{"code":"(fn min-sum [tree]\n  (loop [t (reverse tree)]\n    (let [a (first t)\n          b (second t)\n          c (apply map vector [b a (drop 1 a)])\n          d (map (fn [[x y z]] (+ x (min y z))) c)]\n      (if (= 1 (count d))\n        (first d)\n        (recur (cons d (rest (rest t))))))))","problem":79,"user":"4e89ddf9535d3e98b8023284"},{"problem":79,"code":"#(first \n  (reduce \n   (fn [a e]\n     (map + \n          (map (partial apply min) (partition 2 1 a)) \n          e)) \n   (first (reverse %)) \n   (rest  (reverse %))))","user":"577202d2e4b0979f896515c0"},{"problem":79,"code":"(fn [tri]\n         (letfn [(find-paths [tri r i cur paths]\n                   (if (= (count tri) r) (cons cur paths)\n                       (let [row (nth tri r)]\n                         (if (= i (count row)) (cons cur paths)\n                             (let [new-r (inc r)\n                                   new-paths (find-paths tri new-r i (cons (nth row i) cur) paths)]\n                               (find-paths tri new-r (inc i) (cons (nth row i) cur) new-paths))))))]\n           (let [all-paths (find-paths tri 0 0 [] [])]\n             (apply min (for [a all-paths] (apply + a))))))","user":"5da71eaee4b000c986472c15"},{"problem":79,"code":"(fn [t] (apply min\n                     ((fn ct [t]\n                        (letfn [(gm [m i]\n                                  (let [x (if (= 0 i) 0 (dec i))\n                                        y (if (= (count m) i) i (inc i))]\n                                    (apply min (subvec m x y))))]\n                          (let [l (last t)]\n                            (if (= 1 (count l)) l\n                              (let [m (ct (drop-last t))]\n                                (vec (map-indexed\n                                       #(+ (gm m %) %2) l))))))) t)))","user":"544e6b7fe4b0e39780006986"},{"code":"(fn [[a b & more]]\r\n  (apply +\r\n    (first \r\n\t\t  (sort-by #(apply + %)\r\n\t\t\t   (map second\r\n\t\t\t\t\t    (loop [res  `([0 ~a])\r\n\t\t\t\t\t           n    b\r\n\t\t\t\t\t           data more]\r\n\t\t\t\t\t        (if (not n)\r\n\t\t\t\t\t          res\r\n\t\t\t\t\t          (recur  (reduce into\r\n\t\t\t\t\t                          []\r\n\t\t\t\t\t                          (map (fn [[idx v]]\r\n\t\t\t\t\t                                 [[idx       (conj v (get n idx))]\r\n\t\t\t\t\t                                  [(inc idx) (conj v (get n (inc idx)))]]\r\n\t\t\t\t\t                               )\r\n\t\t\t\t\t                               res)\r\n\t\t\t\t\t                  )\r\n\t\t\t\t\t                  \r\n\t\t\t\t\t                 (first data)\r\n\t\t\t\t\t                 (next data))))))))\r\n)","problem":79,"user":"4f3e6244e4b0e243712b1f85"},{"problem":79,"code":"(fn find-min-path[tri]\n  (let [gen-perms (fn [tri]\n                    (let [bit-width (count tri)\n                          perm-count (->> (- bit-width 1) (Math/pow 2) int)]\n                      (loop [i 0 result []]\n                        (if (>= i perm-count) result\n                          (recur \n                           (inc i)\n                           (conj result (clojure.pprint/cl-format nil \"~V,'0B\" bit-width i)))))))\n        gen-coors (fn [bit-string]\n                    (let [len (count bit-string)]\n                      (loop [i 0 result []]\n                        (if (>= i len) result\n                          (let [ss (subs bit-string 0 (+ i 1))\n                                as-ints (map #(read-string (str %)) ss)\n                                coor (reduce + as-ints)]\n                          (recur (inc i) (conj result coor)))))))\n        get-values-for-coors (fn [tri coors]\n                              (let [tv (into [] tri) len (count tv)]\n                                (loop [i 0 result []]\n                                  (if (>= i len) result\n                                    (recur (inc i) (conj result (get-in tv [i (coors i)])))))))]\n    (->> tri\n     gen-perms\n     (map gen-coors)\n     (map #(get-values-for-coors tri %))\n     (map #(let [] [(reduce + %) %]))\n     (sort-by #(% 0))\n     (ffirst))))","user":"5546704be4b0a04f7929953d"},{"problem":79,"code":"(fn [colls]\n  (let [init-coll (last colls)\n        current-colls (reverse (butlast colls))\n        reduce-fn (fn [init coll] (->> init\n                                       (partition 2 1)\n                                       (map #(apply min %))\n                                       (map + coll)))]\n    (first (reduce reduce-fn init-coll current-colls))))","user":"5cb41c40e4b026601754b911"},{"problem":79,"code":"(fn [ns]\n  (apply\n   min\n   (reduce\n    (fn [r1 r2]\n      (let [x (map #(apply + %) (map vector r1 r2))\n            y (map #(apply + %) (map vector r1 (rest r2)))]\n        (map #(apply min %) (map vector (conj (into [] x) (last y)) (cons (first x) y)))))\n    ns)))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":79,"code":"(fn [rows]\n(first (reduce\n (fn [m e]\n  (map +\n   (map #(apply min %) (partition 2 1 m))\n   e))\n (reverse rows))))","user":"5881d1c2e4b0f1effa3b7644"},{"problem":79,"code":"(fn triangle-min-path [g]\n  (let [g (apply vector g)] \n    (loop [i 1\n           g g]\n      (if (>= i (count g))\n        (apply min (g (dec i)))\n        (let [ip (dec i) ;;previous line\n              n (count (g i)) ;;number elements current line\n              ln (mapv (fn [e] ;;new line update with minimum paths\n                         (let [v1 ((g ip) (max 0 (dec e))) ;;neighbor left\n                               v2 ((g ip) (min e (- n 2)))] ;;neighbor rigth\n                           (+ ((g i) e) (min v1 v2))))\n                       (range n))]\n          (recur (inc i) (assoc g i ln)))))))","user":"574f1c24e4b02ea114799255"},{"problem":79,"code":"(fn minimal-path [t]\n(->>\n\t; generate all (relevant) bit sequences of length |t|\n\t((fn seqs [n]\n\t\t(if (= n 0)\n\t\t\t[[0]]\n\t\t\t; do recursive stuff\n\t\t\t(reduce into(for [x (seqs (dec n))] [(conj x 0) (conj x 1)]))\n\t\t)\n\t) (dec (count t)))\n\n\t; map sequences to path\n\n\t; map paths to weights\n\t(map (fn weight [path]\n\t\t(loop [i 0 s 0 ret 0]\n\t\t\t(if (= i (count path))\n\t\t\t\tret\n\t\t\t\t(recur\n\t\t\t\t\t(inc i)\n\t\t\t\t\t(+ s (nth path i))\n\t\t\t\t\t(+ ret (nth (nth t i) (+ s (nth path i))))\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t))\n\n\t; take min\n\t(apply min)\n)\n)","user":"5f574662e4b0a0bc16850a90"},{"problem":79,"code":"(fn __ [tree]\n  (letfn [(combine-rows\n            [r1 r2]\n            (let [poss1 (map + r1 (butlast r2))\n                  poss2 (map + r1 (rest r2))]\n              (concat [(first poss1)]\n                      (map min (rest poss1) (butlast poss2))\n                      [(last poss2)])))]\n  (apply min (reduce combine-rows tree))))","user":"55916764e4b0604b3f94d57b"},{"problem":79,"code":"(fn tmp\n  ([ls] (tmp ls [0]))\n  ([ls u]\n    (if (empty? ls)\n      (apply min u)\n      (let [l (first ls)\n            nu (concat (take 1 u) (map (partial apply min) (partition-all 2 1 u)))\n            c (map + l nu)]\n        (tmp (rest ls) c)))))\n\n;; if the path calculated\n#_(fn tmp\n  ([ls] (tmp ls [0] [[]]))\n  ([ls u p]\n    (if (empty? ls)\n      (first (sort-by (partial apply +) p)) \n      (let [l (first ls)\n            nu (concat (take 1 u) (map (partial apply min) (partition-all 2 1 u)))\n            c (map + l nu)\n            np (cons (first p) (map (comp first (partial sort-by (partial apply +))) (partition-all 2 1 p)))\n            p (map conj np l)]\n        (tmp (rest ls) c p)))))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn [triangle]\n    ((fn tri-walk [next-rows current-pos path-weight]\n       (if (empty? next-rows)\n         path-weight\n         (apply\n          min\n          (for [increment [0 1]]\n            (tri-walk (rest next-rows)\n                      (+ increment current-pos)\n                      (+ path-weight\n                         ((first next-rows) (+ increment current-pos))))))\n         )\n       )\n     (rest triangle) 0 (get (first triangle) 0))\n    )","problem":79,"user":"52213426e4b0e6a83c8925c4"},{"problem":79,"code":"(letfn ((left-tri [triangles]\r\n          (map butlast triangles))\r\n        (right-tri [triangles]\r\n          (map next triangles))\r\n        (min-path [[[x] & triangles]]\r\n          (if (nil? x) 0\r\n              (+ x (min (min-path (left-tri triangles))\r\n                        (min-path (right-tri triangles)))))))\r\n  min-path)","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn min-path [triangle]\n  (apply min\n    (let [triples (fn [xs] (map (partial filter (complement nil?)) (map vector (cons nil xs) (concat xs '(nil)))))]\n      (reduce \n        (fn [this-row next-row]\n          (let [this-row-triples (triples this-row)]\n            (map \n              (fn [next-row-elem this-row-triple] \n                (+  next-row-elem \n                    (apply min this-row-triple))) \n              next-row \n              this-row-triples)))\n        triangle))))","problem":79,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":79,"code":"(fn [t] \n  (first \n   (reduce #(map + (map (partial apply min) (partition 2 1 %)) %2) \n           (reverse t))))","user":"52b02329e4b0c58976d9acc5"},{"problem":79,"code":"(fn [l]\n  (first \n   (reduce\n    #(map-indexed \n      (fn [i e] \n        (+ e (Math/min (nth %1 i) (nth %1 (inc i))))) \n      %2)\n    (last l)\n    (reverse (drop-last l)))))","user":"5ed52854e4b016b56eae05d2"},{"problem":79,"code":"; I would use memoize if fucking def was allowed\n(fn solve [a]\n (let [help (fn rec [x y] (if (= (inc x) (count a)) \n      (nth (nth a x) y) \n      ;else\n      (+ \n         (min (rec (inc x) y) (rec (inc x) (inc y))) \n         (nth (nth a x) y)\n      ) \n      )) ]\n   (help 0 0)\n  )\n)","user":"56f258d3e4b04a395b9a04a1"},{"problem":79,"code":"(fn [triangle]\n  (let [pattern (iterate #(concat % (map inc %)) [0])\n        expanded-triangle (map (fn [p t] (map #(nth t %) p)) pattern triangle)\n        sums (reduce #(map + (mapcat (partial repeat 2) %) %2) expanded-triangle)]\n    (apply min sums)))","user":"58f44c07e4b0438e51c2ceb7"},{"code":";; Wow, this is terrible, but it's also as close to\n;; a direct translation of my old Haskell solution\n;; that I can be bothered to make. One could probably\n;; be more idiomatic, but I've solved this so many times.\n\n;; And fitting it into a single anonymous function is painful and doesn't help, no.\n\n(fn [s]\n  (let [processRow (fn [thisRow lastBest]\n                     (let [aux (fn aux [u l]\n                                 (cond (empty? u) '()\n                                       (= (count u) (count l) 1) (list (+ (first u) (first l)))\n                                       true (conj (aux (rest u) (rest l)) (+ (first u) (min (first l) (second l))))))]\n                       (conj (aux (rest thisRow) lastBest) (+ (first thisRow) (first lastBest)))))\n        aux (fn [l b] (if (empty? l) b (recur (rest l) (processRow (first l) b))))\n        x (aux (rest s) (first s))]\n    (apply min x)))","problem":79,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":79,"code":"(fn [triangles]\n   (first (reduce (fn [a b]\n                    (->> (partition 2 1 a)\n                         (map #(apply min %))\n                         (map + b)))\n                  (reverse triangles))))","user":"55db7e15e4b0e31453f64ae8"},{"code":"(fn f\r\n  ([rows] (first (f (first rows) (rest rows))))\r\n  ([row rows]\r\n     (let [next-row (first rows)\r\n           rows (rest rows)\r\n           sums (vec (if (seq rows) (f next-row rows) next-row))]\r\n       (for [[i n] (map-indexed (fn [a b] [a b]) row)]\r\n         (let [a (sums i)\r\n               b (sums (inc i))]\r\n           (if (> a b)\r\n             (+ n b)\r\n             (+ n a)))))))","problem":79,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":79,"code":"(fn [x] (let [r (rand-int 2)] (if (zero? r) 7 20)))","user":"53976599e4b0b51d73faaeea"},{"code":"(fn tmp [t]\n  (let [paths (range (reduce * (repeat (count t) 2)))\n        traverse (fn [t p start sum]\n                   (if (empty? t) sum\n                       (let [move (mod p 2)\n                             v (get (first t) start)]\n                         (recur (rest t) (quot p 2) (+ start move) (+ sum v)))))]\n    (apply min (map #(traverse t % 0 0) paths))))","problem":79,"user":"4fbd12a5e4b081705acca2fd"},{"problem":79,"code":"(fn [tr]\n  (loop [tr tr]\n    (if (= 1 (count tr))\n      (apply min (flatten tr))\n      (let [three\n            (fn [one two]\n              (+ one (apply min two)))\n            mergerows\n            (fn [top bot]\n              (map #(three (get top %) (take 2 (drop % bot))) (range (count top))))]\n        (recur\n         (concat (drop-last 2 tr) [(apply mergerows (take-last 2 tr))]))))))","user":"592334c7e4b0a390037439ee"},{"code":"(fn tmp [t]\n  (letfn [(hop [v1 v2]\n               (for [i (range (count v1))]\n                 (map #(+ (nth v1 i) %) [(v2 i) (v2 (inc i))])))\n          (trim [v]\n                (reverse (reduce (fn [l p] (conj (conj (rest l) (min (first p) (first l))) (second p)))\n                                 (list (first (first v)))\n                                 v)))]\n    (apply min (reduce (comp trim hop) t))))","problem":79,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn summin [rows]\n  (letfn [(findpaths [[row & rst] i path]\n    (if (nil? row)\n      [path]\n      (apply concat\n        (map\n          #(findpaths rst % (conj path (row i)))\n          [i (inc i)]))))]\n    (apply min (map (partial apply +) (findpaths rows 0 [])))))","problem":79,"user":"4fe8b6afe4b07c9f6fd12c76"},{"code":"(fn paths [tree]\r\n  (letfn [\r\n    (map2 [f xs ys]\r\n\t\t(if (or (nil? (first xs))\r\n\t\t\t(nil? (first ys)))\r\n\t\t  []\r\n\t\t  (conj (map2 f (rest xs) (rest ys))\r\n\t\t\t(f (first xs) (first ys)))))\r\n\t  \r\n\t  (calc-path [ls ms]\r\n\t\t     (if (= (count ls) 1)\r\n\t\t       (map #(+ (first ls) %) ms)\r\n\t\t       (let [ml (count ms)\r\n\t\t\t     lmst (drop 1 (take (- ml 1) ms))\r\n\t\t\t     l1 (take (- (count ls) 1) ls)\r\n\t\t\t     l2 (drop 1 ls)\r\n\t\t\t     ]\r\n\t\t\t (concat (cons\r\n\t\t\t\t  (+ (first ls) (first ms))\r\n\t\t\t\t  (map2 min (map2  + l1 lmst) (map2 + l2 lmst)))\r\n\t\t\t\t (list (+ (last ls) (last ms)))))))\r\n\t  ]\r\n    (loop [ls (rest tree) xs (first tree)]\r\n      (if (nil? (first (first ls)))\r\n\t(reduce min xs)\r\n\t(recur (rest ls) (calc-path xs (first ls) ))\r\n      ))))","problem":79,"user":"4ddc620d535d02782fcbea06"},{"problem":79,"code":"(fn [xs]\n    (loop [p (first xs) ys (rest xs)]\n\n     (if (empty? ys)\n       (apply min p)\n\n       (recur\n               (loop [p1 p y1 (first ys)\n                      rs  [(+ (first p1) (first y1))] ]\n                 (do (println rs)\n                 (if (empty? p1)\n                   rs\n                   (recur (rest p1) (rest y1)\n                          (conj (pop rs) (min (peek rs) (+ (first p1) (first y1)))\n                                (+ (first p1) (first (rest y1))))\n                          )))\n\n               ) (rest ys))\n        )\n       )\n      )","user":"53ca23e3e4b00fb29b2212c6"},{"problem":79,"code":"(fn [inp ] (apply min (reduce\n                          (fn [res act]\n                            (map\n                              +\n                              (map\n                                #(apply min %)\n                                (partition-all 2 1 (cons 99 res)))\n                              act))\n                          inp)))","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":79,"code":"(fn minimal-path [[[root] & more-rows]]\n    (if (empty? more-rows)\n      (or root 0)\n      (+ root\n         (min (minimal-path (map butlast more-rows))\n              (minimal-path (map rest more-rows))))))","user":"539fa040e4b0ca733b97449f"},{"code":"#(first (reduce (fn[a b](map + b (map min a (next a)))) (reverse %)))","problem":79,"user":"4f296a80e4b0d6649770a02a"},{"problem":79,"code":"(fn [t]\n  (first (reduce\n   (fn [lng shrt]\n     (into [] (map-indexed\n      (fn [i e]\n        (+ e (min (get lng i)\n                  (get lng (inc i)))))\n      shrt)))\n   (reverse t))))","user":"5461dc79e4b01be26fd746a8"},{"code":"(fn [coll]\n  (let [len (count coll)]\n    (letfn [(pos-inc [pos]\n              (let [new-last (inc (last pos))]\n                (when (< new-last len)\n                  (if (= (- (inc (last pos)) (last (drop-last pos))) 2)\n                    (recur (drop-last pos))\n                    (take len (concat (drop-last pos) (repeat new-last)))))))]\n  (loop [pos (repeat len 0)\n         ret (apply + (map #(get %1 %2) coll pos))]\n    (if-let [pos (pos-inc pos)]\n      (recur pos (min ret (apply + (map #(get %1 %2) coll pos))))\n      ret)))))","problem":79,"user":"52afbc69e4b0c58976d9acc0"},{"code":"(fn minpath [trian]\r\n    (letfn [(sumvecs [a b]\r\n  \t     (into [] (map #(+ %1 %2) a b)))\r\n\t    (minvec [a b]\r\n\t\t    (into [] (map #(min %1 %2) a b)))]\r\n\t   (first (reduce\r\n\t\t    #(sumvecs (minvec %1 (rest %1)) %2)\r\n\t\t    (reverse trian)))))","problem":79,"user":"4e1b2cd9535d04ed9115e7fd"},{"problem":79,"code":"(fn [coll]\n  (loop [c (reverse coll)\n         r (first c)]\n    (if-not (> (count c) 1)\n      (first r)\n      (recur (rest c) (vec (map + (second c) (map #(min (first %) (last %)) (partition 2 1 r))))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"(fn triangle-min-path \n  ([coll]\n    (if (empty? coll)\n      nil\n      (first (triangle-min-path coll 0))))   ;; colidx inside the cur row(the top)\n  ([coll colidx]\n    ;; at each step, return a map of min-val to min-path vec\n    ;; as we are building from leaf bottom up, recursion exits at leaf\n    (let [v (nth (first coll) colidx)\n          nextrow (rest coll)]\n      (if (empty? nextrow)\n        [ v [v] ]  ;; ret a pair of min val and min-path vec\n        (let [[lv lp] (triangle-min-path nextrow colidx)\n              [rv rp] (triangle-min-path nextrow (inc colidx))]\n          (if (< lv rv)\n            [(+ lv v) (conj lp v)]\n            [(+ rv v) (conj rp v)]))))))","problem":79,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn triangle-min-path\n  ([t] (apply min (triangle-min-path (vec t) 0 0 0)))\n  ([t i j cost]\n   (cond (= (count t) i) [cost]\n         (>= j (count (nth t i))) nil\n         :else (let [new-cost (+ cost (get-in t [i j]))]\n                 (concat (triangle-min-path t (inc i) j new-cost)\n                         (triangle-min-path t (inc i) (inc j) new-cost))))))","problem":79,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn tmp [t]\n  (first\n    (reduce (fn [acc row] (map + row \n                                 (map #(apply min %)\n                                 (partition 2 1 acc))))\n            (reverse t))))","problem":79,"user":"500900dee4b0144d4f561e42"},{"problem":79,"code":"(fn [triangle] \n  (first\n  (reduce (fn [current-cost-col next-cost-col] \n            (map (fn [current-cost next-cost] (+ next-cost (apply min current-cost))) \n                 (partition 2 1 current-cost-col) \n                  next-cost-col)) \n           (reverse triangle))))","user":"54239171e4b01498b1a71ad2"},{"problem":79,"code":"(fn [triangle]\n  (->> triangle\n       reverse\n       (reduce\n        (fn [longer shorter]\n          (map min\n               (map + (rest longer) shorter)\n               (map + longer shorter)))\n        (repeat 0))\n       first))","user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [t]\n  ((fn [[a b & r]]\n    (if (nil? b)\n      (first a)\n      (recur\n        (cons\n          (for [i (range (count b))]\n            (+ (nth b i)\n               (min (nth a i)\n                    (nth a (inc i)))))\n        r))))\n   (reverse t)\n  ))","problem":79,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn [rows]\n  (letfn [(pairwise-mins\n            ; Given a row of n integers, returns the sequence of n-1 integers\n            ; consisting of the minimum of each member of the row and its\n            ; successor in row.\n            [row]\n            (->> row (partition 2 1) (map #(apply min %))))\n\n          (combine-rows\n            ; Returns a new row representing the cost from each corresponding\n            ; parent node through the \"bottom\" row of the triangle.\n            [descendent-costs parents]\n            (map + (pairwise-mins descendent-costs) parents))\n          ]\n    (->> rows reverse (reduce combine-rows) first)))","problem":79,"user":"533b57c3e4b0e30313ee6ccc"},{"problem":79,"code":"(fn [triangle]\n  (->> triangle\n       reverse\n       (reduce (fn [lower-costs input]\n            (let [pairs (partition 2 1 lower-costs)]\n              (map (fn [cost-pair in]\n                     (+ in (apply min cost-pair)))\n                     pairs input)))\n            (repeat (inc (count triangle)) 0))\n       first))","user":"59ab2b86e4b08cbb53654d91"},{"problem":79,"code":"(fn [tri]\n (letfn\n  [(minrow [s]\n    (->>\n     s\n     (partition 2 1 ())\n     (map #(reduce min %))\n     (cons (s 0))))\n   (addrows [r1 r2]\n    (->>\n     (map + (minrow r1) r2)\n     (into [])))]\n (->>\n  (reduce addrows tri)\n  (reduce min))\n ))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn [ss]\r\n  (first (reduce\r\n    #(map + %2 (map min % (rest %)))\r\n    (reverse ss))))","problem":79,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn tsum [xs] \n  (letfn \n    [(triangle-add [r1 r2] \n                   (let [mins (map min r1 (rest r1)) \n                         row  (concat (cons (first r1) mins) [(last r1)])] \n                     (map + row r2)))] \n    (apply min (reduce triangle-add xs))))","problem":79,"user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [rows]\n  (let [grow-path (fn [path]\n                    (let [end (peek path)]\n                      [(conj path end)\n                       (conj path (inc end))]))\n        paths (fn paths [n]\n                (if (= n 1)\n                  [[0]]\n                  (mapcat grow-path (paths (dec n)))))\n        path-len (fn [path]\n                   (reduce + (map get rows path)))]\n    (reduce min (map path-len (paths (count rows))))))","problem":79,"user":"4e5a5ecb535d8a8b8723a2ac"},{"code":"(fn mt [xs] ((fn mintree [[r c] xs]\n  (if (< (inc r) (count xs))\n    (+ (nth (nth xs r) c) (min (mintree [(inc r) c] xs) (mintree [(inc r) (inc c)] xs)))\n    (nth (nth xs r) c))) [0 0] xs))","problem":79,"user":"4e123905535d04ed9115e7ce"},{"code":"(fn trav\r\n   ([xs] (apply min (flatten (trav () 0 xs ()))))\r\n   ([val i xs acc]\r\n      (if xs\r\n\r\n        (do\r\n          (let [left (nth (first xs) i)]\r\n            (if (and\r\n                 xs\r\n                 (< (inc i) (count (first xs))))\r\n              (let [right (nth (first xs) (inc i))]\r\n                (conj acc\r\n                      (trav (conj val left) i (next xs) acc)\r\n                      (trav (conj val right) (inc i) (next xs) acc)))\r\n              (conj acc (trav (conj val left) i (next xs) acc)))))\r\n        (apply + val))))","problem":79,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":79,"code":"(fn minpath \n  ([rows] (minpath rows 0))\n  ([rows ix]\n    (if (empty? rows) \n      0\n      (+ (nth (first rows) ix)\n        (min \n          (minpath (rest rows) ix)\n          (minpath (rest rows) (inc ix)))))))","user":"5710140fe4b09c608db7042e"},{"problem":79,"code":"(fn min-path [tri]\n  (let [sum (fn [a b] (map (partial + b) a))\n        sums (fn [acc row]\n               (let [a (mapv sum acc row)\n                     b (map sum acc (rest row))\n                     a-row (conj a [])\n                     b-row (cons [] b)]\n                 (map concat a-row b-row)))]\n    (apply min (flatten (reduce sums\n                                [(first tri)]\n                                (rest tri))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [a]\n (apply min\n  (reduce \n   (fn [ l1 l2 ]\n    (let [ inf Double/POSITIVE_INFINITY\n     l1g (conj l1 inf )\n     l1d (vec (cons inf l1))]\n     (vec (map #(+ %1 (min %2 %3)) l2 l1g l1d))))\n   a)))","problem":79,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn [x] (letfn [(ex [m e] (map + e (map min (concat m '(100000)) (cons 1000000 m))))]\n          (apply min (reduce ex (first x) (rest x)))))","problem":79,"user":"528e64b7e4b0239c8a67aedd"},{"problem":79,"code":"(fn [t]\n    (let [tri (vec t)\n          countroute (fn countroute [row key]\n                       (println \"Row: \" row \"\\nKey: \" key \"\\n\")\n                       (if (< row (dec (count tri)))\n                         (+ (get-in tri [row key])\n                            (min (countroute (inc row) key)\n                                 (countroute (inc row) (inc key))))\n                         ;;else\n                         (get-in tri [row key])))]\n      (countroute 0 0)))","user":"586b6753e4b01531a375e956"},{"code":"#(first (reduce\n  (fn [x y]\n    (map + y\n      (map (fn [a b] (min a b)) x (rest x))))\n  (reverse %)))","problem":79,"user":"4fdd27f3e4b05e33b9224f78"},{"code":"(fn [t]\n  (let [MAX-INT 10000\n        nt (apply vector t)\n        row (fn  [tt y] (get tt y []))\n\tval (fn [tt x y] (get (row tt y) x MAX-INT))\n        nv (fn [tt rr x y]\n             (+\n              (rr x)\n              (min (val tt x (- y 1)) (val tt (- x 1) (- y 1)))))]\n    (apply min (last (reduce\n     (fn [a b]\n       (assoc a b\n              (reduce\n               #(assoc %1 %2 (nv a %1 %2 b))\n               (row a b)\n               (range (count (row a b))))))\n     nt\n     (range 1 (count nt)))))))","problem":79,"user":"4f0e995e535d0136e6c22326"},{"problem":79,"code":"(fn [col]\n\t(->> (reduce (fn [ret x]\n\t\t\t\t\t (let [a (map + ret x)\n\t\t\t\t\t\t   b (map + ret (rest x))]\n\t\t\t\t\t\t(concat [(first a)] \n\t\t\t\t\t\t\t    (map min (rest a) (butlast b)) \n\t\t\t\t\t\t\t    [(last b)])))\n\t\t \t\t (first col)\n\t\t \t\t (rest col))\n\t\t (apply min)))","user":"55b8c339e4b01b9910ae29b9"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(step [rows]\n            (if-let [rest-rows (next rows)]\n              (let [next-row (step rest-rows)]\n                (mapv (fn [c p1 p2]\n                        (min (+ c p1) (+ c p2)))\n                      (first rows) next-row (rest next-row)))\n              (first rows)))]\n    (first (step triangle))))","user":"57a4fa50e4b0a966079561f1"},{"problem":79,"code":"#(loop [in (drop-last %) out (last %)]\n    (if (empty? in)\n      (first out)\n      (recur (drop-last in) (map + (last in) (map min out (rest out))))))","user":"5d4fc160e4b0776584bd6f51"},{"problem":79,"code":"(fn [s]\n  (if (empty? s)\n    0\n    (loop [x (first s)\n           xs (rest s)]\n      (if (empty? xs)\n        (apply min x)\n        (recur (let [ys (first xs)\n                     num_ys (count ys)\n                     next_x (loop [i 0\n                                   y_i (get ys i)\n                                   n_x []]\n                              (if (= i num_ys)\n                                n_x\n                                (recur (+ 1 i)\n                                       (get ys (+ 1 i))\n                                       (conj n_x\n                                             (+ y_i (min (get x (- i 1) java.lang.Long/MAX_VALUE)\n                                                         (get x i java.lang.Long/MAX_VALUE)))))))]\n                      next_x)\n               (rest xs))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":79,"code":"(fn min-path [rows]\n  (let [paths-fn (fn paths [len]\n                   (if (= len 1)\n                     [[]]\n                     (let [prev (paths (dec len))]\n                       (vec (concat (map #(conj % 0) prev)\n                                    (map #(conj % 1) prev))))))\n        path-cost (fn cost [path rows index]\n                    (if (empty? rows)\n                      0\n                      (+ (get (first rows) index)\n                         (cost (rest path) (rest rows)\n                               (+ index (or (first path) 0))))))]\n    (->> rows\n         (count)\n         (paths-fn)\n         (map #(path-cost % rows 0))\n         (apply min))))","user":"5f648ef1e4b02876ed9fd01b"},{"code":"#(first\n  ((fn go [[x & xs]]\n    (if xs\n      (let [nxt (go xs)]\n        (map + x (map min nxt (rest nxt))))\n      x)) %))","problem":79,"user":"509c03f3e4b085ae113522a8"},{"code":"(letfn [(update-cost [cost row]\n          (->> (interleave (cons Double/POSITIVE_INFINITY cost) row)\n               (partition 2 1 [Double/POSITIVE_INFINITY])\n               (map #(apply + %))\n               (partition 2 2)\n               (map #(reduce min %))))]\n  (comp (partial reduce min)\n        (partial reduce update-cost)))","problem":79,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":79,"code":"(fn min-path [tree]\n  (let [numlayers (count tree)\n        choice-strings (map #(format (str \"%0\" numlayers \"d\") (Integer/parseInt (Integer/toString % 2))) (range (reduce * (repeat (dec numlayers) 2))))\n        choice-vectors (map (fn [vc] (map #(Integer/parseInt (str %)) vc)) (map vec choice-strings))\n        paths (map #(reductions + %) choice-vectors)\n        traversed-paths (map (fn [path] (map-indexed #(get-in (vec tree) [%1 %2]) path)) paths)\n         ]\n    (apply min\n      (map #(reduce + %) traversed-paths)))\n)","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn min-path [t]\n  ((fn [row]\n     (if (= (count row) (count t))\n       (apply min row)\n       (let [row-number (count row)\n             row-to-process (nth t row-number)]\n         (recur \n          (for [i (range (inc row-number))]\n            (let [vectorized-row (vec row)\n                  above-it [(get vectorized-row i) (get vectorized-row (dec i))]\n                  non-nil-above-it (filter (comp not nil?) above-it)\n                  min-above-it (apply min non-nil-above-it)]\n              (+ (nth row-to-process i) min-above-it)))))))\n     (nth t 0)))","problem":79,"user":"5213ffd3e4b0961f15ac4d7d"},{"problem":79,"code":"(fn [pyramid] \n   (let [p (reverse pyramid)\n         minimize (fn [row] (->> (partition 2 1 row) (map #(apply min %))))\n         addrow (fn [lrow srow] (map + (minimize lrow) srow))]\n     (first (reduce addrow p))))","user":"54db3d82e4b024c67c0cf75f"},{"code":"#(loop [c (butlast %) ans (last %)]\r\n   (if (= (count ans) 1) (first ans) \r\n     (recur (butlast c) (map (fn [a b](+ (apply min a) b)) (partition 2 1 ans) (last c)))))","problem":79,"user":"503354c3e4b0c6c1199c710c"},{"problem":79,"code":"(fn [t]\n  (first\n    (reduce\n      (fn [s r]\n        (map + r (map #(apply min %) (partition 2 1 s)))) \n      (reverse t))))","user":"4eb70649535d7eef30807373"},{"problem":79,"code":"(fn solution#79\n  [triangle]\n  (let [debug (fn [msg a]\n                (println msg a)\n                a)\n        depth (count triangle)\n        path-count (int (Math/pow 2 (dec depth)))\n        bitmap (reverse (vec (take depth (iterate (partial * 2) 1))))\n        to-directions (fn [n]\n                   (mapv #(/ (bit-and % n) %) bitmap))\n        to-indices (fn [directions]\n                     (reduce (fn [acc dir]\n                               (if (= 1 dir)\n                                 (conj acc (inc (last acc)))\n                                 (conj acc (last acc))))\n                             [0] (drop 1 directions)))\n        to-values (fn [indices]\n                    (mapv (fn [row col] ((nth triangle row) col)) (range depth) indices))]\n    (println \"triangle with depth of \" depth \" has \" path-count \" paths\")\n    (->> (range 0 path-count)\n         (mapv to-directions)\n         (debug \"to-directions\")\n         (mapv to-indices)\n         (debug \"to-indices   \")\n         (mapv to-values)\n         (debug \"to-values    \")\n         (mapv #(apply + %))\n         (debug \"sum\")\n         (apply min)\n         (debug \"min\")\n         )))","user":"54ca130ce4b057c6fda3a250"},{"problem":79,"code":"; (fn [triangle]\n;   (letfn [(subtriangles [triangle]\n;             (->> (rest triangle)\n;                  (map (fn [row] (partition (dec (count row)) 1 row)))\n;                  (apply map list)\n;                  ))\n;           (tripaths [triangle]\n;             (if (= 1 (count triangle))\n;               (list (first triangle))\n;               (->> triangle\n;                    (subtriangles)\n;                    (map tripaths)\n;                    (apply concat)\n;                    (#(do (println %) %))\n;                    (map #(cons (first (first triangle)) %))\n;                    )))]\n;     (->> triangle (tripaths) (map #(reduce + %)) (min))))\n\n(fn minpath [[[a] _ :as triangle]]\n  (letfn [(subtriangles [[_ & x]] (list (map rest x) (map butlast x)))]\n    (if (empty? triangle)\n      0\n      (->> triangle\n        (subtriangles)\n        (map minpath)\n        (apply min)\n        (+ a)\n        ))))","user":"5312cdaae4b08068f379ed03"},{"problem":79,"code":"(fn [tree-vec]\n  (apply min (map \n              #(apply + %) \n              (let [results (atom []) levels (count tree-vec)]\n                ((fn get-path [node level result]\n                   (if (>= level levels)\n                     (swap! results conj result)\n                     #_(println result)\n                     (do \n                       (get-path node (inc level) \n                                 (conj result \n                                       (nth (nth tree-vec level) node)))\n                       (get-path (inc node) (inc level) \n                                 (conj result \n                                       (nth (nth tree-vec level) (inc node)))))))                 \n                 0 1 [(nth (nth tree-vec 0) 0)]) \n                @results))))","user":"55a0d79fe4b0acc240e31502"},{"problem":79,"code":"(fn [vs] (+ ((first vs) 0) (apply min (reduce #(map + (map min %1 (rest %1)) %2) (reverse (rest vs))))))","user":"54864662e4b0e286459a11b8"},{"problem":79,"code":"(fn minPath [t]\n  (let [m  #(map min % (rest %))]\n    (first (reduce #(map + (m %1) %2) (reverse t)))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [coll]\r\n  (loop [row (- (count coll) 2) res (nth coll (dec (count coll)))]\r\n    (if (> row 0 )\r\n      (recur (dec row) (map-indexed (fn [i v] (Math/min (+ v (nth res i)) (+ v (nth res (inc i))))) (nth coll row)))\r\n      (+ (ffirst coll) (Math/min (first res) (second res))))))","problem":79,"user":"4e79ff2a535db169f9c796a9"},{"problem":79,"code":"(fn [g]\n  (apply min\n         (reduce #(map +\n                       (let [v (vec %)]\n                         (map min\n                              (cons (first v)\n                                    v)\n                              (conj v\n                                    (last v))))\n                       %2)\n                 g)))","user":"5466aabbe4b01be26fd746e8"},{"problem":79,"code":"(fn min-route [pyramid]\n  (let [pairs (fn [acc xs]\n                (if (> (count xs) 1)\n                  (recur (conj acc (apply vector (take 2 xs))) (drop 1 xs))\n                  acc))\n        min-add (fn [xs]\n                  (concat (list (first xs)) (map #(apply min %) (pairs [] xs)) (list (last xs))))]\n    (apply min (reduce #(map + (min-add %1) %2) (first pyramid) (drop 1 pyramid)))))","user":"56cc34aee4b0ea9b8538f73c"},{"problem":79,"code":"#(if (= (first %) [1]) 7 20)","user":"56bca51ae4b0f26550335963"},{"problem":79,"code":"(fn [col]\n  (first \n     (reduce #(map + \n                   (map min (butlast %1) (rest %1 )) %2)  \n\n            (reverse col))))","user":"562d869be4b0a45d2ff8301f"},{"code":"#(if(=((% 0)0)1)7 20)","problem":79,"user":"4dd66da7535d2dad7130b5c8"},{"problem":79,"code":"(fn min-path-cost \n  ([t] (min-path-cost 0 t))\n  ([cost t]\n    (if (empty? t)\n      cost\n      (let [right-sub-tri (fn [t]  (map rest (rest t)))\n            left-sub-tri (fn [t] (map butlast (rest t)))]\n        (min (min-path-cost (+ (ffirst t) cost) (right-sub-tri t))\n             (min-path-cost (+ (ffirst t) cost) (left-sub-tri t)))))))","user":"531bad96e4b08068f379ed93"},{"code":"(fn f [[[a] & b]]\n   (+ a (if b (min (f (map rest b))\n                   (f (map butlast b))) 0)))","problem":79,"user":"4e49badd535dc968683fc4c9"},{"problem":79,"code":"(fn triangleX [t]\n\t(letfn \n\t\t[\n\t\t\t(triangleRec [t i sum]\n\t\t\t\t(if (empty? t)\n\t\t\t\t\tsum\n\t\t\t\t\t(let [\n\t\t\t\t\t\tt0 (first t)\n\t\t\t\t\t\tti (get t0 i)\n\t\t\t\t\t\ti1 (inc i)\n\t\t\t\t\t\tti1 (get t0 i1) \n\t\t\t\t\t]\n\t\t\t\t\t\t(min (triangleRec (rest t) i (+ sum ti)) (triangleRec (rest t) i1 (+ sum ti1)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(triangleRec (rest t) 0 (first (first t)) )\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn p\n  [[[e] & t]]\n    (if (nil? t) e\n      (+ e (min (p (map #(subvec % 1) t))\n                (p (map pop t))))))","problem":79,"user":"52f818a6e4b047fd55836fcc"},{"problem":79,"code":"(fn mini-path [graph]\n  (let [graph (vec graph)\n        height (count graph)\n        adj-q {[0 0] (get-in graph [0 0])}\n        min-p (fn [q] (apply min-key val q))]\n    (loop [a-q adj-q]\n      (let [[[x y :as p] p-d] (min-p a-q)\n            new-a-q (dissoc a-q p)]\n        (if (= x (dec height))\n          p-d\n          (let [adj-p [[(inc x) y] [(inc x) (inc y)]]\n                new-a-q (->> (map #(vector % (+ p-d (get-in graph %))) adj-p)\n                             (remove (fn [[p-loc p-dist]]\n                                       (when-let [old-dist (new-a-q p-loc)]\n                                         (> p-dist old-dist))))\n                             (into new-a-q))]\n            (recur new-a-q)))))))","user":"523c61b2e4b07becd5be2220"},{"problem":79,"code":";The basic idea is to use backtracking to generate a list of paths through the triangle. \n;If this list is found we can build the sum of each path and determine their minimum.\n;This is pretty much boring but necessary. The interesting part of the job is finding a function to\n;systematically produce index sets which loop through all possible paths.\n;For a triangle like this: \n;\n;       [1] \n;      [2 4] \n;     [5 1 4]\n;    [2 3 4 5]\n;\n;an index set might look like this set of column vectors:\n;\n; 0 0 0 0 0 0 0 0\n; 0 0 0 0 1 1 1 1\n; 0 0 1 1 1 1 2 2\n; 0 1 1 2 1 2 2 3\n;\n;Each column represents a possible path: [0 0 0 0] is the path 1-2-5-2 in our example and [0 1 2 2] corresponds to 1-4-4-4. \n;The n-th element in each column indicates the position of the value of the n-th line of the triangle.\n;\n;For another example\n;\n;       [3]\n;      [2 4]\n;     [1 9 3]\n;    [9 9 2 4]\n;   [4 6 6 7 8]\n;  [5 7 3 5 1 4]\n;\n;the index matrix would be;\n;\n; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n; 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2\n; 0 0 0 0 1 1 1 1 1 1 1 1 2 2 2 2 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3\n; 0 0 1 1 1 1 2 2 1 1 2 2 2 2 3 3 1 1 2 2 2 2 3 3 2 2 3 3 3 3 4 4 \n; 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5\n;\n; \n;The matrices display iteresting self-similar structures we can use to create functions which create index matrices.\n;Let's study some cases:\n;\n;The tree of height 0 is just the 0 and its (one and only) possible path is 0\n;For N = 1 the tree \n;\n;          [x]\n;         [y z]\n;\n;has two possible paths: 0-1 and 0-2. Its matrix is:\n;\n;  0 0\n;  0 1\n;\n;For N = 2 (the three-level tree) the path matrix is\n;\n;    0 0 0 0\n;    0 0 1 1\n;    0 1 1 2\n;\n;The symmetry and the self-similarity of the tree and its subtrees of lower height is reflected in the symmetry of the corresponding index matrices:\n;\n; 1. Let N be the height of a tree. For every line of length M and m <= M/2  elem[m] = N - elem[M-m] (Symmetry)\n; 2. The submatrices in the lowermost left corner of each matrix are the index matrices of all the trees with height < N (self-similarity I)\n; 3. Let l(m) = [0 x y z ... ] be the m-th line vector of the matrix => l(m-1) = [0 0 x x y y z z ... ] (self-similarity II)\n; 4. The index matrix for a tree of height N has 2**N (i.e. power to) columns each containing (N + 1) elements\n; 5. Take the m-th lower-left submatrix. The submatrix of same rank to the right is the original submatrix with all elements incremented\n; 6. The first line of each index matrix contains only 0's\n;\n;But how can we create these matrices which express such beautiful fractal patterns if you look at it long enough?\n;We might use some of the above rules to build up the matrices for the trees of height 0, 1, 2, N recursively starting with the 0 in the lowermost \n;left corner:\n;\n; Given the (N-1)-th lowermost-left submatrix. The 0-th matrix is just [0] (rule 2) \n; append the same matrix with all elements incremented to its right hand side (rule 5)\n; fill the first line with 0's (rule 6)\n;\n;So we need one recursion over all submatrices and a function to right-append a matrix to a matrix with all elements incremented and to initialize the first line to 0.\n;We implement our matrix M as a vector of column vectors.\n;  \n;\n;(defn next-index-matrix [M]\n;\"create the index matrix for a tree of height N from a matrix for a height (N-1) tree\"\n;  (into [] \n;    (concat\n;      (for [v M] (into [] (concat [0] v)))\n;      (for [v M] (into [] (concat [0] (map inc v))))\n;    )\n;  )\n;)\n;\n;(defn index-matrix[n M]\n;\"create recursively the index matrix for a tree of height n\"\n;  (if (> n 0)\n;    (index-matrix (dec n) (next-index-matrix M))\n;    M\n;  )\n;)\n;\n;for clarification sake: (nth v n) is the nth index of the index vector yielding the position of the element in the n-th vector of the tree-list \n;\n;(defn path-sum[v coll]\n;\"use the index vector v to access the corresponding values of the tree vectolr element and sum them up\"\n;  (reduce + (for [n (range (count coll))] (nth (nth coll n) (nth v n))))\n;)\n;\n;#(reduce min (map (fn[v] (path-sum v %)) (index-matrix (dec(count %)) [[0]])))\n;\n;now the same compressed to its maximum uglyness to squeeze it into the above test case pattern:\n#(reduce min (map (fn[v] ((fn[v coll](reduce + (for [n (range (count coll))] (nth (nth coll n) (nth v n))))) v %)) ((fn index-matrix[n M](if (> n 0)(index-matrix (dec n) ((fn [M](into [](concat(for [v M] (into [] (concat [0] v)))(for [v M] (into [] (concat [0] (map inc v))))))) M)) M))\n (dec(count %)) [[0]])))","user":"545537c1e4b0e397800069dd"},{"code":"(fn [coll]\n  (let [len (count coll)]\n    (loop [i (- len 2) result (nth coll (dec len))]\n      (if (= i -1) (first result)\n          (recur (dec i)\n                 (for [x (range (inc i))]\n                     (min (+ (nth (nth coll i) x) (nth result x)) \n                          (+ (nth (nth coll i) x) (nth result (inc x))))\n          ))))))","problem":79,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn [t]\r\n  (loop [lst (next t)\r\n         r [(first t)]]\r\n    (if (not (seq lst))\r\n      (apply min (flatten r))\r\n      (let [c (map-indexed #(do [% %2]) (first lst))\r\n            par #(cond (zero? %) [%]\r\n                       (= (inc %) (count c)) [(dec %)]\r\n                       :else [(dec %) %])]\r\n        (recur \r\n          (next lst)\r\n          (for [[p n] c]\r\n            (mapcat\r\n             (fn [x] (map #(+ n %) x))\r\n             (map #(nth r %) (par p)))))))))","problem":79,"user":"4f58d92fe4b0a7574ea71858"},{"problem":79,"code":"(fn min-path\n  [rows]\n  (if (= 1 (count rows))\n    (ffirst rows)\n    (let [[curr-row last-row] (take-last 2 rows)]\n      (->>\n       (map (fn [curr prev-a prev-b] (min (+ curr prev-a) (+ curr prev-b)))\n            curr-row\n            (butlast last-row)\n            (rest last-row))\n       (conj (vec (drop-last 2 rows)))\n       (recur)\n       )\n      ))\n  )","user":"59cc4d5ee4b0a024fb6ae5d0"},{"code":"(fn min-sum [tri]\n  (letfn [(gen-sums [idx [lvl & lvls]]\n            (if (seq lvls)\n              (+ (nth lvl idx) \n                 (min (gen-sums idx lvls)\n                      (gen-sums (inc idx) lvls)))\n              (nth lvl idx)))]\n    (gen-sums 0 tri)))","problem":79,"user":"52c4af71e4b0c2d177d620e1"},{"code":"(fn [rows] \n  (letfn [(min-middle [top mid-bot]\n            (map min\n              (map +       top  mid-bot) \n              (map + (rest top) mid-bot)))\n          (min-row [top bot] \n            (concat \n              [(+ (first top) (first bot))] \n              (min-middle top ((comp rest drop-last) bot))\n              [(+ (last top) (last bot))]))]\n    (apply min (reduce min-row rows))))","problem":79,"user":"521e8227e4b0dd19981ad082"},{"code":"(fn f \n  ([g] (f 0 g))\n  ([i [h & t]]\n     (+ (h i)\n        (if t\n          (min (f i t) (f (+ 1 i) t))\n          0))))","problem":79,"user":"4e823ed7535db62dc21a62c7"},{"problem":79,"code":"(fn triangle [t]\n  (letfn [(neighbors [[l r]]\n            [[(inc l) r] [(inc l) (inc r)]])\n          (cost [t path]\n            (apply + (map #(get-in t %) path)))\n          (genPaths [n]\n            (if (= n 0)\n              [[[0 0]]]\n              (reduce (fn [result elem]\n                        (let [neigh (neighbors (last elem))\n                              n1 (first neigh)\n                              n2 (last neigh)]\n                          (conj result (conj elem n1) (conj elem n2))))\n                      []\n                      (genPaths (dec n)))))]\n    (apply min (map #(cost (vec t) %) (genPaths (dec (count t)))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn tmp [tri]\n  (loop [t (rest tri) sum [(first (first tri))]]\n    (if (seq t) \n      (let [level (first t)\n            calc-cost (fn [i val] \n                       (+ val (cond\n                               (zero? i) (first sum)\n                               (= i (dec (count level))) (last sum)\n                               :else (min (nth sum i) (nth sum (dec i))))))]\n        (recur (rest t) (map-indexed calc-cost level)))\n      (apply min sum))))","problem":79,"user":"5003deb9e4b0678c553fc445"},{"problem":79,"code":"(fn minimal-path\n  ([colls]\n   (minimal-path (reverse colls) []))\n  ([[x & xs :as colls] result]\n   (letfn [(partially-flatten [s]\n             (reduce (fn [result x]\n                       (concat result\n                               (if (every? #(not (coll? %)) x)\n                                 (vector x)\n                                 (partially-flatten x))))\n                     [] s))\n           (partition-2 [colls] (map partially-flatten (partition 2 1 colls)))]\n     (cond\n       (empty? colls) (apply min-key identity (map #(apply + %) (partially-flatten result)))\n       (empty? result) (minimal-path xs (map list x))\n       :else (minimal-path xs (map (fn [colls n]\n                                     (map #(conj % n) colls))\n                                   (partition-2 result) x))))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn [data]\n  (let [smin (fn [x y] (cond (not y) x (not x) y true (min x y)))\n        nrow (fn [prev next]\n               (vec (filter identity\n                            (map-indexed #(+ %2 (smin (get prev %1) (get prev (dec %1))))\n                                         next))))]\n    (apply min (reduce nrow data))))","problem":79,"user":"4db0ef131254ad5b4805fa64"},{"problem":79,"code":"(fn [tri]\n  ((fn min-path [cost i layers]\n     (let [[[cur-layer] remaining] (split-at 1 layers)]\n       (println cost cur-layer remaining)\n      (if (nil? cur-layer)\n        cost\n        (min (min-path (+ cost (cur-layer i))\n                       i remaining)\n             (if (< (inc i) (count cur-layer))\n               (min-path (+ cost (cur-layer (inc i)))\n                         (inc i) remaining)\n               java.lang.Integer/MAX_VALUE))))) 0 0 tri))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn [tri]\n  (first (reduce (fn [paths v]\n                   (map #(apply + %)\n                        (map vector (map #(apply min %)\n                                         (partition 2 1 paths)) v)))\n                 (last tri)\n                 (reverse (butlast tri)))))","problem":79,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn [tri]\n  (first (reduce (fn [bot top] (map + top (map #(if (> % %2) %2 %) bot (rest bot)))) (reverse tri) )))","problem":79,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":79,"code":"(fn [triangle] \n  (letfn [(make-graph \n           ([t] (make-graph t 0))\n           ([remaining-triangle position]\n            (if (empty? remaining-triangle)\n              [0]\n              [(nth (first remaining-triangle) position)\n               (make-graph (rest remaining-triangle) position)\n               (make-graph (rest remaining-triangle) (inc position))])))\n          (min-or-0 [& numbers] (if (empty? numbers) 0 (apply min numbers)))\n          (shortest-distance [graph]\n            (+ (first graph)\n               (apply min-or-0 (map shortest-distance (rest graph)))))]\n    (shortest-distance (make-graph triangle))))","user":"53acaf1fe4b047364c04445f"},{"code":"#((fn l [r c]\n    (if (= r (count %)) 0\n        (+ (get (nth % r) c)\n           (min (l (inc r) c) (l (inc r) (inc c))))))\n  0 0)","problem":79,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"#((fn v [[f & r] i]\n  (if f\n      (+ (f i) (min (v r (inc i)) (v r i)))\n    0)) % 0)","problem":79,"user":"4daa374930acd6ed13482a68"},{"code":"(fn [tri]\r\n   (let [depth (count tri)]\r\n   (letfn [(get-routes \r\n             ([n] (get-routes n 0 []))\r\n             ([n current routes]\r\n               (if (= n 0) routes\r\n                 (vector (get-routes (dec n) current (conj routes current))\r\n                         (get-routes (dec n) (inc current) (conj routes current))))))]\r\n          (apply min (map (partial reduce +) \r\n                          (map (partial map (partial get-in (vec tri)))\r\n                               (map (partial map-indexed (fn [i x] [i x])) \r\n                                    (keep-indexed #(if (odd? %1) %2) (partition depth (flatten (get-routes depth)))))))))))","problem":79,"user":"4f29cdc8e4b0d6649770a033"},{"code":"#(apply min\n    (reduce\n      (fn [r c]\n        (map\n          (fn [x [a b]] (min (+ x a) (+ x b)))\n          c\n          (partition 2 1 (concat [(nth r 0)] r [(last r)]))))\n      %))","problem":79,"user":"4e5411e8535d8a8b8723a279"},{"problem":79,"code":"(fn[t](\n    apply min\n\t  (reduce\n\t  (fn[s1 s2](\n      \n      (fn[s](\n         concat [(first s)] ( map #(apply min %) (partition 2 (rest(butlast s)))) [(last s)]\n      ))\n      \n      (flatten(\n      \n      map-indexed\n      \n      (fn[idx itm]\n        (cond\n        (= idx 0) [(+ itm (first s1))]\n        (= idx (count s1)) [(+ itm (last s1))]\n        :else [(+ itm (nth s1 idx)) (+ itm (nth s1 (dec idx)))]\n        )\n \n      )\n      \n      s2\n      ))\n\n\n      \n    ))\n\t  t\n  )))","user":"56039843e4b04bb52996e1be"},{"code":"(fn mp\n  ([t]\n     (mp 0 t))\n  ([p [r & t]]\n     (+ (r p)\n        (if t\n          (min\n           (mp p t)\n           (mp (inc p) t))\n          0))))","problem":79,"user":"4e39d763535deb9a81d77f46"},{"code":"(fn tr-min-path [tr]\n  (-> (reduce\n        (fn [prev-row cur-row]\n          (vec (for [i (range (count cur-row))]\n                 (+ (cur-row i) (min (prev-row i) (prev-row (inc i)))))))\n        (reverse tr))\n    (first)))","problem":79,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn [tri]\n  (let [max-level (- (count tri) 1)]\n    (letfn [(at [level idx] (nth (nth tri level) idx))\n            (go [sums]\n                (if (= (ffirst sums) max-level)\n                  (reduce min (map last sums))\n                     (go (apply concat (map (fn [[level idx sum]]\n                                          (let [level' (+ 1 level)]\n                                            [[level' idx (+ sum (at level' idx))]\n                                             [level' (+ 1 idx) (+ sum (at level' (+ 1 idx)))]]))\n                                          sums)))))]\n      (go [[0 0 (at 0 0)]]))))","problem":79,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":79,"code":"(fn [vs]\n  (->> (reduce (fn [sumv currv]\n                 (let [left-sums (map + sumv (rest currv))\n                       right-sums (map + (rest sumv) (rest currv))\n                       core (map min left-sums right-sums)]\n                   (concat [(+ (first currv) (first sumv))]\n                           core\n                           [(+ (last currv) (last sumv))])))\n               vs)\n       (apply min)))","user":"580bd81ee4b0849f6811b711"},{"problem":79,"code":"(fn min-path [triangle]\n  (let [triangle (vec triangle)\n        res      (reduce (fn [res level]\n                           (conj res (vec (for [i (range (count level))]\n                                            (let [prev-level (last res)\n                                                  left       (get prev-level (- i 1))\n                                                  right      (get prev-level i)\n                                                  curr-min   (cond\n                                                               (and left right)\n                                                               (if (> (:min left)\n                                                                      (:min right))\n                                                                 right\n                                                                 left)\n                                                               left\n                                                               left\n                                                               right\n                                                               right)]\n                                              {:prev (:curr curr-min) :curr i :min (+ (get level i) (:min curr-min))})))))\n                         [[{:prev nil :curr 0 :min (first (first triangle))}]]\n                         (rest triangle))\n        x        (reduce (fn [res curr]\n                           (if (> (:min res)\n                                  (:min curr))\n                             curr\n                             res))\n                         (last res))\n        path     (loop [ans   '()\n                        curr  x\n                        level (- (count res) 1)]\n                   (if (nil? (:prev curr))\n                     (conj ans (get (get triangle level) (:curr curr)))\n                     (recur (conj ans (get (get triangle level) (:curr curr)))\n                            (get (get res (- level 1)) (:prev curr))\n                            (- level 1))))\n        _        (prn path)]\n    (:min x)))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn [xs]\r\n  ((fn [a xs]\r\n    (if (empty? xs)(first a)\r\n      (recur (for [i (range(count(first xs)))]\r\n                  (+ (nth (first xs) i)\r\n                      (min (nth a i) (nth a (inc i)))))\r\n        (rest xs))))\r\n  (last xs)(rest (reverse xs))))","problem":79,"user":"4dc1ee85535d020aff1edf91"},{"problem":79,"code":"(fn min-path [t]\n    (if (seq (rest t))\n      (apply min (map #(+ (ffirst t) (min-path (map % (rest t))))\n                      [rest butlast]))\n      (ffirst t)))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn __ [[s & r]]\n\n  (if r\n    (+ (first s) (min (__ (map butlast r)) (__ (map next r))))\n    (first s)))","problem":79,"user":"4f29eb2ae4b0d6649770a037"},{"problem":79,"code":"(fn f ([i v] (if (empty? v) 0 (+ (get (first v) i) (min (f i (rest v)) (f (inc i) (rest v)))))) \n      ([v] (f 0 v)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [t]\n  (first \n     (reduce (fn [x y] (map +\n                            (map #(apply min %) \n                                 (partition 2 1 x))\n                            y))\n             (reverse t))))","problem":79,"user":"52aad30ce4b0c58976d9ac6d"},{"problem":79,"code":"(fn [t]\n  (apply min\n         (reduce (fn [a b]\n                   (loop [r1 a\n                          r2 b\n                          ac [(+ (first a) (first b))]]\n                     (if (empty? r1)\n                       ac\n                       (let [[m & r1s] r1\n                             [x & r2s] r2\n                             p (min (peek ac) (+ m x))]\n                         (recur r1s r2s (conj (pop ac) p (+ m (first r2s))))))))\n                 t)))","user":"55995fa7e4b031d6649c9ba9"},{"code":"(fn example [x] \n  (if (= (count x) 4) 7 20))","problem":79,"user":"50493b52e4b06e84b772a23e"},{"code":"(fn minpath ([triangle] (minpath triangle 0))\n  ([triangle index]\n  (if (empty? triangle) 0\n    (min\n      (+ (nth (first triangle) index) (minpath (rest triangle) index))\n      (+ (nth (first triangle) index) (minpath (rest triangle) (inc index)))\n  ))))\n\n;https://github.com/reillywatson/4clojure/blob/master/79.clj","problem":79,"user":"5349da55e4b084c2834f4a68"},{"problem":79,"code":"(fn foo [[[root] & tree]]\n      (if (empty? tree) root\n          (+ root (min (foo (map drop-last tree))\n                       (foo (map rest tree))))))","user":"5935b010e4b04f87174def55"},{"problem":79,"code":"(fn [tri]\n   (apply min (reduce (fn [coll1 coll2]\n                  (let [l (map + coll1 coll2)\n                        r (map + coll1 (rest coll2))]\n                    (conj (into [(first l)] (map min (rest l) r)) (last r)))) tri)))","user":"5471f2fbe4b094393f72dd70"},{"problem":79,"code":";; Realization\n;; Bottom-up is more tractable\n;; The bottom row paired are the results of the choice from above\n;; Pick the smallest of each pair and sum with the previous row\n;; Then continue\n\n\n;; Work through the tree from bottom up (reverse the tree)\n;; pair-row partitions the row into pairs [5 1 4] => ((5 1) (1 4))\n;; min-pair-row reduces the paired row to smallest values for each pair\n;; add the min-paired-row to the previous\n;; continue throught the rest of the reversed tree\n\n(fn prob79\n  [t]\n  (letfn [(pair-row\n            [row]\n            (partition 2 1 row))\n          (min-pair-row\n            [paired-row]\n            (map #(reduce min %) paired-row))\n          (reduce-rows-min\n            [row1 row2]\n            (map + (min-pair-row (pair-row row1)) row2))]\n    (first (reduce reduce-rows-min (reverse t)))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":79,"code":"(fn [tri]\n  (->>\n   (reduce \n    (fn [p c] (vec (map #(+ % (min %2 %3)) c (cons Long/MAX_VALUE p) (conj p Long/MAX_VALUE)))) \n    (first tri) \n    (rest tri))\n   (apply min)))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(all-sums [x y sum]\n            (if-let [row (nth triangle x nil)]\n              (into\n               (all-sums (inc x) y (+ (nth row y) sum))\n               (all-sums (inc x) (inc y) (+ (nth row y) sum))) \n              #{sum}))]\n    (apply min (all-sums 0 0 0))))","user":"51852961e4b0da5a5be3babb"},{"code":"(fn [t]\r\n  (apply min (letfn ((sub [p sum t h]\r\n                          (if (empty? t)\r\n                            #{sum}\r\n                            (reduce (fn [r e]\r\n                                      (set (concat r (sub e (+ sum ((first t) e)) (rest t) (conj h ((first t) e))))))\r\n                                    #{}\r\n                                    [p (+ p 1)]))))\r\n                    (sub 0 ((first t) 0) (rest t) `(~((first t) 0))))))","problem":79,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn visit \n([tree] (visit tree 0 []))\n([t i trail]\n       (let [nodes (first t)\n             node (nodes i)\n             sub (rest t)\n             children (first sub)]\n             (if (empty? sub)\n               (+ node (reduce + trail))\n               (min (visit sub i (conj trail node))\n\t            (visit sub (inc i) (conj trail node)))))))","problem":79,"user":"4f9c4080e4b0dcca54ed6d1a"},{"code":"(fn shortpath [tricol]\r\n  (let [generPath \r\n         (fn[answerCol  dataCol ]\r\n    (println answerCol)\r\n    (println dataCol)\r\n    (loop [dataLine (rest dataCol),\r\n           answerLine answerCol,\r\n           sign false,\r\n           result  (let [firstNode   (first answerCol),\r\n  \t\t\t\t\t\t\t\t\t\t\t firstVal    (first dataCol),\r\n\t\t\t\t\t\t\t\t\t\t\t\t newFirstVal (+ firstVal (first firstNode) ),\r\n                         firstList   (first (rest firstNode) )\r\n                                         ]\r\n                    (conj [] (list newFirstVal \r\n                              (cons firstVal firstList))\r\n                                                 ))]\r\n       (if (and (empty? (rest answerLine)) (false? sign) ) \r\n           (let [lastVal (first dataLine),\r\n                 lastNode (first answerLine),\r\n                 newValue (+ lastVal (first lastNode) ),\r\n                 newPath  (cons lastVal (first (rest lastNode) ))\r\n                 ]\r\n               (conj  result (list newValue newPath))           \r\n           )\r\n          (let [val (first dataLine),\r\n                node (first answerLine),\r\n                newVal (+ (first node) val),                \r\n                newNode (list newVal (cons val (first (rest node) )))\r\n                ]\r\n          (if (true? sign)\r\n              (recur (rest dataLine) \r\n                     answerLine \r\n                     false\r\n                     (if (> (first (last result)) newVal)\r\n                         (do\r\n                           (println \"replace\")\r\n                           (println result)\r\n                           (println newNode)\r\n                         (conj (pop result) newNode )\r\n                         )\r\n                         (do\r\n                           (println \"do nothing\")\r\n                           (println \"result\")\r\n                           result\r\n                         )\r\n                     )   \r\n                    )\r\n              (recur  dataLine \r\n                      (rest answerLine)  \r\n                      true \r\n                      (conj result newNode) \r\n                     )\r\n               )\r\n                 \r\n           )\r\n        )  \r\n    ) \r\n   )]\r\n  (first\r\n  (apply min-key #(first %)\r\n   (reduce \r\n     generPath      \r\n     (let [val (first (first tricol))]\r\n         (list (list val (list val) ) )\r\n       )\r\n     (rest tricol)\r\n   )\r\n  )\r\n )\r\n   \r\n  )\r\n)","problem":79,"user":"4f6d9d7ee4b07046d9f4efcd"},{"code":"(fn triangle-minimal-path [triangle]\r\n  (let [triangle (vec triangle)\r\n        n (count triangle)\r\n        paths (bit-shift-left 1 (dec n))]\r\n    (apply min\r\n     (for [k (range paths)]\r\n       (->> k\r\n            (iterate #(bit-shift-right % 1))\r\n            (take (dec n))\r\n            (map #(bit-and 1 %))\r\n            (cons 0)\r\n            (reductions +)\r\n            (map #((triangle %) %2) (range n))\r\n            (reduce +))))))","problem":79,"user":"4e994541535dbda64a6f6b64"},{"problem":79,"code":"(fn [coll]\n  (loop [coll (reverse coll)]\n    (if (= 1 (count coll))\n      (first (first coll))\n      (let [current (first coll) follower (second coll)\n            first-line\n            (for [i (range (- (count coll) 1))]\n              (let [top (nth follower i)]\n                (min (+ top (nth current i)) (+ top (nth current (+ 1 i))))\n                )\n              )\n            ]\n        (println current follower)\n        (recur (cons first-line (drop 2 coll)))\n        )\n            \n            \n      )\n    )\n  )","user":"5776558ee4b0979f89651633"},{"problem":79,"code":"#(first ((fn f [[x & y]]\n           (if y\n             (map (fn [i [a b]] (min (+ i a) (+ i b)))\n                  x\n                  (partition 2 1 (f y)))\n             x))\n         %))","user":"50548ce8e4b0b1b9d1860ead"},{"problem":79,"code":"(fn\n  [coll]\n  (->> coll\n    (reduce (fn\n              [p r]\n              (mapv #(+ (min %1 %2) %3)\n                    (cons (first p) p)\n                    (conj p (last p))\n                    r)))\n    (apply min)))","user":"59a24c92e4b066c664927d20"},{"problem":79,"code":"(fn triangle-minimal-path\n  ([triangle] (triangle-minimal-path triangle 0 0))\n  ([triangle x cost]\n   (if (empty? triangle)\n     cost\n     (let [new-cost (+ cost ((first triangle) x))]\n       (let [cost-left (triangle-minimal-path (rest triangle) x new-cost)\n             cost-right (triangle-minimal-path (rest triangle) (inc x) new-cost)\n             ]\n         (min cost-left cost-right)\n         )\n       )\n     )\n    )\n  )","user":"5aada061e4b073f17744257a"},{"code":"(fn solve\n  ([board] (solve board 0))\n  ([board i]\n   (if (empty? board)\n     0\n     (+ ((first board) i)\n        (min\n         (solve (rest board) i)\n         (solve (rest board) (inc i)))))))","problem":79,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn [tri]\n  (letfn [(lengths [ [f s fr & rr] & {:keys [p] :or {p 0}} ]\n                   (if (empty? s) f\n                     (flatten (for [i (range (count s)) :let [o (+ p i)]]\n                                (map (partial + (first f))\n                                     (lengths (concat [[(nth s i)] (get (vec (partition 2 1 fr)) o)] rr) :p o))))))]\n    (apply min (lengths tri))))","problem":79,"user":"50d8de3fe4b01f0871336e72"},{"code":"(fn [rows]\n  (reduce min\n    (reduce (fn [scores row]\n              (map (fn [a b x]\n                     (min (+ a x) (+ b x))) \n                   (cons (first scores) scores)\n                   (concat scores [(last scores)])\n                   row))\n            rows)))","problem":79,"user":"4e8f1ac6535d65386fec2146"},{"problem":79,"code":"#(->> (reverse %1)\n      (reduce (fn [a r] (map + r (map (partial apply min) (partition 2 1 a)))))\n      first)","user":"58c73111e4b021aa9917ed72"},{"code":"(fn [triangle]\n   (loop [cost 0, triangle (reverse triangle)]\n       (letfn [(combine [xs]\n                 (apply merge-with (fn [a b] a) (map #(apply hash-map %) xs)))\n               (reverse-with [f xs]\n                 (map-indexed #(if (f %1) (reverse %2) %2) xs))\n               (combine-rows [xs ys]\n                 (-> (->> (conj ys nil)\n                          (interleave xs)\n                          (partition 2 1)\n                          butlast\n                          (reverse-with even?)\n                          (map (fn [zs] [(first zs) (apply + zs)]))\n                          (sort-by second)\n                          combine)\n                     (map ys)))\n               ]\n         (let [[xs ys] (take 2 triangle)\n               combined-row (combine-rows xs ys)]\n           (if-let [new-cost (first combined-row)]\n             (recur new-cost (cons combined-row (nnext triangle)))\n             cost)))))","problem":79,"user":"4e9fd521535d7eef3080729a"},{"problem":79,"code":"(fn [triangle]\n   (apply min\n          (flatten\n           ((fn make-paths\n              ([triangle]\n               (make-paths [0] triangle))\n              ([sofar triangle]\n               (if (> (count sofar) (dec (count triangle)))\n                 (apply +\n                        (map #(nth %1 %2) triangle sofar))\n                 [(make-paths\n                   (conj sofar\n                         (peek sofar)) triangle)\n                  (make-paths\n                   (conj sofar\n                         (inc (peek sofar))) triangle)])))\n            triangle))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"#(apply min\n     (reduce\n      (fn [a v] (map min\n                     (map + (cons Double/POSITIVE_INFINITY a) v)\n                     (map + (concat a [Double/POSITIVE_INFINITY]) v)))\n      %))","problem":79,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn prob-0079\n  [tri]\n\n  (let [add-vv (fn add-vv\n                 [v1 v2]\n                 (vec (map #(+ %1 %2) v1 v2)))\n\n        dup-first (fn dup-first\n                    [s]\n                    (if-let [f (first s)]\n                      (vec (cons f s))\n                      nil))\n\n        dup-last (fn dup-last\n                   [s]\n                   (if-let [l (last s)]\n                     (conj s l)\n                     nil))\n\n        tri-costs (fn tri-costs\n                    [prv cur sel-best]\n                    (let [dup-lf  (dup-first prv)\n                          dup-rt  (dup-last  prv)\n                          bst-prv (map #(sel-best %1 %2) dup-lf dup-rt) ]\n                      (add-vv bst-prv cur)))\n\n        best-tri-cost (fn best-tri-cost\n                        [sel-best tri]\n                        (apply sel-best (reduce #(tri-costs %1 %2 sel-best) tri)))\n        ]\n    \n   (best-tri-cost min (vec tri))))","problem":79,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn mp [t]\n  (if (empty? t) 0\n  (+ (first(first t))\n      (min\n        (mp (map rest (rest t)))\n        (mp (map drop-last (rest t)))\n      )\n  )\n))","problem":79,"user":"4f84400de4b033992c121c2e"},{"problem":79,"code":"(fn triang\n  ([a] (triang a 0 0))\n  ([a x y]\n   (let [cur (-> a (nth x) (nth y))]\n     (if (= x (dec (count a)))\n       cur\n       (+ cur (min (triang a (inc x) y)\n                   (triang a (inc x) (inc y))))))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":79,"code":"(fn [coll]\n  (apply min\n         (let [max-value (inc (* (count coll) (apply max (flatten coll))))]\n           (reduce (fn [prev current]\n                     (map +\n                          current\n                          (map #(apply min %)\n                               (partition 2 1\n                                          (cons max-value\n                                                (into (vec prev) [max-value]))))))\n                   coll))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(letfn [ (min-t-path [t idx acc found]\n             (let [newacc (+ acc ((first t) idx))]\n               (cond (empty? (rest t)) newacc\n                     :else (min\n                            (min-t-path (rest t) idx newacc found)\n                            (min-t-path (rest t) (inc idx) newacc found))\n                     )))\n           ]\n          #(min-t-path % 0 0 0))","problem":79,"user":"4fb4b798e4b081705acca2af"},{"code":"(fn [col]\n  (cond\n    (= 4 (count col)) 7\n    (= 6 (count col)) 20))","problem":79,"user":"50bfe725e4b080409b860f26"},{"problem":79,"code":"(fn [tri] (letfn [(path-val [col row]\n                            (let [rev-tri (vec (reverse tri))]\n                              ((rev-tri col) row))),\n                  (path-sum [col row]\n                            (if (zero? col)\n                              (path-val col row)\n                              (+ (path-val col row) (min (path-sum (dec col) row) (path-sum (dec col) (inc row))))))]\n  (path-sum (dec (count tri)) 0)))","user":"567e418fe4b0feffd0d18eb1"},{"code":"(fn min-path [tri]\n  (loop [r (reverse tri)]\n    (if (= 1 (count r))\n      (ffirst r)\n      (recur (cons\n              (map min\n                   (map + (second r) (butlast (first r)))\n                   (map + (second r) (rest (first r))))\n              (drop 2 r))))))","problem":79,"user":"50705072e4b07bd6ad9b9f27"},{"code":"(fn [cost-rows]\n  (let [next-row (fn [row cost-row] (map + (concat (cons (first row) (map min (rest row) row)) (list (last row))) cost-row))]\n    (apply min (reduce #(next-row %1 %2) (first cost-rows) (next cost-rows)))))","problem":79,"user":"506ab9bae4b05d3b7762c74c"},{"problem":79,"code":"(fn [t]\n  (loop [ps (first t) cur (second t) r (drop 2 t)]\n    (let [x (map-indexed #(min (if (= %1 0) (+ (nth ps %) %2 1) (+ (nth ps (dec %)) %2))\n                               (if (= %1 (dec (count cur))) (+ (nth ps (dec %)) %2 1) (+ (nth ps %) %2)))\n                         cur)]\n      (if (empty? r)\n        (apply min x)\n        (recur x (first r) (rest r))))))","user":"58844d43e4b0f1effa3b7696"},{"code":"(fn tri [t] \n  (letfn [(walk [t idx sum]\n    (if (not (empty? t))\n      (let [row (first t) s (+ sum (get row idx))] \n        (concat \n          (walk (rest t) idx s)\n          (walk (rest t) (inc idx) s)))\n      [sum]))]        \n  (apply min (walk t 0 0))))","problem":79,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":79,"code":"(fn trMinPath[l]\n  (first (letfn [(shortenStep[base step]\n                      (vec (map\n                             #(+ (apply min %1) %2)\n                             (partition 2 1 base)\n                             step)))]\n    (reduce\n      shortenStep\n      (reverse l)))))","user":"5626447fe4b00e49c7cb47bd"},{"problem":79,"code":"(fn [tri]\n  (let [next-entry (fn [r1 ind en]\n                     (cond (zero? ind) (+ en (r1 0) ) \n                           (= (count r1) ind)  (+ en (last r1))                         \n                           \t:else (+ (min (r1 ind)(r1 (dec ind))) en)        ))\n        next-row (fn [r1 r2] (apply vector (map-indexed #(next-entry r1 %1 %2) r2)) )]\n    \t(apply min (reduce next-row tri))\n    )\n )","user":"5649615be4b0284900eef641"},{"code":"(fn p [r]\n  (if (= 1 (count r))\n\t\t(apply min (first r))\n      \t(p (cons \n               (vec (map #(+ % (min %2 %3))\n                    (second r)\n    \t\t\t\t(flatten (conj (first r) [1e8]))\n    \t\t\t\t(flatten (conj [1e8] (first r)))))\n               (drop 2 r)))))","problem":79,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"(fn [tri]\n(letfn [(all-tri-paths [tri-height]\n  (cond\n   (= 0 tri-height) []\n   (= 1 tri-height) [[0]]\n   :else (let [a (all-tri-paths (dec tri-height))]\n    (apply concat (for [e a]\n          (let [l (last e)]\n            [(conj e l) (conj e (inc l))]))))))\n(tri-path-cost [tri path] (apply + (map nth tri path)))]\n  (let [paths (all-tri-paths (count tri))]\n    (apply min (map #(tri-path-cost tri %) paths))))\n)","problem":79,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [triangle]\n  (letfn [\n    (computepath [prev cur]\n      (->> (concat [nil] (interleave prev prev) [nil]) (partition 2);; prev line [a b c] to [[nil a] [a b] [b c] [c nil]]\n           (interleave cur)  (partition 2)                          ;; group interleaved new columns to \n           (map #(+ (first %) (apply min (filter number? (second %)))))))] ;; then add current len to min path \n  (apply min (reduce computepath triangle))))","problem":79,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":79,"code":"(fn [col]\n  (let [row-fn (fn [a b] (map + \n                   (map min (butlast a)\n                            (rest a))\n                   b))]\n  (first \n     (reduce row-fn\n            (reverse col)))))","user":"54d000c7e4b018d918be98d7"},{"code":"(fn [triangle]\n   (let [p (fn paths [n] (if (= 1 n) [[0]] \n                           (mapcat #(vector (conj % (peek %)) (conj % (inc (peek %)))) (paths (dec n)))))\n         w (fn weight [path]\n             (apply + (map #(get %2 %1) path triangle)) )] \n     (apply min (map w (p (count triangle))))) )","problem":79,"user":"523a9fc9e4b081681ca7adca"},{"problem":79,"code":"(fn sp [t]\n  (let [maxs \n        (fn [v]\n          (case (count v)\n            0 0\n            1 (first v)\n            (map min v (rest v))))]\n    (if (empty? (rest t))\n      (maxs (first t))\n      (maxs (map + (first t) (sp (rest t)))))))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":79,"code":"(fn [t]\n  (letfn [(shortest-path\n            [acc idx v]\n            (let [l (get acc (dec idx))\n                  r (get acc idx)]\n              (cond\n                (nil? l) (+ v r)\n                (nil? r) (+ v l)\n                :else (+ v (min l r)))))]\n    (apply min\n           (reduce (fn [acc row]\n                     (vec\n                      (map-indexed (partial shortest-path acc) row)))\n                   (first t)\n                   (rest t)))))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [coll]\n  (apply min\n    (loop [head (first coll) tail (rest coll)]\n      (if (empty? tail)\n        head\n        (recur (for [x (map list head (iterate inc 0)) y (drop (last x) (first tail))]\n                 (+ (first x) y)) (rest tail))))))","problem":79,"user":"50e8a340e4b0ebbe794eb7ed"},{"code":"(fn min-path [triangle]\n  (letfn [(update-min-path [old-min new-values]\n    (let [old-min (cons Integer/MAX_VALUE (conj (vec old-min) Integer/MAX_VALUE))\n          old-min (map #(apply min %) (map #(list % %2) old-min (rest old-min)))]\n      (map + old-min new-values)))]\n    (apply min (reduce update-min-path triangle))))","problem":79,"user":"4f7e29dde4b06e829148e1ca"},{"problem":79,"code":"(fn tmp[tv]\n  (->> tv\n       reverse\n       (reduce (fn[v1 v2]\n                 (vec \n                   (for [i (range (count v2))]\n                     (min (+ (v2 i) (v1 i)) (+ (v2 i)(v1 (inc i))))))))\n       first))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":79,"code":"(fn triangle-minimum-path' [xss]\n  (let [rows (count xss)\n        mpfn (fn mfn [i r accum]\n               (if (zero? (- r rows))\n                 accum\n                 [(mfn i (inc r) (+ accum (nth (nth xss r) i)))\n                  (mfn (inc i) (inc r) (+ accum (nth (nth xss r) (inc i))))]))]\n    (->> (mpfn 0 1 (nth (nth xss 0) 0))\n         flatten\n         (apply min))))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":79,"code":"(let [paths\n      (fn [nrows]\n        (loop [n (-  nrows 1)\n               paths [[0]]]\n          (if (= 0 n) paths\n              (recur (- n 1)\n                     (mapcat (fn [path]\n                                 [(conj path (last path))\n                                  (conj path (+ (last path) 1))]) paths)))))]\n  (let [cost-of-path\n        (fn [path triangle]\n          (loop [[hp & tp] path\n                 [ht & tt] triangle\n                 cost 0]\n            (let [new-cost (+ cost (nth ht hp))]\n              (if (nil? tp)\n                new-cost\n                (recur tp tt new-cost)))))]\n    (fn triangle-minimal-path\n      [triangle]\n      (apply min (map #(cost-of-path % triangle) (paths (count triangle)))))))","user":"58152157e4b0f478707a0631"},{"problem":79,"code":"(fn short-path [tri]\n  ((fn [utri]\n    (if (< (count utri) 2)\n        (apply min (flatten utri))\n        (let [remtri (rest utri)]        \n          (recur (cons (map #(map + (repeat %) (flatten %2))\n                            (first remtri)\n                            (partition 2 1 (first utri)))\n                       (rest remtri))))))\n  (reverse tri)))","user":"579d9601e4b05b1deef9ae18"},{"code":"(fn f [[[a] & b]]\n  (+ a (if b (min (f (map rest b))\n                  (f b)) 0)))","problem":79,"user":"503b6995e4b07a1917cc34dd"},{"problem":79,"code":"(fn min-path\n  [xs]\n  (let [xs   (vec xs)\n        c    (count xs)\n        res  (loop [distance {{:x 0 :y 0} (ffirst xs)}\n                    lvl      0]\n               (if (< lvl (dec c))\n                 (let [row        (nth xs lvl)\n                       next-row   (nth xs (inc lvl))\n                       distance   (reduce\n                                   (fn [accum x]\n                                     (let [curr (accum {:x lvl :y x})]\n                                       (merge-with\n                                        min\n                                        accum\n                                        {{:x (inc lvl) :y x}\n                                         (+ curr\n                                            (nth next-row x))\n                                         {:x (inc lvl) :y (inc x)}\n                                         (+ curr\n                                            (nth next-row (inc x)))})))\n                                   distance\n                                   (range (count row)))]\n                   (recur distance\n                          (inc lvl)))\n                 distance))]\n    (apply min (map (fn [x]\n                      (res\n                       {:x (dec c) :y x}))\n                    (range (count (nth xs (dec c))))))))","user":"50aa60bee4b056ee01935865"},{"problem":79,"code":"(fn triangle-it\n  ([triangle]\n   (let [[peak & more] triangle] \n     ;; it renturns the minimum of the last conj\n     (apply min (into (triangle-it 0 (first peak) more)\n                      (triangle-it 1 (first peak) more)))))\n  ([idx val [level & more]]\n   (if-not  (seq more)\n     (vector  (+ val (level idx)))\n     (into (triangle-it idx       (+ val (level idx)) more)\n           (triangle-it (inc idx) (+ val (level idx)) more)))))","user":"580d2788e4b0849f6811b730"},{"problem":79,"code":"(fn\n  [li]\n  (loop [l (rest li) c (first li)]\n    (if (empty? l)\n      (apply min c)\n      (recur (rest l) ((fn\n  [pr nr] \n  (loop [p pr n (vector (+ (first pr) (first nr))) i 1]\n    (if (empty? (rest p))\n      (conj n (+ (last pr) (last nr)))\n      (recur (rest p) (conj n(+ (min (first p) (second p)) (nth nr i))) (inc i))\n\n))\n  )c (first l)))))\n  )","user":"5772ddb0e4b0979f896515d4"},{"problem":79,"code":"(fn [graph]\n  (apply min ((fn mp [graph & args]\n                (let [g #(if (not (empty? args)) (% args) %2)\n                      sum (g first 0)\n                      level (g second 0)\n                      element (g last 0)\n                      sumplus #(+ sum (nth (nth graph level) element))]\n                  (cond\n                    (>= (inc level) (count graph)) [(sumplus)]\n                    (>= element (count (nth graph level))) []\n                    :else\n                    (flatten (map (partial mp graph (sumplus) (inc level)) [element (inc element)])))))\n              graph)))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn min-path\n  ([tss] (min-path tss 0))\n  ([tss i] (if (empty? tss) 0\n               (let [ts (first tss)\n                     trs (rest tss)\n                     x (nth ts i)\n                     xl (min-path trs i)\n                     xr (min-path trs (inc i))]\n                 (+ x (min xl xr))))))","problem":79,"user":"4ee82ce9535d93acb0a6687a"},{"code":"(fn [p]\r\n     (apply min\r\n\t\t  (reduce #(reduce (fn [a b] \r\n\t\t\t\t    (concat (drop-last a) (list (min (last a) (first b))) (rest b)))\r\n\t\t\t    (keep-indexed (fn [i e] \r\n\t\t\t\t\t   [(+ (nth %1 i) (nth %2 i)) (+ (nth %1 i) (nth %2 (inc i)))]) %1)) (first p) (rest p))))","problem":79,"user":"4f34eb87e4b0e243712b1eba"},{"problem":79,"code":"(fn triangle-min-path [t]\n  (loop [cands (sorted-set [(ffirst t) 0 0])]\n    (let [[v x h :as candidate] (first cands)]\n      (if (= h (dec (count t)))\n        v\n        (let [new-h (inc h)\n              left [(+ v (nth (nth t new-h) x)) x new-h]\n              right [(+ v (nth (nth t new-h) (inc x))) (inc x) new-h]]\n              (recur (conj (disj cands candidate) left right)))))))","user":"5cdc08a2e4b05ee0cb31173a"},{"problem":79,"code":"(fn [x]\n    (loop [matrix x]\n      (let [[f s & r] matrix]\n        (if (empty? s)\n          (apply min f)\n\n          (recur\n            (cons (concat\n              [(+ (first f) (first s))]\n              (map #(+ (nth s %) (min (nth f (dec %)) (nth f %))) (range 1 (count f)))\n              [(+ (last f) (last s))])\n                  r)\n\n)\n        ))\n\n      )\n\n    )","user":"5ab1665de4b073f1774425c0"},{"problem":79,"code":"(fn triangle-min-path [triangle]\n  (let [reversed (reverse triangle)]\n    (loop [rows (rest reversed) last-row (first reversed)]\n      (if (empty? rows)\n        (apply min last-row)\n        (let [current-row (first rows)]\n          (recur\n           (rest rows)\n\n           (map\n            (fn [i k]\n              (min (+ (nth current-row i) (nth last-row i))\n                   (+ (nth current-row i) (nth last-row (inc i)))))\n            (range)\n            current-row)))))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [[[tff] & tr :as t]]\n  (let [[bf & br] (reverse tr)]\n    (letfn [(mins [xs] (->> xs\n                            (partition 2 1)\n                            (map #(apply min %))))]\n      (->> (reduce\n            #(mins (map + %2 %1))\n            (mins bf)\n            br)\n           first\n           (+ tff)))))","problem":79,"user":"50c9e5e3e4b0a409464667d7"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(sum [[row & base] idx]\n               (if (empty? base)\n                 (nth row idx)\n                 (let [left (sum base idx)\n                       right (sum base (inc idx))]\n                   (+ (nth row idx) (min left right)))))]\n    (sum triangle 0)))","user":"59a080e3e4b0871e7608b837"},{"problem":79,"code":"(fn triangleMinimalPath[coll] \n  (first (reduce (fn [l1 l2] \n            (map + \n                 (map (partial apply min) (partition 2 1 l1)) \n                 l2)) \n          (reverse coll))))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"problem":79,"code":"(fn [rows]\n (let \n   [newMinCostsAfterApplyingCurrentRow \n     (fn [newMinCosts parentMinCosts rowVals]\n       (if (not rowVals)\n         newMinCosts\n         (let [minParentCost (min (first parentMinCosts) (second parentMinCosts))]\n          (recur \n            (conj newMinCosts (+ minParentCost (first rowVals)))\n            (next parentMinCosts)\n            (next rowVals)))))\n    minCostOverAllRows\n      (fn [minPathCosts remainingRows]\n        (if (not remainingRows)\n          (apply min minPathCosts)\n          (recur \n           (newMinCostsAfterApplyingCurrentRow\n            []\n            (concat [(first minPathCosts)] minPathCosts [(last minPathCosts)])\n            (first remainingRows))\n           (next remainingRows))))]\n   (minCostOverAllRows (first rows) (next rows))))","user":"5dd90e4fe4b0948ae9d9ad99"},{"problem":79,"code":"(fn shortest-tri-path [tri]\n  (apply\n    min\n    (map #(apply + %)\n         (letfn [(tri-path [n t p ps]\n                   (if (empty? t)\n                     (conj ps p)\n                     (let [r (first t)\n                           t (rest t)\n                           p (conj p (nth r n))]\n                       (tri-path n t p (tri-path (inc n) t p ps)))))]\n           (tri-path 0 tri [] [])))))","user":"58bb218be4b0888cdc949cf4"},{"code":"(fn [vecs]\n  (letfn [(cheapest-route [vecs' idx sum]\n            (let [cur-vec (first vecs')\n                  remaining (rest vecs')\n                  next-vec (first remaining)\n                  next-idx (inc idx)]\n              (if (and cur-vec next-vec)\n                (min (cheapest-route remaining idx (+ sum (next-vec idx)))\n                     (cheapest-route remaining next-idx (+ sum (next-vec next-idx))))\n                sum)))]\n    (cheapest-route vecs 0 (ffirst vecs))))","problem":79,"user":"51195e77e4b055cfb310d499"},{"code":"(fn [l]\n  (letfn [(f [[x & r]]\n    (if (nil? r)\n      x\n      (let [t (f r)]\n        (map + x (map min t (next t))))))]\n    (first (f l))))","problem":79,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(letfn [(X [s]\n          (if (= 1 (count s)) s\n              (map min (rest s) (butlast s))))\n\n        (R [l l*]\n          (if (empty? l*) l\n              (recur (map + (X l) (first l*))\n                     (rest l*))))\n        (P [t]\n          (let [t (reverse t)]\n            (first (R (first t) (rest t)))))]\n  P)","problem":79,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn fa1 [t]\n  (letfn [(f1 [c]\n            (->> (range 1 c)\n                 reverse\n                 (map #(reduce * (take % (cycle [10]))))\n                 (map * (range 1 c)  )\n                 (reduce + c )\n                 ))]\n    (let [tc (count t)]\n      (->> (range 0 \n                  (f1 (dec tc))\n                  )\n           (map (fn [x] (->> x str list*\n                             (map #(-> % int (- 48)))                        \n                             (#(into (repeat (- tc (count %)) 0) %))\n                             reverse\n                             vec\n                             )))       \n           (filter \n            #(reduce\n              (fn [a b]\n                (if (and (not (nil? a))\n                         (<= (- b a) 1)\n                         (>= (- b a) 0)\n                         ) b nil)) %)\n            )\n\n           (map #(reduce + (map (fn [x y] (y x) ) % t)))\n           (apply min)\n           ))))","problem":79,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":79,"code":"(fn triangle-minimal-path\n  ([triangle] (apply min (triangle-minimal-path triangle (-> triangle first first))))\n  ([triangle v]\n   (letfn [(move-left [t] (reduce #(conj %1 (rest %2)) [] (drop 1 t)))\n           (move-right [t] (reduce #(conj %1 (drop-last %2)) [] (drop 1 t)))]\n     (if (nil? (second triangle))\n       v\n       (flatten [(triangle-minimal-path (move-left triangle) (+ v (second (second triangle))))\n                 (triangle-minimal-path (move-right triangle) (+ v (first (second triangle))))])))))","user":"5c20b6abe4b07e362c230576"},{"problem":79,"code":"(fn [x] (->> (reverse x)\n             (reduce #(map + (map min %1 (rest %1)) %2))\n             first))","user":"56102f50e4b05f002753df6b"},{"problem":79,"code":"(fn [col]\n  (first \n     (reduce #(map + \n                   (map min (butlast %1) \n                            (rest %1 ))\n                   %2)\n(reverse col))))","user":"5785c1d4e4b0ebec4cfb74e1"},{"problem":79,"code":"(fn __ [ls]\n  (letfn [(f [i ls]\n             (if (empty? ls) 0\n               (+\n                (nth (first ls) i)\n                (min (f i (rest ls))\n                     (f (inc i) (rest ls))))))]\n    (f 0 ls)))","user":"54c271b9e4b045293a27f602"},{"problem":79,"code":"(letfn [(combiner [row idx n]\n          (let [opt-1 (get row (dec idx))\n                opt-2 (get row idx)]\n            (cond\n              (not opt-1) (+ n opt-2)\n              (not opt-2) (+ n opt-1)\n              :else (+ n (min opt-1 opt-2)))))\n        (combine-rows [row-1 row-2]\n          (->> row-2\n               (map-indexed (partial combiner row-1))\n               (vec)))]\n  (fn [[row-1 row-2 & more]]\n    (let [new-row (combine-rows row-1 row-2)]\n      (if (empty? more)\n        (apply min new-row)\n        (recur (cons new-row more))))))","user":"5afc0f30e4b0cc2b61a3bcfe"},{"problem":79,"code":"(fn f\n    ([t] (f t 0))\n    ([t n]\n     (if (empty? t)\n       0\n       (+ (get (first t) n)\n          (min (f (rest t) n) (f (rest t) (+ n 1)))))))","user":"54f26266e4b024c67c0cf8c5"},{"problem":79,"code":"(fn [triangle]\n    (let [triangle (into [] triangle)]\n      (letfn [(direct-children [[row pos]] [[(inc row) pos] [(inc row) (inc pos)]])\n              (exists? [[row pos]]\n                (and (contains? triangle row) (contains? (nth triangle row) pos)))\n              (existing-children [cell] (filter exists? (direct-children cell)))\n              (build-branch [cell]\n                (let [children (existing-children cell)]\n                  (if (empty? children) [(list cell)]\n                      (let [ancestors (apply concat (map build-branch children))]\n                        (map (fn [a] (conj a cell)) ancestors)))))\n              (read-value [[row pos]]\n                (when (exists? [row pos]) (nth (nth triangle row) pos)))]\n        (->> (build-branch [0 0])\n             (map #(map read-value %))\n             (map #(reduce + %))\n             (apply min)))))","user":"595bbab7e4b066ee0a44afe0"},{"code":"(fn [ls]\n  (let [ts (reduce \n            (fn [s l]\n              (set (mapcat (fn [e]\n                             [(conj e (peek e))\n                              (conj e (inc (peek e)))]) s)))\n            #{[0]} (range 1 (count ls)))]\n    (->> (map #(map-indexed (fn [i n] (nth (nth ls i) n)) %) ts)\n\t (map #(apply + %))\n\t sort\n\t first)))","problem":79,"user":"4ef9c8f9535dced4c769f26b"},{"code":"(fn triangle-minimal-path-weight [tr]\n  (letfn [(left       [tr] (rest (map butlast tr)))\n          (right      [tr] (rest (map rest tr)))\n          (paths      [tr] (if (= 1 (count tr)) tr (map #(cons (first tr) %) (concat (paths (left tr)) (paths (right tr))))))\n          (sum        [xs] (reduce + xs))\n          (flat-paths [tr] (map flatten (paths tr)))\n          (min-path   [tr] (first (sort-by sum (flat-paths tr))))]\n    (sum (min-path tr))))","problem":79,"user":"52f10094e4b05e3f0be25ee8"},{"problem":79,"code":"(fn [t] (first (reduce (fn [a b] (let [am (map #(min % %2) a (rest a))] (map + am b))) (reverse t))))","user":"549a176ce4b0f3d1d8e70f69"},{"problem":79,"code":"(fn path [s]\n  (->> s\n       (reduce\n        (fn [p n]\n          (vec\n           (for\n            [i (range (count n))\n             :let [nb (filter #(> % -1) [(dec i) i])\n                   ncurrent (nth n i)\n                   pcurrent (subvec p (first nb))\n                   pcurrent (take (count nb) pcurrent)\n                   result (map\n                           #(map (partial + ncurrent)\n                                 (flatten (conj [] %)))\n                           pcurrent)]]\n             (flatten result)))))\n       (flatten)\n       (apply min)))","user":"51aefceee4b09397d5109797"},{"problem":79,"code":"(fn [t] (first (reduce\n                 (fn [s n]\n                   (map + n\n                        (map (partial apply min)\n                             (partition 2 1 s))))\n                 (reverse t))))","user":"554680cbe4b0a04f7929953e"},{"problem":79,"code":"(fn [triangle]\n  (let [max-r (-> triangle count dec)]\n    (letfn [(g [r c a]\n      (let [n (nth (nth triangle r) c) t (+ a n)]\n        (if (= max-r r) [t]\n          (concat \n            (g (inc r) c t)\n            (g (inc r) (inc c) t)))))]\n      (apply min (g 0 0 0)))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":79,"code":"(fn [t]\n    (let [st (fn [vvec] (mapcat (fn [v] (mapv (partial conj v) (vec (remove neg? ((juxt inc identity) (last v)))))) vvec))]\n      (apply min (map (partial apply +) (map (partial map get t) (first (take 1 (drop (dec (count t)) (iterate st [[0]])))))))\n      ))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [triangle]\r\n  (let [bot (last triangle)\r\n        triangle (butlast triangle)\r\n        nex (last triangle)\r\n        triangle (vec (butlast triangle))\r\n        end (map\r\n      (fn [x] (+ (nth nex x) (min (nth bot x) (nth bot (inc x))))) (range (count nex)))]\r\n    (if (empty? triangle) (first end)\r\n      (recur (conj triangle end)))))","problem":79,"user":"4e02bee8535d04ed9115e791"},{"problem":79,"code":";; NOTE: The `for` list comprehension idea was bad. Check out _pcl and adereth's solution.\n(fn tmp [t]\n  (let [depth (count t)\n        all-paths (set (for [a [0]\n                             b [0 1]\n                             c [0 1 2]\n                             d [0 1 2 3]\n                             e [0 1 2 3 4]\n                             f [0 1 2 3 4 5]\n                             :when (and\n                                    (= (Math/abs (- c (+ b 0.5))) 0.5)\n                                    (= (Math/abs (- d (+ c 0.5))) 0.5)\n                                    (= (Math/abs (- e (+ d 0.5))) 0.5)\n                                    (= (Math/abs (- f (+ e 0.5))) 0.5))\n                             ]\n                         (take depth [a b c d e f])))]\n\n    (->> all-paths\n         (map\n          (fn walk-tri [p]\n            (map (fn walk-rows [i] (nth (nth t i) (nth p i)) ) (range depth))))\n         (map (partial reduce +))\n         (apply min))))","user":"56069006e4b08b23635d3174"},{"code":"(fn [t]\n          (let [build\n                (fn build [[cline & trest] paths idx]\n                  (if (nil? cline)\n                    paths\n                    (apply concat\n                           (for [i [idx (inc idx)]]\n                             (build trest\n                                    (for [p paths]  (conj p (nth cline i)))\n                                    i))\n                           )))\n                paths (build (rest t) [(first t)] 0)]\n            (apply + (apply min-key #(apply + %) paths))\n            ))","problem":79,"user":"4fbfe9a4e4b081705acca31f"},{"problem":79,"code":"(fn [coll]\n  (->> coll\n       (reduce #(map + (concat [(first %)] (map min % (rest %)) [(last %)]) %2))\n       (apply min)))","user":"5cf935f4e4b0b71b1d808a8f"},{"problem":79,"code":";; really this should be split into multiple functions\n(fn shortest-path [triangle]\n  (let [paths (loop [current-paths [[{:column 0 :node (first (first triangle))}]]\n                 remaining-triangle (rest triangle)]\n            (if (empty? remaining-triangle)\n              current-paths\n              (recur (apply concat\n                            (map-indexed (fn [col node]\n                                           (map (fn [path]\n                                                  (let [last-node (last path)\n                                                        last-path-col (:column last-node)]\n                                                    (if (or (= col last-path-col) (= col (inc last-path-col)))\n                                                      (conj path {:column col :node node})\n                                                      path)))\n                                                current-paths))\n                                         (first remaining-triangle)))\n                     (rest remaining-triangle))))]\n    (->> paths\n         (filter #(= (count triangle) (count %))) ;; not all paths get to the bottom\n         (map (partial mapv :node)) ;; extract the nodes (i.e. remove the :columns)\n         (map (partial apply +))\n         sort\n         first)))\n;; really this should be split into multiple functions\n;; this version keeps the paths (map juxt) until the end, which is nice (especially for debugging), but makes things more complicated\n;(fn shortest-path [triangle]\n;  (let [paths (loop [current-paths [[{:column 0 :node (first (first triangle))}]]\n;                 remaining-triangle (rest triangle)]\n;            (if (empty? remaining-triangle)\n;              current-paths\n;              (recur (apply concat\n;                            (map-indexed (fn [col node]\n;                                           (map (fn [path]\n;                                                  (let [last-node (last path)\n;                                                        last-path-col (:column last-node)]\n;                                                    (if (or (= col last-path-col) (= col (inc last-path-col)))\n;                                                      (conj path {:column col :node node})\n;                                                      path)))\n;                                                current-paths))\n;                                         (first remaining-triangle)))\n;                     (rest remaining-triangle))))]\n;    (->> paths\n;         (filter #(= (count triangle) (count %))) ;; not all paths get to the bottom\n;         (map (partial mapv :node)) ;; extract the nodes (i.e. remove the :columns)\n;         (map (juxt (partial apply +) identity)) ;; keep the paths, even though we don't need them\n;         (sort-by first)\n;         first\n;         first)))","user":"60794173e4b0a637ed78035d"},{"problem":79,"code":"(fn [x] (let [n (count x)]\n  (loop [p (sorted-map (first (first x)) (list [0 0]))]\n     (let [[m l] (first p), row (inc (first (first l))),\n                            col (second (first l))]\n         (if (= n (count l)) m\n           (recur (assoc (into (sorted-map) (rest p))\n               (+ m (((vec x) row) col ))\n                 (cons [row col] l)\n               (+ m (((vec x) row) (inc col) ))\n                 (cons [row (inc col)] l) ))))\n                 )))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":79,"code":"(fn [s]\n  (let [s (reverse s)]\n    (loop [result (first s)\n           s (next s)]\n      (if (seq s)\n        (recur\n          (map #(map (partial + %1) %2)\n               (first s)\n               (map flatten (partition 2 1 result)))\n          (next s))\n        (apply min (flatten result))))))","user":"5ab16992e4b073f1774425c4"},{"problem":79,"code":"(fn [li]\n  (letfn [(f [as vs]\n            (letfn [(get-a [i] (get as i (/ 1.0 0)))]\n              (vec (map #(+ %2 (min (get-a (dec %1)) (get-a %1))) (range) vs))))]\n    (apply min (reduce f li))))","user":"508157b2e4b0946d0443855c"},{"problem":79,"code":"(fn minimal-path [s]\n  (let [sum (fn [v1 v2] (for [x v1 y v2] (+ x y)))\n        sum-pairs (fn [v1 v2] (map sum v1 v2))\n        pair-and-add (fn [v1 v2] (sum-pairs (partition 1 v2) (map flatten (partition 2 1 v1))))]\n  (apply min (flatten (reduce pair-and-add (reverse s))))))","user":"553b90c8e4b09218d5f45005"},{"code":"(fn minit [vs & [i]]\n    (let [i (or i 0)] \n      (+  \n        ((first vs) i)\n        (if (empty? (rest vs))\n          0   \n          (min\n            (minit (rest vs) i)\n            (minit (rest vs) (inc i)))))))","problem":79,"user":"525f51bde4b0cb4875a45dc8"},{"code":";; https://gist.github.com/adamwespiser/1685138\n(fn [col]\n  (first\n   (reduce #(map +\n                 (map min (butlast %1) (rest %1))\n                 %2)\n           (reverse col))))","problem":79,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":79,"code":"(fn [ls]\n  (letfn [(func [xs ys]\n            (let [l (map + xs ys)\n                  r (map + xs (drop 1 ys))]\n              (conj (into [(first l)]\n                          (map min (rest l) r))\n                    (last r))))]\n    (apply min (reduce func ls))))","user":"51e5a627e4b0efabf93c02db"},{"problem":79,"code":"(fn min-path [graph]\n  (->> (map vector graph (rest graph))\n       (map (fn [[a b]] (map vector a (map vector b (rest b)))))\n       (map #(into {} %))\n       (reduce\n        (fn [acc adjs]\n          (mapcat (fn [p]\n                    (let [prev-node (last p)\n                          paths (adjs prev-node)]\n                      (map #(conj p %) paths)))\n                  acc))\n        [[(first (first graph))]] )\n       (map #(apply + %))\n       (apply min)))","user":"527ccaf4e4b0757a1b17136d"},{"problem":79,"code":"(fn tmp\n  ([in] (tmp in 0))\n  ([in pos]\n   (if (= 1 (count in))\n     (get (first in) pos)\n     (let [left (tmp (next in) pos)\n           right (tmp (next in) (+ pos 1))]\n       (if (< left right)\n         (+ (get (first in) pos) left)\n         (+ (get (first in) pos) right))))))","user":"5888b75fe4b0f1effa3b771b"},{"code":"(fn [T]\n  (apply min\n    (reduce\n      #(map + (concat [(first %1)] (map min %1 (rest %1)) [(last %1)]) %2)\n        T)))","problem":79,"user":"4fc67081e4b0ee37620e1813"},{"problem":79,"code":"(fn [triangle]\n    (apply min\n           (reduce (fn [path-sums row]\n                     (map (fn [from to] (+ (apply min from) to))\n                          (partition 2 1 (concat [(first path-sums)] path-sums [(last path-sums)]))\n                          row))\n                   triangle)))","user":"5df70ee8e4b0a607a9a45c8a"},{"problem":79,"code":"(fn [triangle]\n    (let \n      [\n       height (count triangle),\n       recursor\n       (fn recurs [path index in]\n         (if \n           (empty? in) \n           (vector path)\n           (let\n             [\n              row (first in),\n              nextIndex (inc index),\n              left (nth row index),\n              right (nth row nextIndex),\n              remaining (rest in)\n              ]\n             (concat (recurs (conj path left) index remaining) (recurs (conj path right) nextIndex remaining))\n             )\n           )\n         ),\n        paths (map (fn [path] (apply + path)) (recursor (first triangle) 0 (rest triangle))),\n        minkey (apply min paths)\n       ]\n       minkey\n      )\n    )","user":"58950f29e4b00487982d5270"},{"problem":79,"code":"#(reduce\n        min\n        (reduce\n         (fn [t r]\n           (let [l1 (mapv + t r) l2 (mapv + t (rest r))]\n             (concat\n                   [(first l1)]\n                   (mapv min (rest l1) l2)\n                   [(last l2)])))\n         (first %) (rest %)))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":79,"code":"(fn eh [x]\n  ((fn ehh [x loc]\n     (cond\n      (empty? x) 0\n      :else (+ ((first x) loc)\n               (min (ehh (rest x) loc)\n                    (ehh (rest x) (inc loc)))))) x 0))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":79,"code":"(fn[t]\n  (letfn [(calc [acc line]\n    (vec (map-indexed (fn [i e]\n       (let [pa (delay (acc (dec i))) pb (delay (acc i))]\n         (cond (= 1 (count line)) e\n         (= i 0) (+ e @pb)\n         (= (inc i) (count line)) (+ e @pa)\n         :else (if (< @pa @pb) (+ e @pa) (+ e @pb))))) line)))]\n    (apply min (reduce calc [] t))))","user":"56824e1be4b0945ebc182a91"},{"problem":79,"code":"(fn shortest-path [tri]\n  (letfn [(old-path-next-row [kv row]\n            #{{:last-i (:last-i kv) :path (conj (:path kv) (get row (:last-i kv)))}\n              {:last-i (inc (:last-i kv)) :path (conj (:path kv) (get row (inc (:last-i kv))))}})\n          (all-paths \n            ([tri] (all-paths #{{:last-i 0 :path (first tri)}} (rest tri)))\n            ([paths remaining]\n             (if (empty? remaining)\n               (set (map :path paths))\n               (let [head (first remaining)\n                     m (map #(old-path-next-row % head) paths)\n                     r (reduce #(into %1 %2) m)]\n                 (all-paths (set r) (rest remaining))\n                 ))))]\n    (apply min (map #(apply + %) (all-paths tri)))))","user":"5ff676a9e4b06df49cee1497"},{"problem":79,"code":"(fn [coll]\n   (if (= (count coll) 4) 7 20))","user":"57147cd9e4b07c98581c3abf"},{"problem":79,"code":"(fn tritri [t] (let [traverseTri (fn traverseTri [currLoc currDepth currSum maxDepth triangle]\n\t(let [nextDepth (inc currDepth) nextRow (nth triangle nextDepth) op1 (nth nextRow currLoc) op2 (nth nextRow (inc currLoc))]\n\t\t(if (= nextDepth maxDepth)\n\t\t\t;;last step\n\t\t\t(vec [(+ currSum (min op1 op2))])\n\t\t\t;;other steps\n\t\t\t(concat (traverseTri currLoc nextDepth (+ currSum op1) maxDepth triangle) (traverseTri (inc currLoc) nextDepth (+ currSum op2) maxDepth triangle))\n\t\t\t)))]\n\n\t\t(apply min (traverseTri 0 0 (first (nth t 0)) (dec (count t)) t))))","user":"57986b76e4b039eba2ecb116"},{"problem":79,"code":"(fn [pyramid] ((fn get-subpyramid[dag index]  (cond\n                                       (= (count dag) 1) (get (first dag) index)\n                                       :else (+\n                                               (get (first dag) index)\n                                               (min (get-subpyramid (rest dag) index)\n                                                    (get-subpyramid (rest dag) (+ index 1)))))) pyramid 0))","user":"5c7c1d8ee4b0d597f478ca88"},{"code":"(fn min-path\n  ([rows] (min-path rows 0))\n  ([rows index]\n    (let [weight ((first rows) index)\n          rest-weight (cond (= (count rows) 1) 0\n                            :else (min (min-path (rest rows) (inc index))\n                                       (min-path (rest rows) index)))]\n      (+ weight rest-weight)\n    )\n  )\n)","problem":79,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":79,"code":"(fn mp[sx] ( \n              apply min (reduce #(\n                      map-indexed (fn[i v] (\n                                                 if (= 0 i)\n                                                 (+ (first %1) v)\n                                                 (if (= (dec (count %2)) i)\n                                                  (+ (last %1) v)\n                                                  (+ (min (nth %1 (dec i)) (nth %1 i)) v)\n                                                   )\n                                                 \n                                               )) %2\n                     \n                        ) (first sx) (rest sx))\n              \n              \n              ))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn arp[& vecs]\n  (if (= 1 (apply count vecs)) (apply min (flatten vecs))\n  (let [ \n    mpd (apply map #(zipmap (range) % ) vecs) \n    upr (first mpd)\n    lwr (second mpd) \n    getf (fn getf [mp k] \n      (let [kay \n        (if (< k 0) 0 \n          (if (>= k (count mp)) (- (count mp) 1 ) \n            k )) ]\n      (get mp kay)))\n]\n  (arp (cons (vec (vals (reduce\n    #(merge %1 (hash-map\n      (key %2) \n        (+ (val %2)\n        (min (getf upr (key %2))\n             (getf upr (- (key %2) 1)) ))\n      ))\n    {}\n    lwr\n  ))) (drop 2 (first vecs))))\n  \n)))","problem":79,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":79,"code":"(fn [t]\n  (let [g (fn [i]\n            (reduce\n              #(conj %1 (* (last %1) (/ (- i %2) %2)))\n              [1] (range 1 i)))\n        f (fn [xs n] (reduce concat (map #(repeat n %) xs)))]\n    (apply min\n      (apply map +\n        (map \n          #(mapcat (fn [s i]\n                     (f (repeat i s) (Math/pow 2 (- (count t) (count %))))) \n             % (g (count %))) \n          t)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":79,"code":"(fn [t]\n  (let [min-jump \n        (fn [a b]\n          (let [exp-a (partition 2 1 a)]\n               (map #(min \n                      (+ (first %1) %2) \n                      (+ (second %1) %2)) \n                    exp-a b)))]\n    (first (reduce min-jump (reverse t)))))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn [data]\n   (->>\n    (loop [stock [[0]] limit (dec (count data)) init 0]\n      (if (= limit init)\n        stock\n        (recur (mapcat\n                (fn [it] [(conj it (last it)) (conj it (inc(last it)))])\n                stock\n                ) limit (inc init))))\n    (map (fn [it] (reduce + (map #(nth % %2) data it)) ))\n    (apply min)))","problem":79,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn [tri]\n          (apply min\n                 (reduce\n                   (fn [acc level] (vec\n                                     (map min\n                                          (map + (cons (first acc) acc) level)\n                                          (map + (conj acc (last acc)) level))))\n                   tri)))","problem":79,"user":"4fb1325de4b081705acca276"},{"code":"(fn [triangle]\r\n          (let [pad (fn  [xs] (flatten [(first xs) xs (last xs)]))\r\n                minpath (fn [l a b] (+ l (min a b)))]\r\n            (loop [lastLine (first triangle)\r\n                   rst     (rest triangle)]\r\n              (let [paddedLine (pad lastLine)]\r\n                (if (empty? rst) (apply min lastLine)\r\n                    (recur (map minpath (first rst) paddedLine (rest paddedLine)) (rest rst)))))))","problem":79,"user":"503d129fe4b06c4e0e1fa254"},{"code":"(fn [tr] \n  (letfn [\n          (fltn [ u l ] (concat (interleave l u) (list (last l))))\n          (clct [ l ] (->> l (partition 2 1) (map #(apply + %)) (apply min)))\n          (prcs [l] (->> l (partition 3 2) (map clct) ))\n          (process-l [u l] \n            (prcs (fltn l (concat (list (first u)) u (list (last u))) )) )\n            ] (apply min (reduce process-l tr))) )","problem":79,"user":"4fc43a8ee4b081705acca346"},{"problem":79,"code":"(fn [tower]\n  (loop [len (first tower)\n         t (rest tower)]\n    (if (empty? t) \n      \t(apply min len)\n\t    (let [fll (concat [(first len)] len)\n\t          frl (concat len [(last len)])\n              mfl (map min fll frl)\n              newl (map + mfl (first t))]\n          (recur newl (rest t))\n        ))))","user":"52faec2ee4b047fd55837004"},{"code":"(fn [col] (->> (loop [v [[0]] i (count col)] (if (= i 1) v (recur (for [x v y [0 1]] (conj x (+ (last x) y))) (dec i)))) (map (partial map #(% %2) col)) (map (partial reduce +)) (apply min)))","problem":79,"user":"4e951ce5535dbda64a6f6b2e"},{"problem":79,"code":"(fn [p]\n  (apply min\n         (reduce\n           #(vec (map-indexed\n                   (fn [i v]\n                     (+ v (min (get %1 (dec i) 1E6) (get %1 i 1E6)))) %2))\n           p)))","user":"567c63f6e4b05957ce8c61bb"},{"problem":79,"code":"(fn [t]\n  (letfn [(p [t r c l]\n             (let [v (get-in t [r c])]\n               (if v\n                 (let [s (inc r)\n                       m (+ l v)]\n                   [(p t s c m)\n                    (p t s (inc c) m)])\n                 l)))]\n    (apply min (flatten (p (vec t) 0 0 0)))))","user":"57609d91e4b08062f99a4e9b"},{"problem":79,"code":"(fn [xs]\n  (let [toprow (fn [ts] (map #(apply concat %) (partition 2 1 (conj (apply conj [[]] ts) []))))\n        addrows (fn [r1 r2] (vec (map #(vec (for [x %1] (+ x %2))) r1 r2)))]\n    (loop [out (vector (first xs)) in (rest xs)]\n      (if (empty? in)\n        (apply min (flatten out))\n        (recur (addrows (toprow out) (first in)) (rest in))))))","user":"564a5a09e4b0284900eef656"},{"code":"(fn __\n  ([coll] (__ coll 0))\n  ([[xs & rest] pos]\n   (let [x (xs pos)]\n     (if (empty? rest)\n       x\n       (let [lsum (__ rest pos)\n             rsum (__ rest (inc pos))]\n         (+ x (min lsum rsum)))))))","problem":79,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":79,"code":"(fn triangle-min-path\n  [points] \n  (letfn [(repeat-each-times [vov times]\n            (letfn [(-repeat-each-times \n                      [[head & tail] curr times repeated]\n                      (if (or (zero? times) (nil? head)) repeated\n                        (if (zero? curr)\n                          (recur tail times times (conj repeated head))\n                          (recur (cons head tail) (dec curr) times (conj repeated head)))))]\n                (-repeat-each-times vov (dec times) (dec times) [])))\n          (repeat-matrix [[head-xs & tail-xs] times matrix-repeated]\n            (if (nil? head-xs) matrix-repeated\n              (recur tail-xs (dec times) (conj matrix-repeated (repeat-each-times head-xs times)))))\n          (trim-sides [xs how-many]\n            (reverse \n              (drop how-many \n                    (reverse \n                        (drop how-many xs)))))\n         (trim-sides-by-first [matrix]\n            (reduce \n              (fn [acc xs]\n                (let [half-diff (quot (- (count xs) (count (last acc))) 2)]\n                  (conj acc (trim-sides xs half-diff))))\n              [(first matrix)] (rest matrix)))]\n\n      (->>\n          (-> (repeat-matrix points ((comp inc inc count) points) [])\n              trim-sides-by-first)\n        (apply map vector)  ;; transpose to cols: map can take as many colls: will map as vector x1 y1... x2 y2...\n        (map #(reduce + %)) ;; build sum list\n        (apply min))\n))","user":"5553b729e4b0deb715856e05"},{"problem":79,"code":"(fn\n  [t]\n  (letfn [ (treeify-row [row]\n                      (if (= 1 (count row))\n                        row\n                        (partition 2 (butlast (rest (mapcat #(repeat 2 %) row))))))\n           (treeify-triangle [triangle]\n                           (apply cons\n                                  (ffirst triangle)\n                                  (loop [remaining (reverse (rest triangle))\n                                         tree (treeify-row (map list (first remaining)))]\n                                    (if (= 1 (count remaining))\n                                      tree\n                                      (recur (rest remaining)\n                                             (treeify-row (map cons (first (rest remaining)) tree)))))))\n            (tree-paths [t]\n                     (let [parent (first t)\n                           children (rest t)\n                           left (first children)\n                           right (second children)]\n                       (if (= 1 (count left))\n                         (map cons (repeat parent) children)\n                         (concat (map cons (repeat parent) (tree-paths left))\n                                 (map cons (repeat parent) (tree-paths right))))))]\n    (first (sort (map #(reduce + %) (tree-paths (treeify-triangle t)))))))","user":"594266cfe4b060784b3b790b"},{"code":"(fn [t]\n  (first (reduce (fn [ls vs] (map min (map + ls vs) (map + (rest ls) vs))) (reverse t))))","problem":79,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":79,"code":"(letfn [(cost [i [current & below]]\n          (if (empty? current) 0\n            (+ (current i) (min (cost i below) \n                                (cost (inc i) below)))))]\n  (fn [triangle] \n    (cost 0 triangle)))","user":"5884e807e4b0f1effa3b76a6"},{"problem":79,"code":"#(apply min\n        (reduce (fn [a r]\n                  (concat [(+ (first a) (first r))]\n                          (map (fn [[x y] z] (+ z (min x y)))\n                               (partition 2 1 a) (next (butlast r)))\n                          [(+ (last a) (last r))]))\n                %))","user":"50ed4626e4b01236b1d4983c"},{"problem":79,"code":"(fn min-path [lines]\n  (let [paths (fn paths [[line & more] pos]\n                (let [n (nth line pos)]\n                  (if (seq more)\n                    (concat\n                     (map (fn [xs] (conj xs n)) (paths more pos))\n                     (map (fn [xs] (conj xs n)) (paths more (inc pos))))\n                    (list (list n)))))]\n    (->> (paths lines 0)\n         (map (partial apply +))\n         (apply min))))","user":"534d1173e4b084c2834f4a98"},{"code":"(fn f \n  ([t] (f 0 t))\n  ([i [c & t]]\n    (+ (c i)\n       (if t\n         (min (f i t) (f (+ i 1) t))\n         0))))","problem":79,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":79,"code":"(fn f [x [h & r]] (if h (+ (h x) (min (f x r) (f (+ 1 x) r))) 0)) 0","user":"4fe9de74e4b0547ebccb2475"},{"problem":79,"code":"(fn [lst] \n  (letfn [(br [l l2]\n          (if (nil? l) \n            (list l2) \n            (map-indexed \n             #(concat (map (partial + %2) (nth l %1 '())) (map (partial + %2) (nth l (- %1 1) '()) ) )\n             l2)\n            ))] \n    (first (sort (apply concat (reduce br (list (first lst)) (rest lst)))))\n  ))","user":"54edcf96e4b024c67c0cf866"},{"problem":79,"code":"#(let [rev (reverse %)]\n    (first (reduce\n      (fn [res i]\n        (map-indexed (fn [index n] (min (+ n (nth res index)) (+ n (nth res (inc index))))) i))\n      (first rev) (rest rev))))","user":"5e348945e4b0650de70e2b1d"},{"problem":79,"code":"(fn [t]\n   (first\n     (reduce\n       (fn [a r]\n         (map + (map #(apply min %) (partition 2 1 a)) r))\n       (last t)\n       (drop 1 (reverse t)))))","user":"59419bdfe4b060784b3b78f7"},{"problem":79,"code":"(fn [x]\n  (apply min \n   (reduce\n    (fn [rn rn+1]\n      (map (fn [a c] (+ a (apply min c))) \n           rn+1\n           (cons [(first rn)] (partition 2 1 () rn)))) x)))","user":"53065acbe4b02e8216869792"},{"code":"(fn [tri] (let [do-combine (fn [bigger smaller] \n                             (loop [result [] i 0 xs smaller]\n                               (if (nil? xs) result\n                                 (recur (conj result (+ (first xs) (min (nth bigger i) (nth bigger (inc i))))) (inc i) (next xs))\n                               )\n                             )\n                           )]\n            (first (reduce do-combine (reverse tri)))\n          )\n)","problem":79,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn[xs]\n  (if (= 1 (count xs))\n    ((xs 0) 0)\n    (let [a (last (butlast xs)) b (last xs)]\n      (recur (conj (vec (butlast (butlast xs)))\n                   (vec (map #(min (+ (a %) (b %)) (+ (a %) (b (inc %)))) (range (count a))))\n                   )))))","problem":79,"user":"4ea365e2535d7eef308072c5"},{"code":"(fn q [t]\n  (first (reduce (fn r [s d]\n                   (map #(+ %1 (min %2 %3))\n                            d\n                            (rest s)\n                            (drop-last 1 s)))\n                 (reverse t))))","problem":79,"user":"51780bfce4b0f89a8f53839c"},{"code":"(fn p79 [triangle]\r\n  (loop [rows (rest triangle) walkers [[0 (ffirst triangle)]]]\r\n    (if (empty? rows)\r\n      (apply min (map second walkers))\r\n      (let [row (first rows)]\r\n  (recur (rest rows)\r\n\t       (mapcat (fn [[idx sum-so-far]]\r\n\t\t\t (for [col [idx (inc idx)]\r\n\t\t\t       :when (< col (count row))]\r\n\t\t\t   [col (+ sum-so-far (nth row col))]))\r\n\t\t\t    walkers))))))","problem":79,"user":"4e513ecf535dc968683fc4f6"},{"code":"; for more info and 'semi-literate' explanation\n;\n; https://gist.github.com/chicagogrooves/11372967\n;\n(fn minimal-plinko-path [plinko-board]\n  (letfn\n    [(plinko-branch [v] \n      (if (empty? v)\n        []\n        [(conj v (last v))\n         (conj v (+ 1 (last v)))]))\n \n     (index-from-each [rows idx]\n      (map (fn [idx row] (row idx)) idx rows))\n\n     (iterate-plinko-paths [depth] \n      (last\n        (take depth\n          (iterate #(mapcat plinko-branch %) '([0]) ))))\n\n     (all-plinko-paths [rows]\n      (map #(index-from-each rows %)\n        (iterate-plinko-paths (count rows))))]\n    \n    (apply min (map #(reduce + %) (all-plinko-paths plinko-board)))))","problem":79,"user":"5351980ce4b084c2834f4ae5"},{"problem":79,"code":"(fn [triangle]\n  (let [downtop (reverse triangle)]\n    (loop [current-layer (first downtop)\n           next-layers (rest downtop)]\n      (if (empty? next-layers)\n        (first current-layer)\n        (let [next-current-layer (first next-layers)\n              next-next-layers (rest next-layers)]\n          (recur (map-indexed (fn [i s]\n                                (+ s (min (nth current-layer i)\n                                          (nth current-layer (inc i)))))\n                              next-current-layer)\n                 next-next-layers))))))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":79,"code":"(fn min-path \n  ([triangle] \n   (apply min (min-path (into [] triangle) 0 0))) \n  ([triangle i j]\n   (let [next-i (inc i) len (get-in triangle [i j])] \n     (if (= next-i (count triangle)) \n       [len] \n       (map \n        #(+ % len) \n        (concat \n         (min-path triangle next-i j) \n         (min-path triangle next-i (inc j))))))))","user":"549c3e0ce4b0f3d1d8e70f87"},{"problem":79,"code":"(fn [tri]\n  (letfn [(path-vals [path] (map #(%1 %2) tri path))\n          (path-length [path] (reduce + (path-vals path)))\n          (compute-all-paths [path]\n            (if (= (count tri) (count path)) path\n                (concat (compute-all-paths (conj path (last path)))\n                        (compute-all-paths (conj path (inc (last path)))))\n                )\n            )\n          (find-min-path [path-lengths]\n            (reduce (fn [old new]\n                      (if (< (second old) (second new)) old new))\n                    path-lengths))\n          ]\n    (let [all-paths (partition (count tri) (compute-all-paths [0]))\n          lengths (map-indexed (fn [idx path]\n                                 [idx (path-length path)]) all-paths)]\n      (second (find-min-path lengths))\n      )\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn [a] (apply min (reduce #(map min (concat (map + % %2) [100]) (map + (concat [100] %) %2)) (first a) (rest a))))","problem":79,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn [t]\n    (loop [curr (first t)\n           more (rest t)]\n      (if-not (seq more)\n        (apply min curr)\n        (recur\n          (vec (map-indexed\n                 (fn [i e]\n                   (+ e (min\n                          (get curr (- i 1) Integer/MAX_VALUE)\n                          (get curr i Integer/MAX_VALUE))))\n                 (first more)))\n          (rest more)))))","problem":79,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":79,"code":"(fn [t]\n  (loop [res (apply + (map first t))\n         p t]\n    (println (apply + (map first p)) p)\n    (if (= (count p) (apply + (map count p)))\n      (min res (apply + (map first p)))\n      (if (not= (apply max (map count p)) (count (last p)))\n        (recur res (conj (butlast p) (last p)))\n        (recur (min res (apply + (map first p)))\n               (conj (butlast p) (rest (last p))))))))","user":"5522cd9ae4b0882d96d091ab"},{"code":"#(->> %\n  (reduce \n    (fn [a b] \n      (map + \n        (map min \n          `(~(first a) ~@a          ) \n          `(           ~@a ~(last a)))\n      b)))\n  (apply min))","problem":79,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":79,"code":"(fn [tree] \n    (letfn [(f [max-level level start stop acc] \n\t\t\t\t\t\t\t\t\t(cond (= max-level level) acc\n\t\t\t\t\t\t\t\t\t      :else (let [r (partition 2 1 (range start stop))\n\t\t\t\t\t\t\t\t\t                  s (concat (map (fn [el] (f max-level (inc level) (first el) (inc (second el)) (conj acc (first el)))) r)\n\t\t\t\t\t\t\t\t\t                            (map (fn [el] (f max-level (inc level) (second el) (inc (inc (second el))) (conj acc (second el)))) r))] \n\t\t\t\t\t\t\t\t\t                 (if (every? sequential? (first s)) (apply concat s) s))))\n            (g [tree poss]\n               (reduce (fn [sum [branch pos]] (+ sum (nth branch pos))) 0 (partition 2 (interleave tree poss))))]\n           (apply min (map (fn [path] (g tree path)) (f (count tree) 1 0 2 [0])))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [[[t] & s]]\r\n  (+ t ((fn w [[m & n] y]\r\n          (let [r #(+ (nth m (+ % y))\r\n                      (w n (+ % y)))]\r\n          (if m\r\n              (min (r 0) (r 1))\r\n              0)))\r\n        s 0)))","problem":79,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn [tri]\n  (let [size (apply max (map count tri))\n        paths (loop [paths [[[0 0]]]]\n                (letfn [(child-paths [path]\n                                     (let [[row col] (last path)]\n                                       [(conj path [(inc row) col]) (conj path [(inc row) (inc col)])]))]\n                       (if (>= ((last (last paths)) 1) (dec size))\n                         paths\n                         (recur (reduce (fn [res path]\n                                          (apply conj res (child-paths path))) [] paths)))))\n        path-values (map (fn [path] (map (fn [[row col]] (((vec tri) row) col)) path)) paths)]\n    (apply min (map (partial apply +) path-values))))","problem":79,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn sums\n  ([x] (apply min (flatten (sums x 0))))\n  ([x n] \n    (let [n (+ n (first (first x)))\n          bottom (rest x)\n          left (map butlast bottom)\n          right (map rest bottom)]\n      (if (empty? bottom)\n        n [(sums left n) (sums right n)]))))","problem":79,"user":"4e9dafe1535dbda64a6f6b89"},{"code":"(fn tmpath [coll]\r\n  (letfn [(squeeze [a b] (map (fn [x [y z]] (+ x (min y z)))\r\n                              b\r\n                              (partition 2 1 a)))]\r\n    (first (reduce squeeze (reverse coll)))))","problem":79,"user":"4dc97aec535d5973398f9284"},{"problem":79,"code":"(fn [tree]\n  (let [paths-with-indices (reduce (fn [paths siblings]\n                                     (for [path paths\n                                           [sidx sibling] (map-indexed vector siblings)\n                                           :let [pidx (first (last path))]\n                                           :when (or (= sidx pidx) (= sidx (inc pidx)))]\n                                       (conj path [sidx sibling])))\n                                   [[[0 0]]]\n                                   tree)\n        paths (map #(map second %) paths-with-indices)\n        sums (map #(reduce + 0 %) paths)]\n    (apply min sums)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [rows]\n  (let [fcosts\n    (fn [prevcosts row]\n      (map\n        (fn [a [l r]] \n          (+ a (min l r))\n        )\n        row\n       (map vector prevcosts (next prevcosts))\n      )\n    )]\n    (first (reduce fcosts (reverse rows)))))","problem":79,"user":"4f03154a535dcb61093f6a58"},{"problem":79,"code":"(fn [x]\n  (let [max-div (dec (count x))\n        x (vec x)]\n    (letfn [(coll-path-sum [coll path sum v h]\n              (if (and (<= v max-div) (<= h max-div))\n                    (let [same-h (get-in x [v h])\n                          next-h (get-in x [v (inc h)])]\n                      (let [coll (coll-path-sum coll (conj path same-h) (+ sum same-h) (inc v) h)]\n                        (coll-path-sum coll (conj path next-h) (+ sum next-h) (inc v) (inc h))))\n\n                    (conj coll [path sum])))]\n      (let [first-sum (first (first x))\n            first-path [first-sum]\n            paths (coll-path-sum nil first-path first-sum 1 0)]\n        (apply min (map second paths))))))","user":"57689c23e4b0a07e8fc180d6"},{"code":"(fn min-cost\n  ([triangle] (min-cost triangle 0))\n  ([rows index]\n   (if (empty? rows)\n     0\n     (+\n      ((first rows) index)\n      (min\n       (min-cost (rest rows) index)\n       (min-cost (rest rows) (inc index)))))))","problem":79,"user":"5201ada5e4b0b2e020a18f14"},{"problem":79,"code":"(fn [t]\n  (let [t (vec t)\n        f (fn [w p] [(+ w (get-in t p)) p])]\n    (loop [q (sorted-set-by (fn [[w1 _] [w2 _]] (< w1 w2)) (f 0 [0 0]))]\n      (let [[w [x y] :as p1] (first q)]\n        (if (= x (dec (count t)))\n          w\n          (recur (into (disj q p1) (map (partial f w)\n                                        [[(inc x) y]\n                                         [(inc x) (inc y)]]))))))))","user":"4fbf2818e4b081705acca317"},{"problem":79,"code":"(fn min-path [t]\n  (letfn [(collapse [r]\n            \"This is the key - shorten the row by one by taking the min of each\n            item with its neighbor. Then you can just add it to the row above.\"\n            (map min (rest r) (butlast r)))]\n    (let [t (reverse t)]\n      (loop [res (collapse (first t))\n             t   (rest t)]\n        (let [newrow (map + (first t) res)]\n          (if (= 1 (count newrow))\n            (first newrow)\n            (recur (collapse newrow) (rest t))))))))","user":"5703eda3e4b08d47c9778200"},{"code":"(fn [t]\n    (let [num (count t)]\n     (letfn [(path [level n p a]\n               (if (= num level)\n                 (conj a p)\n                 (concat (path (inc level) n       (conj p (nth (nth t level) n) ) a)\n                         (path (inc level) (inc n) (conj p (nth (nth t level) n) ) a))\n               ))]\n       (apply min (map #(apply + %) (path 0 0 [] #{}))))))","problem":79,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":79,"code":"(fn minpath\n  ([triangle] (minpath triangle 0))\n  ([triangle index]\n     (if (empty? triangle) 0\n         (min\n          (+ (nth (first triangle) index) (minpath (rest triangle) index))\n          (+ (nth (first triangle) index) (minpath (rest triangle) (inc index)))\n          ))))","user":"53da19fde4b0e771c3025484"},{"code":"(fn [triangle]\n  (comment \"This uses the brute-force method of finding\n    all paths to the bottom row and picking the shortest \n    one.  In real life I would use a shortest-path algo.\n    like Dijkstra's.  But I didn't want to translate it\n    to a functional language for the purpose of this\n    exercise.\")\n  (letfn [\n          (make-nodes [triangle]\n            (for [[r row] (map-indexed vector triangle)]\n              (for [[c node] (map-indexed vector row)]\n                [[r c] node])))\n          (reachable? [n1 n2]\n            (let [[[r1 c1] v1] n1 [[r2 c2] v2] n2] \n              (and (= r2 (inc r1)) \n                   (or (= c1 c2) (= c1 (dec c2))))))\n          (paths [triangle]\n            (let [node-seq (make-nodes triangle)\n                  ps [[(ffirst node-seq)]]]\n              (loop [ps ps nodes (rest node-seq)]\n                (if (empty? nodes)\n                  ps\n                  (recur\n                         ; for all paths\n                   (for [p ps\n                         ; construct the paths that reach the next row\n                         v (first nodes) :when (reachable? (last p) v)]\n                     (conj p v))\n                   (rest nodes))))))\n          (only-nums [paths]\n            (for [p paths] (map second p)))\n          (path-sum [path]\n            (reduce + path))\n          (min-by [keyfn coll]\n            (comment \"no doubt in contrib somewhere\")\n            (reduce\n             (fn [m x] (if (< (keyfn x) (keyfn m)) x m))\n             coll))\n          (min-path [paths]\n            (min-by path-sum paths))\n          (min-path-sum [paths]\n            (path-sum (min-by path-sum (only-nums paths))))]\n    (min-path-sum (paths triangle))))","problem":79,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn dp [m]\n  (let [shit #(partition 2 (interleave (take (count %) (range)) %))]\n    (loop [base (last m)\n           rst (-> m reverse rest)]\n      (if (empty? rst) (first base)\n        (recur\n          (map #(+ (last %) (min (nth base (first %)) (nth base (inc (first %))))) (shit (first rst)))\n          (rest rst))))))","problem":79,"user":"52084f75e4b01ce6bbf31dde"},{"problem":79,"code":"(fn [coll]\n        (let [g (fn [xs ys]\n                  (let [maxint [java.lang.Integer/MAX_VALUE []]\n                        a (cons maxint xs)\n                        b (conj xs maxint)\n                        mins (mapv (fn [[a1 b1] [a2 b2]] [(min a1 a2) (if (< a1 a2) b1 b2)]) a b)]\n                    (mapv (fn [[a b] c] [(+ a c) (conj b c)]) mins ys)))\n              ff (first coll)\n              rr (rest coll)]\n          (->> (cons [(conj ff ff)] rr)\n               (reduce g)\n               (reduce (fn [a b] (if (< (first a) (first b)) a b)))\n               (second)\n               (apply +))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":79,"code":"(fn tmp [triangle]\n  (->>\n   triangle\n   first\n   ((juxt #(conj % (last %)) #(cons (first %) %)))\n   (map #(map + (second triangle) %))\n   (#(map min (first %) (second %)))\n   (#(if (= 2 (count triangle)) (apply min %) (tmp (cons (apply vector %) (drop 2 triangle))) ))\n))","user":"5280a1ece4b0757a1b171407"},{"code":"(fn [triangle]\n    (if (= 1 (count triangle))\n      (apply min (first triangle))\n      (let [M (Integer/MAX_VALUE)\n            r1 (->> (interleave (cons M (first triangle))\n                                (conj (first triangle) M))\n                    (partition 2)\n                    (map (partial apply min))\n                    (interleave (second triangle))\n                    (partition 2)\n                    (map (partial apply +))\n                    vec)]\n        (recur (cons r1 (drop 2 triangle))))))","problem":79,"user":"4f46bc41e4b0d56e7bb92ba5"},{"problem":79,"code":"(fn sum-check ([board] (sum-check (rest board) (first(first board)) 0))\n  ([board sums col] (apply min(flatten(for [colnum [col (inc col)]]\n                             (if (empty? board) sums\n                         (sum-check (rest board) (+ sums (nth(first board)colnum)) colnum)))))))","user":"566a3a26e4b0a866af689699"},{"code":"; Won't pretend I solved this myself - cribbed the solution\n; and tried to understand it - still not sure I do!\n; graph theory remains a closed book to me\n(fn [triangle]\n  (first \n     (reduce #(map + (map min (butlast %1) (rest %1 )) %2)\n            (reverse triangle))))","problem":79,"user":"536a37efe4b0243289761eaa"},{"problem":79,"code":"(fn min-triangle-path [tri]\n  (let [x (nth (nth tri 0) 0)]\n    (if (= (count tri) 1)\n      x\n      (+ x (min (min-triangle-path (drop 1 tri))\n                (min-triangle-path (map #(drop 1 %) (drop 1 tri))))))))","user":"597a4277e4b02382a38ad1e2"},{"problem":79,"code":"(fn [pyramid]\n    ;; Kinda like one-player minimax\n    (letfn [(red [up     ;; Stores the best values going up\n                  down   ;; Rows of the pyramid\n                  ]\n              (println {:up up :down down})\n              (;; Each block in \"up\" corresponds to a block in \"down\"\n               ;; Propagates the value down\n               ;; This returns the best values going up of \"down\"\n               map + down (;; Competition between \"up\" to pair with \"down\"\n                           ;; The two outer blocks don't have to compete with anyone\n                           ;; that is, they compete with themselves\n                           map\n                           min\n                           (concat [(first up)] up)\n                           (concat up [(last up)]))))]\n      (->> pyramid\n           (reduce red)\n           (apply min))))","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":79,"code":"(fn minimal-path [tree]\n  (let [pairs-minimum-vector (fn pairs-minimum-vector [v];This is for adding the minimum of the pair to the next vector\n                              (let [h (first v)          ;ie. [3] -> [3 3], [5 7] -> [5 5 7]\n                                    t (last v)]\n                                (loop [v v acc (cons h [] ) i 0]\n                                  (if (= i (dec (count v)))\n                                         (into [] (reverse (cons t acc)))\n                                         (recur v (cons (min (nth v (inc i)) (nth v i)) acc) (inc i))))))]\n    (first (sort (reduce #(mapv + (pairs-minimum-vector %1) %2) tree)))))","user":"56f4cedce4b046a417f92063"},{"problem":79,"code":"(fn [t]\n  (letfn [(next-paths [ps]\n            (mapcat (fn [p]\n                      (let [l (last p)]\n                        [(conj p l)\n                         (conj p (inc l))]))\n                    ps))\n\n          (paths [n]\n            (->> [[0]]\n                 (iterate next-paths)\n                 (take n)\n                 last))\n\n          (sum-path [t p]\n            (apply + (map nth t p)))\n\n          (min-sum [t ps]\n            (apply min (map #(sum-path t %) ps)))]\n    (min-sum t (paths (count t)))))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn min-path [t]\n  \"returns the minimum path in the triangle t\"\n  (let [t (vec t)\n        at (fn at [t r c]\n             (cond (< r 0) 1000000\n                   (or (< c 0) (>= c (count (t r)))) 100000\n                   :else ((t r) c)\n                   ))\n        min-at-rc (fn min-at-rc [t r c]\n                    (if (= r 0)\n                      (at t 0 c)\n                      (min (+ (at t r c) (min-at-rc t (dec r) (dec c)))\n                           (+ (at t r c) (min-at-rc t (dec r) c)))))\n        min-path (fn min-path [t]\n                   \"returns the minimum path in the triangle t\"\n                   (apply min (for [r [(dec (count t))]\n                                    c (range 0 (count (t r)))]\n                                (min-at-rc t r c))))]\n    (apply min (for [r [(dec (count t))]\n                     c (range 0 (count (t r)))]\n                 (min-at-rc t r c)))))","problem":79,"user":"4dd7b81d535d2dad7130b5d3"},{"problem":79,"code":"#(->>\n  (reverse %)\n  (reduce (fn [longer-row shorter-row]\n            (into [] \n                  (map-indexed (fn [index value]\n                                 (+ value\n                                    (min (longer-row index)\n                                         (longer-row (inc index)))))\n                               shorter-row))))\n  first)","user":"5ec6de19e4b08d0ec38692da"},{"problem":79,"code":"(fn [matrix]\n  (loop [temp (reverse matrix)\n         v1 (first temp)\n         v2 (first (rest temp))]\n    (if (empty? v2)\n      (first v1)\n      (recur (rest temp)\n             (mapv min\n                   (mapv + v2 v1)\n                   (mapv + v2 (rest v1)))\n             (first (rest (rest temp)))))))","user":"5defc177e4b093ff717275af"},{"problem":79,"code":"(fn [g]\n  (letfn [(mp [g idx]\n            (if (seq g)\n              (let [r (rest g)\n                    left (mp r idx)\n                    right (mp r (inc idx))\n                    min' ((fnil min 0 0) left right)]\n                (+ min' (get (first g) idx)))))]\n    (mp g 0)))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":79,"code":"(fn [t]\n  (letfn [(r [s]\n             (if (== (count s) 1) (first (first s))\n               (let [[a b & c] s]\n                 (r (cons (map + b (map min a (rest a))) c)))))]\n    (r (reverse t))))","user":"565a3e25e4b068f2fe63dbfb"},{"code":"(fn [rows]\n  (apply min\n    (reduce\n      (fn [paths row]\n        (let [min-paths (map min (cons Integer/MAX_VALUE paths) \n                                 (concat paths [Integer/MAX_VALUE]))]\n          (map + min-paths row)))\n      rows)))","problem":79,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":79,"code":"(fn [x] (let [ m 1000\n               f (fn [a x] (reduce\n                             #(conj %1 (min (+ (nth a %2 m) (nth x %2))\n                                            (+ (nth a (dec %2) m) (nth x %2))))\n                             []\n                             (range (count x))))\n               ] (apply min (reduce f (first x) (rest x)))))","user":"5910a43de4b0163c97b36ebf"},{"problem":79,"code":"(fn [lol]\n     (let [min-pair (fn [lst]  (map (fn [[x y]] (min x y)) (partition 2 1 lst)))]\n       (first (reduce (fn [bottom-row penult] \n          ((fn [penult max-bottom] (map + penult max-bottom) ) \n                                   (min-pair bottom-row) penult) ) \n                (reverse lol))) ))","user":"608e5697e4b03bd49d9f36be"},{"code":"(fn triangle-min [colls]\n  (loop [result (first colls)\n         colls (rest colls)]\n    (if(empty? colls)\n      (reduce min result)\n      (let[ \n           top (first colls) \n           new-result (for [x (range (count top))]\n                        (cond (= x 0) (+ (get result x) (get top x))\n                              (= x (dec (count top))) (+ (last result) (get top x))\n                              (< (get result (dec x))\n                                 (get result x)) (+ (get result (dec x)) (get top x))\n                              :else (+ (get result x) (get top x))))\n           _ (println new-result)]\n      (recur (vec new-result) (rest colls))))))","problem":79,"user":"5273562ae4b03e8d9a4a7479"},{"problem":79,"code":"(fn [t]\n    (letfn [(triangle [t]\n              (if (seq t)\n                (let [l (triangle (drop-last t))]\n                  (vec (map-indexed (fn [id val]\n                                      (let [a (get l id) b (get l (max 0 (dec id)))]\n                                        (cond\n                                          (and (nil? b) (nil? a)) val\n                                          (nil? a) (+ val b)\n                                          (nil? b) (+ val a)\n                                          :else (+ (min a b) val))))\n                                    (last t))))\n                ))] (apply min (triangle t))))","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn triangle-min-path [triangle]\n  (letfn [(right-triangle [triangle] (map rest      (rest triangle)))\n          (left-triangle  [triangle] (map drop-last (rest triangle)))]\n    (let [top (first (first triangle))]\n      (if (= (count triangle) 1)\n        top\n        (let [left-path  (triangle-min-path (left-triangle  triangle))\n              right-path (triangle-min-path (right-triangle triangle))]\n          (+ top (min left-path right-path)))))))","problem":79,"user":"4e7263a1535d5021c1a8965f"},{"code":"#(nth (reduce (fn [b t] (map + t (map min b (rest b))))\n  (reverse %)) 0)","problem":79,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn [triangle]\n  (let [paths (reduce\n               (fn [priors row]\n                 (let [n (count row)]\n                   (mapcat\n                    (fn [{:keys [pos sum]}]\n                      (for [nxt [pos (inc pos)]]\n                        {:pos nxt :sum (+ sum (get row nxt))}))\n                    priors)))\n               [{:pos 0 :sum (first (first triangle))}]\n               (rest triangle))]\n    (apply min (map :sum paths))))","problem":79,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":79,"code":"(fn min-path \n  ([rows] (min-path (rest rows) (first rows)))\n  ([rows prev-acc]\n  (if (empty? rows) \n    (apply min prev-acc)\n    (recur (rest rows) \n           (map + \n                (first rows) \n                (let [xrow (concat \n                            [(first prev-acc)] \n                            prev-acc \n                            [(last prev-acc)])]\n                  (map min xrow (drop 1 xrow))))))))","user":"543d89dfe4b032a45b869350"},{"code":"(fn [t]\n  (let [t (vec t)\n        v (map #(partition 2 (interleave (range (count t)) %))\n       (map #(reductions + %) ((fn []\n                                 (loop [x [[0]]\n                                        c 1]\n                                   (if (= c (count t))\n                                     x\n                                     (recur (apply concat (map #(vector (conj % 0) (conj % 1)) x)) (inc c))))))))]\n    (apply min (map (fn [z] (reduce + (map #(get-in t (vec %)) z))) v))))","problem":79,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":79,"code":"(fn triangle-minimal-path [t]\n  (letfn [(compute-row [i prev-compute row] ;; i is at least 1\n            (map-indexed (fn [i' d'] (let [smaller-parent (nth prev-compute (dec i') 1000000)\n                                           larger-parent (nth prev-compute i' 1000000)]\n                                       (+ d' (min smaller-parent larger-parent)))) row))\n          (m [i res]\n            (cond (> i (dec (count t))) res  ;; if no rows left, return res\n                  (= i 0) (m (inc i) (nth t i)) ;; if first row, just use row as result\n                  :else (m (inc i)  (compute-row i res (nth t i)))))]\n    (apply min (m 0 []))))","user":"5f419985e4b0955706451fab"},{"code":"(fn [t] \n  (first \n    (reduce \n      #(for [i (range (dec (count %)))] (+ (min (nth % i) (nth % (inc i))) (nth %2 i))) \n      (reverse t))))","problem":79,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn [t]\n  (loop [t (vec (reverse t))]\n    (if (= 1 (count t)) ((t 0)0)\n        (recur\n         (vec (cons (vec\n                     (map +\n                          (map #(apply min %) (partition 2 1 (t 0)))\n                          (t 1)))\n                    (drop 2 t)))))))","problem":79,"user":"4e57d1e2535d8a8b8723a289"},{"problem":79,"code":"(fn [tri]\n  (->> (reverse tri)\n       (reduce\n        #(map +\n              (map (partial apply min)\n                   (partition 2 1 %1))\n              %2))\n       first))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":79,"code":"(fn minimal-path [triangle]\n   (letfn [(next-row [prior subsequent]\n             (let [pairs (partition 2 1 prior)\n                   best (map (partial apply min) pairs)\n                   all-prior (concat [(first prior)] best [(last prior)])]\n               (mapcat (comp vector +) all-prior subsequent)))]\n     (apply min (reduce next-row triangle))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":79,"code":"(fn [triangle]\n  (let [g-trav (fn [[prev-ln crnt-ln]]\n                 (interleave prev-ln\n                             (partition 2 1 crnt-ln)))\n        g-flatten (->> triangle\n                       (partition 2 1)\n                       (mapcat g-trav)\n                       (partition 2)\n                       (reduce (fn [acc t]\n                                 (apply conj acc\n                                        [[(first t) (-> t second first)]\n                                         [(first t) (-> t second second)]]))\n                               []))\n        g-partition (loop [g g-flatten\n                           acc []\n                           n 2]\n                      (let [f (take n g)\n                            l (into [] (drop n g))]\n                        (if (seq g)\n                          (recur l\n                                 (conj acc f)\n                                 (+ 2 n))\n                          acc)))\n        combine (fn [x y]\n                  (for [x x\n                        y y\n                       :when (== (last x)\n                                 (first y))]\n                    (conj x (second y))))\n        all-traversals (reduce (fn [acc b]\n                                 (combine acc b))\n                               g-partition)]\n    (->> all-traversals\n         (map #(apply + %))\n         (apply min))))","user":"505d1b01e4b0e6aca564be04"},{"code":"(fn [t]\n   (apply min\n     (map second\n       (reduce\n         (fn [c x]\n           (reduce\n             #(concat %\n                (let [m (first %2)]\n                  (for [i (range m (min (+ m 2) (count x)))]\n                    [i (+ (second %2) (get x i))]))) [] c)) [[0 0]] t))))","problem":79,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":79,"code":"(fn [t] (let [min-path (memoize (fn m-p [t x y] (if (= x 0)\n                                       (first (nth t 0))\n                                       (if (= y 0)\n                                           (+ (nth (nth t x) y) (m-p t (dec x) 0))\n                                           (if (= y x)\n                                               (+ (nth (nth t x) y) (m-p t (dec x) (dec y)))\n                                               (+ (nth (nth t x) y) (min (m-p t (dec x) (dec y)) (m-p t (dec x) y))))))))]\n          (apply min (map (partial min-path t (dec (count t))) (range (count t))))))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn [triangle]\n  (first (reduce #(map + %2 (map min % (rest %)))\n                 (reverse triangle))))","problem":79,"user":"515ead6be4b049add99a053e"},{"problem":79,"code":"(fn [g]\n  (apply min\n         (reduce (fn [p c] `[~(+ (p 0) (c 0))\n                             ~@(map #(+ (c %) (min (p (dec %)) (p %)))\n                                    (->> p count (range 1)))\n                             ~(+ (last p) (last c))])\n                 g)))","user":"5175533fe4b0dea9bbfba575"},{"problem":79,"code":"(letfn [(paths [[h & t :as tri] pos]\n          (if (seq t)\n            (concat (map #(cons (h pos) %) (paths t pos))\n                    (map #(cons (h pos) %) (paths t (inc pos))))\n            [[(h pos)]]))]\n  (fn [rows]\n    (apply min (map #(reduce + %) (paths rows 0)))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":79,"code":"(fn min-path [tri]\n  (letfn [(node [btr]\n            (ffirst btr))\n          (left [[_ & children]]\n            (when (seq children)\n              (for [row children\n                    :let [left-row (vec (butlast row))]]\n                left-row)))\n          (right [[_ & children]]\n            (when (seq children)\n              (for [row children\n                    :let [right-row (vec (rest row))]]\n                right-row)))\n          (path-sums [btr sum sums]\n            (let [left-subtree (left btr),\n                  right-subtree (right btr),\n                  sum-here (+ sum (node btr))]\n              (cond (and (nil? left-subtree)\n                         (nil? right-subtree))\n                    (conj sums sum-here)\n                    (nil? right-subtree)\n                    (into sums\n                          (path-sums left-subtree sum-here sums))\n                    (nil? left-subtree)\n                    (into sums\n                          (path-sums right-subtree sum-here sums))\n                    :else\n                    (into sums\n                          (into (path-sums left-subtree sum-here sums)\n                                (path-sums right-subtree sum-here sums))))))]\n    (apply min (path-sums tri 0 #{}))))","user":"5341b141e4b00652c8746ecf"},{"code":"(fn [t]\n  (first (reduce \n           #(map + (map (partial apply min) (partition 2 1 %)) %2)\n           (reverse t))))","problem":79,"user":"512f06c5e4b0762be4c7aad7"},{"problem":79,"code":"(fn [t]\n  (letfn [(nnth [i j] (nth (nth t i) j))\n          (paths [i j] \n           (if \n              (= (inc i) (count t)) [[(nnth i j)]]\n              (map #(cons (nnth i j) %) (concat (paths (inc i) j) (paths (inc i) (inc j))))\n           )      \n         )]\n    (apply min (map #(reduce + %) (paths 0 0)))\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":79,"code":"(fn [tri]\n  ((fn tmp [tri i j]\n    (if (>= i (count tri)) 0\n      (+ (get-in (vec tri) [i j]) (min (tmp tri (inc i) j) (tmp tri (inc i) (inc j)))))\n    ) tri 0 0))","user":"56fbf83de4b07572ad1a88da"},{"problem":79,"code":"(fn [vs]\n  (letfn [(sum [vs pos]\n            (if-let [v (first vs)]\n              (+ (v pos) (min (sum (rest vs) pos)\n                              (sum (rest vs) (inc pos))))\n              0))]\n    (sum vs 0)))","user":"53576356e4b04ce2eb3ed27a"},{"problem":79,"code":"(fn [coll]\n  (apply min (reduce (fn [c1 c2]\n            (let [ ct (count c2)]\n              (map (fn [c]\n                     (let [idx (.indexOf c2 c)]\n                       (cond\n                         (= idx 0) (+ (first c1) c)\n                         (= idx (dec ct)) (+ (last c1) c)\n                         :else\n                         ;; 其他的情况就是中间的数字，需要加上别的\n                         (+ c (min (nth c1 idx)\n                                   (nth c1 (dec idx))))\n                         )))\n                   c2)))\n          coll)))","user":"5823d3e6e4b051871117beb8"},{"problem":79,"code":"(fn tmp [tree]\n  (let [path-generator (fn [] (filter #(= (count %) (count tree)) (tree-seq #(< (count %) (count tree)) \n                                        #(list (conj % (last %)) (conj % (inc (last %)))) \n                                        [0])))\n        step-cost (fn [row column] (nth (nth tree row) column))\n        path-cost (fn [path] (apply + (map-indexed step-cost path) ) )]\n    (apply min (map path-cost (path-generator)))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn minimal-path [triangle]\n  (let [t (reverse triangle)\n        combine (fn [a b]\n                  (let [pairs (partition 2 1 a)\n                        m (fn [x] (apply min x))]\n                    (map + (map m pairs) b)))]\n    (first (reduce combine t))))","problem":79,"user":"4f1c2a3a535d64f603146480"},{"code":"(fn min-tri [coll]\n  (letfn [(expand [coll]\n                  (reduce (fn [v n] \n                            (if (coll? (last v)) \n                              (conj (pop v) (conj (last v) n) [n]) \n                              [[n] [n]]))\n                          []\n                          coll))\n         (next-level [t-c b-c] \n                     (map #(+ (apply min %1) %2) t-c b-c))]\n  (apply min (reduce #(next-level (expand %1) %2) coll))))","problem":79,"user":"52463059e4b09dbe66b56198"},{"code":"(fn triangle [ [f & lst] ]\n  (apply min\n   (reduce\n   (fn [acc it]\n     (loop [id 1\n            newAcc [(+ (nth it 0) (nth acc 0))]\n            lastV (+ (nth it 1) (nth acc 0))]\n       (if (= id (- (count it) 1))\n         (conj newAcc lastV)\n         (do\n           (recur\n            (+ id 1)\n            (conj newAcc (min (+ (nth it id) (nth acc (- id 0))) lastV))\n            (+ (nth it (+ 1 id)) (nth acc id))))\n         )))\n   f\n   lst\n   )))","problem":79,"user":"52aa16d1e4b0c58976d9ac5a"},{"code":"(fn [t]\n  (letfn [(tmp-node [v i c w]\n  {\n    :v v \n    :l (if (empty? c) \n        nil \n        (tmp-node (get (first c) i) i (rest c) (+ v w)))\n    :r (if (empty? c)\n        nil \n        (tmp-node (get (first c) (inc i)) (inc i) (rest c) (+ v w)))\n    :w (+ v w)\n  })\n  (build-tmp-tree [t]\n    (tmp-node (ffirst t) 0 (rest t) 0))\n  (min-path [t]\n    (if (nil? (:l t))\n      (:w t)\n      (apply min (map min-path [(:l t) (:r t)]))))]\n  (min-path (build-tmp-tree t))))","problem":79,"user":"50843a4ae4b0c98812d0788b"},{"code":"(letfn [(next-layer [paths layer]\n          (for [path paths\n                n (range 2)]\n            (let [[old-value old-index] path\n                  index (+ old-index n)\n                  value (+ old-value (get layer index))]\n              [value index])))]\n  (fn [triangle]\n    (apply min\n           (map first\n                (reduce next-layer\n                        [(conj (first triangle) 0)]\n                        (rest triangle))))))","problem":79,"user":"5014754de4b094324338f8e5"},{"problem":79,"code":"#(case (count (flatten %))\n   10 7\n   20)","user":"5507cfd3e4b021ccfedb96ad"},{"code":"#(last (reduce (fn [a b] (map + b (map (partial apply min) (partition 2 1 a)))) (reverse %)))","problem":79,"user":"4fca2ef0e4b0ee37620e184e"},{"code":"(fn f [[[h] & t]] (+ h (if t (min (f (map butlast t)) (f (map rest t))) 0)))","problem":79,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":79,"code":"(fn rc\n  ([t] (rc (into [] t) 0 0))\n  ([t r c]\n    (if (>= r (count t))\n      0\n      (let [r2 (inc r)\n            c2 (inc c)]\n        (+ (get-in t [r c]) \n           (min \n             (rc t r2 c)\n             (rc t r2 c2)))))))","user":"56a76f36e4b07966d5a8a05b"},{"problem":79,"code":"(fn [t]\n    (reduce min\n            (map (comp last (fn [p]\n                              (reduce\n                                (fn [[x y a] e]\n                                  [(+ x e)\n                                   (inc y)\n                                   (+ a (nth (nth t (inc y)) (+ x e)))])\n                                [0 0 (first (first t))]\n                                p)))\n                 (map\n                   (fn [n]\n                     (map first\n                          (take (dec (count t))\n                                (rest (iterate (fn [[_ a]] [(mod a 2) (long (/ a 2))])\n                                               [0 n])))))\n                   (range (apply * (repeat (dec (count t)) 2)))))))","user":"51e28063e4b08e53a149f0f2"},{"problem":79,"code":"(fn p79\n  ([t] (p79 (rest t) 0 (nth (first t) 0)))\n  ([t i a]\n   (let [r (first t)\n         t (rest t)]\n     (if (not (seq r)) a\n         (min (p79 t i (+ a (nth r i)))\n              (p79 t (inc i) (+ a (nth r (inc i)))))))))","user":"5357b241e4b04ce2eb3ed282"},{"problem":79,"code":"(letfn [(subtree\n         [t b]\n         (map (fn [v]\n                (case b\n                  :left (vec (first (split-at (dec (count v)) v)))\n                  :right (vec (second (split-at 1 v)))))\n              (rest t)))\n        (minimal-path\n         [t]\n         (if (= (count t) 1)\n           (first (first t))\n           (+ (first (first t))\n              (min (minimal-path (subtree t :left))\n                   (minimal-path (subtree t :right))))))]\n  minimal-path)","user":"5829d9f8e4b051871117bf4d"},{"problem":79,"code":"(fn triangle-minimal-path [t]\n  (let [t (into [] t)\n        next-nodes (fn [row col] [[(+ row 1) col]\n                                  [(+ row 1) (+ col 1)]])\n        sum-triangle (reduce #(conj %1 (vec (repeat (count %2) nil)))\n                             [(first t)]\n                             (rest t))\n        get-node (fn [t row col] (nth (nth t row) col))\n        set-node (fn [t row col n]\n                   (assoc t row (assoc (nth t row) col n)))\n        modify-sum-triangle\n        (fn [sum-triangle row col]\n          (let [[[next-row1 next-col1]\n                 [next-row2 next-col2]] (next-nodes row col)\n                n (get-node sum-triangle row col)\n                next-n1 (get-node t next-row1 next-col1)\n                next-n2 (get-node t next-row2 next-col2)\n                to-beat1 (get-node sum-triangle next-row1 next-col1)\n                to-beat2 (get-node sum-triangle next-row2 next-col2)\n                modif\n                (if (or (= to-beat1 nil) (< (+ n next-n1) to-beat1))\n                  (set-node sum-triangle\n                            next-row1\n                            next-col1\n                            (+ n next-n1))\n                  sum-triangle)]\n            (if (or (= to-beat2 nil) (< (+ n next-n2) to-beat2))\n              (set-node modif next-row2 next-col2 (+ n next-n2))\n              modif)))\n        iter (fn [row col] (if (= col row)\n                             [(+ row 1) 0]\n                             [row (+ col 1)]))\n        nb-rows (- (count t) 1)]\n    (loop [[row col] [0 0]\n           sum-triangle sum-triangle]\n      (if (= row nb-rows)\n        (reduce min (last sum-triangle))\n        (recur (iter row col)\n               (modify-sum-triangle sum-triangle\n                                    row\n                                    col))))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":79,"code":"(fn [triangle]\n  (reduce min\n          (map #(apply min %)\n               (reduce\n                (fn [prev cur]\n                  (vec (map-indexed\n                        (fn [i col]\n                          (remove nil?\n                                  (flatten (map-indexed (fn [j item]\n                                                          (if (and (not= 1 (- i j)) (not= i j)) nil\n                                                              (cond (number? item) (+ item col)\n                                                                    :else (map #(+ % col) item))))\n                                                        prev)))) cur))) triangle))))","user":"58f98231e4b0438e51c2cf4c"},{"problem":79,"code":"(fn m [[[r] & t]]\n  (if (nil? r) 0\n      (+ r (min (m (map rest t))\n                (m (map butlast t))))))","user":"5532a04ee4b09218d5f44f82"},{"code":"(fn [tr]\n  (apply min (reduce #(map (fn [a [b c]] (min (+ a b) (+ a c)))\n                           %2\n                           (partition 2 1 (concat [(first %1)]\n                                                  %1\n                                                  [(last %1)])))\n                     tr)))","problem":79,"user":"4f1bb9d8535d64f60314647d"},{"problem":79,"code":"(fn [triangle]\n  (apply min (map (partial reduce +)\n                  (map second\n                       (loop [[x y :as triangle] triangle\n                              acc [[0 x]]]\n                         (if y\n                           (recur (rest triangle) (mapcat (fn [[idx path]]\n                                                            [[idx (conj path (get y idx))]\n                                                             [(inc idx) (conj path (get y (inc idx)))]]) acc))\n                           acc))))))","user":"5a250b86e4b07f18be40aa19"},{"code":"(fn min-path-sum\n  [triangle]\n  (letfn [(vector-sum [v1 v2]\n            (map + v1 v2))]\n    (loop [[x y & xs] (reverse triangle)]\n      (if y\n        (recur\n          (cons\n            (map (comp (partial apply min) vector-sum)\n                 (partition 2 1 x) (map (partial repeat 2) y))\n            xs))\n        (first x)))))","problem":79,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn f1[x]\n   (letfn [(f [x y](apply merge-with concat \n            (map #(hash-map \n              % (map (fn[z] (conj z (nth y %))) (get x %))\n              (inc %) (map (fn[z] (conj z (nth y (inc %)))) (get x %)))\n            (keys x))))\n            (f2 [x](map (fn[dd] (map (fn[d] (apply + d)) dd)) x))]\n    (apply min (flatten \n        (f2 (vals (reduce f {0 (vector (first x))} (rest x))))))))","problem":79,"user":"500b61b1e4b03d00572d2d81"},{"problem":79,"code":"(fn triangle_path [triangle]\n    (let \n    [\n        triangle (into [] triangle)\n        aux\n            (memoize (fn [f row col]\n                (if (or (< row 0 ) (< col 0)) 0\n                    (let [ above (f f (dec row) col) above_left (f f (dec row) (dec col)) ]\n                        (+ (get-in triangle [row col] 0)\n                            (cond\n                                (and (= row 0) (= col 0)) 0\n                                (= col 0) above\n                                (= col (dec (count (nth triangle row))) ) above_left \n                                :otherwise (min above above_left)\n                            )\n                        )\n                    )\n                )\n            ))\n        aux\n            (partial aux aux)\n    ]\n    (let [last_row_index (dec (count triangle)) last_row_size (count (last triangle))]\n        (->> (map list (repeat last_row_index) (range last_row_size))\n            (map #(apply aux %))\n            (apply min)\n        )\n    )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":79,"code":"(fn tri [cc]\n  (let [calc\n        (fn [row rowres]\n          (concat (list (+ (first row) (first rowres)))\n                  (for [[i j] (partition 2 1 (-> row (count) (dec) (range)))]\n                    (min (+ (nth row j) (nth rowres i)) (+ (nth row j) (nth rowres j))))\n                  (list (+ (last rowres) (last row)))))\n        level\n        (fn [cc rowres]\n          (if (empty? cc)\n            (apply min rowres)\n            (recur (rest cc) (calc (first cc) rowres))))]\n    (level (rest cc) (first cc))))","user":"5953bdb6e4b066ee0a44aeed"},{"code":"#(apply min (reduce (fn f [r t]\n  (map + t (map min (cons (first r) r) (concat r (list (last r)))))) %))","problem":79,"user":"4ec07699535dfed6da9c6da2"},{"problem":79,"code":"(fn compute-path\n  [tree]\n  (let [children     (fn children\n                       [[i j]]\n                       [[(inc i) j]\n                        [(inc i) (inc j)]])\n        minimum-path (fn minimum-path\n                       [paths]\n                       (apply min-key\n                              (partial apply +)\n                              paths))\n        make-paths   (fn make-paths\n                       ([tree] (make-paths (vec tree) [] [0 0]))\n                       ([tree path location]\n                        (if-let [current (get-in tree location)]\n                          (let [path          (conj path current)\n                                [loc-a loc-b] (children location)]\n                            (clojure.set/union (make-paths tree path loc-a)\n                                               (make-paths tree path loc-b)))\n                          #{path})))]\n    (apply +\n           (minimum-path\n            (make-paths tree)))))","user":"53de7484e4b0d874e779ae35"},{"problem":79,"code":"(fn shortest-path\n  ([coll] (shortest-path coll 0))\n  ([coll idx]\n   (let [segment (get (first coll) idx)\n         segments (rest coll)]\n     (if (seq segments)\n       (let [choice1 (shortest-path segments idx)\n             choice2 (shortest-path segments (inc idx))]\n         (+ segment (min choice1 choice2)))\n       segment))))","user":"56488119e4b0284900eef632"},{"code":"(fn q79 [coll]\n  (letfn [ \n    (small [coll] \n  \t  (if (= 1 (count coll)) \n        (first coll) \n\t\t    (map #(apply min %) (partition 2 1 coll))))]\n    (reduce \n      #(small (map + % %2))\n      (repeat 0)\n      (reverse coll))))","problem":79,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":79,"code":"#(let [init (list [(nth % 0) 0])\nnext (fn [[path index]] (let [n (count path) v (nth % n)] \n  (list [(conj path (get v index)) index] [(conj path (get v (+ index 1))) (+ index 1)])))\nappl-combi (fn [combis] (apply concat (map next combis)))\ncombinations (nth (iterate appl-combi init) (- (count %) 1))\nm-f (fn [[x v]] [x (reduce + 0 x)])\nminimal-path (->> combinations\n  (map m-f)\n  (apply min-key (fn [x] (get x 1))))]\n(get minimal-path 1))","user":"5e13a6b7e4b099d064963001"},{"code":"(fn stuff [triangle]\n  (apply min (reduce\n         (fn [costs item]\n           (apply vector (map-indexed\n                           (fn [i cost]\n                             (+' cost (min\n                                       (get costs i Integer/MAX_VALUE)\n                                       (get costs (dec i) Integer/MAX_VALUE))))\n                           item))) triangle)))","problem":79,"user":"4f03641a535dcb61093f6a9b"},{"problem":79,"code":"(fn triangle-min-path \n  ([triangle] (triangle-min-path (rest triangle) (ffirst triangle) 0 nil))\n  ([[row & next-triangle-section] sum i lowest-sum]\n   (do\n     (println row next-triangle-section sum i lowest-sum)\n     (if (and lowest-sum (> sum lowest-sum))\n       lowest-sum\n       (let [[left-sum right-sum :as sums] (map (partial + sum) (subvec row i (+ i 2)))]\n         (if next-triangle-section\n           (->> lowest-sum\n                (triangle-min-path next-triangle-section left-sum i)\n                (triangle-min-path next-triangle-section right-sum (inc i)))\n           (first (sort (filter (complement nil?) (conj sums lowest-sum))))))))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [p]\n  (first\n    (reduce #(map + %2\n              (map (partial apply min)\n                (partition 2 1 %)))\n      (reverse p))))","problem":79,"user":"50657775e4b0deb876850599"},{"problem":79,"code":"(fn [triangle]\n    (let [row (last triangle)]\n      (if (= (count row) 1)\n        (first row)\n        (recur (concat (drop-last 2 triangle)\n                       [(mapv (fn [a [b c]] (min (+ a b) (+ a c)))\n                              (last (drop-last triangle))\n                              (partition 2 1 (last triangle)))])))))","user":"5777cffae4b0979f89651651"},{"problem":79,"code":"(fn [triangle]\n    (letfn [(make-tree [lov indx]\n              (if (seq lov)\n                [(nth (first lov) indx) {:left-adj (make-tree (rest lov) indx) :right-adj (make-tree (rest lov) (inc indx))}]\n                nil))\n            (visit-nodes [tree acc]\n              (if (apply :left-adj (rest tree))\n                [(visit-nodes (apply :left-adj (rest tree)) (conj acc (first tree)))\n                 (visit-nodes (apply :right-adj (rest tree)) (conj acc (first tree)))]\n                (conj  acc (first tree))))\n            (almost-flatten [x]\n              (filter #(and (sequential? %) (not-any? sequential? %))\n                      (rest (tree-seq #(and (sequential? %) (some sequential? %)) seq x))))]\n      (apply min  (map #(apply + %) (almost-flatten (visit-nodes  (make-tree triangle 0) []))))))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":79,"code":"(fn __ [triangle]  \n  (apply min (reduce  \n   #(map +\n     (interleave %1 %1)\n     ((fn x [y a](if (zero? a) (flatten y) (x (partition 2 1 y) (dec a) ))) %2 (- (count %2) 2)))\n   (first triangle)\n   (rest triangle))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn triangle-min-path\n  [xs]\n  (let [x  (ffirst xs)\n        xs (next xs)]\n    (if xs\n      (let [l (map drop-last xs)\n            r (map rest xs)]\n        (+ x (min (triangle-min-path l) (triangle-min-path r))))\n      x)))","problem":79,"user":"4e50b67b535dc968683fc4ed"},{"problem":79,"code":"(fn [lsts]\n  (if (next lsts)\n    (let\n      [adder (->> (first lsts)\n                  (partition 2 1)\n                  (map #(apply min %))\n                  (cons (first (first lsts)))\n                  (into []))\n       added (map + (conj adder (last (first lsts))) (second lsts))]\n      (recur (cons added (drop 2 lsts)))\n      )\n    (apply min (first lsts))\n    )\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":79,"code":"(fn [tr]\n  (let [get-node (fn [t i j] (nth (nth t i) j))\n        get-adj-nodes (fn [node nodes]\n                        (if (= (:r node) (dec (count nodes)))\n                          nil\n                          [(get-node nodes (inc (:r node)) (:c node)) (get-node nodes (inc (:r node)) (inc (:c node)))]))\n        path-source? (fn [node path] (= node (first path)))\n        path-dest? (fn [node path] (= node (last path)))\n        path-cost (fn [path] (reduce #(+ %1 (:v %2 0)) 0 path))\n        nodes (for [i (range 0 (count tr))]\n                (for [j (range 0 (count (nth tr i)))]\n                  (let [v (nth (nth tr i) j)]\n                    {:v v :r i :c j})))\n        edges (->> (for [i (range 0 (dec (count nodes)))]\n                \t(for [j (range 0 (count (nth nodes i)))]\n                  \t\t(let [n (get-node nodes i j)\n                        \tadjn (get-adj-nodes n nodes)]\n                    \t\t[[n (first adjn)] [n (last adjn)]])))\n                   (apply concat)\n                   (apply concat))\n        paths (reduce (fn [acc node]\n                        (let [dest-paths (->> acc (filter (partial path-dest? node)) (into []))\n                              [e1 e2] (->> edges (filter (partial path-source? node)) (into []))\n                              new-paths (apply concat (map #(vector (conj % (last e1)) (conj % (last e2))) dest-paths))]\n                          (apply conj (apply disj acc dest-paths) new-paths))\n                        ) (->> edges (take 2) (into #{})) (rest (flatten nodes)))]\n    (->> paths (map path-cost) (apply min))))","user":"542c22bde4b0dad94371f29e"},{"problem":79,"code":"#(loop [[f & r :as o] (first %) [n & t] (rest %)]\n    (if (nil? n)\n      (apply min o)\n      (recur \n        (mapv + n (concat [f] (map min r (butlast o)) [(last o)])) \n        t)))","user":"576df252e4b0979f8965156f"},{"problem":79,"code":"(fn [g]\n  (let [\ngp (fn [l] (reduce #(conj %1 (conj %2 (last %2)) (conj %2 (inc (last %2)))) [] l))\np (fn [n] (nth (iterate gp [[0]]) (dec n)))]\n    (apply min (map #(apply + (map nth g %)) (p (count g))))))","user":"5632e850e4b0bfe05bf117ac"},{"problem":79,"code":"(fn tmp [triangle]\n    (let [max-y (dec (count triangle))\n          triangle-v (vec triangle)\n          tmp-r (fn tmp-r [x y this-path acc]\n                    (let [this-value (get-in triangle-v [y x])]\n                        (if (= y max-y)\n                            (list (+ this-path this-value))\n                            (concat acc\n                                    (mapcat #(tmp-r % (inc y) (+ this-path this-value) acc) [x (inc x)])))))]\n        (apply min (tmp-r 0 0 0 []))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":79,"code":"(fn [s] ((memoize (fn rec [i [v & more]] (if more (+ (v i) (min (rec i more) (rec (inc i) more))) (v i)))) 0 s))","user":"5c379636e4b0d62ef62d9f76"},{"problem":79,"code":"(fn triangle-minimal-path\n  ([triangle]\n   (letfn[(add-elems [[a b]]\n            (if (sequential? a)\n              (mapv (partial + b) a)\n              (+ a b)))\n\n          (add-rows [rows]\n            (->> rows\n                 (apply interleave)\n                 (partition 2)\n                 (mapv add-elems)))\n          \n          (step-to-next-row [prev row]\n            (let [left-path  (add-rows [prev (drop-last row)])\n                  right-path (add-rows [prev (rest row)])\n                  ret-first  (first left-path)\n                  ret-last   (last right-path)\n                  \n                  left-mid   (rest left-path)\n                  right-mid  (drop-last right-path)\n                  \n                  ret-mid    (if (empty? left-mid)\n                               nil\n                               (->> [left-mid right-mid]\n                                    (apply interleave)\n                                    (partition 2)\n                                    (mapv flatten)\n                                    ))]\n              (concat [ret-first] ret-mid [ret-last] )))]\n\n            (->> (reduce step-to-next-row triangle)\n                (flatten)\n                (apply min)\n                ))))","user":"5bf5ddfde4b0bdcf453d159e"},{"code":"(fn [c]\n    (let [V (vec c) \n          t (dec (count V))\n          f (fn [[u v] A] (+ (A u) (get-in V v))) ]\n       (loop [A  {[0 0] (get-in V [0 0])}\n              FE [ [[0 0] [1 0]] [[0 0] [1 1]] ] ]\n          (let [ [a [u v]] (reduce (fn [[m j] e]\n                                       (let [x (f e A)]   (if (< x m) [x e] [m j])))\n                                   [Long/MAX_VALUE [[0 0] [0 0]] ] \n                                   FE)\n                 [x y] v ]\n\n              (if (= t x)\n                  a\n                  (let [z (remove #(= [u v] %) FE) ]\n                     (recur (assoc A v a) \n                            (vec (concat z (filter #(not (A (last %))) \n                                                   [ [v [(inc x) y]]\n                                                     [v [(inc x) (inc y)]] ] ))))))))))","problem":79,"user":"4ee7d177535d93acb0a6686f"},{"problem":79,"code":"(fn minimal-triangle-path [triangle]\n  (let [triangle-vec         (vec triangle)\n        start-nodes          (map (fn [i] [(dec (count triangle)) i]) (range (count triangle)))\n        adjacent-upper-nodes (fn [[row col]] (cond\n                                              (= 0 col) [[(dec row) col]]\n                                              (= row col) [[(dec row) (dec col)]]\n                                              :else [[(dec row) col] [(dec row) (dec col)]]))\n        node-value           (partial get-in triangle-vec)\n        next-node            (fn [current-node] (apply min-key node-value (adjacent-upper-nodes current-node)))\n        path-sum (fn [path] (apply + (map node-value path)))\n        min-path-from-node (fn [start-node] (take (count triangle-vec) (iterate next-node start-node)))]\n    (->> start-nodes\n      (map min-path-from-node)\n      (apply min-key path-sum)\n      path-sum)))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn [triangle]\n  (let\n    [depth (count triangle)\n     val-at (fn [x y] (nth (nth triangle y) x))\n     min-path-through (fn min-path-through [x y]\n       (if (= y depth)\n         0\n         (+ (val-at x y)\n          (min (min-path-through x (inc y))\n               (min-path-through (inc x) (inc y))))))]\n    (min-path-through 0 0)))","problem":79,"user":"4f725466e4b07046d9f4f030"},{"problem":79,"code":"(fn triangle-min-path\n  [t]\n  (let [v (first (first t))]\n    (if (= 1 (count t))\n      v\n      (min (+ v (triangle-min-path (map butlast (next t))))\n           (+ v (triangle-min-path (map next (next t))))))))","user":"5ed6030de4b016b56eae05db"},{"code":"(fn mp \n  ([tr]\n    (mp (into [] tr) 0 0 0))\n  ([tr init x y]\n    (if (= (inc x) (count tr))\n      (+ init ((tr x) y))\n        (min (mp tr (+ init ((tr x) y)) (inc x) y)\n             (mp tr (+ init ((tr x) y)) (inc x) (inc y))))))","problem":79,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn [triangle] \n  (apply min ((fn path-sum [p]\n                (if (= (count triangle) (count p)) \n                  [(reduce + (map-indexed #(get-in triangle [%1 %2]) p))] \n                  (let [x (last p)] \n                    (concat \n                      (path-sum (conj p x)) \n                      (path-sum (conj p (inc x))))))) \n              [0])))","problem":79,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":79,"code":"(fn min-path [tri]\n  (let [tri (into [] tri)\n        co-ord->value ((fn [tri]\n                         (fn [[col row]]\n                           (get-in tri [row col]))) tri)\n        one->two-extender (fn [path]\n                            (let [[end-col end-row] (last path)\n                                  lower-left-ending [end-col (inc end-row)]\n                                  lower-right-ending [(inc end-col) (inc end-row)]]\n                              [(into path [lower-left-ending]) (into path [lower-right-ending])]))]\n    (->> (iterate (fn [paths] (mapcat one->two-extender paths)) [[[0 0]]])\n         (take (count tri))\n         last\n         (map (fn [co-ords] (map co-ord->value co-ords)))\n         (map (partial apply +))\n         (apply min))))","user":"561d8936e4b064ca9f4b16b2"},{"problem":79,"code":"(fn [tr]\n     (apply min\n            (reduce (fn [final elem]\n                      (if (empty? final)\n                        elem\n                        (map #(+ %1 (apply min %2))\n                             elem\n                             (partition 2 1 (concat (take 1 final) final (take-last 1 final))))\n                        )) '() tr))\n     )","user":"58987ee9e4b00487982d52d2"},{"problem":79,"code":"(fn [[h & t]]\n    (loop [sums h\n           [n & n1 :as nodes] t]\n      (if (nil? nodes)\n        (apply min sums)\n        (let [[x & y] (map + sums n)\n              newsums (map + sums (rest n))]\n          (recur (concat [x]\n                         (map min y newsums)\n                         [(last newsums)])\n                 n1)))))","user":"544e9022e4b0e3978000698b"},{"problem":79,"code":"(fn [lst]\n  (let [p (fn p [pos lst]\n            (if (= 1 (count lst))\n              (nth (first lst) pos)\n              (min (+ (nth (first lst) pos) (p pos (rest lst)))\n                   (+ (nth (first lst) pos) (p (inc pos) (rest lst))))))]\n    (p 0 lst)))","user":"53664e3be4b0243289761e74"},{"code":"(fn [t] \n  (first\n   (reduce #(map + (map min % (rest %)) %2) (reverse t))))","problem":79,"user":"4dada16fc9a9d6ed2699dc57"},{"problem":79,"code":"(fn [s] \n (->> (reverse s)\n      (reduce \n        (fn [fr pr]\n          (map #(+ %1 (min %2 %3)) pr fr (rest fr))))\n      first))","user":"56b86e64e4b0f26550335924"},{"code":"(fn [t]\n  (loop [s (first t) r (rest t)]\n    (if (empty? r)\n      (apply min s)\n      (let [es (concat [(first s)] s [(last s)])]\n        (recur\n         (map-indexed #(+ %2 (min (nth es %1) (nth es (inc %1)))) (first r))\n         (rest r))))))","problem":79,"user":"4f713878e4b07046d9f4f00a"},{"code":"(fn minimal-path [triangle]\n  (let [root         (ffirst triangle)\n        generations  (next triangle)\n        perform-step (fn [length [x y]] [(+ length x) (+ length y)])\n        shrink       (fn [lengths]\n                       (->> (next lengths)\n                         (partition-all 2)\n                         (map #(apply min %))\n                         (cons (first lengths))))]\n    (->> generations\n      (map (partial partition 2 1))\n      (reduce #(shrink (mapcat perform-step %1 %2)) [root])\n      (apply min))))","problem":79,"user":"4f169a0f535d64f60314644c"},{"problem":79,"code":"(fn ps [vs]\n    (let [vvs (vec vs)\n          cost (fn [path]\n                 (reduce +\n                  (map-indexed #(get-in vvs [% %2]) path)))\n          next (fn [paths]\n                 (for [path paths\n                       :let [pos (last path)\n                             next-len (inc (count path))]\n                       next (range pos (min (+ 2 pos) next-len))]\n                   (conj path next)))\n          n (count vs)\n          paths (take n (iterate next [[0]]))]\n      (->> (last paths)\n           (map #(vector % (cost %)))\n           (sort-by second)\n           first second)))","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":79,"code":"(fn [tri]\n  (let [merge-rows (fn [s r]\n                     (->> (interleave s s)\n                          (drop 1)\n                          (butlast)\n                          (interleave (interleave r r))\n                          (partition 2)\n                          (map #(apply + %))\n                          (partition 2)\n                          (map #(apply min %))))]\n    (first (reduce merge-rows (reverse tri)))))","user":"530b8580e4b02e82168697cc"},{"problem":79,"code":"#(letfn [(add [n r] (map (fn [x] (+ n x)) r))\n        (pairs [r p] (concat (butlast r) [(min (first p) (last r)) (second p)]))\n        (rows [p n] (->> (map (fn [x r] (add x r)) p (partition 2 1 n)) (reduce pairs)))]\n  (->> % (reduce rows) (apply min)))","user":"576e607ae4b0979f89651579"},{"problem":79,"code":"(fn [s]\n  (letfn [(genline [ss]\n                   (let [rs (reverse ss)]          \n                     (if (<= (first rs) (second rs))\n                       (reverse (concat [(inc (first rs)) (second rs)] (nnext rs)))\n                       (concat (genline (butlast ss)) [(dec (last ss))]))))]\n    (let [lines\n          (filter \n           #(every? (fn [x] (apply <= x)) (partition 2 1 %))\n           (loop [r [(take (count s) (repeat 0))] step 0]\n             (if (= (last r) (range (count s))) r\n               (recur (conj r (genline (nth r step))) (inc step)))))]\n      (apply min (for [x lines]\n                   (apply + (for [y (range (count x))]\n                              (nth (nth s y) (nth x y))))))\n      )))","user":"574abbfbe4b02ea114799200"},{"problem":79,"code":"(fn mintri [t]\n    (let [n (count t)]\n      (if (= 2 n)\n        (+ (first (first t)) (apply min (second t)))\n        (mintri\n         (conj (vec (drop-last 2 t))\n               (vec (map-indexed\n                     #(+ %2 (apply min (subvec (last t) %1 (+ %1 2))))\n                     (nth t (- n 2)))))))))","user":"579693d4e4b039eba2ecb0e7"},{"problem":79,"code":"(fn [levels]\n  (let [[l & ls] (reverse levels)]\n    (letfn [(sum-level [prev cur]\n              (->> cur\n                   (map-indexed #(+ %2 (min (prev %1) (prev (inc %1)))))\n                   (into [])))]\n      (first (reduce sum-level l ls)))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":79,"code":"(fn minimal-path-sum\n  [triangle]\n  (let [n (count triangle)\n        paths (fn [n]\n                (loop [r 1\n                       ps [[0]]]\n                  (if (>= r n)\n                    ps\n                    (recur (inc r)\n                           (for [path ps\n                                 :let [i (peek path)]\n                                 j [i (inc i)]]\n                             (conj path j))))))\n        ps (paths n)\n        path-sum (fn [triangle path]\n                   (apply + (map #(nth %1 %2) triangle path)))]\n    (->> ps\n         (map #(path-sum triangle %))\n         sort\n         first)))","user":"57617c20e4b0994c1922fb8c"},{"code":"(fn tmp[rows]\n\t(letfn [\n\t\t\t(choices [lst]\n\t\t\t\t(loop [cur (first lst)\n\t\t\t\t       las 9999\n\t\t\t\t\t\t\t a []\n\t\t\t\t\t\t\t lst lst]\n\t\t\t\t\t(if lst \n\t\t\t\t\t\t(recur (first (next lst)) cur (conj a [cur las]) (next lst))\n\t\t\t\t\t\t(conj a [las]))))\n\t\t\t(minrows[accu rows]\n\t\t\t\t(let [ch (choices accu)\n\t\t\t\t\t\t\tn (first rows)\n\t\t\t\t\t\t\ta (map #(apply min (map (fn[a] (+ a %2)) %1)) ch n)]\n\t\t\t\t\t(if (next rows)\n\t\t\t\t\t\t(minrows a (next rows))\n\t\t\t\t\t\ta)))]\n\t\t(apply min (minrows (first rows) (next rows)))))","problem":79,"user":"4f1fd734535d64f6031464a5"},{"problem":79,"code":"(fn foo [[[x] & triangles]]\r\n  (if (empty? triangles) x\r\n    (let [left (foo (map drop-last triangles))\r\n          right (foo (map rest triangles))]\r\n      (min (+ x left) (+ x right)))))","user":"606e0a42e4b069485764de19"},{"code":"(fn [t] (first (reduce #(map (fn [x s] (+ x (apply min s))) %2 (partition 2 1 %)) (reverse t))))","problem":79,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn _\n   ([tri](let [row (first tri) e (first row) t (rest tri) next_row (first t)\n               esp_nest (fn [nest_seq](loop [nseq  nest_seq](if  (not (sequential? (first (first nseq))))nseq(recur (apply concat nseq)))))]\n     (first (sort (map #(apply + %) (esp_nest (conj [] (_ (rest t) [e (nth next_row 0)] 0) (_ (rest t) [e (nth next_row 1)] 1))))))\n   ))\n   ([tri m ind]\n     (if (empty? tri)m\n       (let [row (first tri) t (rest tri)]\n         (conj [] (_ t (conj m (nth row ind)) ind) (_ t (conj m (nth row (inc ind))) (inc ind)))\n       )\n     )\n   )\n)","problem":79,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn min-path [triangle]\n  (if (empty? triangle) 0\n    (let [[[n] & t] triangle]\n      (+ n (min (min-path (map butlast t))\n                (min-path (map rest t)))))))","problem":79,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":79,"code":"(fn my-min-route [triangle]\n  (letfn [(fold1 [coll coll2]\n                 (map-indexed (fn [idx item]\n                                [[item (coll2 idx)]\n                                 [item (coll2 (inc idx))]]) coll))\n          (fold2 [coll coll2]\n                 (->> (fold1 coll coll2)\n                      (map (fn [colls]\n                             (apply min (map #(apply + %1) colls))))\n                      vec))\n          (min-count [triangle]\n                     (if (== (count triangle) 1)\n                       (first triangle)\n                       (recur (conj (vec (drop-last 2 triangle)) \n                                           (apply fold2 (take-last 2 triangle))))))]\n    (first (min-count triangle))))","user":"5370d152e4b0fc7073fd6e9d"},{"code":"#(last\n  (reduce (fn [c l]\n            (map + (map min c (next c)) l))\n          (reverse %)))","problem":79,"user":"51ad244fe4b09397d510977f"},{"problem":79,"code":"(fn calc-path [& args]\n     (let [xs (first args)] \n      (letfn [(reduce-first-two[ts zs]\n       (letfn [(get-from-pairs[bs]  (concat (vector (first bs)) ( #(for [[a b] (partition 2 (butlast (rest %)))](min a b)) bs) (vector (last bs))) )]\n          (loop [acc [] ys ts vs zs]\n             (if (empty? ys)\n                  (vector (if (> (.size acc) 3)  (get-from-pairs acc) acc))\n                  (\n                    recur  (concat acc (vector (+ (first ys) (first vs)) (+ (first ys) (second vs))) )\n                           (rest ys)\n                           (rest vs)\n                  )\n               )\n          )\n       ))]\n      (if (= (.size (rest xs)) 1)\n        (apply min (flatten (concat (reduce-first-two  (first xs)  (second xs) ) (rest (rest xs)))))\n        ;(concat (reduce-first-two  (first xs)  (second xs) ) (rest (rest xs)))\n        (calc-path (concat (reduce-first-two  (first xs)  (second xs) ) (rest (rest xs))))\n        )\n     )\n   )\n )","user":"55d7312ee4b0e31453f64a9f"},{"problem":79,"code":"(fn get-minimal-path-sum [x]  \n  (if (empty? x)\n    0\n    (let [vl (get-minimal-path-sum (map butlast (rest x)))\n          vr (get-minimal-path-sum (map rest (rest x)))]\n      (+ (ffirst x) (min vl vr)))))","user":"54e345a1e4b024c67c0cf7db"},{"problem":79,"code":"(fn min-path\n  ([rows] (min-path rows 0))\n  ([rows i] (if-let [[row & rows] rows]\n              (+ (row i)\n                 (min (min-path rows i)\n                      (min-path rows (inc i))))\n              0)))","user":"583e27e2e4b089d5ab817daa"},{"problem":79,"code":";; from 1067\n(fn triangle-min-path [xs]\n  (->> (reverse xs)\n       (reduce (fn [d u]\n                 (map + u (map min d (drop 1 d)))))\n       (first)))\n;; my real answer is\n;; ;; 79.Triangle Minimal Path\n;; (defn triangle-min-path [coll]\n;;   (->> coll\n;;        (reduce (fn induction [row0 row1]\n;;                  (let [front (map + row0 (drop-last row1))\n;;                        back (map + row0 (drop 1 row1))]\n;;                    (concat [(first front)]\n;;                            (apply min (drop 1 front) (drop-last back))\n;;                            [(last back)]))))\n;;        (apply min)))","user":"5d2e5065e4b01671435dbcae"},{"problem":79,"code":"(fn [xs]\n  (letfn [(gentree [ys n]\n            (if (empty? (rest ys))\n              (nth (first ys) n)\n              (lazy-cat (vector (nth (first ys) n))\n                        (vector (gentree (rest ys) n))\n                        (vector (gentree (rest ys) (inc n))))))\n          (walkpath [txs]\n             (if (number? txs)\n               txs\n               (+ (first txs) (min (walkpath (second txs)) (walkpath (nth txs 2))))))]\n    (walkpath (gentree xs 0))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":79,"code":"(fn  [data]\n  (let [prep  (fn [in]  (map (partial map-indexed vector) in))\n        dataset (reverse (prep data))\n        min-of (fn [v1 v2] (if (< (second v1) (second v2)) v1 v2))\n        get-item (fn [vect index] (if (and (< index (count vect))(>= index 0))(vect index) [index Integer/MAX_VALUE ]))\n        reduce-fn (fn [vecto e] (let [curr-index (first (last vecto))\n                                      v (into [] e)\n                                      min-v (min-of (get-item v curr-index) (get-item v (dec curr-index)))]\n                                  (conj vecto min-v)))\n        find-min-path (fn [start graph] (reverse  (reduce reduce-fn [start] graph )))\n        filter-data  (fn [lst] (map second lst))\n        sum (fn [lst] (reduce + lst))]\n    (apply min  (map sum  (map filter-data  (map #(find-min-path % (rest dataset )) (first dataset)))))))","user":"5832be57e4b089d5ab817c86"},{"problem":79,"code":"(fn walk\n  ([tree] (walk tree 0))\n  ([tree i] \n  \t(let [cur (nth (first tree) i)\n          base (rest tree)]\n      (if (empty? base)\n        cur\n  \t\t(+ cur (min (walk base i) (walk base (inc i))))))))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn min-path [triangle]\n  (if (= 1 (count triangle))\n    (ffirst triangle)\n    (let [left-sub-triangle (map butlast (rest triangle))\n          right-sub-triangle (map rest (rest triangle))]\n      (+ (ffirst triangle) (min (min-path left-sub-triangle)\n                                (min-path right-sub-triangle))))))","problem":79,"user":"5186134ce4b0da5a5be3bac7"},{"problem":79,"code":"(fn eka\n    ([xs] (eka 0 (first xs) (rest xs)))\n    ([pos path xs]\n     (let [p1 (conj path (get (first xs) pos))\n           p2 (conj path (get (first xs) (inc pos)))]\n       (if (seq (rest xs))\n         (min (eka pos p1 (rest xs)) (eka (inc pos) p2 (rest xs)))\n         (min (reduce + p1) (reduce + p2))\n         )\n       )\n      ))","user":"596d630ae4b069c0a1a19846"},{"problem":79,"code":"#((memoize (fn tri-min-path [[curr-row & more :as list-of-vec] index]\n             (if (empty? list-of-vec)\n               0\n               (min\n                (+ (get curr-row index) (tri-min-path more index))\n                (if-let [right-val (get curr-row (inc index))]\n                  (+ right-val (tri-min-path more (inc index)))\n                  Integer/MAX_VALUE)))))\n  %1 0)","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":79,"code":"(fn __ [triangle]\n  (letfn [\n\n          (isTerminal? [triangle] (= (count  triangle) 1))\n          (lefty [triangle] (map #(drop-last %) (rest triangle)))\n          (righty [triangle] (map #(rest %) (rest triangle)))\n\n          (paths [triangle]\n            (let [node (ffirst triangle)]\n              (if (isTerminal? triangle) (list (list node))\n                  (map #(conj % node) (concat\n                                       (paths (lefty triangle))\n                                       (paths (righty triangle)))))))\n          ] (reduce min\n                    (map #(reduce + %) (paths triangle)))))","user":"5e078ba7e4b0978307768fb6"},{"problem":79,"code":"(fn [tri]\n    (let [paths  (fn paths [[roots & nxt]]\n                   (if (seq nxt)\n                     (let [children (paths nxt)\n                           grouped (partition (/ (count children) (inc (count roots)))\n                                              children)]\n                       (mapcat (fn [p [a b]] (for [item (concat a b)] (cons p item)))\n                               roots (partition 2 1 grouped)))\n                     (map list roots)))]\n      (apply min (keys (group-by (partial reduce +) (paths tri))))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"code":"(fn [ar]\n  (let [t (fn t-m-p [[f & a]]\n      (let [m (vec a)]\n\t\t (if (= 1 (count m)) (let [arr (first m)]\n\t\t\t(vec (map-indexed #(vector (+ %2 (arr %)) (+ %2 (arr (inc %)))) f)))\n\t\t     (vec (map-indexed #(concat (map (fn [x] (+ x %2)) ((t-m-p a) %) )\n\t\t\t\t    (map (fn [x] (+ x %2)) ((t-m-p a) (inc %)))) f)))))]\n(apply min (first (t ar)))))","problem":79,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":79,"code":"(fn [triangle]\n   (letfn [(collapse [s]\n     (let [above      (first s)\n           below      (second s) \n           vals-above (concat [[(first above)]] (map vec (partition 2 1 above)) [[(last above)]])]\n       (lazy-seq (cons (map #(+ %1 (apply min %2)) below vals-above) (rest (rest s))))))]\n      (apply min (first (last (take-while #(not-empty (first %)) (iterate collapse triangle)))))))","user":"545e9cf1e4b01be26fd7467f"},{"problem":79,"code":"(fn\n  [coll]\n  ; work from bottom to top, each row calculating min of each pair of\n  ; elements and then summing the resultant vector to the vector above\n  (letfn [(add-v [vold vnew]\n            (lazy-seq\n              (if (seq vnew)\n                (cons (+ (min (first vold)\n                              (second vold))\n                         (first vnew)) (add-v (rest vold) (rest vnew)))\n                nil)))]\n    (first (reduce add-v (reverse coll)))))","user":"52dfc89be4b09f7907dd1405"},{"problem":79,"code":"(fn [tri]\n  (let [tri (vec tri)]\n    (letfn [(step [x y y+]\n              (map #(+ (get-in tri [x y]) %) (get-sums (inc x) y+)))\n            (get-sums [x y]\n              (if (= (count tri) x)\n                [0]\n                (concat (step x y y) (step x y (inc y)))))]\n      (apply min (get-sums 0 0)))))","user":"555f3bfde4b0a2eb076a39c1"},{"problem":79,"code":"(fn [triangle]\n  (letfn [(cost-of-paths\n            [[x y] cost triangle]\n            (if (= (inc x) (count triangle))\n              [cost]\n              (let [next-x (inc x)\n                    right-y (when (>= (count (get triangle next-x)) (inc y))\n                              (inc y))]\n                (->> [right-y y]\n                     (keep identity)\n                     (mapcat #(cost-of-paths [next-x %] (+ cost (get-in triangle [next-x %])) triangle))))))]\n    (apply min (cost-of-paths [0 0] (first (first triangle)) (vec triangle)))))","user":"5125029de4b0ce9225d2ed3e"},{"problem":79,"code":"(fn cost\n  ([t] (cost 0 t))\n  ([i [r & t]]\n   (+ (r i)\n      (if t\n        (min (cost i t) (cost (inc i) t))\n        0))))","user":"4e6a4950535d8ccf87e9febf"},{"code":"(fn [s]\n    (let [nested-paths (loop [[r & rs] (reverse s)\n                              ret []]\n                         (if-not (seq ret)\n                           (recur rs (map vector r))\n                           (if r\n                             (recur rs\n                                    (let [p (partition 2 1 ret)]\n                                      (for [[a [l1 l2]] (map vector r p)]\n                                        [(conj l1 a) (conj l2 a)])))\n                             ret)))\n          f (fn f [[r l & a]]\n              [(concat r a) (concat l a)])\n          g (fn g [x] (if-not (coll? (ffirst x))\n                      x\n                      (g (mapcat f x))))]\n      (->> nested-paths\n           g\n           (group-by (partial apply +))\n           (sort-by first)\n           ffirst)))","problem":79,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn min-sum\n  ([xs]\n   (min-sum (first (first xs)) 0 (rest xs)))\n  ([s, i, xs]\n   (let [row  (first xs)\n         rows (rest xs)\n         i1   (if (= 1 (count (drop i row))) (dec i) (inc i))]\n     (if (empty? rows)\n       (+ s\n          (min\n           (nth row i)\n           (nth row i1)))\n       (min\n        (min-sum (+ s (nth row i)) i rows)\n        (min-sum (+ s (nth row i1)) i1 rows))))))","problem":79,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [triangle]\n  (let [minabove \n        (fn [row n]\n          (if (= n 0)\n            (nth row 0)\n            (if (= n (count row))\n              (nth row (dec n))\n              (min (nth row (dec n)) (nth row n)))))]\n    (loop [tri (rest triangle) lastrow (first triangle)]\n      (if (empty? tri)\n        (apply min lastrow)\n        (recur (rest tri) (map #(+ (minabove lastrow %2) %1) (first tri) (range)))))))","problem":79,"user":"4e7f5a0b535db966e863cc41"},{"problem":79,"code":"(fn [triangle]\n  (let [r-triangle (reverse triangle)\n        triangle-tier (count r-triangle)]\n    (reduce\n      +\n      (apply\n        (partial min-key #(apply + %))\n        (reduce\n          (fn [to from]\n            (let [parted-length (reduce * (repeat (- triangle-tier (count from)) 2))\n                  parted-to (partition parted-length (quot parted-length 2) to)]\n              (mapcat #(map (fn [coll] (cons %1 coll)) %2) from parted-to)))\n          (map #(vec [%]) (first r-triangle))\n(rest r-triangle))))))","user":"5790f9d7e4b0ebec4cfb75b4"},{"code":"(fn [s] (apply min\n           (reduce \n             (fn [x y] \n               (let [p (flatten (vector (first x) x (last x)))]\n                 (map-indexed \n                   (fn [i a] (let [l (nth p i) r (nth p (inc i))] (+ (min l r) a))) y))) (first s) (rest s))))","problem":79,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn [t]\n  (first (reduce (fn [r2 r1] (map + (map #(apply min %) (partition 2 1 r2)) r1))\n                 (reverse t))))","problem":79,"user":"5078d366e4b08327cd804a5b"},{"problem":79,"code":"(fn mintriag [t]\n  (letfn [(get-least [t]\n                       (loop [v (rest t) acc [(first (first t))]]\n                         (if (empty? v)\n                           acc\n                           (let [next-dists (map-indexed\n                                              (fn [idx val]\n                                                (let [f (dec idx)\n                                                      s idx]\n                                                  (cond (neg? f) (+ val (nth acc s))\n                                                        (>= idx (count acc)) (+ val (nth acc f))\n                                                        (< (nth acc f) (nth acc s)) (+ val (nth acc f))\n                                                        :otherwise (+ val (nth acc s))\n                                                        )\n                                                ))\n                                              (first v))]\n                             (recur (rest v) next-dists))\n                           )\n                         ))]\n    (apply min (get-least t))\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"problem":79,"code":"(fn minimalPath\n  [triangle]\n  (letfn [(subTriangle \n             [triangle col]\n             (map (fn [r]\n                    (if (= 0 col)\n                      (butlast r)\n                      (rest r)))\n                  (rest triangle)))]\n    (if (= 1 (count triangle))\n      (ffirst triangle)\n      (+ (ffirst triangle)\n         (min (minimalPath (subTriangle triangle 0))\n              (minimalPath (subTriangle triangle 1)))))))","user":"56fc0601e4b07572ad1a88db"},{"problem":79,"code":"(fn [s]\n        (letfn [(des [i [f & rest]]\n                  (if (empty? f)\n                    0\n                    (if (= 1 (count f))\n                      (+ (first f) (des i rest))\n                      (let [l (+ (nth f i) (des i rest))\n                            r (+ (nth f (inc i)) (des (inc i) rest))]\n                        (min l r)))))]\n          (des 0 s)))","user":"541ae7dbe4b01498b1a71a61"},{"code":"(fn sol\n  [t]\n  (apply min (last\n               (reduce\n                 (fn [ts r]\n                   (let [pr (vec (last ts))\n                         nr (map-indexed\n                              (fn [ix it]\n                                (+ it (cond \n                                        (zero? ix) (first pr)\n                                        (= (dec (count r)) ix) (last pr)\n                                        :default (min (get pr (dec ix)) (get pr ix)))))\n                              r)]\n                     (conj ts nr)))\n                 [(first t)] (rest t)))))","problem":79,"user":"50f48298e4b004d364930527"},{"code":"(fn [l]\n  (letfn [(z [l]\n\t     (map #(apply min %) (partition 2 1 l)))\n          (f [l]\n             (z (if (empty? (rest l))\n               (first l)\n               (map + (first l) (f (rest l))))))\n          ]\n    (+ (ffirst l) (first (f (rest l)))))\n  )","problem":79,"user":"52bb27fee4b07a9af57922df"},{"code":"(fn [tree]\n  (let [f\n    (fn [x y]\n      (apply vector\n        (map-indexed\n          (fn [i itm]\n              (let [p1 (get x (dec i) nil)\n                    p2 (get x i nil)\n                    ps (map #(if (nil? %)\n                              []\n                              (if (sequential? %) % [%])) [p1 p2])]\n            (flatten (map (fn [x] (map (partial + itm) x)) ps))\n                  )) y)))]\n  (apply min (flatten (reduce f tree)))))","problem":79,"user":"50464831e4b011c5dfee771f"},{"problem":79,"code":"(fn min-path\n  ([triangle] (min-path 0 triangle))\n  ([idx [row & rest]]\n   (if-not rest\n     (row idx)\n     (+ (row idx) (min (min-path idx rest) (min-path (inc idx) rest))))))","user":"60849bd6e4b0736b099e42f2"},{"problem":79,"code":"(fn [m]\n\t(apply min (reduce (fn [l n] (map min (map + (cons (first l) l) n) (map + (concat l [(last l)]) n))) m)))","user":"57c647bbe4b05aa3c4741cf3"},{"code":"(fn [s]\n  (letfn [(f [p n]\n      (vec (for [i (range (count n))]\n         (cond\n           (= i 0) (+ (p 0) (n 0))\n           (= i (count p)) (+ (last p) (last n))\n           :else (+ (n i) (min (p (dec i)) (p i)))))))]\n    (apply min (reduce f s))))","problem":79,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":79,"code":"(fn spath [l]\n    (let [full-path (fn flat' [s]\n      (let [fl (fn fl [st r]\n             (if (coll? r)\n               (map (fn [e] (let [z  (fl (cons (first r) st) e)]  z)) (rest r))\n               (cons r st) ))]\n             (fl () s)))\n\n          flat-level-2 (fn flat2 [coll] \n                        (when-let [s (seq coll)]\n                          (if (coll? (first (first s)))\n                            (concat  (flat2 (first s)) (flat2 (rest s)))\n                            (cons  (first s) (flat2 (rest s))))) ) ]\n       \n       (->> (reduce (fn [a e] (map-indexed (fn [i ee] \n                                             (for [ia (range 0 (count a)) :when (or (= ia i) (= (inc ia) i)) ]\n                                               (cons ee (nth a ia))\n                                               )\n                                             ) e)  ) [(first l)] (rest l))\n            (apply concat)\n            (map full-path)\n            flat-level-2\n            (sort (fn [c1 c2] (- (apply + c1) (apply + c2))))\n            first\n\t\t\t(apply +)   \n        ))\n   \n  )","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn triangle [v]\r\n  (let [paths (fn paths [v]\r\n                (cond\r\n                  (empty? (rest v)) (first v)\r\n                  true (map + (first v) (let [w (paths (rest v))]\r\n                                  (map min w (rest w))))    \r\n))]\r\n  (first (paths v))))","problem":79,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [s]\n  (loop [f (first s)         \n         r (rest s)]\n    (if (seq r)\n      (let [c0 (into [(first f)] f)\n            c1 (into f [(last f)])\n            c (map min c0 c1)]\n        (recur\n         (vec (map + (first r) c))\n         (rest r)))\n      (reduce min f))))","problem":79,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":79,"code":"(fn [triangle]\n  (let [get-paths (fn f [c]\n                    (if (= (count triangle) (count c))\n                        [c]\n                        (concat\n                         (f (conj c (last c)))\n                         (f (conj c (inc (last c))))))),\n        paths (get-paths [0])]\n    (->> paths\n         (map (fn [path]\n                (map #(get-in (vec triangle) [% (get path %)]) (range (count triangle)))))\n         (map #(reduce + %))\n         (apply min))))","user":"567695c2e4b05957ce8c6157"},{"problem":79,"code":"(fn triangle-min-path [t]\n  (if (empty? t)\n    0\n    (+ (ffirst t)\n       (min\n        (triangle-min-path (map butlast (next t)))\n        (triangle-min-path (map next (next t)))))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn min-path [tri]\n  (letfn [(nilmin [a b]\n            (if (or (nil? a) (nil? b))\n              (or a b)\n              (min a b)))\n          (minpath-reduce [ls1 ls2]\n            (into [] (keep-indexed #(+ (nilmin (get ls1 (dec %1)) (get ls1 %1)) %2) ls2)))]\n    (apply min (reduce minpath-reduce tri))))","problem":79,"user":"5301157ae4b0d8b024fd3717"},{"problem":79,"code":"(fn triangle-minimal-path\n  [triangle]\n  (letfn\n    [(all-routes [[r n] depth]\n      (if (= 1 depth)\n        (list (list (list r n)))\n        (map\n          #(conj % (list r n))\n          (concat\n            (all-routes [(inc r) n] (dec depth))\n            (all-routes [(inc r) (inc n)] (dec depth))))))\n     (cost [[r n]] (((vec triangle) r) n))\n     (route-cost [route] (reduce + (map cost route)))]\n    (let\n      [routes (all-routes [0 0] (count triangle))\n       route-costs (map route-cost routes)]\n      (first (sort route-costs)))))","user":"56050f06e4b08b23635d3161"},{"code":"#(->> % reverse (reduce\n                 (fn [x y]\n                   (map\n                    (fn [i]\n                      (+ (nth y i) (min (nth x i) (nth x (inc i)))))\n                    (range (count y)))))\n      first)","problem":79,"user":"53460d02e4b084c2834f4a39"},{"problem":79,"code":"(fn get-mini-path [paths]\n ((fn mini-path [colls row index]\n  (let [current-row (nth colls row),\n        current-value (nth current-row index)]\n    (if (= row (dec (count colls)))\n      ;; last row:\n      current-value\n      ;; 2 options for next row:\n      (let [opt1 (mini-path colls (inc row) index),\n            opt2 (mini-path colls (inc row) (inc index))]\n        (+ current-value (min opt1 opt2))\n        )\n      )))\n   paths 0 0))","user":"53ca41dae4b00fb29b2212c8"},{"problem":79,"code":"(fn [xxs]\n  (letfn [(red [down up]\n               (map + up (map min down (rest down))))]\n    (->> xxs reverse (reduce red) first)))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [x]\n  (first\n    (reduce\n      (fn [last current]\n        (map #(+ % (min %2 %3)) current last (next last)))\n      (into '() x))))","problem":79,"user":"4e7db3b4535db169f9c796e1"},{"code":"(fn minipath\n  ([triangle row col border]\n     (letfn [(item [seqs r c]\n               (nth (nth seqs r) c))]\n       (let [current (item triangle row col)]\n         (if (= row border)\n           current\n           (let [left (minipath triangle (inc row) col border)\n                 right (minipath triangle (inc row) (inc col) border)]\n             (if (<= left right)\n               (+ current left)\n               (+ current right)))))))\n  ([triangle] (minipath triangle 0 0 (dec (count triangle)))))","problem":79,"user":"512eb723e4b0b740abc5982b"},{"code":"#(first\n  (reduce (fn [bottom top]\n            (map (fn [x [l r]] (+ x (min l r))) \n                 top\n                 (partition 2 1 bottom)))\n          (reverse %)))","problem":79,"user":"4e9660ec535dbda64a6f6b44"},{"code":"(fn [l] (first (reduce #(map + (map min %1 (rest %1)) %2) (reverse l))))","problem":79,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":79,"code":"(fn [xs]\n  (first\n   (reduce #(map + (map (partial apply min) (partition 2 1 %1)) %2)\n           (reverse xs))))","user":"554b8572e4b0a04f79299589"},{"code":"(fn min-path-triangle [triangle]\n  (loop [triangle triangle\n         sums (repeat (inc (count triangle)) 0)]\n    (if (= 1 (count triangle))\n      (+ (first (first triangle)) (reduce min sums))\n      (recur\n       (drop-last triangle) \n       (for [x (range (count triangle))] (+ (nth (last triangle) x) (min (nth sums x) (nth sums (inc x)))))))))","problem":79,"user":"51d360d1e4b099f3b6acddff"},{"code":"(fn [rows]\n  (letfn [(collapse-min [[f s & r]]\n            (let [row (map #(+ (apply min %1) %2) (partition 2 1 f) s)]\n              (if (seq r)\n                (recur (cons row r))\n                (first row))))]\n    (collapse-min (reverse rows))))","problem":79,"user":"50d93c53e4b0fd36a4b89223"},{"problem":79,"code":"(fn [tree]\n   (let [all-paths (tree-seq \n           (fn [path] (< (first (last path)) (dec (count tree)))) \n           (fn [path] (let [[x y] (last path)]\n                        (list (conj path [(+ x 1) y]) (conj path [(+ x 1) (+ y 1)]))\n                        ))\n           [[0 0]])\n         full-paths (filter #(= (count tree) (count %)) all-paths)\n         valued-paths (map (fn [path] (map #(nth (nth tree (first %)) (last %)) path)) full-paths)\n         path-val (fn [path] (reduce + path))\n         path-vals (map path-val valued-paths)\n         ]\n     (apply min path-vals)\n     ))","user":"5245e320e4b09dbe66b56177"},{"problem":79,"code":"(fn [rows]\n    (loop [bottom (first rows)\n           up (rest rows)]\n      (if (empty? up)\n        (apply min bottom)\n        (let [row (first up)\n              bottomLength (count bottom)\n              merged (for [x (range 0 (count row))\n                           :let [elem (nth row x)\n                                 left  (if (= 0 x) 10000 (nth bottom (dec x))) ;valid if the upper bound for the paths is less than 10000\n                                 right (if (= bottomLength x) 10000 (nth bottom x))]]\n                       (min (+ elem left) (+ elem right)))]\n          (recur \n            (apply vector merged)\n            (rest up))))))","user":"57974188e4b039eba2ecb0f4"},{"code":"(fn [triangle] \r\n  (apply min ((fn path-sum [p] \r\n                (concat \r\n                  (if (= (count triangle) (count p)) \r\n                    [(reduce + (map-indexed #(get-in triangle [%1 %2]) p))] \r\n                    (let [x (last p)] \r\n                      (concat \r\n                        (path-sum (conj p x)) \r\n                        (path-sum (conj p (inc x)))))))) \r\n              [0])))","problem":79,"user":"4e1158aa535d04ed9115e7c6"},{"problem":79,"code":"#(loop [a (vec (reverse %))]\n  (let [z (get a 0)]\n    (if (= 1 (count z))\n      (get z 0)\n      (recur (assoc (vec (rest a)) 0 (mapv + (get a 1) (map min (butlast z) (rest z)))))\n    )\n  )\n)","user":"5b99a0a3e4b0c0b3ffbd4ad7"},{"code":"(fn [triangle]\n  (let [paths-indexes (loop [n 2 p [[0]]]\n               (if (< (count triangle) n)\n                 p\n                 (recur (inc n)\n                        (mapcat #(map (partial conj %) [(last %) (inc (last %))]) p)))),\n        paths (map #(map nth triangle %) paths-indexes)]\n    (apply min (map (partial apply +) paths))))","problem":79,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn min-path- [triangle]\n  ^{:doc \"79. Write a function which calculates the sum of the minimal                                                                                                  \n  path through a triangle.\"}\n  ;; We're going to use a dynamic programming solution, which will                                                                                                      \n  ;; reduce from the bottom of the triangle upward, replacing each row                                                                                                  \n  ;; with the sum from there on down. After the final reduction the                                                                                                     \n  ;; single remaining row will contain one element with the sum of the                                                                                                  \n  ;; min path.                                                                                                                                                          \n  (loop [r (reverse triangle)]\n    (if (= 1 (count r))\n      (ffirst r)\n      (recur (cons\n              (map min\n                   (map + (second r) (butlast (first r)))\n                   (map + (second r) (rest (first r))))\n              (drop 2 r))))))","problem":79,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":79,"code":"(fn [coll-vec]\n  (letfn [(minTri [[f & r]]\n            (if (= (count r) 0)\n              f\n              (let [next-vec (minTri r)]\n                (map +\n                     f\n                     (for [x (range (count f))]\n                       (min (nth next-vec x) (nth next-vec (inc x))))))))]\n    (first (minTri coll-vec))))","user":"591072e0e4b0163c97b36ebc"},{"code":"(fn  [triangle]\n  (letfn \n    [(path-sum [p] (first p))\n     (compare-paths [p1 p2]\n       (let [cmp (compare (path-sum p1) (path-sum p2))]\n         (if (zero? cmp) (compare p1 p2) cmp)))\n     (path-children [tr [sum [y x :as pos]]]\n       (if (= (count tr) (inc y)) nil\n         [(path tr sum [(inc y) x]) \n          (path tr sum [(inc y) (inc x)])]))\n     (path [tr previous-sum pos]\n        [(+ previous-sum (get-in tr pos)) pos])]  \n    (let [tr (vec triangle)]\n      (loop [queued-paths (sorted-set-by compare-paths (path tr 0 [0 0]))\n             finished-paths (sorted-set-by compare-paths)]\n        (let [p (first queued-paths)]\n          (if p \n            (let [children (path-children tr p)]\n              (if children\n                (recur (apply conj (disj queued-paths p) children) finished-paths)\n                (recur (disj queued-paths p) (conj finished-paths p))))          \n            (path-sum (first finished-paths))))))))","problem":79,"user":"53300924e4b019098a6f8b55"},{"problem":79,"code":"(fn _79_ [coll]\n  (letfn [(tri [triagle]\n            (reduce (fn [acc v]\n                      (let [shr (map #(apply min %) (partition 2 1 acc))]\n                        (map + shr v)))\n                    (reverse triagle)))]\n    (first (tri coll))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":79,"code":"(fn tri-mi-pa [ws]\n  (letfn [         \n         (new-tree [v tL tR] { :val v, :L tL, :R tR })\n\n         (add-upper-level [base-tree-vec vs]\n           (if (= [] base-tree-vec)\n               (map #(new-tree % nil nil) vs) ;; bottom layer\n               (map #(new-tree %1 %2 %3) vs base-tree-vec (rest base-tree-vec))))\n  \n         (make-tree [vvs]\n            (loop [tv []\n                   [v & vr] (reverse vvs)]\n                  (if (nil? v)\n                      (first tv) \n                      (recur (add-upper-level tv v) vr))))\n\n          (enum-paths [t]\n             (loop [tv [[t]]\n                    paths []]\n                   (if (empty? tv)\n                        paths\n                        (let [tact (first tv)\n                              trest (vec (rest tv))\n                              nod (last tact)\n                              prf (conj (vec(butlast tact)) (nod :val))]\n                             (if (nod :L)\n                                 (recur (conj  trest (conj  prf (nod :L)) \n                                                     (conj  prf (nod :R))) paths)\n                                 (recur trest (conj paths prf)))))))\n          ]\n\n    (->> ws\n         make-tree\n         enum-paths\n         seq\n         (map #(apply + %))\n         sort\n         first)))","user":"56fa2905e4b07572ad1a88be"},{"problem":79,"code":"(comp\n  first\n  (fn f [[x & r]]\n    (if x\n      (map #(apply min %) (partition-all 2 1 (map + x (f r))))\n      (repeat 0))))","user":"4fb1d7ace4b081705acca281"},{"problem":79,"code":"(fn [tree]\n    (letfn [(from [n tree]\n              (if (empty? tree)\n                0\n                (+ (nth (first tree) n)\n                   (min (from n (rest tree))\n                        (from (inc n) (rest tree))))))]\n      (from 0 tree)))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"problem":79,"code":"(fn f [t]\n   (if-let [[[u] & v] (seq t)]\n     (+ u\n        (min\n         (f (map butlast v))\n         (f (map rest v))\n         ))\n     0))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn min-path [triangle]\n  (let [\n  paths (fn paths [section n]\n    (let [head ((first section) n)\n          next-layer (rest section)]\n      (if (seq next-layer)\n        (map #(cons head %) (concat\n            (paths next-layer n)\n            (paths next-layer (+ 1 n))))\n        [[head]])))\n  sum (fn [xs]\n    (reduce + 0 xs))\n  ]\n  (->> 0\n       (paths triangle)\n       (map sum)\n       (apply min))))","problem":79,"user":"4e691c79535d8ccf87e9fe97"},{"problem":79,"code":"(fn [t]\n  (let \n    [triangle (apply vector t)\n     \n     start-node [-1 0]\n     \n     ;; (neighbours node) => [[neighbourNode localCost],..]\n     neighbours (fn [[x y]] \n                  (for [node [[(+ x 1) y]  [(+ x 1) (+ y 1)]] \n                        :let [cost (get-in triangle node)] \n                        :when cost ] \n                    [node cost] ) ) \n     \n     ;; (end node) => true when target node is reached, nothing more to do\n     end #(empty? (neighbours %))\n     \n     ]\n    \n    ;; minimum path\n    \n    (loop \n      [solved {start-node :start} ;; format is {node: prevNode }\n       boundry (into [] (for [[k v] (neighbours start-node)] [v k]) )\n       ] \n      \n      \n      (do (println :solved solved :boundry boundry)\n        \n        (let \n          [ [pathCost node] (first boundry)\n            unvisited ;; [[pathCost Node],..]\n            (if node \n              (for [[n stepCost] (neighbours node) \n                    :when (not (contains? solved n)) ] \n                [(+ pathCost stepCost) n])\n              [] )\n            ] \n          \n          (do \n            \n            (println :pathCost pathCost :node node :unvisited unvisited)\n            \n            \n            ;;{:cost pathCost, :node node, :solved solved, :path (reverse (take-while some? (iterate #(get solved %) node ))) }\n            (if (end node) pathCost\n              \n              (recur \n               ;; solved should gain {node:prevNode} for all unvisited  \n               (into solved (for [[_ nextNode] unvisited] [nextNode node]))\n               \n               ;; boundry should have node removed, and unvisited items added with accumulated cost\n               (-> boundry\n                   rest\n                   (into unvisited )\n                   sort\n                   ) \n               ))))))))","user":"533a2f7be4b0e30313ee6cb8"},{"problem":79,"code":"(fn k \n  ([l] (k l 0)) \n  ([l i] \n   (if l\n     (let [[v & vs] l]\n       (+ (nth v i) (min\n                      (k vs i)\n                      (k vs (inc i)))))\n     0)))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn [t]\n  (first\n   (reduce\n          #(for [i (range (count %2))]\n             (+\n              (nth %2 i)\n              (min\n               (nth % i)\n               (nth % (inc i)))))\n          (reverse t))))","problem":79,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn [t] ((reduce (fn [a b]\n                           (mapv\n                            #(min (+ %2 (get a % 99)) (+ %2 (get a (inc %) 99)))\n                            (range) b\n                            ))\n                         (reverse t)) 0))","problem":79,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [t] (loop [T [[0 0 (ffirst t) 1]] D []]\n           (let [[y x s d :as f] (first T)\n                 r (rest T)\n                 t (vec t)\n                 c (count t)]\n             (cond (not f) (apply min (map #(% 2) D))\n                   (= d c) (recur r (conj D f))\n                   (< c y) (recur r D)\n                   :else   (recur (concat r    \n                                          (map (fn [k] [(inc y) k (+ s (get-in t [(inc y) k])) (inc d)])\n                                               [x (inc x)]))\n                                  D)))))","problem":79,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [x]\n  (last\n   (reduce\n     (fn [y z] (map #(+ (min %2 %3) %) z (rest y) y))\n     (reverse x))))","problem":79,"user":"4da3e51330acd6ed10482a68"},{"problem":79,"code":"(fn calculate-path-values\n  [value-tree]\n  (let [generate-tree (fn generate-tree\n                        ([limit] (generate-tree 0 0 limit))\n                        ([node row limit]\n                         (if (< row limit)\n                           [node\n                            (generate-tree node (inc row) limit)\n                            (generate-tree (inc node) (inc row) limit)]\n                           nil)))\n        calculate-routes (fn calculate-routes\n                           ([tree] (calculate-routes [] tree))\n                           ([route tree]\n                            (when-not (nil? tree)\n                              (let [node (first tree)\n                                    left (second tree)\n                                    right (last tree)\n                                    new-route (conj route node)]\n                                (-> route\n                                    (conj node)\n                                    (conj (calculate-routes new-route left))\n                                    (conj (calculate-routes new-route right))))))) \n        get-all-routes (fn get-all-routes\n                         [rows]\n                         (->> (generate-tree rows)\n                              calculate-routes\n                              (tree-seq vector? (partial filter vector?))\n                              (filter (partial not-any? vector?))\n                              (map (partial remove nil?))))\n        get-route-values (partial map-indexed\n                                  (fn [k v] (-> value-tree (nth k) (nth v))))]\n    (->> (get-all-routes (count value-tree))\n         (map (fn [route] (apply + (get-route-values route))))\n         (apply min))))","user":"562e8b2be4b0ab312c17ebbb"},{"code":"(fn boo [tree]\n  (let\n    [make-next (fn [[row col]]\n                 [[(inc row) col] [(inc row) (inc col)]])\n     add-path (fn [paths]\n                (mapcat (fn [path]\n                          (map #(conj path %) (make-next (last path))))\n                        paths))\n     read-tree (fn [tree [row col]]\n                 ((nth tree row) col))\n     paths (nth (iterate add-path [[[0 0]]]) (dec (count tree)))\n     read-paths (map (fn [path] (map #(read-tree tree %) path)) paths)\n     sums (map #(apply + %) read-paths)]\n    (apply min sums)))","problem":79,"user":"50217818e4b00bba4502f7a7"},{"problem":79,"code":"#(letfn [(tri-sum [x y] (vec (map + y (map min (pop x) (rest x)))))]\n(first (reduce tri-sum (reverse %))))","user":"56304db8e4b073c1cf7a9be5"},{"code":"(fn [tri]\n  (letfn [(paths\n            ([n] (paths n 0))\n            ([n idx]\n               (if (= n 1)\n                 [[idx]]\n                 (map #(cons idx %)\n                   (concat\n                     (paths (dec n) idx)\n                     (paths (dec n) (inc idx))))\n                )))]\n    (first\n      (sort\n        (map\n          #(apply +\n            (map\n              (fn [[level i]] (get level i))\n              (partition 2 (interleave tri %))))\n          (paths (count tri)))))))","problem":79,"user":"504c8165e4b09724c857af31"},{"code":"(fn tridis [coll]\n  (let [calc (fn calc [c]\n               (cond\n                (empty? (rest c)) (map #(min (first %) (second %)) (partition 2 1 (first c)))\n                :else (let [ch (calc (rest c))\n                            sums (map + (first c) ch)\n                            r (if (= 1 (count sums)) (first sums)\n                                 (map #(min (first %) (second %)) (partition 2 1 sums)))]\n                        \tr)))] (calc coll)))","problem":79,"user":"52140b53e4b0961f15ac4d7e"},{"code":"#(apply min (reduce (fn [u d] (vec (map-indexed \n                               \t(fn [i x]\n                                      (cond\n                                       (= 0 i) (+ x (first u))\n                                       (= i (count u)) (+ x (last u))\n                                        :else (+ x (min (u i) (u (dec i))))\n                                       )\n                                 ) d))\n                      ) %))","problem":79,"user":"526a3412e4b03e8d9a4a721e"},{"problem":79,"code":"(fn calc-tri [triangle]\n  ((fn calc-sub [[head & tail] head-index]\n     ;(println \"head\" head \"tail\" tail \"head-index\" head-index \"acc\" acc)\n     (if (empty? tail)\n       (get head head-index)\n       (let [left (calc-sub tail head-index)\n             right (calc-sub tail (inc head-index))]\n         (+\n           (get head head-index)\n           (if (<= left right) left right)))))\n   triangle 0))","user":"53f7820be4b0de5c41848560"},{"code":"(fn f\n ([vecs] (+ (ffirst vecs) (f (rest vecs) 0)))\n ([vecs i]\n  (if (empty? (rest vecs))\n      (min (nth (first vecs) i) (nth (first vecs) (inc i)))\n      (min\n       (+ (nth (first vecs) i) (f (rest vecs) i))\n       (+ (nth (first vecs) (inc i)) (f (rest vecs) (inc i)))))))","problem":79,"user":"4fb510b5e4b081705acca2b8"},{"code":"(letfn [\r\n  (next-steps [paths]\r\n\t\t(apply concat\r\n\t\t\t(for [path paths, :let [last-step (last path)]]\r\n\t\t\t\t[(conj path last-step) (conj path (inc last-step))])))\r\n\t(all-paths [length]\r\n\t\t(nth (iterate next-steps [[0]]) length))\r\n\t(values-along-path [triangle path]\r\n\t\t(map nth triangle path))]\r\n\t\t\r\n\t(fn [triangle]\r\n\t\t(let [paths         (all-paths (count triangle))\r\n\t\t\t  values        (map (partial values-along-path triangle) paths)\r\n\t\t\t  summed-values (map (partial apply +) values)]\r\n\t\t\t(apply min summed-values))))","problem":79,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":79,"code":"(fn [seq]\n   (letfn [(calc-sum [coll]\n                     (map #(reduce + %) coll))\n\n           (separate-pattern [coll depth]\n                             (partition depth\n                                        (flatten\n                                          ((fn traversal [t coll]\n                                             (if (nil? (second t))\n                                               (conj coll (first t))\n                                               (conj (traversal (second t) (conj coll (first t))) (traversal (last t) (conj coll (first t))))))\n                                            coll []))))\n\n           (mktree [coll pos]\n                   (letfn [(tree\n                             ([v l r] (conj '() r l v))\n                             ([leaf] (conj '() nil nil leaf)))]\n                     (if (next coll)\n                       (tree\n                         (get (first coll) pos)             ;val\n                         (mktree (rest coll) pos)            ;left\n                         (mktree (rest coll) (inc pos))      ;right\n                         )\n                       (tree (get (first coll) pos)))))\n           ]\n\n     (reduce min\n             (calc-sum\n               (separate-pattern\n                 (mktree seq 0)\n                 (count seq))))))","user":"55a372f1e4b0acc240e31537"},{"problem":79,"code":"(fn [tree]\n(letfn [(update-length \n\t[prev next]\n\t\t(if (empty? next)\n\t\t'()\n\t\t(cons (min (+ (first next) (first prev)) (+ (first next) (second prev))) (update-length (rest prev) (rest next)))\n\t\t)\n\t)\n\t(update-all [prev next]\n\t(concat [(+ (first prev) (first next))] (if (> (count prev) 1) (update-length prev (subvec next 1 (dec (count next)))) []) [(+ (last prev) (last next))])\n\t\n\t\n\t)\n\t\n\t]\n\t(apply min (reduce update-all tree))\n\t)\n)","user":"57011eb3e4b08d47c97781d1"},{"problem":79,"code":"(fn triangle-min-path [tri]\n    (apply min\n           (reduce\n            (fn [acc cur]\n              (->> (concat [(first acc)] acc [(peek acc)])\n                   (partition 2 1)\n                   (map #(apply min %))\n                   (mapv + cur)))\n            (first tri) (rest tri))))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn m [c]\n  (let [f (ffirst c)]\n    (if (= (count c) 1) f\n      (let [r (rest c)]\n        (+ f (min (m (map #(take (dec (count %)) %) r)) (m (map #(rest %) r))))))))","problem":79,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":79,"code":"(fn f [t]\n    (if\n      (= (count t) 1)\n      (ffirst t)\n      (let [left\n            (f (map\n                 #(subvec % 0 (- (count %) 1)) (rest t)))\n            right\n            (f (map\n                 #(subvec % 1) (rest t)))]\n        (+ (ffirst t) (min left right)))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":79,"code":"(fn\n  f\n  ([s] (f s 0))\n  ([s i]\n   (if (empty? (rest s))\t\n     (get (first s) i)\n     (min \n      (+ (get (first s) i) (f (rest s) i)) \n      (+ (get (first s) i) (f (rest s) (inc i)))))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn [tri]\n  (letfn [(path-pairs [path]\n            (if (seq path)\n              (let [p1 (cons (first path) path)\n                    p2 (conj path (last path))]\n                (map min p1 p2))\n              [0]))\n\n          (addpath [path line]\n            (into [] (map + (path-pairs path) line)))]\n\n     (apply min (reduce addpath [] tri))))","problem":79,"user":"4f0d093b535d0136e6c22313"},{"problem":79,"code":"(fn min-tree-path [t]\n  (letfn\n    [(tree-paths [t]\n      (if (= (count t) 1)\n        t\n        (concat\n         (map #(concat (first t) %) (tree-paths (map drop-last (rest t))))\n         (map #(concat (first t) %) (tree-paths (map #(drop 1 %) (rest t)))))))]\n    (->> t\n         tree-paths\n         (map #(apply + %))\n         (apply min))))","user":"551afdf8e4b07993ea3788cb"},{"problem":79,"code":"(fn tr\n  ([tree] (tr 0 tree))\n  ([pos [cur & rest]]\n   (if (seq rest)\n     (min (+ (nth cur pos) (tr pos rest))\n          (+ (nth cur pos) (tr (inc pos) rest)))\n     (nth cur pos))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn [list]\n  (->> list \n    (reduce (fn [previous current]\n      (map-indexed (fn [pos item]\n        (let [previous (vec previous)\n              left (when (contains? previous (- pos 1)) (previous (- pos 1)))\n              right (when (contains? previous pos) (previous pos))\n              min-entry ((comp (partial apply min) (partial keep identity)) [left right])]\n          (+ min-entry item))) current)))\n    (apply min)\n  ))","problem":79,"user":"4f294c48e4b0d6649770a023"},{"code":"(fn [t] (first (reduce #(map + %2 (map min %1 (next %1))) (repeat 0) (reverse t))))","problem":79,"user":"5176afd2e4b085adf681d889"},{"code":"(letfn\n  [(zip-with [f & xss]\n     (loop [xss xss, acc []]\n       (if (some empty? xss)\n         acc\n         (recur (map next xss)\n                (conj acc (apply f (map first xss)))))))\n   (mins [xs] (map (partial apply min) xs))\n   (combine-layers [bot nxt]\n     (zip-with + (mins (partition 2 1 bot)) nxt))]\n  (fn [tri]\n    (loop [[bot nxt & rst] (reverse tri)]\n      (if nxt\n        (recur (cons (combine-layers bot nxt) rst))\n        (first bot)))))","problem":79,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [s]\n            (let [pascal (fn [n] \n                             (nth (iterate \n                                   (fn [s] \n                                       (map #(apply + %) \n                                            (partition 2 \n                                                       (#(interleave (concat % [0]) (concat [0] %)) \n                                                         s))))\n                                   [1])\n                                  (dec n)))\n            \n                 group-pascal (fn [s n]\n                                  (loop [p (pascal n) q s res []]\n                                     (if (empty? q)\n                                         res\n                                         (let [r (split-at (first p) q)\n                                              h (first r)\n                                              l (last r)\n                                              ]\n                                              (recur (rest p) l (conj res h))))))\n                 make-path (fn [p q]\n                               (apply concat (reduce (fn [x y]\n                                                         (apply conj x\n                                                                (map (fn [z]\n                                                                         (reduce #(conj % (conj %2 z)) [] (first y)))\n                                                                     (last y))))\n                                                     []\n                                                     (partition 2 (interleave p (partition 2 (interleave q (rest q))))))))\n                 ]\n                 (apply min \n                        (map #(reduce + 0 %) \n                             (apply concat \n                                    (reduce #(group-pascal (make-path % %2) (count %2))\n                                            (list [(first s)])\n                                            (rest s)))))))","problem":79,"user":"4f03f197535dcb61093f6b84"},{"problem":79,"code":"(fn [x]\n    (letfn [(mp\n              ([t]\n               (mp (rest t) (first t) 0))\n              ([t p i]\n               (if (empty? t)\n                 p\n                 (for [i (range i (+ i 2))]\n                   (mp (rest t) (conj p ((first t) i)) i)))))\n            (fp [t p] (partition (count t) (flatten p)))\n            (sp [fps] (apply min-key (partial reduce +) fps))\n            (psp [s] (clojure.string/join \"->\" (map str s)))\n            ]\n      (let [shortest-path (sp (fp x (mp x)))]\n        (println (psp shortest-path))\n        (apply + shortest-path)  \n        )\n      \n      ))","user":"5a9d64c8e4b0d174b936c7eb"},{"code":"(fn [tri]\n  (letfn [(minfrom [triangle ind]\n            (if (empty? triangle) 0\n                (min\n                 (+' (nth (first triangle) ind) (minfrom (rest triangle) ind))\n                 (+' (nth (first triangle) ind) (minfrom (rest triangle) (inc' ind))))))]\n    (minfrom tri 0)))","problem":79,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":79,"code":"#((fn p79\n  [x y coll]\n  (if (get-in coll [(inc x) y])\n    (+ (get-in coll [x y])\n       (min (p79 (inc x) y coll)\n            (p79 (inc x) (inc y) coll)))\n    (get-in coll [x y]))) 0 0 (vec %))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":79,"code":"(fn [tri] (\n(fn tr [triangle cu] (\n                      if (empty? triangle)\n                      (apply min cu)\n                      (tr (rest triangle)\n                          ((fn nxt [cur prev] (map (fn [p1 p2 c] (+ c (min p1 p2))) (cons (first prev) prev) (concat prev (list (last prev))) cur))\n                           (first triangle) cu))\n                    ))\n           (rest tri) (first tri)\n           ))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":79,"code":"(fn minpath [t]\n  (letfn [(mp [s r] ;computes min-path for r given the previous min-path s\n              (lazy-seq\n                (if (seq r)\n                  (cons (+ (first r) (min (first s) (second s)))\n                        (mp (rest s) (rest r)))\n                  [])))]\n    (apply min (reduce mp (reverse t)))))","user":"57adbe7ee4b0b8559636fca0"},{"code":"(fn [world]\n  (loop [[r1 r2 & rs] (reverse world)]\n    (if (= (count r1) 1)\n      (first r1)\n      (let [f #(+ (nth r2 %) (min (nth r1 %) (nth r1 (inc %))))]\n       \t(recur (cons (map f (range (count r2))) rs))))))","problem":79,"user":"4f84a4a4e4b033992c121c39"},{"problem":79,"code":"#((fn min-sum [[v & vs] idx sum]\n    (if vs\n      (min (min-sum vs idx (+ sum (v idx)))\t\t\t; sum of left node\n           (min-sum vs (inc idx) (+ sum (v idx))))\t; sum of right node\n      (+ sum (v idx))))\n  % 0 0)","user":"56ae214ce4b03c432f18735a"},{"problem":79,"code":"(fn triangle-min-path [[h & t]]\n  (apply min\n   (reduce\n    (fn [prev-row row]\n      (map-indexed\n       (fn [index item]\n         (+ item\n            (min (nth prev-row (min index (- (count prev-row) 1)))\n                 (nth prev-row (max 0 (- index 1))))))\n       row))\n    h t)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":79,"code":"(fn [t]\n  (first\n  \t(reduce\n   \t\t(fn [r1 r2]\n     \t\t(map-indexed #(+ %2 (min (nth r1 %1) (nth r1 (inc %1)))) r2))\n   \t\t(reverse t))))","user":"553dd883e4b0a04f792994e6"},{"code":"(fn [tree]\n  (letfn [(paths [c]\n           (if (= (count c) 1) \n            [(first c) (first c)]\n            (let [x (+ 1 (first c)) y (+ 1 (last c))]\n              (conj (vec (cons x (flatten (map (fn [x] [x x]) c)))) y))))\n          (shortest-paths [c]\n            (if (= 2 (count c))\n              c\n              (map #(min (first %) (last %)) (partition 2 c))))\n          (merge-level [up-level this-level]\n            (map + (shortest-paths (paths up-level)) this-level))]\n    (apply min (reduce merge-level tree))))","problem":79,"user":"514721c6e4b0d520409ed392"},{"problem":79,"code":"(letfn [(all-paths \n          [triangle offset p]\n          (let [p (conj p offset)]\n            (if-not (next triangle)\n              [p]\n              (concat (all-paths (rest triangle) offset p)\n                      (all-paths (rest triangle) (inc offset) p)))))\n        (value-for-path\n          [triangle p]\n          (reduce + (map (fn [row idx] (nth row idx)) triangle p)))]\n  (fn [triangle]\n    (reduce min (map #(value-for-path triangle %) (all-paths triangle 0 [])))))","user":"51f01925e4b0249c592fbdfc"},{"code":"(fn [t]\n  (apply min\n    (map first\n      (reduce\n        (fn [previous row]\n          (mapcat\n            #(vector\n              (list\n                (+ (first %) (nth row (last %)))\n                (last %))\n              (list\n                (+ (first %) (nth row (inc (last %))))\n                (inc (last %))))\n            previous))\n        (vector (list (ffirst t) 0))\n        (rest t)))))","problem":79,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":79,"code":"(fn [[[c1] & cr]]\n  (letfn [(f [a [[b1 b2] & bs]]\n             (if (nil? bs)\n               [(+ a b1) (+ a b2)]\n               (concat (f (+ a b1) bs)\n                       (f (+ a b2) (map rest bs)))))]\n    (apply min (f c1 cr))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [tri]\n(letfn [(p [agg row col t]\n          (let [rows (count t)\n                cur (nth (nth t row) col)\n                next-row (and (< row (- rows 1)) (nth t (+ row 1)))\n                left (and next-row (nth next-row col))\n                right (and next-row (nth next-row (+ col 1)))]\n            (list\n             (if left\n               (p (conj agg cur) (+ row 1) col t)\n               (concat agg (list cur)))\n             (if right\n               (p (conj agg cur) (+ row 1) (+ col 1) t)\n               (concat agg (list cur))))))]\n  (apply min-key identity\n          (map #(apply + %) (partition (count tri) (flatten (map flatten (p [] 0 0 tri))))))))","problem":79,"user":"502873a8e4b01614d1633ff8"},{"problem":79,"code":"(fn [xss]\n  (first\n    (reduce\n      (fn [l h]\n        (map min (map + (rest l) h) (map + (butlast l) h)))\n      (reverse xss))))","user":"5416b4a2e4b01498b1a71a01"},{"problem":79,"code":"(fn [tri]\n  (let [pairwise #(partition 2 1 %)\n        apply-min #(apply min %)\n        pairwise-min #(map apply-min (pairwise %))]\n    (first (reduce #(map + (pairwise-min %1) %2)\n                    (reverse tri)))))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":79,"code":"(fn min-path\n           ([col] (min-path col 0 0))\n           ([col vidx idx]\n            (if (= (- (count col) 1) vidx)\n              ((nth col vidx) idx)\n              (let [x (min-path col (+ 1 vidx) idx)\n                    y (min-path col (+ 1 vidx) (+ 1 idx))]\n                (+ (min x y) ((nth col vidx) idx))))))","user":"5e1c3e6ee4b0dc9594008530"},{"code":"(fn tri-min [triangle]\n  (if (seq (first triangle))\n    (+ (ffirst triangle) ; the top element\n       (min (tri-min (rest (map rest triangle)))\n            (tri-min (rest (map drop-last triangle)))))\n    0))","problem":79,"user":"51460e4ce4b04ef915e37314"},{"code":"(fn m\n  ([l]\n   (m l 0))\n  ([l n]\n   (if (empty? l)\n     0\n     (min (+ (nth (first l) n)\n             (m (rest l) n))\n          (+ (nth (first l) n)\n             (m (rest l) (inc n)))))))","problem":79,"user":"50a83315e4b054305ba5a830"},{"problem":79,"code":"(fn tri-path [triangle]\n  (let [paths (loop [acc [[0]]\n                     depth (dec (count triangle))]\n                (if (zero? depth)\n                  acc\n                  (recur (mapcat\n                           (fn [p]\n                             (let [l (last p)]\n                               (vector (conj p l)\n                                       (conj p (inc l)))))\n                           acc)\n                         (dec depth))))]\n    (->> (map #(map get triangle %) paths)\n        (map (partial apply +))\n        (sort)\n        (first))))","user":"540e8d13e4b0addc1aec671e"},{"code":"#(loop [[ft & rt] (rest %) out (first %)]\n   (if (nil? ft) (apply min out)\n     (let [res (for [i (range 1 (dec (count ft)))]\n                 (+ (ft i) (min (out (dec i)) (out i))))]\n       (recur rt\n              (conj \n                    (vec (cons (+ (first ft) (first out)) res))\n                    (+ (last ft) (last out)))))))","problem":79,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":79,"code":"(fn min-path [col]\n   (first \n    (reduce #(map + \n                  (map (fn [pair] (apply min pair)) (partition 2 1 %1))\n                  %2)\n            (reverse col))))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":79,"code":"(fn f\n  ([triangle] (f 0 0 triangle))\n  ([level path-idx [top & sub-triangle]]\n   (let [result (+ (get top path-idx)\n                  (if sub-triangle\n                    (min\n                      (f (inc level) path-idx sub-triangle)\n                      (f (inc level) (inc path-idx) sub-triangle))\n                    0))]\n     result)))","user":"53a83c74e4b047364c044426"},{"code":"; outline\n; f[ seq:triangle position length path-so-far]\n;\n\n(fn triangle-minimum\n  [tri]\n  (letfn [(triangle-branch [tri dir]\n            (let [drop-fn (if (= dir :l) drop-last drop)]\n              (drop 1 (map (partial drop-fn 1) tri))))\n          (triangle-single-bound [tri comp-fn]\n            (apply + (map (partial apply comp-fn) tri)))\n          (triangle-bounds [tri]\n            (vector (triangle-single-bound tri min)\n                    (triangle-single-bound tri max)))]\n    (condp = (count tri)\n      1 (first (first tri)) ; return the only element\n      2 (+ (first (first tri)) (apply min (second tri))) ; return the sum of the top and the lesser of the bottom\n      (let [possibilities (map (partial reduce triangle-branch tri) [[:l] [:r]])\n            bounds        (map triangle-bounds possibilities)\n            lowest-maximum (apply min (map second bounds))\n            after-prune   (map second (filter #(< (first (first %)) lowest-maximum)\n                                              (map vector bounds possibilities)))]\n        (+ (first (first tri)) (apply min (map triangle-minimum after-prune)))))))","problem":79,"user":"511b233ae4b07ab9ec456180"},{"problem":79,"code":"(fn triangle-min-path\n  [triangle]\n  (letfn [(min-pairs [col acc]\n            (if (> (count col) 1)\n              (recur (rest col) (conj acc (apply min (take 2 col))))\n              acc))]\n    (loop [remaining-triangle triangle]\n        (if (= (count remaining-triangle) 1)\n        (ffirst remaining-triangle)\n        (recur (conj\n                (into [] (drop-last 2 remaining-triangle))\n                (mapv\n                 +\n                 (first (take-last 2 remaining-triangle))\n                 (min-pairs (last remaining-triangle) []))))))))","user":"55a9e0fee4b0988bba2ad945"},{"problem":79,"code":"(fn minp ([tri] (minp tri 0 0))\n   ([tri x y]\n    (if (= (inc x) (count tri))\n      \t\t((nth tri x) y) \n      \t    (+ ((nth tri x) y) (min (minp tri (inc x) y) (minp tri (inc x) (inc y))))\t\n     )\n   )\n)","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":79,"code":"(fn minimal-path [triangle]\n  (letfn [(left-triangle [triangle]\n            (rest (map rest triangle)))\n          (right-triangle [triangle]\n            (rest (map rest (map reverse triangle))))]\n    (if (empty? triangle) 0\n        (+ (first (first triangle))\n           (min (minimal-path (left-triangle triangle)) (minimal-path (right-triangle triangle)))))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":79,"code":"(fn lala [dt] \n (letfn [(dpat [t ohs]\n (loop [zo ohs acc [] i 0 pis 0]\n   (if (empty? zo) acc\n       (recur (rest zo)\n       \t      (conj acc (nth (nth t i) (+ (first zo) pis)))\n       \t      (inc i)\n\t      (+ (first zo) pis)))))\n(genpats [n]\n      (for [m (range (inc n))]\n      \t   (let [bs (rest (clojure.string/split (Integer/toBinaryString m) #\"\"))]\n\t   \t(map #(Integer/parseInt %) \n\t\t     (if (< (count bs) n)\n\t\t     \t (into (into [] (repeat (- n (count bs)) \"0\")) bs)\n\t\t    \t bs)))))]\n  (let [rt (map reverse dt)]\n   (->> dt\n   \tcount\n  \tgenpats\n\t(map #(list (dpat dt %) (dpat rt %)))\n\t(reduce #(conj %1 (first %2) (second %2)))\n\t(sort-by #(apply + %) >)\n\tlast\n\t(apply +)))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":79,"code":"(fn [bt]\n  (letfn [(smart-pop [v]\n            (if (= 1 (count (flatten v)))\n              empty\n              (if (> (count (last v)) 1)\n                (conj (pop v) (into [] (rest (peek v))))\n                (recur (pop v)))))\n          (all-paths [bt]\n            (loop [paths [[0]], acc []]\n              (cond (empty? (flatten paths)) acc\n                    (= (count paths) (count bt)) (recur (smart-pop paths)\n                                                        (conj acc (map #(nth % (first %2)) bt paths)))\n                    :else (let [i (first (last paths))]\n                            (recur (conj paths [i (inc i)]) acc)))))]\n    (apply min (map #(reduce + %) (all-paths bt)))))","user":"538e36c7e4b0b51d73faae81"},{"problem":79,"code":"(fn [triangle] (let [M (reduce + (map (partial apply max) triangle))] (loop [trapezoid triangle] (if (= 1 (count trapezoid)) (apply min (first trapezoid)) (recur (cons (into [] (for [i (range (count (second trapezoid)))] (+ (get (second trapezoid) i) (min (get (first trapezoid) i M) (get (first trapezoid) (dec i) M))))) (drop 2 trapezoid)))))))","user":"5e1cc888e4b0dc959400853d"},{"problem":79,"code":"; (defn min-path [rows]\n;   (apply min\n;     (reduce\n;       (fn [s r]\n;         (first (reduce\n;           (fn [[r' i] e]\n;             (let [left  (get s (dec i) Integer/MAX_VALUE)\n;                   right (get s i       Integer/MAX_VALUE)]\n;               [(conj r' (min (+ e left) (+ e right)))\n;                (inc i)]))\n;           [[] 0] r)))\n;       rows)))\n\n(fn min-path [[[root] & more]]\n  (if more\n    (+ root (min (min-path (map butlast more))\n                 (min-path (map rest more))))\n    root))","user":"53d78b64e4b0e771c3025466"},{"problem":79,"code":"(fn m\n    ([t]\n     (m (vec t) 0 0)) \n    ([t r c]\n     (if (= r (- (count t) 1)) \n       (get-in t [r c]) \n       (+ (get-in t [r c]) (min (m t (+ 1 r) c) (m t (+ 1 r) (+ 1 c))))\n       )   \n     )   \n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(letfn [(x [a b] (map #(+ (apply min %1) %2) (partition 2 1 a) b))]\n  (fn [t] (first (reduce x (reverse t)))))","problem":79,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn f [x] (if (== 2 (count x))\n                                 (min (+ (first (first x)) (first (second x)))\n                                      (+ (first (first x)) (second (second x))))\n                                 (+ (first (first x)) (min (f (pop (reverse (reduce (fn [a b] (conj a (pop b))) '() x))))\n                                                           (f (pop (reverse (reduce (fn [a b] (conj a (subvec b 1))) '() x))))))))","problem":79,"user":"51c4690fe4b06b70b3e207e1"},{"code":"(fn minimum-all\n  ([triangle]\n    (apply min (minimum-all triangle 0 0)))\n  ([triangle index sum]\n    (if (= 0 (count triangle))\n      [sum](if (= 1 (count (first triangle)))\n            (minimum-all (rest triangle) 0 (first (first triangle)))\n            (concat (minimum-all (rest triangle) index (+ sum (get (first triangle) index))) (minimum-all (rest triangle) (inc index) (+ sum (get (first triangle) (inc index)))))))))","problem":79,"user":"4e16bdef535d04ed9115e7e9"},{"problem":79,"code":"(fn tri [sq]\n  (let [sums (fn [l nx] \n               (let [n (map + l nx) \n                     n1 (map + l (rest nx))] \n                 (concat [(first n)] (map min (rest n) (butlast n1)) [(last n1)] )))\n        row (reduce sums sq)]\n    (apply min row)))","user":"5ecc0831e4b016b56eae058c"},{"code":"(fn [c]\n    (apply min\n           (reduce\n            (fn [m v]\n              (map (fn [a b v]\n                     (cond (nil? a) (+ b v)\n                           (nil? b) (+ a v)\n                           (> a b) (+ b v)\n                           :else (+ a v)))\n                   (cons nil m)\n                   (concat m '(nil))\n                   v))\n            c)))","problem":79,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [triangle]\n  (letfn [(split-row [row]\n            (if (empty? (rest row)) ()\n                (cons [(first row) (second row)] (split-row (rest row)))))\n\n          (path-row [r1 r2]\n            (map (fn [a b]\n                   [a b]\n                   ) r1 (split-row r2)))\n\n          (triangle-tree [triangle]\n            (first\n             (reduce (fn [acc r]\n                       (path-row r acc)\n                       ) (repeat (inc (count (last triangle))) []) (reverse triangle))))\n          \n          (walk-triangle [[v [l r]]]\n            (if (not (empty? l))\n              (concat\n               (map \n                #(cons v %) (walk-triangle l))\n               (map \n                #(cons v %) (walk-triangle r))\n               )\n              [[v]])\n            )\n          ]\n    (first (sort (map #(apply + %) (walk-triangle (triangle-tree triangle)))))\n  ))","problem":79,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"(fn tr-min-path [t]\n  (let [t (reverse t)\n        p-start (map (fn [x] [x (list x)]) (first t)) \n        choose (fn [ [a & _ :as A] [b & _ :as B]] (if (< a b) A B)) \n        grow   (fn [n [score stack]] [(+ n score) (cons n stack)])]\n    (ffirst (reduce\n             (fn [p c-row]\n               (map (fn [n [a b]] (grow n (choose a b)))\n                    c-row (partition 2 1 p)))\n             p-start (rest t)))))","problem":79,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn min-cost \n  ([tree] (min-cost tree 0))\n  ([tree idx]\n    (let [v ((first tree) idx)\n          children (rest tree)]\n      (if (empty? children)\n        v\n        (+ v (min (min-cost children idx) (min-cost children (inc idx))))))))","problem":79,"user":"53513d28e4b084c2834f4ae3"}]