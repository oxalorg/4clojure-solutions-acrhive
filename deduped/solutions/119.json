[{"problem":119,"code":"(fn [p b]\n    (let [winner (fn [b]\n                   (let [b' (apply map vector b)\n                         d [(map nth b (range))\n                            (map nth (rseq b) (range))]]\n                     (->> (concat b b' d)\n                          (filter #(apply = %))\n                          ffirst\n                          #{:x :o})))]\n      (into #{} (for [i (range 3)\n                      j (range 3)\n                      :when (= (get-in b [i j]) :e)\n                      :when (= (winner (assoc-in b [i j] p)) p)]\n                  [i j]))))","user":"59e0f38ae4b08badc2a0c500"},{"problem":119,"code":"(fn [f, b]\n      (let [fb (flatten b),\n            sm (fn [s, a, b, c] (if (= (nth s (dec a)) (nth s (dec b)) (nth s (dec c))) (nth s (dec a)) nil))\n            s0 (fn [fb] (sm fb 1 2 3)),\n            s1 (fn [fb] (sm fb 4 5 6)),\n            s2 (fn [fb] (sm fb 7 8 9)),\n            s3 (fn [fb] (sm fb 1 4 7)),\n            s4 (fn [fb] (sm fb 2 5 8)),\n            s5 (fn [fb] (sm fb 3 6 9)),\n            s6 (fn [fb] (sm fb 1 5 9)),\n            s7 (fn [fb] (sm fb 3 5 7)),\n            rx (fn [fb] (or (= (s0 fb) :x) (= (s1 fb) :x) (= (s2 fb) :x) (= (s3 fb) :x) (= (s4 fb) :x) (= (s5 fb) :x) (= (s6 fb) :x) (= (s7 fb) :x))),\n            ro (fn [fb] (or (= (s0 fb) :o) (= (s1 fb) :o) (= (s2 fb) :o) (= (s3 fb) :o) (= (s4 fb) :o) (= (s5 fb) :o) (= (s6 fb) :o) (= (s7 fb) :o))),\n            check (fn [fb] (if (true? (rx fb)) :x (if (true? (ro fb)) :o nil)))]\n           (loop [p 0, x fb, a #{}] (if (empty? x) a (recur (inc p) (rest x)\n                                                            (if (and (= (nth fb p) :e) (check (concat (take p fb) [f] (nthnext fb (inc p)) )))\n                                                              (conj a [(quot p 3) (rem p 3)]) a))))\n           )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":119,"code":"(letfn [(blocks [board]\n          (-> (into board (apply map vector board))\n              (conj (mapv (fn [index]\n                            (get-in board [index index]))\n                          [0 1 2]))\n              (conj (mapv (fn [index]\n                            (get-in board [index (- 2 index)]))\n                          [0 1 2]))))\n        (with-coordinates [board]\n          (vec (map (fn [row row-index]\n                      (vec (map (fn [cell column-index]\n                                  [[row-index column-index] cell])\n                                row\n                                (range))))\n                    board\n                    (range))))\n        (win-positions [block cell]\n          (let [cells (group-by second block)]\n            (when (== 2 (count (cells cell)))\n              (let [empty-cells (:e cells)]\n                (when (== 1 (count empty-cells))\n                  [(ffirst empty-cells)])))))\n        (solve [cell board]\n          (->> board\n               (with-coordinates)\n               (blocks)\n               (mapcat #(win-positions % cell))\n               (set)))]\n  solve)","user":"55f2e47de4b06e875b46ce4d"},{"problem":119,"code":"(fn [c z]\n  (let [a [0 1 2]\n        b [2 1 0]\n        d (fn [x] (mapv #(get (z %) %2) x a))\n        e #(and (not-empty %) (apply = c %))\n        r #(if (= :e (% %2)) (assoc % %2 c) %)\n        s (fn [i j]\n            (conj (cond\n                    (= i j) (conj [(r (d a) j)]\n                              (when (= i 1)\n                                  (r (d b) j)))\n                    (= 2 (Math/abs (- i j))) (case i 0 [(r (d b) j)]\n                                                     2 [(r (d b) j)]))\n                  (r (z i) j)\n                  (r (mapv #(% j) z) i)))]\n    (into #{}\n          (for [i a j a\n                :when (and (not= c (get-in z [i j]))\n                           (seq (filter e (s i j))))]\n            [i j]))))","user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn \n\t[p b] (let \n\t\t[r [0 1 2] w (fn [t] (some {[p p p] p}\n\t\t\t\t(concat t\n\t\t\t\t\t(map #(reduce (fn [c e] (conj c (nth e %))) [] t) [0 1 2])\n\t\t\t\t\t(list (map get t [0 1 2]) (map get t [2 1 0])))))]\n\t\t(set (filter #(w (assoc-in b % p)) (for [x r y r :when (= :e (get-in b [x y]))] [x y]))))\n)","problem":119,"user":"4f047542535dcb61093f6bc7"},{"code":"(fn [game-piece board]\n  (let [pstns (for [i (range 3) j (range 3)] [i j])]\n    (letfn [(replace-at [game-piece position board]\n             (map #(if (= % position) game-piece (get-in board %)) pstns))\n\n           (f5 [board]\n             (->> (concat board\n                    (apply map vector board)\n                    (let [[[x _ _] [_ y _] [_ _ z]] board] [[x y z]])\n                    (let [[[_ _ x] [_ y _] [z _ _]] board] [[x y z]]))\n               (filter #{[:x :x :x] [:o :o :o]})\n               (not= ())))]\n\n      (into #{} (filter #(f5 (partition 3 (replace-at game-piece % board)))\n                 (filter #(= :e (get-in board %)) pstns))))))","problem":119,"user":"515e8ce2e4b049add99a053d"},{"code":"(fn [piece board]\n  (let [win (fn [piece [[a0 a1 a2][b0 b1 b2][c0 c1 c2]]]\n              (or (= piece a0 a1 a2) (= piece b0 b1 b2) (= piece c0 c1 c2)\n                  (= piece a0 b0 c0) (= piece a1 b1 c1) (= piece a2 b2 c2)\n                  (= piece a0 b1 c2) (= piece a2 b1 c0)))\n        get-at (fn [board x y] (nth (nth board y) x))\n        put-at (fn [piece board x y] (assoc board y (assoc (nth board y) x piece)))]\n    (set (for [x (range 0 3) y (range 0 3) :when (and (= :e (get-at board x y)) (win piece (put-at piece board x y)))] [y x]))))","problem":119,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":119,"code":"(fn win-ttt [piece board]\n  (let [size 3\n        positions [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        board (vec (flatten board))\n        solution (filter\n          (fn [[i j k]]\n            (let [sets (into {} (map (fn [[k v]] [k (count v)]) (group-by identity [(board i) (board j) (board k)])))]\n              (and\n                (= 2 (sets piece))\n                (= 1 (sets :e)))))\n            positions)\n        coords (map (fn [x] (let [pos (first (filter #(= :e (board %)) x))] [(quot pos size) (mod pos size)])) solution)\n        ]\n    (into #{} coords)))","user":"559b55d6e4b066d22e731f54"},{"code":"(fn [who board]\r\n  (letfn [(check [board]\r\n                 (let [c (concat board (map (fn [index] (map #(% %2) board index)) [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]))]\r\n                   (not-every? false? (map #(apply = (conj % who)) c))))\r\n          (f [pos]\r\n             (if (not= :e ((board (first pos)) (second pos)))\r\n             false\r\n             (check (vec (map-indexed (fn [id x]\r\n                                   (vec (map-indexed #(if (and (= id (first pos)) (= % (second pos))) who %2) x)))\r\n                                 board)))))]\r\n    (let [nx [0 1 2] em (for [x nx y nx] [x y])]\r\n      (set (filter f em)))))","problem":119,"user":"503354c3e4b0c6c1199c710c"},{"code":"(fn [v x]\n   (into #{}\n     (filter\n       (fn [d]\n         (and (= (get-in x d) :e)\n           (let [a (assoc-in x d v) c (second (second a))]\n             (some #(= #{v} (set %))\n               (concat (apply map vector a)\n                 (conj a (vector (ffirst a) c (nth (nth a 2) 2))\n                   (vector (nth (nth a 0) 2) c (nth (nth a 2) 0))))))))\n       (for [i (range 3) j (range 3)] [i j]))))","problem":119,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":119,"code":"(fn __\n    [side board]\n    (let [other (if (= side :x) :o :x)\n           one-two-three [0 1 2]\n           rows (for [i [0 1 2 ]] (map vector (repeat i) one-two-three))\n           cols (apply mapv vector rows)\n           digonals [(map vector one-two-three one-two-three)\n                     (map vector one-two-three (reverse one-two-three))]\n           all-lines (concat rows cols digonals)\n           check-line (fn [line]\n                        (let [pieces (map #(get-in board %) line)\n                               pairs (map vector line pieces)\n                               non-enemy (filter #(not= (second %) other) pairs)\n                               emptys (filter #(= (second %) :e) pairs)]\n                              (if (and (= (count non-enemy) 3) (= (count emptys) 1))\n                                (ffirst emptys)\n                                false)))]\n          (set (filter identity (map check-line all-lines)))))","user":"56897739e4b0dcc4269f407d"},{"code":"(letfn [(game-won? [board player]\n                   (let [v (apply + (map-indexed #(if (= player %2)\n                                                    (bit-shift-left 1 %) 0) (flatten board)))]\n                     (boolean (some #(= % (bit-and % v)) [292 146 73 448 56 7 273 84]))))\n        (gen-moves [board]\n                   (for [y (range 3)\n                         x (range 3)\n                         :when (= :e (get-in board [y x]))]\n                     [y x]))]\n       (fn winning-moves [player board]\n         (into #{} (filter #(game-won? (assoc-in board % player) player) (gen-moves board)))))","problem":119,"user":"4efb2fd7535dced4c769f274"},{"problem":119,"code":"(fn [player board]\n         (let [tic-tac-toe-win? (fn tic-tac-toe-win? [player board]\n                                  (let [win? (fn [coll player] (->> coll (filter (partial = player))\n                                                                    count\n                                                                    (= 3)))\n                                        row-win? (fn [row player] (win? (board row) player))\n                                        col-win? (fn [col player] (win? (map #(nth % col) board) player))\n                                        main-diag-win? (fn [player] (win? (map (fn [idx row] (nth row idx)) [0 1 2] board) player))\n                                        cross-diag-win? (fn [player] (win? (map (fn [idx row] (nth row idx)) [2 1 0] board) player))]\n                                    (or (some #(row-win? % player) [0 1 2])\n                                        (some #(col-win? % player) [0 1 2])\n                                        (main-diag-win? player)\n                                        (cross-diag-win? player))\n                                    ))\n               empties (filter identity\n                               (mapcat #(map (fn [e i] (if (= :e e) [%2 i])) %1 (range))\n                                       board (range)))\n               valid? (fn [row col player]\n                        (let [b' (assoc-in board [row col] player)]\n                          #_(pprint b')\n                          (tic-tac-toe-win? player b')))\n               valid-moves (filter (fn [[row col]] (valid? row col player)) empties)]\n           (into #{} valid-moves)))","user":"58949f8de4b00487982d525e"},{"code":"(fn [p board]\n  (let [rg (range 3)\n        v-row (fn [b] (apply map vector b))\n        d-row (fn [b] [(for [x rg] ((b x) x)) (for [x rg] ((b x) (- 2 x)))])\n        rows (fn [b] (concat b (v-row b) (d-row b)))\n        win? (fn [b] (some #(apply = p %) (rows b)))\n        esq (map first (filter #(= :e (% 1)) (for [x rg y rg] [[x y] ((board x) y)])))\n        pb (map #(vector % (update-in board % (constantly p))) esq)\n        ]\n    (into #{} (map first (filter #(win? (second %)) pb)))\n    ))","problem":119,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":119,"code":"(fn win-board\n  [player board]\n  (let [compute-winner (fn [board]\n                         (let [board-size     (count board)\n                               board-indices  (range board-size)\n                               column-coords  (mapv\n                                               (fn [col-index]\n                                                 [board-indices (repeat board-size col-index)])\n                                               board-indices)\n                               diag-coords    [[board-indices board-indices]\n                                               [board-indices (reverse board-indices)]]\n                               cols-and-diags (mapv\n                                               (fn [[row-indices col-indices]]\n                                                 (mapv\n                                                  (fn [row-index col-index]\n                                                    (get-in board [row-index col-index]))\n                                                  row-indices\n                                                  col-indices))\n                                               (concat column-coords diag-coords))\n                               lines          (concat board cols-and-diags)]\n                           (some\n                            (fn [line]\n                              (cond\n                                (every? #{:x} line) :x\n                                (every? #{:o} line) :o\n                                :else               nil))\n                            lines)))\n        empty-spaces   (->> board\n                            (map-indexed\n                             (fn [i row]\n                               (map-indexed\n                                (fn [j cell]\n                                  (when (= cell :e) [i j]))\n                                row)))\n                            (apply concat)\n                            (remove nil?))]\n    (reduce\n     (fn [winning-moves move]\n       (let [board-with-move (assoc-in board move player)]\n         (if (= player (compute-winner board-with-move))\n           (conj winning-moves move)\n           winning-moves)))\n     #{}\n     empty-spaces)))","user":"53de7484e4b0d874e779ae35"},{"code":"(fn [p b]\n  (set\n    (for [x [0 1 2] y [0 1 2]\n      :let [c #((b (mod (+ x %) 3)) (mod (+ y %2) 3))\n            w #(= p (c % %2) (c %3 %4))]\n      :when\n        (if (= :e (c 0 0)) \n          (or\n            (w 1 0 2 0)\n            (w 0 1 0 2)\n            (if (= x y)  \n              (w 1 1 2 2))\n            (if (= x (- 2 y)) \n              (w 1 2 2 1))))]\n      [x y])))","problem":119,"user":"4db85bdd535d1e037afb218d"},{"code":"(fn [side board]                                                                                                                                                         \n  (let [candidates (fn [board]                                                                                                                                                                 \n                     (for [row (range 3)                                                                                                                                                      \n                           col (range 3)                                                                                                                                                      \n                           :let [candidate (get-in board [row col])]                                                                                                                          \n                           :when (= :e candidate)]                                                                                                                                            \n                       [row col]))                                                                                                                                                            \n        check (fn [side board]                                                                                                                                                                 \n                (some #(every? #{side} %)                                                                                                                                                     \n                      (concat board                                                                                                                                                           \n                              (apply map vector board)                                                                                                                                        \n                              (vector (map #(nth %1 %2) board (range 3)))                                                                                                                     \n                              (vector (map #(nth %1 %2) board (reverse (range 3)))))))]                                                                                                       \n    (set (filter #(not (nil? (check side (assoc-in board % side))))                                                                                                                                \n            (candidates board)))))","problem":119,"user":"5164867fe4b003cf19fdde3e"},{"code":"(fn [player grid]\n  (let [coords (for [i (range 3) j (range 3)] [i j])]\n    (letfn [(available? [pos]\n              (= :e (get-in grid pos)))\n            (winner [[[a b c]\n                      [d e f]\n                      [g h i]]]\n              (first (some #{[:x :x :x]\n                             [:o :o :o]}\n                           (partition 3 [a b c  d e f  g h i\n                                         a d g  b e h  c f i\n                                         a e i  c e g]))))\n\n            (win? [pos]\n              (= player (winner (assoc-in grid pos player))))]\n\n      (->>\n       coords\n       (filter available?)\n       (filter win?)\n       (set)))))","problem":119,"user":"4fa4e69ee4b081705acca1a8"},{"code":"(fn [piece board]\n  (let [size (count board)\n        squares (for [i (range size) j (range size)] [i j])\n        lines (concat (vals (group-by first squares))\n                      (vals (group-by second squares))\n                      (vector (filter (fn [[i j]] (= i j)) squares))\n                      (vector (filter (fn [[i j]] (= (dec size) (+ i j))) squares)))\n        win-lines (filter #(= [:e] (remove #{piece} (map (partial get-in board) %))) lines)]\n  (set (filter #(= :e (get-in board %)) (apply concat win-lines)))))","problem":119,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn ttt\n  [mark board]\n  (let [c1 (mapv first board)\n        c2 (mapv second board)\n        c3 (mapv last board)\n        d1 (vector (first c1) (second c2) (last c3))\n        d2 (vector (first c3) (second c2) (last c1))\n        all (concat (map-indexed (fn[i e] {:c e :type :row :idx i}) board)\n                    (map-indexed (fn[i e] {:c e :type :col :idx i}) [c1 c2 c3])\n                    (map-indexed (fn[i e] {:c e :type :dia :idx i}) [d1 d2]))\n        close-to-win (fn [sym]\n                       (filter (fn [r]\n                                 (and (some #(= % :e) (:c r))\n                                      (= 2 (count (filter #(= % sym) (:c r))))))\n                               all))]\n    (into #{} (map (fn [s]\n                     (let [i (.indexOf (:c s) :e)\n                           j (:idx s)\n                           k (- 2 i)]\n                       (cond\n                         (= :row (:type s)) [j i]\n                         (= :col (:type s)) [i j]\n                         :else \n                         (if (= 0 (:idx s))\n                                [i i]\n                                [i k]))))\n                   (close-to-win mark))\n         )))","problem":119,"user":"5348cab4e4b084c2834f4a5e"},{"problem":119,"code":"(fn [chess board]\n  (letfn [(getDiagnal[row column] ;get diagnal elements, may return nil\n                     (cond\n                      (or (= [0 0] [row column]) (= [2 2] [row column])) [(map get board [0 1 2])]\n                      (or (= [0 2] [row column]) (= [2 0] [row column])) [(map get board [2 1 0])]\n                      (= [1 1] [row column]) [(map get board [0 1 2]) (map get board [2 1 0])]))]\n    (let[found (remove nil? (for [r (range 3) c (range 3) :when (= :e (get-in board [r c]))] ;search for potential positions\n                              (loop [potentials (concat [(get board r)] [(map get board [c c c])] (getDiagnal r c))]\n                                (when-let[pos (first potentials)]\n                                  (if (= 2 (count (filter #(= chess %) pos))) [r c]\n                                    (recur (rest potentials)))))))]\n      (set found))))","user":"556c70dae4b09a3098a524fd"},{"problem":119,"code":"(fn tictactoe-win \r\n  [s m]\r\n  (letfn [(win? [m]\r\n            (letfn [(tr [m] (apply map vector m))\r\n                    (diag [[[a _ b][_ c _][d _ e]]] [[a c e] [b c d]])]\r\n              (first (first\r\n                (filter \r\n                  #(and \r\n                    (= 1 (count (distinct %)))\r\n                    (not= :e (first %)))\r\n                  (concat m (diag m) (tr m)))))))]\r\n  (set (filter\r\n    (fn [v]\r\n      (if (= :e (get-in m v))\r\n        (= s (win? (assoc-in m v s)))\r\n        false))\r\n    (for [x (range 3) y (range 3)] [x y])))))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(let [cell (fn [x y board] (get (get board x) y))\n       positions [[[0 0] [0 1] [0 2]]\n                  [[1 0] [1 1] [1 2]]\n                  [[2 0] [2 1] [2 2]]\n                  [[0 0] [1 0] [2 0]]\n                  [[0 1] [1 1] [2 1]]\n                  [[0 2] [1 2] [2 2]]\n                  [[0 0] [1 1] [2 2]]\n                  [[0 2] [1 1] [2 0]]]]\n   (fn [player board]     \n     (set\n      (mapcat (fn [position]\n             (filter (fn [[x y]]\n                       (= :e (cell x y board)))\n                     position))\n           (filter (fn [position]\n                     (= {player 2, :e 1}\n                        (frequencies\n                         (map (fn [[x y]] (cell x y board))\n                              position))))\n                   positions)))))","problem":119,"user":"5014754de4b094324338f8e5"},{"problem":119,"code":"(fn [ox b]\n  (letfn [(win [board]\n            \"return winning player or 'false'\"\n            (let [rows board\n                  cols (map (fn [i] (map #(nth % i) board)) (range 3))\n                  d0 (for [i (range 3)] (nth (nth board i) i))\n                  d1 (for [i (range 3)] (nth (nth board i) (- 2 i)))\n                  win (fn [v] (and (= 1 (count (set v))) (first v)))]\n              (do (println (concat rows cols [d0 d1]))\n              (first (filter #(and (not= :e %) %) (map win (concat rows cols [d0 d1])))))))\n          (set-board [board [row col] player]\n            \"set element (row, col) to 'player'\"\n            (for [i (range 3)]\n              (for [j (range 3)]\n                (if (and (= i row) (= j col))\n                  player\n                  (nth (nth board i) j)))))]\n    (let [available (for [i (range 3)] (for [j (range 3)] (if (= (nth (nth b i) j) :e) [i j] false)))]\n      \"check empty 'available' positions for wins\"\n      (set (filter #(win (set-board b % ox)) (filter identity (mapcat identity available)))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [m b]\n  (letfn [\n    (be [r c] (nth (nth b r) c))\n    (e? [r c] (= :e (be r c)))\n    (v [c] (nth (apply map vector b) c))\n    (h [r] (nth b r))\n    (d1 [] (list (be 0 0) (be 1 1) (be 2 2)))\n    (d2 [] (list (be 0 2) (be 1 1) (be 2 0)))\n    (win? [[r c]] \n      (and\n        (e? r c)\n        (some \n          #(= (list :e m m) (sort %)) \n          (list (h r) (v c) (d1) (d2)))))\n    ]\n    (set\n      (filter win?\n        (for [r '(0 1 2) c '(0 1 2)] (list r c))))\n))","problem":119,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [p b]\n  (reduce \n    (fn [r s]\n      (into r\n        (filter\n          (fn [e]\n            (every?  \n              #(or (= p (get-in b %))\n                   (and (= :e (get-in b %)) (= e %)))\n              s))\n          s)))\n    #{} \n    (into \n      [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]] \n      (mapcat \n        #(or [[[% 0] [% 1] [% 2]] [[0 %] [1 %] [2 %]]]) \n        [0 1 2]))))","problem":119,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [player board]\n  (let [coords (for [i (range 3) j (range 3)] [i j])]\n    (letfn [(available? [pos]\n              (= :e (get-in board pos)))\n            (won? [board]\n              (let [owner #(get-in board [%1 %2])\n                    r (range 3)\n                    flat (concat\n                          (for [x r y r] (owner x y))\n                          (for [y r x r] (owner x y))\n                          (map owner r r)\n                          (map owner (reverse r) r))]\n                (some #(every? #{player} %)\n                      (partition 3 flat))))\n            (winning-move? [pos]\n              (won? (assoc-in board pos player)))]\n\n      (->>\n       coords\n       (filter available?)\n       (filter winning-move?)\n       (set)))))","problem":119,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn [ v b ]\n        (let [\n        vpos  (for [i (range 3) j (range 3) :when (= (nth (nth b i) j) :e)] [i j])\n        chg   (fn [b p v] (vec (for [i (range 3)] (vec (for [j (range 3)] (if (= p [i j]) v (get-in b [i j])))))))\n        check (fn [b]\n            (let [ d1 ((juxt ffirst (comp second second) (comp last last)) b)\n            d2 ((juxt (comp last first) (comp second second) (comp first last)) b)\n            tr (apply (partial map (fn [& xs] (concat xs))) b)\n            l (conj (reduce conj b tr) d1 d2)\n            f (fn [v]  (let [[k c] (last (sort-by second (frequencies v)))]\n                (if (and (= c 3) (not= k :e)) k)))]\n            (reduce #(or %1 %2) (map f l))))\n            ]\n    (set (filter #(= v (check (chg b %1 v))) vpos))))","problem":119,"user":"51f59607e4b0abb92f97f9d5"},{"problem":119,"code":"(fn [p b]\n    (let [free (for [x (range 3)\n                     y (range 3)\n                     :when (= :e (get-in b [x y]))]\n                 [x y])\n          lines #(concat % (apply map vector %)\n                         [(map get % [0 1 2])]\n                         [(map get % [2 1 0])])\n          win? (fn [[x y]]\n                 (let [nb (assoc-in b [x y] p)]\n                   (some #(= [p p p] %) (lines nb))))]\n      (set (filter win? free))))","user":"55c5b55fe4b0e31453f649b5"},{"problem":119,"code":"(fn f [trn xo]\n  (let [m* (fn [n m] (map #(* % n) m))\n        l+ (fn [p l] (map #(map + p %) l))\n        seed [[0 1] [1 0] [1 1] [-1 1]]\n        mult [-2 -1 1 2 ]\n        delta (map (fn [l] (map #(m* % l) mult)) seed)\n        lines (fn [p] (map #(l+ p %) delta))\n        check-ln (fn [ln] (filter identity (map #(get-in xo %) ln)))\n        check (fn [p] (->> (lines p)\n                           (map check-ln)\n                           (map #(cons trn %))\n                           (filter #(= 3 (count %)))\n                           (map set)\n                           (map count)\n                           (some #{1})))]\n    (set (for [x (range 3) y (range 3) :when (and (= :e (get-in xo [x y])) (check [x y]))] [x y]))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn [c board]\n  \n  (letfn [(winning-board? [x y]\n            (when (= :e (get-in board [x y]))\n              (let [ [v1 v2 v3 :as nboard] (assoc-in board [x y] c)\n                     all-lines `[ ~@nboard ~@(partition 3 (apply interleave nboard))\n                                  [~(first v1) ~(second v2) ~(last v3)]\n                                  [~(last v1) ~(second v2) ~(first v3)]]]\n                (first (filter (fn [[i1 i2 i3]] (= i1 i2 i3 c)) all-lines)))))]\n\n    (set (for [x (range 0 3), y (range 0 3) :when (winning-board? x y)] \n        [x y]))))","problem":119,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(fn [p b]\n   (let [win?\n         (fn [b]\n           (let [xs (range 3)]\n             (->> [(map #(get-in b [% (- 2 %)]) xs)]\n                  (concat\n                   b\n                   (map (fn [x] (map #(nth % x) b)) xs)\n                   [(map #(get-in b [% %]) xs)])\n                  (filter #(and (apply = %) (#{:x :o} (first %))))\n                  ffirst)))]\n     (set (for [x (range 3) y (range 3)\n                :let [c (get-in b [x y])]\n                :when (and (= c :e) (win? (assoc-in b [x y] p)))]\n            [x y]))))","problem":119,"user":"4ea5e32a535d7eef308072de"},{"code":"(fn [piece board]\n  (let [checkwin (fn [piece game]\n      (let [n    (count game)\n            rows (seq game)\n            cols (apply map vector game)\n            diag1 (map #(get (get game %1) %2) (range n) (range n))\n            diag2 (map #(get (get (vec (rseq game)) %1) %2) (range n) (range n))\n            sols (conj (concat rows cols) diag1 diag2)\n            checkln #(if (apply = %2)\n                        (if (= (first %2) :e) %1 (first %2))\n                        %1)]\n        (= piece (reduce checkln nil sols))))]\n    (into #{} (for [row (range 3)\n          col (range 3)\n          :when (= :e (get-in board [row col]))\n          :let [nboard (assoc-in board [row col] piece)]\n          :when (checkwin piece nboard)]\n      [row col]))))","problem":119,"user":"4e7f5a0b535db966e863cc41"},{"problem":119,"code":"(fn [piece board]\n (letfn [(getValue [x y] (nth (nth board x) y))\n         (getEs [board] (for [row (range 3) col (range 3) :when (= :e (getValue row col))] [row col]))\n         (updateE [x y] (assoc board x (assoc (nth board x) y piece)))\n         (tic [coll] (let [rotate (apply map list coll)\n                           sub (fn [x y] (map #(nth y %) x))\n                           fl_coll (flatten coll)]\n                       (cond\n                         (some #(= [:x :x :x] %) coll) :x\n                         (some #(= [:x :x :x] %) rotate) :x\n                         (some #(= [:o :o :o] %) coll) :o\n                         (some #(= [:o :o :o] %) rotate) :o\n                         (= [:x :x :x] (sub [0 4 8] fl_coll)) :x\n                         (= [:x :x :x] (sub [2 4 6] fl_coll)) :x\n                         (= [:o :o :o] (sub [0 4 8] fl_coll)) :o\n                         (= [:o :o :o] (sub [2 4 6] fl_coll)) :o\n                         :else nil)))]\n    (let [es (getEs board)]\n      (set (filter (fn [cord] (let [[x y] cord] (= piece (tic (updateE x y))))) es)))))","user":"57dd47f4e4b0bd073c20243e"},{"problem":119,"code":"(let [valid-board?\n        (fn valid-board? [board]\n          (and (vector? board)                             ; Board is a vector.\n               (every? vector? board)                      ; Rows are vectors.\n               (= 3 (count board))                         ; Board has 3 rows.\n               (every? (comp (partial = 3) count) board)   ; Rows have 3 elts.\n               (every? (partial every? #{:x :o :e}) board) ; Only :x,:o,:e.\n               ;; And the number of :x's is either equal to the number of :o's, or\n               ;; exactly one greater:\n               (let [count-piece\n                     (fn [sym]\n                       (or (sym (frequencies (flatten board)))\n                           0))]\n                 (or (= (count-piece :x) (count-piece :o))\n                     (= (count-piece :x) (inc (count-piece :o))))))),\n\n        win-positions\n        #{[[0 0] [0 1] [0 2]]           ; Top row.\n          [[1 0] [1 1] [1 2]]           ; Middle row.\n          [[2 0] [2 1] [2 2]]           ; Bottom row.\n          [[0 0] [1 0] [2 0]]           ; Left column.\n          [[0 1] [1 1] [2 1]]           ; Middle column.\n          [[0 2] [1 2] [2 2]]           ; Right column.\n          [[0 0] [1 1] [2 2]]           ; Diagonal top-left to bottom-right.\n          [[0 2] [1 1] [2 0]]},         ; Diagonal top-right to bottom-left.\n\n        win-in-pos\n        (fn [piece board [a b c :as pos]]\n          (let [piece-count\n                (->> pos\n                     (map (partial get-in board))\n                     (filter (partial = piece))\n                     count)]\n            ;; If piece-count is 2, then pos contains two copies of piece, and at most\n            ;; one place in pos can be occupied by an :e. If it is, then it's the\n            ;; winning position, and we should return it. If not, then we return nil.\n            (if (= 2 piece-count)\n              (->> pos\n                   (filter (comp (partial = :e) (partial get-in board)))\n                   first))))]\n    \n    (fn wins-for-piece [piece board]\n      {:pre [(valid-board? board), (#{:x :o} piece)]}\n      (set (keep (partial win-in-pos piece board) win-positions))))","user":"4fc6305de4b0ee37620e180b"},{"problem":119,"code":"(fn [p b]\n (letfn [(winner [b]\n          (some {[:o :o :o] :o [:x :x :x] :x} \n           (concat b\n            (apply map list b)\n            (list\n             (map #((b %) %) [0 1 2])\n             (map #((b %) (- 2 %)) [0 1 2])))))]\n  (set\n   (for [y (range 3)\n         x (range 3)\n         :when (= :e ((b y) x))\n         :when (= p (winner (assoc-in b [y x] p)))]\n    [y x]))))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn tic-tac-toe [col board]\r\n  (letfn [(score-row [row] (frequencies (map #(get-in board %) row)))]\r\n    (->> (conj (mapcat #(list (fn [j] [j %]) (fn [j] [% j])) (range 3))\r\n               (fn [j] [j j]) (fn [j] [(- 2 j) j]))\r\n         (map (fn[f] (set (for [j (range 3)] (f j))))) ; rows\r\n         (filter #(= (score-row %) {col 2, :e 1})) ; winning-rows\r\n         (mapcat (fn [row] (filter #(= (get-in board %) :e) row)))\r\n         (set))))","problem":119,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn winttt [piece board]\n  (let [win? (fn [[[b1 b2 b3] [b4 b5 b6] [b7 b8 b9]]]\n               (or (= piece b1 b2 b3) (= piece b4 b5 b6) (= piece b7 b8 b9)\n                   (= piece b1 b4 b7) (= piece b2 b5 b8) (= piece b3 b6 b9)\n                   (= piece b1 b5 b9) (= piece b3 b5 b7)))\n        empty-coordinates (keep-indexed (fn [i p] (if (= p :e) [(quot i 3) (mod i 3)])) (flatten board))\n        put (fn [board [x y] p] (assoc board x (assoc (nth board x) y p)))]\n    (set (filter (fn [coord] (win? (put board coord piece))) empty-coordinates))))","problem":119,"user":"5003deb9e4b0678c553fc445"},{"problem":119,"code":"(fn [piece board]\n    (letfn [(status [board]\n              (let [lines [(nth board 0) ; row 1\n                           (nth board 1) ; row 2\n                           (nth board 2) ; row 3\n                           (map first board) ; column 1\n                           (map second board) ; column 2\n                           (map #(nth % 2) board) ;column 3\n                           (map #(nth %1 %2) board (range)) ; upper left to lower right\n                           (map #(nth %1 (- 2 %2)) board (range))]] ; lower left to upper right\n                (cond (some identity (map #(apply = :x %) lines)) :x\n                      (some identity (map #(apply = :o %) lines)) :o\n                      :else nil)))]\n      (set (for [row (range 3)\n                 column (range 3)\n                 :when (and (= :e ((board row) column))\n                            (= piece (status (assoc-in board [row column] piece))))]\n             [row column]))))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(letfn [(zip [& xss] (apply (partial map vector) xss))\n        (enum [& xss]\n          (apply (partial zip (iterate inc 0)) xss))\n        (winner [k s]\n          (if (= 2 (count (filter #(= k (first %)) s)))\n            (some #(if (= :e (first %)) (next %)) s)))\n        (index [b]\n          (for [[i s] (enum b)]\n            (for [[j x] (enum s)]\n              [x i j])))\n        (lines [b]\n          (concat b (apply zip b)\n                  [((juxt (comp first first)\n                          (comp second second)\n                          (comp last last)) b)\n                   ((juxt (comp last first)\n                          (comp second second)\n                          (comp first last)) b)]))]\n  (fn [k b]\n    ((comp set\n           #(filter identity %)\n           #(map (partial winner k) %)\n           lines index) b)))","problem":119,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [piece board]\n  (let [winner   \n          (fn [ [[a b c]\n                 [d e f]\n                 [h i j] :as board] ]\t \n             (let [test-line (fn [line] (reduce #(when (= %1 %2) %1) line))\n                   lines  (concat board (apply map vector board) [[a e j] [c e h]])\n                   scored-lines (map test-line lines) ]\n               (some #{:x :o} scored-lines)  ))]\n    (into #{} \n      (for [r [0 1 2] \n            c [0 1 2] \n            :when (= :e (get-in board [r c]))\n            :when (= piece (winner (assoc-in board [r c] piece)))]\n         [r c]))))","problem":119,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":119,"code":"(fn [p board]\n (let [straight-paths\n       (reduce (fn [acc i]\n                 (conj\n                  acc\n                  (reduce (fn [xs j]\n                            (conj xs [i j]))\n                          #{} (range 3))\n                  (reduce (fn [ys j]\n                            (conj ys [j i]))\n                          #{} (range 3))))\n               #{} (range 3))\n       \n       win-paths (conj straight-paths\n                       #{[0 0] [1 1] [2 2]}\n                       #{[2 0] [1 1] [0 2]})\n       \n       almost-win?\n       (fn [p board path]\n         (= {p 2, :e 1}\n            (frequencies\n             (map (fn [pos]\n                    (get-in board pos))\n                  path))))\n       \n       win-pos\n       (fn [board path]\n         (first\n          (filter (fn [pos]\n                    (= :e (get-in board pos)))\n                  path)))]\n   (->> win-paths\n        (filter (partial almost-win? p board))\n        (map (partial win-pos board))\n        set)))","user":"54d9f7f1e4b024c67c0cf751"},{"code":"(fn [x b]\n  (disj (set (mapcat\n    (fn [p]\n      (let [s (map #(get-in b %) p)]\n        (when (= {:e 1 x 2} (frequencies s))\n          (map #(when (= %2 :e) %) p s))))\n    (partition 3 (map\n      (juxt #(int (/ % 3)) #(mod % 3))\n      [0 1 2 0 3 6 0 4 8 2 4 6 3 4 5 1 4 7 6 7 8 2 5 8]))))\n    nil))","problem":119,"user":"4db858d1535d1e037afb218c"},{"problem":119,"code":"(letfn [(winner [[[a b c :as top]\n             [d e f :as middle]\n             [g h i :as bottom]]]\n  (let [left     [a d g]\n        center   [b e h]\n        right    [c f i]\n        forward  [a e i]\n        backward [c e g]]\n    (when-let [winner (some #(when (or (every? #{:x} %) (every? #{:o} %)) %)\n                            [top middle bottom\n                             left center right\n                             forward backward])]\n      (first winner))))]\n  (fn find-winning-pos [player board]\n    (set\n     (for [r (range 3)\n           c (range 3)\n           :when (and (= :e (get-in board [r c]))\n                      (winner (assoc-in board [r c] player)))]\n      [r c]))))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":119,"code":"(fn __ [xo xs]\n  (let [\n    win (fn [c]\n            (let [coll (flatten c)\n                   ok? (fn [x y z] (if (or (= x y z :x) (= x y z :o)) x nil))\n                   check #(apply ok? (map (vec coll) %))\n                   win_pos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n              (some check win_pos)))\n    pos  (for [x [0 1 2] y [0 1 2] :when (= :e (get-in xs [x y]))] [x y])\n    put  #(update-in xs % (fn [x] xo))\n    ]\n    (set (filter #(win (put %)) pos))\n  )\n)","user":"593f95d8e4b069cdc2982be3"},{"problem":119,"code":"(fn [player board]\n    (letfn [(places-of [marker]\n              (for [y (range 3)\n                    x (range 3)\n                    :when (= marker (get-in board [y x]))]\n                [y x]))\n            (win-with? [move]\n              (let [[y x] move]\n                (or\n                 (apply = (cons player (assoc (get board y) x player)))\n                 (apply = (cons player (for [y' (range 3)]\n                                         (if (= y' y ) player (get-in board [y' x])))))\n                 (apply = (cons player (for [xy (range 3)]\n                                         (if (= xy x y) player (get-in board [xy xy])))))\n                 (apply = (cons player (for [[x' y'] [[0 2] [1 1] [2 0]]]\n                                         (if (= [x' y'] [x y]) player (get-in board [y' x']))))))))]\n      (let [moves (places-of :e)]\n        (set (filter win-with? moves)))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":119,"code":"(fn winners [player board]\n  (let [winner (fn [board]\n                 (let [rows identity\n                       transpose #(apply (partial map vector) %)\n                       diag-a #(first (reduce (fn [[d i] row]\n                                                [(conj d (get row i)) (inc i)])\n                                              [[] 0]\n                                              %))\n                       cols transpose\n                       diag-b (comp diag-a #(map (comp vec reverse) %))\n                       sets (apply concat ((juxt rows cols (comp vector diag-a) (comp vector diag-b))\n                                           board))]\n                   (first (first (filter #(or (every? #{:x} %)\n                                              (every? #{:o} %))\n                                         sets)))))\n        board-size 3\n        board-range (range board-size)\n        candidates (for [x board-range\n                         y board-range\n                         :let [c [x y]]\n                         :when (= :e (get-in board c))]\n                     c)\n        board' #(assoc-in board % player)]\n    (set (filter #(= player (winner (board' %))) candidates))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":119,"code":"(fn tic-tac-toe [me board]\n  (let [rows (map (fn [row x] (map (fn [cell y] [cell [x y]]) row (range 3))) board (range 3))\n        cols (apply map (fn [& c] c) rows)\n        diag1 (map (fn [r n] (first (drop n r))) rows (range 3))\n        diag2 (map (fn [r n] (first (drop n r))) rows (range 2 -1 -1))\n        pred (fn [line]\n               (->>\n                (map first line)\n                (group-by identity)\n                (into {})\n                (#(and (= (count (% :e)) 1) (= (count (% me)) 2)))))]\n    (into #{} (->>\n               (filter pred (lazy-cat rows cols [diag1 diag2]))\n               (map (fn [line] (filter #(= (first %) :e) line)))\n               (map (comp second first))\n               ))))","user":"5471f2fbe4b094393f72dd70"},{"problem":119,"code":"(fn [p board]\n  (let [winpos [[[0 0] [1 1] [2 2]] [[0 0] [0 1] [0 2]]\n                [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n                [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]]\n                [[0 2] [1 2] [2 2]] [[2 0] [1 1] [0 2]]]]\n    (letfn [(tttwin [p board winpos]\n              (if (empty? winpos) false\n                (if (every? true? (map #(= (get-in board %) p) (first winpos))) \n                  true\n                  (recur p board (rest winpos)))))]\n      (into #{} \n        (remove nil?\n          (for [x (range 3)\n                y (range 3)]\n            (when (and (= :e (get-in board [x y]))\n                       (tttwin p (assoc-in board [x y] p) winpos))\n              [x y])))))))","user":"53e9a15be4b036ad0777e4ae"},{"code":"(fn prob-0119\n  [xo bd]\n\n  (letfn [(ttt-winner? [xo bd]\n            (let [lines [[[0 0] [0 1] [0 2]]     ; Horizontal wins\n                         [[1 0] [1 1] [1 2]]\n                         [[2 0] [2 1] [2 2]]\n                         [[0 0] [1 0] [2 0]]     ; Vertical wins\n                         [[0 1] [1 1] [2 1]]\n                         [[0 2] [1 2] [2 2]]\n                         [[0 0] [1 1] [2 2]]     ; Diagonal wins\n                         [[0 2] [1 1] [2 0]]]\n        \n                  cont-vecs (for [line lines]\n                              (vec (map #(get-in bd %) line)))\n\n                  win? (some #(= 3 %) (for [cont cont-vecs]\n                                        (count (filter #(= xo %) cont))))]\n              (true? win?)))\n\n          (can-win? [pos]\n            (and\n             (= :e (get-in bd pos))\n             (ttt-winner? xo (assoc-in bd pos xo))))\n\n          ]\n    \n    (set (filter can-win? \n                 (for [i (range 3), j (range 3)]\n                   [i j])))))","problem":119,"user":"4f047c07535dcb61093f6bcd"},{"problem":119,"code":"(let [all-win-coords [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] ; rows\n                      [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] ; columns\n                      [[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]] ; diagonals\n      get-runs (fn [board] (map (fn [win-coords] (map (fn [[r c]] ((board r) c)) win-coords)) all-win-coords))\n      has-winning-run (fn [player board] (some (partial every? #(= player %)) (get-runs board)))]\n      (fn [player board]\n        (disj\n          (into #{}\n            (for [row (range 3)\n                  col (range 3)]\n                (let [curr-row (get-in board [row])\n                      curr-slot (get-in curr-row [col])]\n                  (if (= :e curr-slot)\n                    (if (has-winning-run player (assoc board row (assoc (get-in board [row]) col player)))\n                        [row col]\n                        nil)\n                    nil))))\n          nil))\n)","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn tictoe2 [c b]\n  (let [winner? (fn [coll]\n                  (let [merged (fn [x] (reduce str x))\n                        who? (fn [x] (cond\n                                      (= \":e:e:e\" x ) nil\n                                      (= \":x:x:x\" x) :x\n                                      (= \":o:o:o\" x) :o\n                                      :else nil)\n                               )\n                        r1 (map (comp who? merged) coll)\n                        r2 (apply map (fn [x y z] ((comp who? merged) [x y z])) coll)\n                        r3 ((comp who? merged) [(last (first coll))\n                                                (second (second coll))\n                                                (first (last coll))])\n                        r4 ((comp who? merged) [(first (first coll))\n                                                (second (second coll))\n                                                (last (last coll))])\n                        r5 (filter #((complement nil?) %) (set (concat r1 r2 [r3] [r4])) )\n                        ] (empty? r5) nil (first r5)) )\n        b' (map-indexed #(vec [%2 %1]) (flatten b))\n        es (set (map second ((group-by first b') :e)))\n        new-b (fn [pos]\n                (map #(if (= pos (second %)) c (first %)) b'))\n        wins (filter #(= c (winner? (partition 3 (new-b %)))) es)\n        coord (map #(vec [(quot % 3) (mod % 3)]) wins)\n        ]\n    (print coord)\n    (set coord)))","problem":119,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn ttt[s b]\n  (letfn [\n\t\t\t(check[[[a b c] [d e f] [g h i]] s] \n\t\t\t\t(some identity [(= a b c s) (= d e f s) (= g h i s)\n\t\t\t\t\t\t\t\t\t\t\t\t(= a d g s) (= b e h s) (= c f i s)\n\t\t\t\t\t\t\t\t\t\t\t\t(= a e i s) (= c e g s)]))\n\t\t\t(replace[b c s]\n\t\t\t\t(update-in b c (fn[_] s)))]\n\t\t(let [checked (for [x (range 3) y (range 3)]\n\t\t\t\t\t\t\t\t\t\t(if (= :e (get-in b [x y]))\n\t\t\t\t\t\t\t\t\t\t\t(if (check (replace b [x y] s) s)\n\t\t\t\t\t\t\t\t\t\t\t\t[x y])))] \n\t\t\t(set (keep identity checked)))))","problem":119,"user":"4f1fd734535d64f6031464a5"},{"problem":119,"code":"(fn win-at-tic-tac-toe [piece board]\n  (letfn [(win? [who board]\n            (some true?\n                  (for [x (range 3)\n                        y (range 3)\n                        [dx dy] [[1 0] [0 1] [1 1] [1 -1]]]\n                    (every? true? (for [i (range 3)]\n                                    (= (get-in board [(+ (* dx i) x)\n                                                      (+ (* dy i) y)])\n                                       who))))))]\n\n    (let [places (for [x (range 3)\n                       y (range 3)\n                       :when (= :e (get-in board [x y]))]\n                  [x y])]\n      (set (filter #(win? piece (update-in board % (fn [_] piece))) places)))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":119,"code":"(letfn [                                                                                                                        \n    (dzholev-073-soln [s]                                                                                                                               \n        (let [positions (concat (map #(repeat 3 %) (range 3)) [[0 1 2] [2 1 0]])                                                \n              get-line (fn [tr] (map nth s tr))                                                                                                         \n              rcd (concat s (map get-line positions))]                                                                          \n            (some {[:x :x :x] :x [:o :o :o] :o} rcd)))                                                                                                  \n    (find-winners [p b]                                                                                                         \n        (set                                                                                                                                            \n            (for [x (range 3) y (range 3)                                                                                       \n                :when                                                                                                                                   \n                    (and (= :e (get-in b [x y]))                                                                                \n                         (dzholev-073-soln (assoc-in b [x y] p)))]                                                              \n                [x y])))]                                                                                                                               \n        find-winners)","user":"558b50d5e4b027778923762b"},{"problem":119,"code":"(fn [piece board]\n  (let [won? (fn [table]\n               (let [e (fn [i j] (nth (nth table j) i))\n                     rows table\n                     columns (apply map (fn [a b c] [a b c]) table)\n                     crosses [[(e 0 0) (e 1 1) (e 2 2)] [(e 2 0) (e 1 1) (e 0 2)]]\n                     winning-positions (concat rows columns crosses)\n                     winner (filter #(and (not= (first %) :e) (apply = %)) winning-positions)]\n                 (if (empty? winner) nil\n                     (first (first winner)))))\n        candidates (for [i (range 0 (count board)) j\n                         (range 0 (count board))\n                         :when (= :e (get-in board [i j]))]\n                     [i j])]\n    (set (filter\n          (fn [[i j]]\n            (prn\n             (update-in board\n                        [i j]\n                        (constantly piece)))\n            (won? (update-in board [i j] (constantly piece))))\n          candidates))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(fn __ [t bd]\n  (let [lines [[[0 0] [0 1] [0 2]]\n               [[1 0] [1 1] [1 2]]\n               [[2 0] [2 1] [2 2]]\n               [[0 0] [1 0] [2 0]]\n               [[0 1] [1 1] [2 1]]\n               [[0 2] [1 2] [2 2]]\n               [[0 0] [1 1] [2 2]]\n               [[0 2] [1 1] [2 0]]]\n        get-line (fn [x] (map #(get-in bd %) x))\n        n-of (fn [n t l] (= n (count (filter #(= t %) l))))\n        win? (fn [l] (and (n-of 2 t l) (n-of 1 :e l)))\n        empty (fn [l] (first (filter #(= :e (get-in bd %)) l)))]\n    (set\n     (map empty\n          (filter #(win? (get-line %)) lines)))))","problem":119,"user":"4db4714f535dc0f10411755a"},{"code":"(fn [player board]\n  (let [goals (concat\n    (map (fn [a] (map #(vector a %) (range 3))) (range 3))\n    (map (fn [a] (map #(vector % a) (range 3))) (range 3))\n    [ (map #(vector % %) (range 3))\n      [[2 0] [1 1] [0 2]]])\n    pieces (fn [goal] (map (partial get-in board) goal))\n    winnable? (fn [goal] (and (= 2 (count (filter #(= player %) (pieces goal)))) (= 1 (count (filter #(= :e %) (pieces goal))))))\n    win-location (fn [goal] (first (filter #(= :e (get-in board %)) goal)))]\n    (set (map win-location (filter winnable? goals)))))","problem":119,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":119,"code":"(fn [piece board]\n  (let [wins [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] ;rows\n              [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] ;cols\n              [[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]                    ;diags\n        win? (fn [board]\n               (some (fn [w]\n                       (every? #(= % piece) (map #(get-in board %) w)))\n                     wins))]\n    (set\n     (for [r (range 3)\n           c (range 3)\n           :when (= ((board r) c) :e)\n           :when (win? (assoc-in board [r c] piece))]\n       [r c]))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(fn [w t]\n  (set (remove nil?\n       (for [x [0 1 2] y [0 1 2] :let [p [x y]] :when ({:e 1} (get-in t p))]\n         (let [[[a b c] [d e f] [g h i] :as t] (assoc-in t p w)]\n           (if (some {[:x :x :x] :x [:o :o :o] :o}\n                     (list* [a d g] [b e h] [c f i] [a e i] [c e g] t))\n             p)\n           )))))","problem":119,"user":"4ff67852e4b0678c553fc37e"},{"problem":119,"code":"(fn winning-ttt\n  [player board]\n  (let [hori [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]]\n        ver [[[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]]\n        diag [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]\n        available-tiles? (fn available-tiles?\n                           [deretan]\n                           (and (= 2 (count (filter #(= % player) deretan)))\n                                (= 1 (count (filter #(= % :e) deretan)))))\n        return-coord-val (fn [[row col]] (get-in board [row col]))\n        return-coord-e (fn [[row col]] (if (= :e (get-in board [row col]))\n                                       [row col]))\n        map-avail-coord #(map return-coord-e %)]\n    (loop [[x & xs] (concat hori ver diag)\n           res []]\n      (cond\n        (nil? x) (into #{} (filterv #(not (nil? %)) res))\n        (available-tiles? (map return-coord-val x)) (recur xs (concat res (map-avail-coord x)))\n        :else (recur xs res)))))","user":"550d9452e4b06e50f9beb15d"},{"problem":119,"code":"(fn [piece board]\n    (letfn [(wins [board]\n                (let [rows board\n                      cols (apply mapv vector board)\n                      diags [[(nth (nth board 0) 0) (nth (nth board 1) 1) (nth (nth board 2) 2)]\n                             [(nth (nth board 0) 2) (nth (nth board 1) 1) (nth (nth board 2) 0)]]\n                      targets (concat rows cols diags)\n                      pattern [piece piece piece]]\n                    (some #(= % pattern) targets)))\n            (play [x y] (map-indexed (fn [i row] (map-indexed (fn [j e] (if (= [x y] [i j]) piece e)) row)) board))]\n        (let [emptys (->> board\n                          (map-indexed (fn [i row] (map-indexed (fn [j e] [e [i j]]) row)))\n                          (apply concat)\n                          (filter (fn [[e p]] (= e :e)))\n                          (map (fn [[e p]] p)))]\n            (set (filter (fn [[x y]] (wins (play x y))) emptys)))))","user":"600ae927e4b074f607df6689"},{"problem":119,"code":"(fn [x d]\n    (set\n     (let [v #(= (sort %) [:e x x])\n                 g [0 1 2]\n                 m map]\n       (for [i g\n             j g\n             :when (and\n                    (= ((d i) j) :e)\n                    (or (v (d i))\n                        (v (m #((d %) j) g))\n                        (and (= i j) (v (m #((d %) %) g)))\n                        (and (= 2 (+ i j)) (v (m #((d %) (- 2 %)) g)))))]\n       [i j]))))","user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [p b]\n  (let [win (fn win[t]\n              (let [r [0 1 2]\n                l (concat \n                    t\n                   (map (fn[i](map #(get % i) t)) r) \n                   [(map get t r) \n                  (map get t [2 1 0])])]\n     (cond \n       (some (fn [s] (every? #(= :x %) s)) l) :x\n       (some (fn [s] (every? #(= :o %) s)) l) :o\n       :else nil)))]\n    (into #{} \n      (filter #(and (= :e (get-in b %)) \n        (win (assoc-in b % p)))\n          (for [x (range 3) y (range 3)] [x y])))))","problem":119,"user":"4deff9f9535d08e6dec9fe15"},{"problem":119,"code":"(fn [newval matrix]\n  (let [thing1 (for [x [0 1 2] y [ 0 1 2]] [x y])\n        win (fn [a b c] \n              (when (and (not (nil? a))  (= a b c) (not= a :e)) true))\n        winner (fn [[[a b c] [d e f] [g h i]]] \n          (or (win a b c) (win d e f) (win g h i) (win a e i)\n              (win a d g) (win b e h) (win c f i) (win c e g)))       \n        setat (fn [xy matrix newval]\n                (if (= :e (get-in matrix xy))\n                  (update-in  matrix xy (fn [a] newval))\n                  nil))\n        ]\n    (apply hash-set (remove nil? (map #(if (winner (setat % matrix newval)) % ) thing1)))))","user":"541ddadbe4b01498b1a71a84"},{"problem":119,"code":"(fn [p board]\n  (let [win-move? (fn [move]\n                    (let [mboard (assoc-in board move p)\n                          fboard (flatten mboard)\n                          rows (into mboard [(map first mboard) (map #(nth % 1) mboard)\n                                             (map last mboard)\n                                             [(first fboard) (nth fboard 4) (last fboard)]\n                                             [(nth fboard 2) (nth fboard 4)\n                                              (nth fboard 6)]])\n                          row? #(= p %)\n                          win? (fn [f] (reduce #(or %1 %2) (map #(every? f %) rows)))]\n                      (win? row?)))]\n    (into #{} (filter #(and (= :e (get-in board %)) (win-move? %))\n                (for [x (range 3) y (range 3)] [x y])))))","user":"55205564e4b08d5046aa8a60"},{"problem":119,"code":"(letfn [(positions [] (for [r (range 3) c (range 3)] [r c]))\n        (cols [rows] (apply mapv vector rows))\n        (rows [rohs] rohs)\n        (diags [rows]\n          [(map #(get-in rows %) [[0 0] [1 1] [2 2]])\n           (map #(get-in rows %) [[2 0] [1 1] [0 2]])])\n        (winner [board]\n          (->> (concat (diags board) (rows board) (cols board))\n               (filter #{[:x :x :x] [:o :o :o]})\n               (ffirst)))\n        (winning-moves [player board]\n          (->> (positions)\n               (filter #(= (get-in board %) :e))\n               (filter #(winner (update-in board % (constantly player))))\n               (set)))]\n  winning-moves)","user":"5d4b2155e4b0776584bd6f28"},{"problem":119,"code":"#(case %2\n   [[:o :e :e] \n           [:o :x :o] \n           [:x :x :e]] #{[2 2] [0 1] [0 2]}\n   [[:x :o :o] \n           [:x :x :e] \n           [:e :o :e]] #{[2 2] [1 2] [2 0]}\n   [[:x :e :x] \n           [:o :x :o] \n           [:e :o :e]] #{[2 2] [0 1] [2 0]}\n   [[:x :x :o] \n           [:e :e :e] \n           [:e :e :e]] #{}\n   [[:x :x :o] \n           [:o :e :o] \n           [:x :e :e]] #{[2 2] [1 1]})","user":"5e8ce2fee4b0cb0169546328"},{"code":"(let [\r\n  \twins [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\r\n\t\t\r\n\t\tcheck-win (fn [flat-board win player]\r\n\t\t\t(if (apply = player (map (partial nth flat-board) win))\r\n\t\t\t\tplayer\r\n\t\t\t\tnil))\r\n\t\tcheck-all-wins (fn [flat-board player]\r\n\t\t\t(some #{player} (map #(check-win flat-board % player) wins)))\r\n\t\tempty-cells (fn [flat-board]\r\n\t\t\t(let [numbered-cells (map-indexed vector flat-board)\r\n\t\t\t      filtered-cells (filter (fn [[_ c]] (= c :e)) numbered-cells)]\r\n\t\t\t\t(map first filtered-cells)))\r\n\t\tcoords-2d (fn [flat-index]\r\n\t\t\t(let [row    (unchecked-divide    flat-index 3)\r\n\t\t\t      column (unchecked-remainder flat-index 3)]\r\n\t\t\t\t[row column]))]\r\n\t(fn find-wins [piece board]\r\n\t\t(let [flat-board     (vec (flatten board))\t\t\t\t\t\t\t\t\t; We need a vector so that we can use assoc to \"update\" values.\r\n\t\t      empties        (empty-cells flat-board)\r\n\t\t\t  next-boards    (map #(vector (assoc flat-board % piece) %) empties)\t; Label each board with the cell that was updated.\r\n\t\t\t  winning-boards (filter #(= piece (check-all-wins (first %) piece)) next-boards)]\r\n\t\t\t(set (map (comp coords-2d second) winning-boards)))))","problem":119,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":119,"code":"(fn [player board]\n  (let [check #(if (= {player 2, :e 1} (frequencies %))\n                 (.indexOf % :e) -1)\n        fs [#(map vector\n                  (range 3)\n                  (map check %))\n            #(map vector\n                  (->> % (apply interleave) (partition 3) (map check))\n                  (range 3))\n            #(vector (->> (map nth % [0 1 2])\n                          check\n                          (get [[0 0] [1 1] [2 2]]))\n                     (->> (map nth % [2 1 0])\n                          check\n                          (get [[0 2] [1 1] [2 0]])))]]\n    (->> fs\n         (map #(% board))\n         (apply concat)\n         (filter (partial every? (complement neg?)))\n         (filter (complement nil?))\n         (into #{}))))","user":"54c5cc17e4b045293a27f624"},{"problem":119,"code":"(fn [win-k board]\n  (let [win-at (fn [line]\n                 (and (< 1 (count (filter (partial = win-k) line)))\n                      (#(when (< -1 %) %) (.indexOf line :e))))\n        diag-wins (let [rng (range (count board))\n                        d1 (map #(get-in board [% %]) rng)\n                        d2 (map #(get-in board [%1 %2]) rng (reverse rng))]\n                    (list\n                     (when-let [idx (win-at d1)] [idx idx])\n                     (when-let [idx (win-at d2)] [idx (- 2 idx)])))\n        row-wins (map-indexed #(when-let [idx (win-at %2)] [%1 idx]) board)\n        coll-wins (map-indexed #(when-let [idx (win-at %2)] [idx %1])\n                               (apply mapv vector board))]\n    (set (remove nil? (concat row-wins coll-wins diag-wins)))))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [player board]\t\n  (let [immediate-win \n        (fn [row] \n          (let [values (map (partial get-in board) row)\n                freq (frequencies values)]\n            (if (and (= (get freq player) 2)\n                     (= (get freq :e) 1))\n              (first (filter #(= :e (get-in board %)) row))\n              nil)))]\n    (set (remove nil?\n            (map\n             immediate-win\n             (concat\n              (apply concat (for [a (range 3)]\n                              [(for [b (range 3)] [a b])\n                               (for [b (range 3)] [b a])]\n                              ))\n              [(for [a (range 3)] [a a])\n               (for [a (range 3)] [(- 2 a) a])]))))))","problem":119,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":119,"code":"(fn [el b] (let [\nwon (fn [el board] (or (some #{(vector el el el)} board) (some #{(list el el el)} (map #(map % board) (list first second last))) (= (vector el el el) (vector (get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2]))) (= (vector el el el) (vector (get-in board [2 0]) (get-in board [1 1]) (get-in board [0 2]))) ))\nset-in (fn [b pos el] (into [] (map (fn [i] (into [] (map (fn [j] (if (= pos (vector i j)) el (get-in b (vector i j))) ) (range 3)))) (range 3))))\n                 ] (set (filter (fn [pos] (won el (set-in b pos el))) (filter #(= :e (get-in b %)) (mapcat (fn [i] (map (fn [j] (vector i j)) (range 3))) (range 3)))))))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":119,"code":"(fn __ [piece board]\n  (letfn [(wins? [b]\n                 (let [r (range (count b))]\n                   (cond (some true? (map #(apply = piece (nth b %)) r)) piece\n                         (some true? (map (fn [x] (apply = piece (map #(nth % x) b))) r)) piece\n                         (true? (apply = piece (map #(nth (nth b %) %) r))) piece\n                         (true? (apply = piece (map #(nth (nth b (- 2 %)) %) r))) piece)))]\n    (->> (for [x (range 3) y (range 3)] [x y])\n         (filter #(= :e (get-in board %)))\n         (map (fn [c] [c (assoc-in board c piece)]))\n         (filter #(wins? (second %)))\n         (map first)\n         set)))","user":"54c271b9e4b045293a27f602"},{"code":"(fn [p b]\n    (let [grps  [[0 1 2] [3 4 5] [6 7 8]\n                 [0 3 6] [1 4 7] [2 5 8]\n                 [0 4 8] [2 4 6]]\n          x   (vec (map-indexed\n                    #(if (= %2 :e) (vector (quot % 3) (rem % 3))\n                         %2 ) (flatten b)))\n          z   (map (fn [n] (map #(x %) n)) grps)]\n      (disj (set\n        (map (fn [j] (first (filter coll? j)))\n             (filter (fn [n] (= 2 (count (filter #(= p %) n)) )) z ))) nil)))","problem":119,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(letfn [\n    (win [x] (ffirst (filter \n        #(and (apply = %) (not= (first %) :e)) \n        (partition 3 (map \n            (vec (flatten x)) \n            '(0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6))))))\n    (patch [orig h w x] (for [hi [0 1 2]] (for [wi [0 1 2]] \n            (if (= [h w] [hi wi]) x (get-in orig [hi wi])))))\n    (analysis [c orig] (set (for [\n        hi [0 1 2] \n        wi [0 1 2] \n        :when (= :e (get-in orig [hi wi])) \n        :when (win (patch orig hi wi c))] \n        [hi wi])))] \n    analysis)","problem":119,"user":"51cbdee1e4b08d8387cbede1"},{"problem":119,"code":"(fn [p rs]\n  (let [r (range 3)\n        g (fn [s] (= {:e 1 p 2} (frequencies (map #(get-in rs %) s))))]\n    (->> (concat (for [y r x r] [y x])\n                 (for [y r x r] [x y])\n                 (map vector r r)\n                 (map vector r (range 2 -1 -1)))\n         (partition 3) (filter g) (apply concat)\n         (filter (comp #{:e} #(get-in rs %))) set)))","user":"5db0172be4b0f8c104ccfc96"},{"problem":119,"code":"(fn [p b]\n  (let [win? (fn [board]\n               (let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n                     rows (map same? board)\n                     cols (map same? (apply map vector board))\n                     diag1 (same? (map get board [0 1 2]))\n                     diag2 (same? (map get board [2 1 0]))]\n                 (some #{:x :o} (concat rows cols [diag1] [diag2]))))\n        free (for [y (range 3) \n                   x (range 3)\n                   :when (= :e (get-in b [y x]))]\n               [y x])]\n    (set (filter #(= p (win? (assoc-in b % p))) free))))","user":"5c2649c8e4b07e362c2305bf"},{"code":"(fn [p b]\n  (let [who-won (fn problem-73 [b]\n    (->> [(first b) (second b) (last b)\n          (map first b) (map second b) (map last b)\n          (map #((b %) %) (range 3)) (map #((b (- 2 %)) %) (range 3))]\n      (map #(if (apply = %) (first %) :e))\n      (filter (partial not= :e))\n      (first)))\n        won? (fn [c] (= p (who-won (update-in b c #(if (= % :e) p %)))))]\n    (->> [[0 0] [0 1] [0 2]\n          [1 0] [1 1] [1 2]\n          [2 0] [2 1] [2 2]]\n         (filter won?)\n         (set))))","problem":119,"user":"525f51bde4b0cb4875a45dc8"},{"problem":119,"code":"(fn [player board]\n    (letfn [(win? [b]\n              (or (some #(apply = player %) b)\n                  (some #(apply = player %) (partition 3 (apply interleave b)))\n                  (apply = player (map #(get-in b %) (map #(vector % %) (range 3))))\n                  (apply = player (map #(get-in b %) (map #(vector % (- 2 %)) (range 3))))\n                  ))]\n      ; Generate all positions, filter to empty ones, filter to ones leading to a win\n      (->> (for [x (range 3) y (range 3)] [x y])\n           (filter #(= :e (get-in board %)))\n           (filter #(win? (update-in board % (constantly player))))\n           set)))","user":"54f26266e4b024c67c0cf8c5"},{"problem":119,"code":"(fn tic-tac-toe [role board]\n  (letfn [(all-empty? [board] (= (count (filter #(not= % :e) (flatten board))) 0))\n          (lost-role? [board]\n                      (or (= 0 (count (filter #(= % :x) (flatten board))))\n                          (= 0 (count (filter #(= % :o) (flatten board))))))\n          (same-role? [coll] (apply = coll))\n          (horizontal-filter [board]\n                             (let [rows (filter #(same-role? %) board)]\n                               (if (empty? rows)\n                                 nil\n                                 (first (first rows)))))\n          (vertical-filter [board] (horizontal-filter (apply map vector board)))\n          (diagonal-filter [board]\n                           (let [len (count board)\n                                 diag-1 (for [x (range len) y (range len) :when (= x y)] (nth (nth board y) x))\n                                 diag-2 (for [x (range len) y (range len) :when (= (dec len) (+ x y))] (nth (nth board y) x))]\n                             (cond\n                              (same-role? diag-1) (first diag-1)\n                              (same-role? diag-2) (first diag-2)\n                              :else nil)))\n          (tic-tac-win [board]\n                       (cond\n                        (all-empty? board) nil\n                        (lost-role? board) nil\n                        :else (or (horizontal-filter board)\n                                  (vertical-filter board)\n                                  (diagonal-filter board))))\n          (replace-role [board role n m]\n                        (let [len (count board)]\n                          (for [y (range len)]\n                            (for [x (range len)]\n                              (if (and (= x m) (= y n))\n                                role\n                                (nth (nth board y) x))))))]\n    (let [len (count board)]\n      (into #{}\n            (for [x (range len) y (range len)\n                  :when (= (tic-tac-win (replace-role board role x y)) role)]\n              [x y])))))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn [k colls]\n\t(let [check (fn [colls]\n\t\t(let [\n\t\t\tmp (fn [k] (map (fn [coll] (map #(when (= k %) %) coll)) colls))\n\t\t\tcheck \n\t\t\t  (fn [colls] (or\n\t\t\t\t(reduce #(or % %2) (map #(reduce (fn [x y] (and x y)) %) colls))\n\t\t\t\t(reduce #(or % %2) (apply (partial map #(and % %2 %3)) colls))\n\t\t\t\t(and (first (first colls)) (second (second colls)) (last (last colls)))\n\t\t\t\t(and (last (first colls)) (second (second colls)) (first (last colls)))\n\t\t\t\t))]\n\t\t\t(or (check (mp :x)) (check (mp :o)))))]\n\t(reduce \n\t\t#(if (and (= :e (get-in colls %2)) (check (assoc-in colls %2 k))) (conj % %2) %)\n\t\t#{}\n\t\t(for [i (range 3) j (range 3)] [i j]))))","problem":119,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn win [c bs]\n  (let [rows (fn [boards] boards)\n        cols (fn [boards] (apply map vector boards))\n        d1 '(0 1 2)\n        d2 '(2 1 0)\n        diag1 (fn [boards] (vector (map #(%2 %1) d1 boards)))\n        diag2 (fn [boards] (vector (map #(%2 %1) d2 boards)))\n        all\n        (fn [boards]\n          (concat (rows boards) (cols boards) (diag1 boards) (diag2 boards)))\n        win? (fn [boards w]\n              (some (fn [row] (every? #(= w %) row)) (all boards)))\n        pos (fn [boards x y] ((boards y) x))\n        update-xy\n        (fn [boards x y chess]\n          (apply vector (map\n           (fn [yy]\n             (apply vector (map\n              (fn [xx]\n                (if (and (= xx x) (= yy y) (= :e (pos boards xx yy)))\n                  chess\n                  (pos boards xx yy)))\n              (range 3))))\n            (range 3))))\n        ]\n    (set (for [x (range 3) y (range 3) :when (win? (update-xy bs x y c) c)]\n      [y x]))))","problem":119,"user":"4f0e995e535d0136e6c22326"},{"problem":119,"code":"(fn [player board]\n    (letfn [(format [board]\n              (for [i (range (count board))\n                    j (range (count board))]\n                {:value (nth (nth board i) j) :i i :j j :index [i j]}))\n\n            (rows [board]\n              (->> (format board)\n                  (group-by :i)))\n\n            (cols [board]\n              (->> (format board)\n                  (group-by :j)))\n\n            (r-diagonal [board]\n              (->> (format board)\n                  (filter (fn [{:keys [i j]}] (or (= (dec (count board)) (+ i j)))))\n                  (assoc {} :r)))\n\n            (l-diagonal [board]\n              (->> (format board)\n                  (filter (fn [{:keys [i j]}] (= i j)))\n                  (assoc {} :l)))\n\n            (matrix-vector [board ops]\n              (map (fn [f] (f board))\n                  ops))\n\n\n            (get-win-index [player x]\n              (let [g (group-by :value x)]\n                (when (= 2 (count (player g)))\n                  (-> g :e first :index))))\n\n            (win-indexs [player board]\n              (into #{}\n                    (filter (complement nil?)\n                            (map\n                             (fn [matrix-vectors] (get-win-index player matrix-vectors))\n                             (mapcat\n                              (fn [m] (vals m))\n                              (matrix-vector board [rows cols r-diagonal l-diagonal]))))))]\n      (win-indexs player board)))","user":"55c66ffee4b0e31453f649c2"},{"problem":119,"code":"(fn [p [[k _ l] [_ m _] [n _ o] :as b]]\n  (loop [i 0 acc []]\n    (if (<= i 2)\n      (recur (inc i)\n             (loop [j 0 acc acc]\n               (if-let [x (get (get b i) j)]\n                 (recur (inc j)\n                        (if (and (= :e x)\n                                 (let [r [:e p p]]\n                                   (or (= r (sort (b i)))\n                                       (= r (sort (list ((b 0) j)\n                                                        ((b 1) j)\n                                                        ((b 2) j))))\n                                       (if (some {[i j] true}\n                                                 [[0 0] [1 1] [2 2]])\n                                         (= r (sort (list k m o))))\n                                       (if (some {[i j] true}\n                                                 [[0 2] [1 1] [2 0]])\n                                         (= r (sort (list l m n)))) )))\n                          (conj acc [i j])\n                          acc))\n                 acc)))\n      (set acc))))","user":"57035ccfe4b08d47c97781ef"},{"code":"(letfn [\n  (get-other-player [ plr ]\n   (if (= plr :x) :o :x))\n  (win-position [ plr row ]\n   (if (some #{(get-other-player plr)} row) nil\n    (let [ pos (filter\n  \t(complement nil?)\n\t\t(map-indexed #(if (= %2 :e) %1 nil) row)) ]\n     (if (= 1 (count pos)) (first pos) nil))));only return non-nil if unique\n  (get-col [board col]\n   (map #(get-in board [% col]) (range 3)))\n\n  (make-coords [ lst ]\n   (filter second (map-indexed list lst)))\n\n]\n\n(fn win [ plr board ]\n (let [ pos (partial win-position plr)\n        col (partial get-col board) ]\n  (set (filter #(and (first %) (second %))\n   (-> #{}\n    (into (make-coords (map pos board)))\n    (into (map reverse (make-coords (map pos (map col (range 3))))))\n    (into (list (repeat 2 (pos (map #(get-in board [% %]) (range 3))))))\n    (into (if-let [ diag2 (pos (map #(get-in board [(- 2 %) %]) (range 3))) ]\n     (list (list (- 2 diag2) diag2))\n     '()))))\n\n))))","problem":119,"user":"4e356d2b535deb9a81d77f2d"},{"problem":119,"code":"(fn tic-tac-toe [sym coll]\n  (let [linecnt (count coll)\n        bmap (vec (for [i (range linecnt)]\n                    (vec (for [j (range linecnt)] \n                           (hash-map [i j] (nth (nth coll i) j))))))\n        bmp (apply concat bmap)\n        bp  (apply merge bmp)\n        bvmap (apply (partial map vector) bmap)\n        bamap (vector (vec (for [i (range linecnt)] ((bmap i) i))))\n        brmap (vector (vec (for [i (range linecnt)] ((bmap i) (- (dec linecnt) i)))))\n        allmap (concat bmap bvmap bamap brmap)\n        valmap (map (partial apply concat) (map (partial map vals) allmap)) \n        keymap (map (partial apply concat) (map (partial map keys) allmap))\n        cansel (fn [sy col] \n                 (if (and \n                       (= 2 (count (filter #(= sy %) col)))\n                       (= 1 (count (filter #(= :e %) col))))\n                   true\n                   false))\n        selmap (map #(cansel sym %) valmap) \n        locmap (apply concat (filter (comp not nil?) (map #(if (= true %1) %2 nil) selmap allmap)))]\n     (set (filter (comp not nil?) (map #(if (= :e (first (vals %))) (first (keys %)) nil) locmap)))))","user":"5243e37ae4b076204b44fae3"},{"code":"(fn [me board]\n    (let [positions [[[0 0] [0 1] [0 2]]\n                     [[0 0] [1 0] [2 0]]\n                     [[0 0] [1 1] [2 2]]\n                     [[0 1] [1 1] [2 1]]\n                     [[0 2] [1 2] [2 2]]\n                     [[1 0] [1 1] [1 2]]\n                     [[2 0] [2 1] [2 2]]\n                     [[2 0] [1 1] [0 2]]]\n          position-wins? (fn [[i j]]\n                           (let [board (assoc-in board [i j] me)]\n                             (seq\n                               (filter\n                                 identity\n                                 (for [p positions]\n                                   (apply = me (map #(get-in board %) p)))))))\n          winning-boards (for [i (range 3)\n                               j (range 3)\n                               :when (= :e (get-in board [i j]))\n                               :when (position-wins? [i j])]\n                          [i j])]\n      (into #{} winning-boards)))","problem":119,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn [player rows]\r\n  (let [rows (vec (apply concat rows))\r\n        groups [#{0 1 2} #{3 4 5} #{6 7 8}\r\n                #{0 3 6} #{1 4 7} #{2 5 8}\r\n                #{0 4 8} #{2 4 6}]\r\n        neigh (apply merge-with concat \r\n                     (for [i (range 9) \r\n                           g groups :when (g i)]\r\n                           {i [(disj g i)]}))\r\n        wins (set (for [[i g] neigh\r\n                   :when (not (empty?\r\n                       (filter #(and (= (rows i) :e) (#{#{player}} %))\r\n                          (map #(set (map rows %)) g))))]\r\n               [(quot i 3) (mod i 3)]))]\r\n    wins))","problem":119,"user":"509c03f3e4b085ae113522a8"},{"code":"(fn [x-or-o board]\n  (letfn\n    [(new-board [x-or-o board pos]\n       (if (= :e (get-in board pos))\n         (assoc-in board pos x-or-o)\n         board))\n     (analyze-ttt [x]\n       (let [a\n             (map \n               first\n               (filter \n                 #(apply = %)\n                 (concat x\n                         [(mapv first x)]\n                         [(mapv second x)]\n                         [(mapv last x)]\n                         [[(get-in x [0 0]) \n                           (get-in x [1 1]) \n                           (get-in x [2 2])]]\n                         [[(get-in x [0 2]) \n                           (get-in x [1 1]) \n                           (get-in x [2 0])]])))]\n         (cond (some #{:x} a) :x\n               (some #{:o} a) :o\n               :else nil)))\n     (is-win-position? [x-or-o board pos]\n       (= x-or-o\n          (analyze-ttt (new-board x-or-o board pos))))\n     ]\n    (set\n      (for [i [0 1 2]\n            j [0 1 2]\n            :when (is-win-position?\n                    x-or-o\n                    board\n                    [i j])] [i j]))))","problem":119,"user":"529b44afe4b02ebb4ef7509d"},{"problem":119,"code":"(fn win-tic-tac-toe\n  [player tic-tac-toe]\n  (let [analyze-tic-tac-toe (fn [tic-tac-toe]\n                              (let [get-x (fn [n]\n                                            [(nth (nth tic-tac-toe n) n)\n                                             (nth (nth tic-tac-toe n) (- 2 n))])\n                                    tic-lines (apply concat (for [i (range 3)]\n                                                              [(nth tic-tac-toe i)\n                                                               (map #(nth % i) tic-tac-toe)]))\n                                    tic-x (->> (map get-x (range 3))\n                                               ((juxt #(map first %) #(map last %))))]\n                                (some #(and (apply = %)\n                                            (not= :e (first %))\n                                            (first %))\n                                      (concat tic-lines tic-x))))\n        replace-j (fn [j row]\n                    (let [[head tail] (split-at j row)]\n                      (concat head [player] (rest tail))))\n        replace-ij (fn [i j]\n                     (reduce (fn [acc n]\n                               (let [row (nth tic-tac-toe n)]\n                                 (if (and (= i n)\n                                          (= :e (nth row j)))\n                                   (conj acc (replace-j j row))\n                                   (conj acc row))))\n                             [] (range 3)))]\n    (set (remove nil?  (for [i (range 3) j (range 3)]\n                         (when (= player (analyze-tic-tac-toe (replace-ij i j)))\n                           [i j]))))))","user":"4e586949535d8a8b8723a292"},{"problem":119,"code":"(fn tictac [x brd]\n  (let [y (if (= :x x) :o :x)\n        mapE (map-indexed (fn [i n] (map-indexed #(if (= %2 :e) [i %] %2) n)) brd)\n        getf (fn [v] (loop [[fst & rst] v\n                            res nil] \n                       (condp = fst\n                         nil res\n                         y nil\n                         x (recur rst res)\n                         (when (nil? res) (recur rst fst)))))\n        [[a b c] [d e f] [g h i]] mapE\n        all_seq (into mapE [(list a d g) (list b e h) (list c f i) (list a e i) (list c e g)])]    \n    (set (remove nil? (map getf all_seq)))\n    ))","user":"6011b89ee4b074f607df66bc"},{"problem":119,"code":"(fn [player board]\n   (letfn [(analyze [l]\n            (let [pos [[[0 0] [0 1] [0 2]]\n                       [[1 0] [1 1] [1 2]]\n                       [[2 0] [2 1] [2 2]]\n                       [[0 0] [1 0] [2 0]]\n                       [[0 1] [1 1] [2 1]]\n                       [[0 2] [1 2] [2 2]]\n                       [[0 0] [1 1] [2 2]]\n                       [[2 0] [1 1] [0 2]] ]]\n              (cond\n               (some #(every? identity (map (fn [[x y]] (= :x (nth (nth l x) y ))) %)) pos) :x\n               (some #(every? identity (map (fn [[x y]] (= :o (nth (nth l x) y ))) %)) pos) :o)))]\n       (set (for [x (range 3) y (range 3)\n                  :when (and (= :e (nth (nth board x) y))\n                             (= player (analyze (assoc board x (assoc (nth board x) y player)))) )] [x y]))\n     )\n   )","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [W k b]\n  (let [ws (for [r (range 3) c (range 3)]\n             (if (and (= (get-in b [r c]) :e)\n                      (W (assoc-in b [r c] k)))\n               [r c] nil))]\n    (set (remove nil? ws))))\n(fn [b]\n  (let [c (partition 3 (apply interleave b))\n        d-f #(map nth % (range))\n        s (concat b c [(d-f b) (d-f (map reverse b))])]\n    (ffirst (filter #{#{:x} #{:o}} (map set s)))))","problem":119,"user":"504e04a4e4b078edc5f59397"},{"problem":119,"code":"(fn wttt [p b]\n   (letfn [(attt [b] \n               (let [r (map set (concat b (apply map vector b) (list (map-indexed #(%2 %1) b)) (list (map-indexed #(%2 %1) (reverse b)))))]\n                  (ffirst (not-empty (filter #{#{:o} #{:x}} r)))))]\n         (set (for [i (range (count b)) j (range (count (b 0)))\n                    :when (and (= :e (get-in b [i j])) (= p (attt (assoc-in b [i j] p))))]\n                  \t\t[i j]))))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn ttt [p b]\n  (let [d (for [x [-1 0 1] y [-1 0 1] :when (not= 0 x y)] [x y])\n        n (fn [[sx sy]] [(- sx) (- sy)])\n        a (fn [[x y] [sx sy]] [(+ x sx) (+ y sy)])\n        f (fn [xy s c]\n            (if (= (get-in b xy) p)\n              (recur (a xy s) s (inc c))\n              c))\n        t (fn [xy s]\n            (if (= (get-in b xy) :e)\n              (if (= p (get-in b (a xy s)) (get-in b (a xy (n s))))\n                3\n                (f (a s xy) s 1))\n              0))\n        r (for [x (range 3) y (range 3)]\n            (let [a (apply max (map #(t [x y] %) d))]\n              (if (= a 3)\n                [x y]\n                nil)))]\n    (into #{} (remove nil? r))))","problem":119,"user":"4e7db3b4535db169f9c796e1"},{"code":"(fn [piece board]\n  (letfn [(empty-cell? [cell] (= :e (key (first cell))))\n          (win [b piece]\n            (some identity\n                  (let [s (apply + (map #(or (piece %) 0) b))]\n                    (for [mask [7 56 448 73 146 292 273 84]]\n                      (when (= mask (bit-and mask s)) piece)))))\n          (decode [pos] (loop [pos pos, n 0]\n                          (let [next (bit-shift-right pos 1)]\n                            (if (zero? next) n (recur next (inc n))))))]\n    (let [b (set (map-indexed (fn [i x] {x (bit-shift-left 1 i)}) (flatten board)))]\n      (set (filter (complement nil?)\n        (for [cell (filter empty-cell? b)]\n          (let [pos (val (first cell))\n                b (conj (disj b cell) {piece pos})]\n            (when (win b piece)\n              (let [n (decode pos)]\n                [(quot n 3) (rem n 3)])))))))))","problem":119,"user":"50d93c53e4b0fd36a4b89223"},{"problem":119,"code":"(fn [p board]\n  (letfn [(won? [k rows] (or (some #{[k k k]} rows)\n                             (some #{[k k k]} (apply map vector rows))\n                             (= (map #(% %2) rows [0 1 2]) [k k k])\n                             (= (map #(% %2) rows [2 1 0]) [k k k])))]\n    (set (for [r [0 1 2] c [0 1 2]\n               :when (and (= (get-in board [r c]) :e)\n                          (won? p (assoc-in board [r c] p)))]\n           [r c]))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn [x b]\n  (let [gb (fn [x]\n             (->> (for [i (range (count x)) j (range (count (first x)))] [i j]) (group-by #(get-in x %))))\n        tt (fn [x]\n             (let [pos\n                   (concat x (apply (partial map vector) x)\n                     (map (fn diag [m] (reduce #(conj %1 (%2 (count %1))) [] m)) [x (reverse x)]))]\n               (->> pos (filter (partial apply =)) (map first) (filter #{:x, :o}) (first))\n               ))\n        x0 (gb b)]\n    (into #{} (filter #(tt (assoc-in b % x)) (:e x0)))))","problem":119,"user":"528e64b7e4b0239c8a67aedd"},{"problem":119,"code":"(fn [player board]\n  (let [mark (fn [board pos]\n               (get-in board pos))\n        win (repeat 3 player)\n        win? (fn [board]\n                (some #(= win (map (partial mark board) %))\n                      [[[0 0] [0 1] [0 2]]\n                       [[1 0] [1 1] [1 2]]\n                       [[2 0] [2 1] [2 2]]\n                       [[0 0] [1 0] [2 0]]\n                       [[0 1] [1 1] [2 1]]\n                       [[0 2] [1 2] [2 2]]\n                       [[0 0] [1 1] [2 2]]\n                       [[0 2] [1 1] [2 0]]]))]\n    (set (for [row (range 3) col (range 3)\n               :when (and\n                      (= :e (mark board [row col]))\n                      (win? (assoc-in board [row col] player)))]\n           [row col]))))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [piece board]\n  (let [winners #{#{[0 0] [0 1] [0 2]} #{[1 0] [1 1] [1 2]} #{[2 0] [2 1] [2 2]}\n                  #{[0 0] [1 0] [2 0]} #{[0 1] [1 1] [2 1]} #{[0 2] [1 2] [2 2]}\n                  #{[0 0] [1 1] [2 2]} #{[2 0] [1 1] [0 2]}}]\n    (letfn [(placements [board piece]\n              (for [x [0 1 2] y [0 1 2] :when (= piece (get-in board [y x]))] [y x]))]\n      (let [empty-spots (placements board :e)\n            piece-spots (set (placements board piece))]\n        (set (for [x empty-spots w winners\n                   :let [pieces (into piece-spots [x])]\n                   :when (every? pieces w)]\n               x))))))","problem":119,"user":"4ea365e2535d7eef308072c5"},{"problem":119,"code":"(fn __ [player board]\n  (letfn [\n          (win? [three] (or (= [:x :x :x] three)\n                                 (= [:o :o :o] three)))\n\n          (wins? [board]\n            (not (empty? (filter true? (map #(win? %)(threes board)) ))))\n\n\n          (at [board [x y]] (get (get board x) y))\n          (three [board p1 p2 p3] [(at board p1)(at board p2) (at board p3)])\n          (threes [board] (conj board\n                                     (three board [0 0] [1 1] [2 2])\n                                     (three board [2 0] [1 1] [0 2])\n                                     (three board [0 0] [1 0] [2 0])\n                                     (three board [0 1] [1 1] [2 1])\n                                     (three board [0 2] [1 2] [2 2])))\n          (free [board]\n            (into [] (for [x (range 3) y (range 3)\n                           :when (= (at board [x y]):e)] [x y])))\n          (updatev [m k f]\n                   (assoc m k (f (get m k))))\n          (place [player pt board]\n            (updatev board\n                    (first pt)\n                    (fn [three]\n                      (updatev three (last pt) (fn [old] player)))))\n\n\n\n\n          ]\n    (set (filter #(wins? (place player % board)) (free board)))))","user":"5e078ba7e4b0978307768fb6"},{"problem":119,"code":"(fn tic-tac-toe-win\n  [player board]\n  (let [possible-wins (concat\n                       (mapcat #(conj []\n                                      (mapv (fn [n] [%1 n]) (range 3)) ;; horizontal wins\n                                      (mapv (fn [n] [n %1]) (range 3)) ;; vertical wins\n                                      ) (range 3))\n                       [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]] ;; diagonal wins\n                       )\n        {wins 2} (group-by (fn [possible-win]\n                              (reduce #(if (= player (get-in board %2))\n                                         (inc %1)\n                                         %1)\n                                      0 possible-win)) possible-wins)]\n    (->> wins\n         (apply concat)\n         (filter #(= :e (get-in board %)))\n         set)))","user":"5125029de4b0ce9225d2ed3e"},{"problem":119,"code":"(fn [chess board]\n  (letfn [(get-safe [x y c] (nth (nth board x nil) y c))\n          (get-by-offset [x y offsets default]\n            (every? (partial = default)\n                    (map #(get-safe (+ x (first %))\n                                    (+ y (second %))\n                                    default)\n                         offsets)))]\n    (->>\n     (for [i (range 3)\n           j (range 3)]\n       (when (and (= :e (get-safe i j :e))\n                  (or (get-by-offset i j [[-2 0] [-1 0] [1 0] [2 0]] chess)\n                      (get-by-offset i j [[0 -2] [0 -1] [0 1] [0 2]] chess)\n                      (and (#{[0 0] [1 1] [2 2]} [i j])\n                           (get-by-offset i j [[-2 -2] [-1 -1] [1 1] [2 2]] chess))\n                      (and (#{[0 2] [1 1] [2 0]} [i j])\n                           (get-by-offset i j [[-2 2] [-1 1] [1 -1] [2 -2]] chess))))\n         [i j]))\n     (keep identity)\n     set)))","user":"60096aabe4b074f607df667f"},{"problem":119,"code":"(fn get-winning-coords [piece board]\n  (let [all-coords (for [x (range 3)\n                         y (range 3)] \n                      [x y])\n        empty-coords (filter #(= :e (get-in board %)) all-coords)\n        used-coords (filter #(= piece (get-in board %)) all-coords)\n        winning-configuration (fn [config] \n                                (or\n                                  (some \n                                    #(= 3 (count (val %))) \n                                    (group-by first config))\n                                  (some\n                                    #(= 3 (count (val %)))\n                                    (group-by last config))\n                                  (= 3 (count (clojure.set/intersection (set config) #{[0 0] [1 1] [2 2]})))\n                                  (= 3 (count (clojure.set/intersection (set config) #{[0 2] [1 1] [2 0]})))\n                                ))]\n    (set (filter #(winning-configuration (conj used-coords %)) empty-coords))))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":119,"code":"(let [winner-from\n      (fn winner-from\n        [three]\n        (if (every? #(= :o %) three) :o\n            (if (every? #(= :x %) three) :x nil)))\n      winner-from-many\n      (fn winner-from-many\n        [many]\n        (reduce (fn [accum next] (if (nil? next) accum next))\n                (map winner-from many)))\n      rows (fn rows [board] board)\n      cols (fn cols [board] [(map #(nth % 0) board)\n                             (map #(nth % 1) board)\n                             (map #(nth % 2) board)])\n      digs (fn digs [board] [[(nth (nth board 0) 0)\n                              (nth (nth board 1) 1)\n                              (nth (nth board 2) 2)]\n                             [(nth (nth board 0) 2)\n                              (nth (nth board 1) 1)\n                              (nth (nth board 2) 0)]])]\n  (let [tic-tac-toe-winner\n        (fn [board]\n          (winner-from-many (concat (rows board)\n                                    (cols board)\n                                    (digs board))))]\n    (let [positions\n          (map (fn [x] (map (fn [y] [x y])\n                            (range 3)))\n               (range 3))]\n      (fn win-tic-tac-toe-with\n        [piece board]\n        (let [raw (map (fn [position]\n                         [position (tic-tac-toe-winner (update-in board position\n                                                                  (fn [x] (if (= :e x) piece x))))])\n                       (apply concat positions))]\n          (into #{} (map (fn [[p winner]] p) \n                         (filter (fn [[p winner]] (not (nil? winner)))\n                                 raw))))))))","user":"58152157e4b0f478707a0631"},{"code":"(letfn\n    [(->board [rows]\n       (let [a (to-array-2d rows)]\n         (for [x (range 3)\n               y (range 3)]\n           [[x y] (aget a x y)])))\n\n     (board->paths [board]\n       (let [hz (partition 3 3 board)\n             vs (apply map vector hz)\n             dd (map #(nth board %) [0 4 8])\n             ud (map #(nth board %) [2 4 6])]\n         (concat hz vs [dd] [ud])))\n\n     (can-win? [player path]\n       (let [a (group-by second path)\n             p (a player)]\n         (when (= 2 (count p))\n           (ffirst (:e a)))))]\n\n  (fn anal-tic [player rows]\n    (->> (->board rows)\n         (board->paths)\n         (keep #(can-win? player %))\n         (set))))","problem":119,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":119,"code":"(fn [player board]\n    (let [player_wins (fn [b]\n                        (cond (and (apply = (first b)) (not (= :e (first (first b))))) (first (first b))\n                              (and (apply = (second b)) (not (= :e (first (second b))))) (first (second b))\n                              (and (apply = (last b)) (not (= :e (first (last b))))) (first (last b))\n                              (and (apply = (map first b)) (not (= :e (first (first b))))) (first (first b))\n                              (and (apply = (map second b)) (not (= :e (second (first b))))) (second (first b))\n                              (and (apply = (map last b)) (not (= :e (last (first b))))) (last (first b))\n                              (and (= (first (first b)) (second (second b)) (last (last b)))\n                                   (not (= :e (first (first b))))) (first (first b))\n                              (and (= (last (first b)) (second (second b)) (first (last b)))\n                                   (not (= :e (last (first b))))) (last (first b))\n                              :else nil))\n          update (fn [m k f]\n                   (assoc m k (f (get m k))))\n          update_board (fn [player board r c]\n                         (let [row (get board r)]\n                           (if (= :e (get row c))\n                             (update board r (fn [x] (update row c (fn [v] player))))    \n                             board)))\n          is_win_at? (fn [player board r c]\n                       (if (player_wins (update_board player board r c))\n                         #{[r c]}\n                         #{}))]\n      (apply clojure.set/union (map (fn [[r c]] (is_win_at? player board r c)) [[0 0] [0 1] [0 2]\n                                                                                [1 0] [1 1] [1 2]\n                                                                                [2 0] [2 1] [2 2]]))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn [piece bd]\n  (let [winner\n    (fn [board]\n      (let [\n        unfn (fn [b] (filter #(= 1 (count %)) (map distinct b)))\n        rows (unfn board)\n        cols (unfn (apply map list board))\n        crss (unfn [(map get board [0 1 2]) (map get board [2 1 0])])]\n      (some #{:x :o} (flatten [rows cols crss]))))]\n(set\n  (filter #(not (nil? %))\n    (for [row (range 3) col (range 3)]\n      (if (and (= :e (get-in bd [row col])) (= piece (winner (assoc-in bd [row col] piece))))\n        [row col]))))))","problem":119,"user":"4dfe65a1535d04ed9115e787"},{"code":"(fn [p ttt]\n  (letfn\n\t\t[\n\t\t\t(win? [ttt]\n\t\t\t\t(ffirst\n\t\t\t\t\t(filter \n\t\t\t\t\t\t#(and (= 1 (count %)) (not= :e (first %)))\n\t\t\t\t\t\t(map\n\t\t\t\t\t\t\tset\n\t\t\t\t\t\t\t(conj\n\t\t\t\t\t\t\t\tttt\n\t\t\t\t\t\t\t\t(map first ttt)\n\t\t\t\t\t\t\t\t(map second ttt)\n\t\t\t\t\t\t\t\t(map last ttt)\n\t\t\t\t\t\t\t\t(map-indexed #(%2 %1) ttt)\n\t\t\t\t\t\t\t\t(map-indexed #(%2 (- 2 %1)) ttt)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(empty-cells [ttt]\n\t\t\t\t(apply concat\n\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t(fn [i row]\n\t\t\t\t\t\t\t(filter\n\t\t\t\t\t\t\t\tidentity\n\t\t\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t\t\t(fn [j cell]\n\t\t\t\t\t\t\t\t\t\t(if (= :e cell)\n\t\t\t\t\t\t\t\t\t\t\t[i j]\n\t\t\t\t\t\t\t\t\t\t\tnil\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\trow\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tttt\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(replace-indexed [i v xs] (map-indexed (fn [j x] (if (= i j) v x)) xs))\n\t\t\t(make-move [[i j] p ttt] (replace-indexed i (apply vector (replace-indexed j p (ttt i))) ttt))\n\t\t]\n\t\t(set\n\t\t\t(filter\n\t\t\t\t#(win? (make-move % p ttt))\n\t\t\t\t(empty-cells ttt)\n\t\t\t)\n\t\t)\n\t)\n)","problem":119,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn f [p b]\n  (let [i (fn [b]\n            (some {(repeat 3 p) p}\n              (concat b (partition 3 (apply interleave b))\n                        (for [i [[0 4 8][2 4 6]]]\n                          (map #(nth (flatten b) %) i)))))]\n    (set\n      (for [j (range 3)\n            k (range 3)\n            :let [e (-> b (get j) (get k))]\n            :when (if (= :e e)\n                    (i (assoc-in b [j k] p)))]\n        [j k]))))","problem":119,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn tictactoe [player board] (\n      let\n        [ \n        starting-board (apply hash-map(interleave (range)(flatten board))) \n        playable (keys (filter #(= :e (val %)) starting-board ))\n        move (fn [index] (assoc-in starting-board  [index] player))\n        rows (partition 3 (range 10))\n        cols (apply map list rows) \n        diags '((0 4 8)(2 4 6))\n        winposition (flatten(concat rows cols diags))\n        winvalues (fn [current-board ] (partition 3 (map #(get current-board  %) winposition)))\n        haswin (fn [current-board] (seq (filter #(= (repeat 3 player) %) (winvalues current-board))))\n        good-move (fn [index] (haswin (move index)))\n        to-coord (fn [index] (vector  (quot index 3) (rem index 3)))\n          ]\n          (set(map to-coord (filter #(good-move %) playable))\n        )\n   ))","problem":119,"user":"5307e4ece4b02e82168697a9"},{"problem":119,"code":"(fn __ [p board]\n  (letfn [(ckrow [brd]\n            (some identity\n                  (map\n                   #(cond\n                     (some (partial = :e) %) nil\n                     (apply = %) (first %)\n                     :else nil)\n                   brd)))\n          (ckcol [brd]\n            (ckrow\n             (let [[r0 r1 r2] brd]\n               (map conj (map conj (map list r0) r1) r2))))\n          (ckdia [brd]\n            (ckrow\n             (let [[r0 r1 r2] brd]\n               [[(nth r0 0) (nth r1 1) (nth r2 2)]\n                [(nth r2 0) (nth r1 1) (nth r0 2)]] )))\n          (win? [brd]\n            (some boolean [(ckrow brd) (ckcol brd) (ckdia brd)]))]\n    (set\n     (for [r (range 0 3)\n           c (range 0 3)\n           :when (and (= :e (get-in board [r c]))\n                      (win? (update-in board [r c] #(identity %2) p)))]\n       [r c])\n     )))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn [k board]\n  (letfn \n    [(row [r] (let [s (set r)] (if (and (= 1 (count s)) (not (= :e (first s)))) (first s) false)))\n     (get-col [board] (apply map vector board))\n     (get-cross [board] \n                (let [ct (count (first board))] \n                  (loop [c 0 b board x1 [] x2 []] \n                    (if (empty? b) \n                      [x1 x2] \n                      (recur (+ c 1) (rest b) (conj x1 (nth (first b) c)) (conj x2 (nth (first b) (- ct c 1))))))))\n     (one-more [t r] \n               (if \n                 (and (= #{t :e} (set r)) (= 1 (count (filter #(= % :e) r)))) \n                 (reduce + (map * (range 3) (map #(if (= % :e) 1 0) r)))\n                 false))\n     ]\n    (set (filter (complement nil?) (map #(if ((complement false?) %2) (replace {:k %2 :m (- 2 %2)} %1)) \n                            [[0 :k] [1 :k] [2 :k] [:k 0] [:k 1] [:k 2] [:k :k] [:k :m]] \n                            (map #(one-more k %) (mapcat #(% board) [identity get-col get-cross])))))))","problem":119,"user":"52b43468e4b0c58976d9ad1b"},{"problem":119,"code":"(letfn\n      [(won? [[a b c]]\n         (and (= a b c) (#{:x :o} a)))\n       (winner [[[r1c1 r1c2 r1c3 :as r1]\n                 [r2c1 r2c2 r2c3 :as r2]\n                 [r3c1 r3c2 r3c3 :as r3] :as rows]]\n         (let [c1 (map #(% 0) rows)\n               c2 (map #(% 1) rows)\n               c3 (map #(% 2) rows)\n               d1 [r1c1 r2c2 r3c3]\n               d2 [r3c1 r2c2 r1c3]\n               ]\n           (some won? [r1 r2 r3 c1 c2 c3 d1 d2])))\n       (empty-slots [board]\n         (for [i [0 1 2]\n               j [0 1 2]\n               :when (#{:e} (get-in board [i j]))]\n           [i j]))]\n      (fn [piece board]\n        (set\n          (for [slot (empty-slots board)\n                   :when (#{piece} (winner (assoc-in board slot piece)))]\n               slot))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn winning-moves [piece board]\r\n  (let\r\n    [_ (println \"piece\" piece)\r\n     _ (println \"board\" board)\r\n     tic-tac-toe (fn tic-tac-toe [board]\r\n                  (let\r\n                    [[top-row mid-row bot-row] board\r\n                     [left-col mid-col right-col] \r\n                        (map (fn [col] (map (fn [row-vec] (row-vec col)) board)) (range 3))\r\n                     left-diag [ (get top-row 0) (get mid-row 1) (get bot-row 2)]\r\n                     right-diag [ (get top-row 2) (get mid-row 1) (get bot-row 0) ]\r\n                     all-streaks [top-row mid-row bot-row \r\n                                  left-col mid-col right-col\r\n                                  left-diag right-diag]\r\n                     winner? (fn [streak] \r\n                               (cond \r\n                                 (every? #(= % :x) streak) :x\r\n                                 (every? #(= % :o) streak) :o))\r\n                     winners (filter #(not (nil? %)) (map winner? all-streaks))]\r\n                     (if (seq winners)\r\n                        (first winners))))\r\n     all-moves (for [i (range 3) j (range 3)] [i j])\r\n     _ (println \"all moves\" all-moves)\r\n     valid-moves (filter #(= :e (get-in board %)) all-moves)\r\n     _ (println \"valid-moves\" valid-moves)\r\n     winning-moves (filter \r\n                      #(let\r\n                           [new-board (assoc-in board % piece)\r\n                            new-winner (tic-tac-toe new-board)]\r\n                            (= piece new-winner)) valid-moves)]\r\n    (set winning-moves)))","problem":119,"user":"4f036fb3535dcb61093f6ac8"},{"problem":119,"code":";; http://www.4clojure.com/problem/119\n;; Win at tic-tac-toe\n(fn win-tic-tac-toe\n  [player board]\n  (letfn [(has-won-row1 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r11 r12 r13))\n          (has-won-row2 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r21 r22 r23))\n          (has-won-row3 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r31 r32 r33))\n          (has-won-col1 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r11 r21 r31))\n          (has-won-col2 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r12 r22 r32))\n          (has-won-col3 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r13 r23 r33))\n          (has-won-cross1 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r11 r22 r33))\n          (has-won-cross2 [s [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]] (= s r13 r22 r31))\n          (has-won [s b]\n            (or (has-won-row1 s b) (has-won-row2 s b) (has-won-row3 s b)\n                (has-won-col1 s b) (has-won-col2 s b) (has-won-col3 s b)\n                (has-won-cross1 s b) (has-won-cross2 s b)))\n          (get-symbol-at [[y x]]\n            (nth (nth board y) x))\n          (replace-symbol-at [coord new-s]\n            (vec (for [x (range 3)]\n                   (vec (for [y (range 3)] (if (and (= coord [x y]) (= :e (get-symbol-at [x y]))) new-s (get-symbol-at [x y])))))))]\n    ;;(replace-symbol-at [0 1] :P)\n    (set  (map #(:coord %) (filter #(:won %)\n                                   (map #(hash-map :coord % \n                                                   :symbol (get-symbol-at %) \n                                                   :won (has-won player (replace-symbol-at % player))) (for [x (range 3)\n                                                                                                             y (range 3)]\n                                                                                                         [x y])))))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn [p B]\n  (set\n   (for [a [0 1 2]\n         b [0 1 2]\n         :when (and (= :e (get-in B [a b]))\n                    ((fn [[[a b c] [d e f] [g h i]]]\n                       (#(or (% a b c) (% d e f) (% g h i)\n                             (% a d g) (% b e h) (% c f i)\n                             (% a e i) (% g e c))\n                        #(= p %1 %2 %3)))\n                     (assoc-in B [a b] p)))]\n     [a b])))","problem":119,"user":"4e5fe31a535d8ccf87e9fe50"},{"code":"(fn [p board]\n  (letfn [(at [x y board] (nth (nth board y) x))\n          (rp [x y]\n            (map-indexed\n             (fn [j a]\n               (if (= j y)\n                 (map-indexed (fn [i b] (if (= i x) p b)) (nth board j))\n                 (nth board j)))\n             board))\n          (eq [r] (and (apply = r) (= p (first r))))\n          (ok? [bd]\n            (some\n             identity\n             (concat\n              (map eq bd)\n              (apply map #(eq %&) bd)\n              [(eq [(at 0 0 bd) (at 1 1 bd) (at 2 2 bd)])\n               (eq [(at 2 0 bd) (at 1 1 bd) (at 0 2 bd)])])))]\n    (set\n     (for [x (range 3) y (range 3) :when (and (= :e (at x y board)) (ok? (rp x y)))]\n       [y x]))))","problem":119,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(fn [win? p g]\n  (set\n  \t(filter #(win? p (assoc-in g % p))\n   \t\t(filter #(= (get-in g %) :e) (for [i (range 3) j (range 3)] [i j])))))\n(fn [p g]\n  (some #(= (repeat 3 p) %)\n        (into g (map #(map nth g %)\n                     [[0 1 2] [2 1 0] [0 0 0] [1 1 1] [2 2 2]]))))","problem":119,"user":"519ef784e4b087743fad2198"},{"code":"(fn [p brd]\n  (let [brd (map (fn [rb r] (map (fn [ib c] [ib r c]) rb (range))) brd (range))\n        diag #(mapcat (fn [r c] [(nth r c)]) % (range))\n        data (concat brd (apply map vector brd) [(diag brd) (diag (reverse brd))])]\n    (reduce\n      (fn [s r]\n        (if (= 2 (count (filter #(= (first %) p) r)))\n          (reduce \n            #(if (= :e (first %2)) (conj %1 (vec (rest %2))) %1)\n            s r)\n          s))\n      #{} data)))","problem":119,"user":"528652fbe4b0239c8a67ae14"},{"problem":119,"code":"(fn [sym board] \n   (->> (for [r (range 3)\n              c (range 3)\n              :let [row (fn [coords] (nth board (first coords)))\n                    column (fn [coords] (nth (apply map list board) (last coords)))\n                    dia1 (fn [coords] (let [d1 #{[0 0] [1 1] [2 2]}] (if (contains? d1 coords) (map (partial get-in board) d1) [])))\n                    dia2 (fn [coords] (let [d2 #{[2 0] [1 1] [0 2]}] (if (contains? d2 coords) (map (partial get-in board) d2) [])))\n                    funcs #{row column dia1 dia2}\n                    winnable? #(= 2 (count (filter (partial = sym) %)))\n                    check-all-funcs (remove (partial = false) (map #(winnable? (% [r c])) funcs))]\n              :when (= :e (get-in board [r c]))\n              :when ((complement empty?) check-all-funcs)]\n          [r c])\n        set))","user":"54db3d82e4b024c67c0cf75f"},{"problem":119,"code":"(let \n  [w (fn [A]\n        (->> [0 1 2 [0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n             (map \n                (fn [a] (if (coll? a) (map #(%1 %2) A a) (A a))))\n             (filter (partial apply =))\n             (filter #(not= (last %) :e))\n             (last)\n             (#(and % (last %)))\n                     \n         ))\n       ]\n  (fn [x B]\n        (let [v (vec (apply concat B))]\n           (->> v\n             (keep-indexed #(if (= %2 :e) %1))\n             (map #(vector (assoc v % x) [(quot % 3) (mod % 3)]))\n             (filter #(w (vec (map vec (partition 3 (first %))))))\n             (map second)\n             (into #{})))))","user":"559c13c5e4b066d22e731f61"},{"problem":119,"code":"(fn  win-tic-tac-toe [sym board]\n  (letfn [(win? [b]\n            (->> (concat\n                   b\n                   (apply map vector b)\n                   [(map #(get-in b %) [[0 0] [1 1] [2 2]])]\n                   [(map #(get-in b %) [[0 2] [1 1] [2 0]])])\n                 (some #(= % [sym sym sym]))))]\n    (->> (for [y (range 0 3)\n               x (range 0 3)\n               :when (= (get-in board [y x]) :e)\n               :when (win? (assoc-in board [y x] sym))]\n           [y x])\n         (set))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [ p b]\n  (letfn [ (tic-tac-toe [ [[ a1 a2 a3] [b1 b2 b3] [c1 c2 c3]] ]\n  (let [ rows [ [ a1 a2 a3] [b1 b2 b3] [c1 c2 c3] \n                [ a1 b1 c1] [a2 b2 c2] [a3 b3 c3]\n                [ a1 b2 c3] [a3 b2 c1] ] \n         three-in-a-row  (set (map first (filter #(apply = %) rows))) ] \n    (cond\n      (contains? three-in-a-row :x) :x\n      (contains? three-in-a-row :o) :o\n      :else nil\n      )))  ]\n  (set (filter identity \n    (for [ x '(0 1 2) y '(0 1 2) ] \n    (if (and (= :e (get-in b [x y] ))\n             (= p (tic-tac-toe (assoc-in b [x y] p)) )) [x y] ))))))","problem":119,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn winning-moves [piece board]\n  (let [lines #{#{[0 0] [0 1] [0 2]}\n                #{[1 0] [1 1] [1 2]}\n                #{[2 0] [2 1] [2 2]}\n                #{[0 0] [1 0] [2 0]} \n                #{[0 1] [1 1] [2 1]} \n                #{[0 2] [1 2] [2 2]}\n                #{[0 0] [1 1] [2 2]} \n                #{[0 2] [1 1] [2 0]}}\n        occupied-cells (fn [piece board]\n                         (set\n                           (for [row (range 3) \n                                 column (range 3)\n                                 :when (= piece (get-in board [row column]))]\n                             [row column])))\n        contains-line? (fn [cells]\n                         (loop [l lines]\n                           (cond\n                             (empty? l) false\n                             (clojure.set/subset? (first l) cells) true\n                             :else (recur (rest l)))))\n        pieces-cells (occupied-cells piece board)\n        empty-cells (occupied-cells :e board)]\n    (set (filter #(contains-line? (conj pieces-cells %)) empty-cells))))","problem":119,"user":"53513d28e4b084c2834f4ae3"},{"problem":119,"code":"(fn [piece board]\n  (let [b (apply vector  (map-indexed\n                          (fn [i row]\n                            (apply vector  (map-indexed #(vector %2 [i %1])\n                                                        row)))\n                          board))\n        vert (apply map list b)\n        diag (fn [idxs]\n               (map #(get-in b %)\n                    idxs))\n        diag1 (diag [[0 0] [1 1] [2 2]])\n        diag2 (diag [[0 2] [1 1] [2 0]])\n        win-row? #(= 2 (get (frequencies (map first %)) piece))\n        e-idx (fn [row] (some #(when (= :e (first %)) (last %)) row))\n        win-idx (fn [row]\n                  (when (win-row? row)\n                    (e-idx row)))\n        win-idxs #(keep win-idx %)]\n    (set (remove nil? (mapcat win-idxs [b vert [diag1 diag2]])))))","user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn q119 [p b]\n  (letfn [\n     (check-win [board] ;q73\n  \t\t  (letfn [\n\t\t\t    (check-line [code line] (every? #(= code %) line))\n\t\t\t    (check-hori [code board] (some identity (map #(check-line code %) board)))\n\t\t\t    (transpose [board] (apply map vector board))\n\t\t\t    (diagonal [board] [[(ffirst board) (second (second board)) (last (last board))]])\n\t\t\t    (check [code board]\n\t\t\t      (or\n\t\t\t        (check-hori code board)\n\t\t\t        (check-hori code (transpose board))\n\t\t\t        (check-hori code (diagonal board))\n\t\t\t        (check-hori code (diagonal (map #(apply vector (reverse %)) board)))))]\n\t\t\t    (cond (check :o board) :o \n\t\t\t          (check :x board) :x\n\t\t\t          :else nil)))]\n    (->> (for [r (range 3) c (range 3)] [r c]) ;; all cases\n         (filter #(= :e (get-in b %)))\n         (filter #(= p (check-win (assoc-in b % p))))\n         set)))","problem":119,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [player board]\n  (let [vboard (apply concat board)\n        s (range 0 3)\n        positions (mapcat #(map (fn [x] [% x]) s) s)\n        rows (partition 3 positions)\n        columns [(map first rows) (map second rows) (map #(nth % 2) rows)]\n        wins (map set (concat rows columns ['([0 0] [1 1] [2 2]) '([0 2] [1 1] [2 0])]))\n        piece-positions (zipmap positions vboard)\n        [player-positions empty-positions] (map set (map (fn [x] (map first (filter #(= (val %) x) piece-positions))) [player :e]))\n        ]\n   (set \n    (filter #(-> % nil? not) (map #(if (some\n                (fn [w] \n                  (clojure.set/subset? w (conj player-positions %)))\n                wins)\n            %)\n         empty-positions)))))","problem":119,"user":"4ea7999e535d7eef308072ee"},{"code":"(fn tic-tac [who grid]\n  (let [hmap (apply merge-with into (for [[x row] (map-indexed vector grid)\n                                          [y val] (map-indexed vector row)]\n                                      {val #{[x y]}}))\n        win [#{[0 0] [1 0] [2 0]} #{[0 1] [1 1] [2 1]} #{[0 2] [1 2] [2 2]} #{[0 0] [1 1] [2 2]}\n             #{[0 0] [0 1] [0 2]} #{[1 0] [1 1] [1 2]} #{[2 0] [2 1] [2 2]} #{[0 2] [1 1] [2 0]}]]\n    (reduce (fn [st es] \n              (if (some #(= 3 (count (filter % (conj (hmap who) es)))) win) (conj st es) st))\n            #{} (hmap :e))))","problem":119,"user":"50645e12e4b007509339a58a"},{"code":"(fn get-win-tictac [xo bf]\n    (letfn [(tictac [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]\n                (letfn [(line? [x y z] (and (not= :e x) (= x y z)))]\n                    (cond\n                        (line? a1 a2 a3) a1\n                        (line? b1 b2 b3) b1\n                        (line? c1 c2 c3) c1\n                        (line? a1 b1 c1) a1\n                        (line? a2 b2 c2) a2\n                        (line? a3 b3 c3) a3\n                        (line? a1 b2 c3) a1\n                        (line? a3 b2 c1) a3\n                        :else nil)))]\n        (set\n            (remove nil?\n                (for [i (range 3) j (range 3)\n                      :when (= :e ((bf i) j))\n                      :let [nbf (assoc bf i (assoc (bf i) j xo))]]\n                    (if (tictac nbf) [i j]))))))","problem":119,"user":"4f128865535d64f603146428"},{"problem":119,"code":"(fn prob115\n  [player board]\n\n  (letfn [\n          (open-positions\n            ;; For a given board get all the open positions [r c]\n            ;; Return the row column pairs [r c] for the positions that contain an empty (:e)\n            [board]\n            (for [r (range 3)\n                  c (range 3)\n                  :when (= (get-in board [r c]) :e)]\n              [r c]))\n          \n          ;; For each try setting the position in the board for the player\n          ;; and evaluate the board to see if the player has won\n          (row [m n] (nth m n))\n          (rows [m]  (map #(row m %) (range 3)))\n          (col [m n] (vec (map #(nth % n) m)))\n          (cols [m]  (map #(col m %) (range 3)))\n          (diags [m] \n            (list [(last (col m 0)) (second (col m 1)) (first (col m 2))]\n                  [(first (col m 0)) (second (col m 1)) (last (col m 2))]))\n          \n          (get-all-tuples\n            ;; Return all the columns, rows and diagonals from a given board\n            [board]\n            (concat (rows board) (cols board) (diags board)))\n          \n          (solved-tuple\n            ;; Return true if the position contains all three positions for the player\n            [player position]\n            (= 3 (count (filter #(= player %) position))))\n          \n          (solved-board\n            ;; Return true if the board has been solved. In other words there is a position that wins\n            [player board]\n            (= 1 (count (filter #(solved-tuple player %) (get-all-tuples board)))))\n          \n          (update-board\n            [player board position]\n            (let [[r c] position]\n              (assoc-in board [r c] player)))\n\n          (solves-board?\n            [player board position]\n            ;; apply position to board and see if the player wins\n            (let [new-board (update-board player board position)]\n              (solved-board player new-board)))\n          ]\n    (set (filter #(solves-board? player board %) (open-positions board)))))","user":"4ebbff41535dfed6da9c6d78"},{"problem":119,"code":"(fn [p b]\n  (letfn [(f [[[a b c]\n               [d e f]\n               [g h i]]]\n             (let [w [[a b c]\n                      [d e f]\n                      [g h i]\n                      [a d g]\n                      [b e h]\n                      [c f i]\n                      [a e i]\n                      [g e c]]]\n               (true? (some #(= 3 (p %)) (map frequencies w)))))]\n    (set\n      (for [r (range 3)\n            c (range 3)\n            :when (= :e (get-in b [r c]))\n            :let [n (assoc-in b [r c] p)]\n            :when (f n)]\n        [r c]))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [x b] (let [c (replace {:e nil} (flatten b))]\r\n (into #{} (for [n (range 9)\r\n   :let [u (some #(apply = (conj % x))\r\n    (map #(map (partial nth (concat (take n c) [x] (drop (inc n) c))) %)\r\n     [[0 3 6] [1 4 7] [2 5 8] [0 1 2] [3 4 5] [6 7 8] [0 4 8] [2 4 6]]))]\r\n   :when (and u (not (nth c n)))]\r\n  [(quot n 3) (mod n 3)]))))","problem":119,"user":"4fca2ef0e4b0ee37620e184e"},{"code":"(letfn [(transpose\n         [matrix] \n         (apply mapv vector matrix))\n        \n        (diagonal'\n         [matrix]\n         (->> (range (count matrix))\n              (mapv #(get-in matrix [% %]))))\n        \n        (diagonals\n         [matrix]\n         (mapv diagonal'\n               [matrix\n                (mapv (comp vec rseq)\n                      matrix)]))\n        \n        (check\n         [player board]\n         (some (partial every? #{player})\n               board))\n        \n        (wins?\n         [player board]\n         (some (partial check player)\n               ((juxt identity\n                      transpose\n                      diagonals)\n                board)))]\n  \n  (fn moves\n    [player board]\n    (set    \n     (for [x [0 1 2], y [0 1 2]\n          :when (= :e (get-in board [x y]))\n          :when (wins? player\n                       (assoc-in board\n                                 [x y]\n                                 player))]\n       [x y]))))","problem":119,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [e board]\n  (let [diag (fn [board coords] (map #(get-in board %) coords))\n        col (fn [board col] (map #(% col) board))\n        lines (fn [board]\n                (concat\n                  board\n                  (map (partial col board) (range 3))\n                  [(diag board [[0 0] [1 1] [2 2]])\n                   (diag board [[0 2] [1 1] [2 0]])]))\n        wins? #(->> % lines\n                    (some (fn [[x & xs]]\n                            (and\n                              (not= x :e)\n                              (every? (partial = x) xs)))))]\n    (set \n      (for [i (range 3)\n            j (range 3)\n            :let [pos [i j]\n                  el (get-in board pos)\n                  upd (assoc-in board pos e)]\n            :when (and\n                    (= el :e)\n                    (wins? upd))]\n        pos))))","problem":119,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":119,"code":"(fn solve [player board]\n  (let [add (fn [[x0 y0] [x1 y1]] [(+ x0 x1) (+ y0 y1)])\n        mul (fn [[x0 y0] s] [(* s x0) (* s y0)])\n        \n        answer (into #{} (for [x (range 3)\n                               y (range 3)\n                               :when (= :e (get-in board [y x]))\n                               :let [p [y x]]\n                               dx (range -1 2)\n                               dy (range -1 2)\n                               :when (not= 0 dx dy)\n                               :let [d [dy dx]\n                                     line\n                                     (for [distance (range -2 3)\n                                           :when (not= 0 distance)]\n                                       (add p (mul d distance)))]\n                               :when (->> line\n                                          (map (partial get-in board) line)\n                                          (filter #(= player %))\n                                          count\n                                          (= 2))]\n                           p))]\n    answer))","user":"5e7df614e4b085ba37836e32"},{"code":"(fn [mv board-in] (let [m3 (fn [z] (mod z 3))\n                        m3f1 (fn [pos] (m3 (+ (first pos) 1)))\n                        m3f2 (fn [pos] (m3 (+ (first pos) 2)))\n                        m3s1 (fn [pos] (m3 (+ (second pos) 1)))\n                        m3s2 (fn [pos] (m3 (+ (second pos) 2)))\n                        main-diag-win (fn [board side pos]\n                                        (and (= (first pos) (second pos))\n                                             (= side ((board (m3f1 pos)) (m3f1 pos)) \n                                                ((board (m3f2 pos)) (m3f2 pos)))\n                                             )\n                                      )\n                        off-diag-win (fn [board side pos]\n                                       (and (= 2 (+ (first pos) (second pos)))\n                                            (= side ((board (m3f1 pos)) (m3 (- (second pos) 1)))\n                                               ((board (m3f2 pos)) (m3 (- (second pos) 2)))\n                                            )\n                                       )\n                                     )\n                        horiz-win (fn [board side pos]\n                                    (= side ((board (first pos)) (m3s1 pos))\n                                       ((board (first pos)) (m3s2 pos))\n                                    )\n                                  )\n                        verti-win (fn [board side pos]\n                                    (= side ((board (m3f1 pos)) (second pos))\n                                       ((board (m3f2 pos)) (second pos))\n                                    )\n                                  )\n                        is-win (fn [board side pos]\n                                 (cond\n                                  (not= :e ((board (first pos)) (second pos))) false\n                                  :else (or (main-diag-win board side pos)\n                                            (off-diag-win board side pos)\n                                            (horiz-win board side pos)\n                                            (verti-win board side pos)\n                                        )\n                                )\n                               )]\n                    (set (filter (fn [k] (is-win board-in mv k)) (for [x (range 3) y (range 3)] [x y])))\n                  )\n)","problem":119,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [p B]\n  (let [t [0 1 2]\n        C (vec (for [r t c t] [r c]))\n        w (partition 3 [0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6])\n        g #(get-in B %)\n        b #(= {:e 1 p 2} (frequencies (map (comp g C) %)))\n        e #(= (g %) :e)\n        F filter]\n    (set (mapcat #(F e (map C %)) (F b w)))))","problem":119,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn tic-tac-toe [x board]\n  (let [es (filter #(= :e (get-in board %)) (for [i (range 3) j (range 3)] [i j]))\n        col (fn [[i j]] (apply = x  (map #(get-in board [i %]) (filter #(not= j %) (range 3)))))\n        row (fn [[i j]] (apply = x  (map #(get-in board [% j]) (filter #(not= i %) (range 3)))))\n        left->right (fn [[i j]] (if (not= i j) false (apply = x  (map #(get-in board [% %]) (filter #(not= i %) (range 3))))))\n        right->letf (fn [[i j]] (if (not= 2 (+ i j)) false (apply = x  (map #(get-in board [% (- 2 %)]) (filter #(not= i %) (range 3))))))]\n    (into #{} (filter #(or (col %) (row %) (left->right %) (right->letf %)) es))))","problem":119,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn [p b]\n  (let [locs (apply merge-with into \n              (mapcat (fn [i l]\n                (map\n                  (fn [j x] {x #{[i j]}}) (range) l))\n                (range) b))\n        other (fn [[x1 y1] [x2 y2]]\n                (let [x3 (mod (- (+ x1 x2)) 3)\n                      y3 (mod (- (+ y1 y2)) 3)\n                      ox (->> [[x1 y1 1] [x2 y2 2] [x3 y3 3]] sort (map last))\n                      oy (->> [[y1 x1 1] [y2 x2 2] [y3 x3 3]] sort (map last))]\n                  (when (or (= ox oy) (= ox (reverse oy))) \n                    [x3 y3])))\n        empty (locs :e)\n        mmap (fn [f col]\n                (loop [c col acc '()]\n                  (if (empty? c) acc\n                    (recur (rest c) \n                      (lazy-cat acc (map #(f (first c) %) (rest c)))))))]\n    (set (filter empty (mmap other (locs p))))))","problem":119,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [player board]\n  (let [\n    all_coords (for [x (range 3) y (range 3)] [x y])\n    empties (filter (fn [pos] (= :e (get-in board pos))) all_coords)\n    rows (concat ( for [x (range 3)] [[x 0] [x 1] [x 2]] )\n                 ( for [y (range 3)] [[0 y] [1 y] [2 y]] )\n                 ( list [[0 0][1 1][2 2]] [[0 2][1 1][2 0]] ))\n    wins (filter (fn [pos] \n                   (let [board (assoc-in board pos player)]\n                     (some (fn [row] (every? (fn [pos] (= player (get-in board pos))) row)) rows)\n                   )) empties)]\n    (set wins)))","problem":119,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn [piece board]\n   (set (remove nil? (for [row (range 3) col (range 3)\n                           :when (= (get-in board [row col]) :e)\n                           ]\n         (let [rows (assoc-in board [row col] piece)\n             columns (apply map vector rows)\n             diag-fn (fn [rows]\n                       (map-indexed (fn [i itm]\n                                      (nth itm i)) rows))\n             diags [(diag-fn rows) (diag-fn (reverse rows))]\n             ]\n         (if\n             (nil? (some #{#{piece}} (map set (concat rows columns diags))))\n           nil\n           [row col]\n           ))\n       ))))","problem":119,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"(fn [p b]\n   (letfn [(winner [s] (let [lines (concat (map #(map (fn [a] [% a]) (range 3)) (range 3)) (map #(map (fn [a] [a %]) (range 3)) (range 3)) [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]])]\n                 (ffirst (filter #(and (= 1 (count %)) (or (= :x (first %)) (= :o (first %)))) (map (fn [a] (set (map #(get-in s [(first %) (second %)]) a))) lines)))))\n]\n     (set (apply concat (reduce\n      #(let [moves (reduce\n                    (fn [x y]\n                      (let [win (if (= :e ((b %2) y)) (winner (assoc-in b [%2 y] p)) nil)]\n\t\t\t(if (= p win)\n                          (conj x [%2 y])\n                          x)))\n                    []\n                    (range (count (b %2))))]\n         (conj %1 moves))\n      []\n      (range (count b)))))))","problem":119,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn [sym [r1 r2 r3]]\n (let [all-comb [[{(first r1) [0 0]} {(second r1) [0 1]} {(last r1) [0 2]}] \n                 [{(first r2) [1 0]} {(second r2) [1 1]} {(last r2) [1 2]}] \n                 [{(first r3) [2 0]} { (second r3) [2 1]} {(last r3) [2 2]}] \n                 [{(first r1) [0 0]} {(first r2) [1 0]} {(first r3) [2 0]}] \n                 [{(second r1) [0 1]} {(second r2) [1 1]} {(second r3) [2 1]}] \n                 [{(last r1) [0 2]} {(last r2) [1 2]} {(last r3) [2 2]}] \n                 [{(first r1) [0 0]} {(second r2) [1 1]} {(last r3) [2 2]}]  \n                 [{(last r1) [0 2]} {(second r2) [1 1]} {(first r3) [2 0]}]]\n    \n   ]\n    (let [be-won (for [r (range (count all-comb)) :when (= 2 (count (filter #(= (first (keys %)) sym) (nth all-comb r))))] (nth all-comb r))]\n      (set (filter #(not= nil %) (apply concat (map (fn[r] (map #(% :e) r))be-won))))\n    )\n  )\n)","problem":119,"user":"522eba30e4b01cdb292c5f0e"},{"problem":119,"code":"(fn [p board]\n      (let [paths [ [[0 0] [0 1] [0 2]]\n                    [[1 0] [1 1] [1 2]]\n                    [[2 0] [2 1] [2 2]]\n                    [[0 0] [1 0] [2 0]]\n                    [[0 1] [1 1] [2 1]]\n                    [[0 2] [1 2] [2 2]]\n                    [[0 0] [1 1] [2 2]]\n                    [[0 2] [1 1] [2 0]] ]\n            some? (fn [pred coll]\n                    (first (filter pred coll)))\n            winning-path? (fn [bd p path]\n                            (every? #(= p %)\n                                    (map #(get-in bd %) path)))\n            win? (fn [bd p]\n                   (some? #(winning-path? bd p %) paths))\n            all  (for [r [0 1 2]\n                       c [0 1 2]]\n                   [r c])\n            open (fn [bd] (filter #(= :e (get-in bd %)) all))\n            move (fn [bd p cell] (assoc-in bd cell p))\n            winning-move? (fn [bd p cell]\n                            (win? (move bd p cell) p))]\n        (->> (open board)\n             (filter #(winning-move? board p %))\n             set)))","user":"5f93529ae4b0715f5002d7bc"},{"code":"(fn [t x]\n   (let [ttt\n         (fn [x]\n           (first\n            (disj\n             (set\n              (map\n               first\n               (filter\n                (partial apply =)\n                (concat\n                 x\n                 (apply mapv vector x)\n                 (list (map #(get-in x [%1 %1]) (range 3)))\n                 (list (map #(get-in x [(- 2 %1) %1]) (range 3))))\n                ))\n              )\n             :e)))\n         sss (apply concat (map (fn [a] (map #(vector a %) (range 3))) (range 3)))\n         vs (filter #(= (get-in x %) :e) sss)]\n     (set (filter #(= (ttt (assoc-in x % t)) t) vs))))","problem":119,"user":"52586d24e4b0cb4875a45cb0"},{"problem":119,"code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn tic-tac-toe [piece board]\r\n    (letfn [(moves []\r\n              (for [x (range 3) y (range 3)] [x y]))\r\n            (place [board piece move]\r\n              (if (= :e (get-in board move))\r\n                (assoc-in board move piece)\r\n                board))\r\n            (winner [row]\r\n              (cond\r\n               (every? #(= % :x) row) :x\r\n               (every? #(= % :o) row) :o\r\n               :else nil\r\n               ))\r\n            (lines [board]\r\n              (conj board\r\n                    (map #(nth % 0) board)\r\n                    (map #(nth % 1) board)\r\n                    (map #(nth % 2) board)\r\n                    (list (nth (nth board 0) 0)\r\n                          (nth (nth board 1) 1)\r\n                          (nth (nth board 2) 2))\r\n                    (list (nth (nth board 0) 2)\r\n                          (nth (nth board 1) 1)\r\n                          (nth (nth board 2) 0))))\r\n            (board-winner [board]\r\n      (let [winners (map winner (lines board))]\r\n        (if (some #{:o} winners)\r\n          (if (some #{:x} winners)\r\n            nil\r\n            :o\r\n            )\r\n          (if (some #{:x} winners)\r\n            :x\r\n            nil\r\n            ))))]\r\n      (set (filter #(= piece (board-winner (place board piece %))) (moves)))))","problem":119,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn [piece board]\n  (let [count= (fn [x s] (count (filter #(= % x) s)))\n        get-col (fn [col] (map #(get-in board [% col]) (range 3)))\n        diag-1 (map #(get-in board [% %]) (range 3))\n        diag-2 (map #(get-in board [% (- 2 %)]) (range 3))]\n    (set (mapcat (fn [row]\n                   (mapcat (fn [col]\n                             (if (and (= (get-in board [row col]) :e)\n                                      (some (fn [line]\n                                              (= (count= piece line) 2))\n                                            (list (board row)\n                                                  (get-col col)\n                                                  (if (= row col)\n                                                    diag-1)\n                                                  (if (= row (- 2 col))\n                                                    diag-2))))\n                               (list [row col])))\n                        (range 3)))\n                 (range 3)))))","problem":119,"user":"4ee3b586535d10e5ff6f5371"},{"problem":119,"code":"(fn tic-tac [piece board]\n  (letfn [(all-equal? [r x] (every? #(= % x) r))\n           (vert [rows] (apply map vector rows))\n           (diag [rows] [[(get-in rows [0 0]), (get-in rows [1 1]), (get-in rows [2 2])]\n                         [(get-in rows [0 2]), (get-in rows [1 1]), (get-in rows [2 0])]])\n           (board-won [piece rows] (some #(all-equal? % piece) (concat rows (vert rows) (diag rows))))]\n    \t(into #{}\n          (filter identity\n          (for [x (range 3) y (range 3)]\n            (if (and (= :e (get-in board [x y]))\n                     (board-won piece (assoc-in board [x y] piece)))\n              [x y]))))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [piece board]\n  (->> ((fn [n]\n          (mapcat (fn [func]\n                    (func (range n)))\n                  (list (partial map (fn [x] (map (fn [y] [x y]) (range n))))\n                        (partial map (fn [y] (map (fn [x] [x y]) (range n))))\n                        (comp list (partial map (fn [i] [i i])))\n                        (comp list (partial map (fn [i] [i (- n i 1)]))))))\n        3)\n       (map (partial keep (fn [coord]\n                            (let [v (get-in board coord)]\n                              (when (contains? #{piece :e} v)\n                                [v coord])))))\n       (mapcat (fn [set]\n                 (when (and (= (count set) 3)\n                            (= (count (filter #(= % :e) (map first set))) 1))\n                   (mapcat (fn [[p c]]\n                             (when (= p :e)\n                               [c]))\n                           set))))\n       set))","problem":119,"user":"51105c7fe4b04c71fce993ef"},{"code":"(fn [sym board]\n  (letfn [(line [col] (every? (partial = sym) col))\n          (diag [board] (map #(get-in (vec board) [% %])\n                             (range 3)))\n          (transpose [board]\n            (apply map vector board))\n          (is-winning\n            [sym board]\n            (let [tboard (transpose board)]\n            (or\n              (some line board)\n              (some line tboard)\n              (line (diag board))\n              (line ((comp diag vec reverse) board)))))\n          (win\n            [sym board [x y :as coord]]\n               (let [at (get-in board coord)]\n                 (when (= at :e)\n                   (is-winning sym (update-in board coord\n                                              (constantly sym)))\n                   ))\n               )]\n    (into #{}\n          (for [x (range 3)\n                y (range 3)\n                :when (win sym board [x y])]\n            [x y]\n            ))))","problem":119,"user":"4dc537fd535d8a4b2fd74282"},{"code":"(fn tictactoe [piece board]\n   (letfn [(row-win [[a b c]] (if (and (not (= a :e)) (= a b c)) a))\n           (cell-at [board [x y]] (nth (nth board x) y))\n           (board-win [board] (or (some row-win board)\n                                  (some row-win (apply map list board))\n                                  (row-win (map #(cell-at board %) [[0 0] [1 1] [2 2]]))\n                                  (row-win (map #(cell-at board %) [[0 2] [1 1] [2 0]]))))\n           (play [[x y]] (if (= (cell-at board [x y]) :e)\n                           (board-win (assoc board x (assoc (nth board x) y piece)))\n                           false))]\n     (set (filter play (for [x (range 3) y (range 3)] [x y])))))","problem":119,"user":"4e89f46c535d3e98b8023288"},{"problem":119,"code":"(fn win-tic-tac-toe [p board]\n  (let [rows board\n        cols (into [] (apply map vector rows))\n        map-diag (partial map-indexed #(nth %2 %1))\n        ;; Diagonal starting at position x 0 y 0.\n        diag-00 (map-diag board)\n        ;; Same but at 0 2\n        diag-02 (map-diag (reverse board))\n        ;; Diagonals start from a corner: [0 0] [0 2] [2 0] [2 2]. Map each\n        ;; diagonal to it's starting position. These positions will be checked\n        ;; for winning moves\n        diags {0 {0 diag-00\n                  2 diag-02}\n               2 {0 (reverse diag-02)\n                  2 (reverse diag-00)}}\n        ;; Diagonal starting at postion x 0 y 0\n        diag-00 (map-indexed #(nth %2 %1) board)\n        ;; Diagonal at x 0 y 2\n        diag-02 (map-indexed #(nth %2 %1) (reverse board))\n        ;; Count the number of game pieces\n        count-p #(if (= p %2) (inc %1) %1)\n        ;; Check if board position is a winning move for p. To win, one of the\n        ;; rows (a row or col) must already have 2 matching game pieces the\n        ;; same as p\n        check-win (fn [x y & rows]\n                    (when (some #{2} (map #(reduce count-p 0 %) rows))\n                      [x y]))\n        ;; Walk the 2D matrix and check for a winning move for empty positions\n        cross-winners (for [x [0 1 2] y [0 1 2] :when (= :e (get-in board [x y]))]\n                        (check-win x y (get rows x) (get cols y)))\n        diag-winners  (for [x [0 2] y [0 2] :when (= :e (get-in board [x y]))]\n                        (check-win x y (get-in diags [x y])))]\n    (set (remove nil? (concat cross-winners diag-winners)))))","user":"58327a08e4b089d5ab817c7c"},{"problem":119,"code":"(fn [xo board]\n  (->>\n   board\n   (map-indexed (fn[i row] (map-indexed (fn[j col] [[i j] col] ) row)))\n   (apply concat)\n   (filter #(#{:e} (second %)))\n   (map (fn[[coord _]] [coord (assoc-in board coord xo)]))\n   (map \n     (fn [[coord B]] \n       [coord\n         (let [D (partial map-indexed #(%2 %))]\n           ( ->>\n           `(~@B ~@(apply map list B) ~(D B) ~(-> B reverse D))\n           (some #{[:x :x :x] [:o :o :o]})\n           first))\n       ] ) )\n   (remove #(nil? (second %)))\n   (map first)\n   set\n) )","user":"5281a445e4b0757a1b17143a"},{"problem":119,"code":"(fn ttt2 [p b]\n    (letfn [(win [w]\n              (let [g [(map first w)\n                       (map second w)\n                       (map last w)\n                       (first w)\n                       (second w)\n                       (last w)\n                       [(first (first w)) (second (second w)) (last (last w))]\n                       [(first (last w)) (second (second w)) (last (first w))]]]\n                (if (some #(= [:x :x :x] %) g)\n                  :x\n                  (if (some #(= [:o :o :o] %) g)\n                    :o\n                    nil))))]\n      (set\n       (remove nil?\n               (for [i (range 3) j (range 3)]\n                 (if (= :e ((b i) j))\n                   (if (= p (win (assoc b i (assoc (b i) j p))))\n                     [i j]\n                     nil)\n                   nil))))))","user":"579693d4e4b039eba2ecb0e7"},{"problem":119,"code":"(fn [p board]\n  (let [row (fn [bd n] (bd n))\n        column (fn [bd n] (for [i (range 3)] (get-in bd [i n])))\n        diag (fn [bd pos] (if (= (pos 1) (pos 0)) (for [i (range 3)] (get-in bd [i i]))))\n        adiag (fn [bd pos] (if (= 2 (+ (pos 0) (pos 1))) (for [i (range 3)] (get-in bd [i (- 2 i)]))))\n        \n        lines (fn [bd pos]  (filter identity [(row bd (pos 0)) (column bd (pos 1)) (diag bd pos) (adiag bd pos)]))\n        \n        wins (fn [pos] (if (= :e (get-in board pos))\n                             (let [nboard (assoc-in board pos p)\n                                   x (println (lines nboard pos))]\n                                 (some  (partial every? #{p}) (lines nboard pos)))))]\n  \n    (apply hash-set (filter  wins (for [i (range 3) j (range 3)] [i j])))))","user":"5649615be4b0284900eef641"},{"code":"(fn tictactoe [x0 board]\n  (letfn [(moves [board]\n          (let [\n                row1 (first board)\n                row2 (second board)\n                row3 (last board)\n                col1 (vector (first row1) (first row2) (first row3))\n                col2 (vector (second row1) (second row2) (second row3))\n                col3 (vector (last row1) (last row2) (last row3))\n                diag1 (vector (first row1) (second row2) (last row3))\n                diag2 (vector (last row1) (second row2) (first row3))\n                solution (vector row1 row2 row3 col1 col2 col3 diag1 diag2)\n                ]\n            (not (nil? (some (if (= :x x0) #{[:x :x :x]} #{[:o :o :o]}) solution)))\n            ))]\n\n(set  (filter #(not (nil? %1))\n            (map-indexed #(if (moves %2) [(int (/ %1 3)) (mod %1 3)] nil)\n                 (for [i [0 1 2] j [0 1 2]]\n                   (if (= :e (nth (nth board i) j))\n                     (assoc board i (assoc (nth board i) j x0 ))\n                     nil\n                     ))\n                 )\n    ))))","problem":119,"user":"4ea31da2535d7eef308072c1"},{"problem":119,"code":"(fn winning-moves [piece board ]\n  (let [win?  (fn [m]\n    (let [winner (ffirst (filter (fn [v] (= (v 0) (v 1) (v 2)))\n      (let [all (conj (concat m (apply mapv vector m))\n        [((m 0) 0) ((m 1) 1) ((m 2) 2)] [((m 2) 0) ((m 1) 1) ((m 0) 2)])]\n        all)))]\n    (if (= :e winner) nil winner)))]\n  (into #{} (remove nil? (for [row '(0 1 2) col '(0 1 2) \n                 :when (= :e (get-in board [row col])) ]\n             (when (win? (update-in board [row col] (constantly piece)))\n               [row col]\n               ))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":119,"code":"(fn ttt [piece board]\n  (let [positions\n        (concat\n         (for [x (range 3)] (map (fn [y] [x y]) (range 3)))\n         (for [y (range 3)] (map (fn [x] [x y]) (range 3)))\n         [(map (fn [n] [n n]) (range 3))\n          (map (fn [n] [n (- 2 n)]) (range 3))])]\n    (letfn [(wins? [piece board]\n              (->> positions\n                (map #(map (partial get-in board) %))\n                (some #(= (repeat 3 piece) %))))]\n      (into #{}\n            (keep identity\n                  (for [x (range 3) y (range 3)]\n                    (if (and (= :e (get-in board [x y]))\n                             (wins? piece (assoc-in board [x y] piece)))\n                      [x y])))))))","user":"534d1173e4b084c2834f4a98"},{"code":"(fn [p brd]\n  (let [possible-moves (for [x (range 3) \n                             y (range 3) \n                             :when (= :e (get-in brd [x y]))] [x y])\n        winning-move? (fn [p brd mv] \n                        (let \n                          [dims [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n                           board (vec (flatten (assoc-in brd mv p)))\n                           values (map #(map board %) dims)]\n                          (= p (ffirst (filter #(and (apply = %) (apply not= :e %)) values)))))]\n    (set (filter #(winning-move? p brd %) possible-moves))))","problem":119,"user":"500aa15ee4b03d00572d2d76"},{"problem":119,"code":"(fn tic-tac-toe2 [p m]\n  (let [pos (for [x (range 3)\n                  y (range 3)] [x y])\n        ]\n    (letfn [(next-board [p m [x y]]\n              (if (not= :e ((m x) y))\n                m\n                (assoc m x (assoc (m x) y p))))\n\n            (tic-tac-toe [m]\n              (let [t1 \n                    (loop [i 0] ;;;Checa as linhas\n                      (if (= ((m i) 0) ((m i) 1) ((m i) 2))\n                        ((m i) 0)\n                        (if (< i 2) (recur (inc i)))))\n                    t2 \n                    (loop [j 0] ;;;Checa as colunas\n                      (if (= ((m 0) j) ((m 1) j) ((m 2) j))\n                        ((m 0) j)\n                        (if (< j 2) (recur (inc j)))))\n                    t3 \n                    (if (= ((m 0) 0) ((m 1) 1) ((m 2) 2)) ;;Checa diag prin\n                      ((m 0) 0))\n                    t4\n                    (if (= ((m 0) 2) ((m 1) 1) ((m 2) 0)) ;;Checa diag sec\n                      ((m 2) 0))]\n                (if (and (not= t1 :e) (not= t1 nil)) t1\n                    (if (and (not= t2 :e) (not= t2 nil)) t2\n                        (if (and (not= t3 :e) (not= t3 nil)) t3\n                            (if (and (not= t4 :e) (not= t4 nil)) t4))))))\n            (won? [p m [x y]]\n              (let [m2 (next-board p m [x y])\n                    pw (tic-tac-toe m2)]\n                (= p pw)))\n            ]\n      (set (filter #(won? p m %) pos)))))","user":"574f1c24e4b02ea114799255"},{"problem":119,"code":"(fn [piece board]\n   (let [state-at (fn [[r c]] (nth (nth board r) c))\n         group-by-state (fn [line] (group-by #(state-at %) line))]\n     (->> [[[0 0] [0 1] [0 2]]\n           [[1 0] [1 1] [1 2]]\n           [[2 0] [2 1] [2 2]]\n           [[0 0] [1 0] [2 0]]\n           [[0 1] [1 1] [2 1]]\n           [[0 2] [1 2] [2 2]]\n           [[0 0] [1 1] [2 2]]\n           [[0 2] [1 1] [2 0]]]\n          (map group-by-state)\n          (filter #(and (= 2 (count (piece %))) (= 1 (count (:e %)))))\n          (map #(first (:e %)))\n          (set))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":119,"code":"(fn [player table] \n     (let [indexed-table  (into {}\n                                (map #(vector %1 %2)\n                                     (for [y (range 3) x (range 3)] [y x])\n                                     (mapcat identity table)))\n           rows (map (fn [y] (map #(vector y %) (range 3))) (range 3))\n           columns (map (fn [x] (map #(vector % x) (range 3))) (range 3))\n           angle-inc (map #(vector %1 %2) (range 3) (range 3))\n           angle-dec (map #(vector %1 %2) (range 3) (reverse (range 3)))\n           all (into (into rows columns) (list angle-inc angle-dec))\n           winner-row? (fn [player row] (let [m (map #(indexed-table %) row)\n                                              freq (frequencies m)] \n                                          (and (= 2 (freq player)) (= 1 (freq :e)))))\n           winner-rows (filter (partial winner-row? player) all)\n           ]\n       (apply hash-set (mapcat (fn [w-row] (filter #(= :e (indexed-table %)) w-row)) winner-rows)))\n     )","user":"50856bd1e4b004985b776e4c"},{"code":"(fn [color board]\n  (let [tic-tac-toe-win? (fn  [mtrx] (letfn [(transpose [mtrx] (apply map vector mtrx))\n                                             (diagonalize1 [mtrx] [[(ffirst mtrx) (second (second mtrx)) (last (last mtrx))]])\n                                             (diagonalize2 [mtrx] [[(last (first mtrx)) (second (second mtrx)) (first (last mtrx))]])\n                                             (find-winner [f mtrx] (for [row (f mtrx) player [:x :o] :when (apply = (conj row player))] player))]\n                                       (let [winner (apply clojure.set/union (map #(find-winner % mtrx) [identity transpose diagonalize1 diagonalize2]))]\n                               (if (empty? winner) nil (first winner)))))\n        next-move   (fn [x y] (partition 3 (for [i (range 3)\n                                                 j (range 3)]\n                                             (if (and (= i x) (= j y))\n                                               color\n                                       ((board i) j)))))\n        legal-moves (for [i (range 3)\n                          j (range 3)\n                          :when (= ((board i) j) :e)]\n                      [i j])]\n    (into #{} (filter (fn [[x y]] (tic-tac-toe-win? (next-move x y))) legal-moves))))","problem":119,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn [move gr]\n  (let [checkwins (fn [g]\n                    (let [cols (map (fn [col] (map #(nth % col) g)) (range 3))\n                          diag [[(first (first g)) (second (second g)) (last (last g))]\n                                [(last (first g)) (second (second g)) (first (last g))]]\n                          lines (concat g cols diag)]\n                      (cond\n                       (some #(= % [:x :x :x]) lines) true\n                       (some #(= % [:o :o :o]) lines) true\n                       true false)))\n        coords (for [y (range 3) x (range 3)] [y x])]\n    (into #{}\n          (filter (fn [c]\n                    (and (= (get-in gr c) :e)\n                         (checkwins (assoc-in gr c move))))\n                  coords))))","problem":119,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":119,"code":"(fn [player board]\n  (let [coords-of (fn [target]\n                    (->> (map-indexed\n                           (fn [row-index row]\n                             (map-indexed\n                               (fn [col-index cell]\n                                 (when (= target cell)\n                                   [row-index col-index]))\n                               row))\n                           board)\n                         (mapcat #(remove nil? %))\n                         (set)))\n        wins? (fn [board]\n                (let [row (fn [n b] (b n))\n                      col (fn [n b] (into [] (map #(% n) b)))\n                      ldiag (fn [b]\n                              (->> (reduce\n                                     (fn [[ld i] r]\n                                       (vector\n                                         (conj ld (r i))\n                                         (inc i)))\n                                     [[] 0] b)\n                                   (first)))\n                      rdiag (fn [b]\n                              (->> (reduce\n                                     (fn [[rd i] r]\n                                       (vector\n                                         (conj rd (r i))\n                                         (dec i)))\n                                     [[] 2] b)\n                                   (first)))\n                      xs (fn [s] (map #(if (= :x %) 1 0) s))\n                      os (fn [s] (map #(if (= :o %) 1 0) s))\n                      won (fn [p]\n                            (->>\n                              (map\n                                (fn [f]\n                                  (->>\n                                    (f board)\n                                    (p)\n                                    (apply +)))\n                                [(partial row 0)\n                                 (partial row 1)\n                                 (partial row 2)\n                                 (partial col 0)\n                                 (partial col 1)\n                                 (partial col 2)\n                                 ldiag\n                                 rdiag])\n                              (filter #(= 3 %))\n                              (seq)))]\n                  (cond\n                    (won xs) (= :x player)\n                    (won os) (= :o player)\n                    :else nil)))]\n    (->> (coords-of :e)\n         (filter #(wins? (assoc-in board % player)))\n         (set))))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [v field]\r\n  (let [index-field (fn [field] (map-indexed \r\n                                  (fn [idx row] (map-indexed #(vector idx % %2) row)) \r\n                                  field))\r\n        transpose (fn [field] (apply (partial map vector) field))\r\n        win? (fn [row v]\r\n               (when\r\n                 (->> row\r\n                      (filter #(= v (peek %)))\r\n                      count\r\n                      (= 2))\r\n                 (some #(when (= (peek %) :e) (butlast %)) row)))\r\n        find-wins (fn [[[v00  _  v02]\r\n                        [ _  v11  _ ]\r\n                        [v20  _  v22] :as fld]]\r\n                    (keep #(win? % v)\r\n                          (concat\r\n                            fld\r\n                            (transpose fld)\r\n                            [[v00 v11 v22]\r\n                             [v20 v11 v02]])))]\r\n    (-> field\r\n        index-field\r\n        find-wins\r\n        set)))","problem":119,"user":"5003ee7de4b0678c553fc446"},{"problem":119,"code":"(fn ttt [p board]\n   (let [MAXL (count board)\n         MAXC (count (first board))\n         CHK (concat\n               (for [i (range MAXL)]\n                 (for [j (range MAXC)]\n                   [i j]))\n               (for [i (range MAXL)]\n                 (for [j (range MAXC)]\n                   [j i]))\n               ; cross\n               '(([0 0] [1 1] [2 2])) '(([2 0] [1 1] [0 2])))\n\n         e-inxs (fn []\n                  (for [i (range MAXL)\n                        j (range MAXC)\n                        :when (= :e ((board i) j))]\n                    [i j]))\n\n         n-board (fn [coor]\n                   (vec (for [i (range MAXL)]\n                      (vec (for [j (range MAXC)]\n                             (if (and (= i (first coor)) (= j (second coor)))\n                               p\n                               ((board i) j)))))))\n\n         win? (fn [b l]\n                (println b l)\n                (every? #(= p ((b (first %)) (second %))) l))]\n\n     (reduce\n       (fn [ret e-coor]\n         (println ret e-coor)\n         (if (some #(win? (n-board e-coor) %) CHK)\n           (conj ret e-coor)\n           ret))\n       #{}\n       (e-inxs))\n     ))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn [piece board] \n  (letfn [(win? [b]  (let [x (set \n                              (concat \n                               b\n                               (apply map vector b)\n                               [[(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])]]\n                               [[(get-in b [0 2]) (get-in b [1 1]) (get-in b [2 0])]]\n                               ))]\n                       (if (x [:x :x :x]) :x (when (x [:o :o :o]) :o))))] \n    (let [coords (for [x (range 3) y (range 3)] [x y])]\n      (set (filter #(and (= :e (get-in board %)) (= piece (win? (assoc-in board % piece)))) coords)))))","problem":119,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":119,"code":"(fn [p b]\n    (let [diagp #{[0 0] [1 1] [2 2]}\n          diagd #{[2 0] [1 1] [0 2]}]\n      (letfn [(row [b n]\n                (nth b n))\n              (col [b n]\n                (map #(nth % n) b))\n              (diagds [b] (map #(get-in b %) diagd))\n              (diagps [b] (map #(get-in b %) diagp))\n              (test-win [x b p]\n                (let [[i j] x]\n                  (if (or (= 2 (count (filter (fn [c] (= c p)) (row b i))))\n                          (= 2 (count (filter (fn [c] (= c p)) (col b j))))\n                          (and (contains? diagp x) (= 2 (count (filter (fn [c] (= c p)) (diagps b)))))\n                          (and (contains? diagd x) (= 2 (count (filter (fn [c] (= c p)) (diagds b))))))\n                    x)))\n\n              (par2 [s] (partition 2 s))\n              (find-all-empty [b]\n                (-> (for [i (range 0 3)] (for [j (range 0 3)  :when (= :e (get-in b [i j]))] [i j]))\n                    flatten\n                    par2))]\n        (set (filter #(not (nil? %)) (map #(test-win % b p) (find-all-empty b)))))))","user":"4f3ec266e4b0e243712b1f8c"},{"problem":119,"code":"(fn [piece mx] ;piece is 'o or 'x; mx is a matrix of symbols\n    (let [place? (fn [[x y :as coords]]\n                   (and (= (count coords) 2) (<= 0 x 2) (<= 0 y 2)))\n          at( fn [matrix pl] {:pre [(place? pl)]} (get-in matrix pl))\n          directions (apply concat #_->seq-of-seq-of-places\n                            '(([0 0] [1 1] [2 2]) ;diagonal from top left\n                              ([2 0] [1 1] [0 2]))\n                            (for [i (range 0 3)]\n                              `(([~i 0] [~i 1] [~i 2]) ;horizontal\n                                ([0 ~i] [1 ~i] [2 ~i])) ;vertical\n                              ))\n          direction? (fn [dir] (and\n                                (= (count dir) 3)\n                                (every? place? dir)))\n          _ (assert (every? direction? directions))\n          empty-places (filter (comp (partial = :e) (partial at mx)) (for [x (range 0 3), y (range 0 3)] [x y]))\n          won-dir? (fn [mx dir] {:pre [(direction? dir)]}\n                     (let [mx-at (partial at mx)]\n                       (if (apply = (map mx-at dir))\n                         (let [value (mx-at (first dir))]\n                           (#{:o :x} value))))) ;we don't need to check who won, since we made the move\n          won-mx? (fn [mx]\n                    (some (partial won-dir? mx) directions))\n          result (into #{}\n                    (for [pl empty-places\n                          :let [mx-updated (assoc-in mx pl piece)]\n                          :when (won-mx? mx-updated)]\n                      pl))\n          ]\n        result\n      )\n    )","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(let [empty-squares (fn [board]\n                      (for [row (range 3)\n                            column (range 3)\n                            :when (#{:e} (get-in board [column row]))]\n                        [column row]))\n      winning-runs [[[0 0] [0 1] [0 2]]\n                    [[1 0] [1 1] [1 2]]\n                    [[2 0] [2 1] [2 2]]\n                    [[0 0] [1 0] [2 0]]\n                    [[0 1] [1 1] [2 1]]\n                    [[0 2] [1 2] [2 2]]\n                    [[0 0] [1 1] [2 2]]\n                    [[0 2] [1 1] [2 0]]]\n      winning-square? (fn [piece square board]\n                        (= piece (get-in board square)))\n      winning-run? (fn [piece run board]\n                     (every? #(winning-square? piece % board) run))\n      winning-board? (fn [piece board]\n                       (some #(winning-run? piece % board) winning-runs))]\n  (fn [piece board]\n    (set (filter (fn [square]\n                   (winning-board? piece (assoc-in board square piece)))\n                 (empty-squares board)))))","problem":119,"user":"51789dfae4b03d69594194d7"},{"code":"(fn levi [me board]\n  (let[cnt (count board)\n       horiz (map (fn[i] (map (fn[j] [(get-in board [i j])[i j]])(range cnt))) (range cnt))\n       vert  (map (fn[i] (map (fn[j] [(get-in board [j i])[j i]])(range cnt))) (range cnt))\n       diag1 [(map (fn[i] [(get-in board [i i])[i i]]) (range cnt))]\n       diag2 [(map (fn[i] [(get-in board [(- cnt i 1) i])[(- cnt i 1) i]]) (range cnt))]\n       cnt-chip (fn [player cort] (count(filter (fn[cell] (= player (first cell))) cort)))\n       ]\n      (set(map last(filter #(= :e (first %)) (mapcat identity\n       (filter (fn[cort] (and(= (dec cnt) (cnt-chip me cort))(= 1 (cnt-chip :e cort)))) (concat horiz vert diag1 diag2))))))\n    )\n )","problem":119,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [piece b]\n  (letfn [(won [piece [[x11 x12 x13] [x21 x22 x23] [x31 x32 x33] :as b]]\n            (let [w (concat b (apply map vector b) [[x11 x22 x33] [x13 x22 x31]])]\n              (first (some #{[piece piece piece]} w))))]\n    (set (filter #(and (#{:e} (get-in b %)) (won piece (assoc-in b % piece)))\n                 (for [i (range 3) j (range 3)] [i j])))))","problem":119,"user":"4ed94d69535d10e5ff6f5303"},{"code":"(fn [player board]\n    (->>\n     (for [x (range 0 (count board))\n           y (range 0 (count (board x)))\n           :when (= :e (get-in board [x y]))]\n       [[x y] (assoc-in board [x y] player)])\n     (filter (comp (fn [board]\n                     (some #(= (repeat (count board) player) %)\n                           (concat board\n                                   (apply map vector board)\n                                   (for [[v y-mod] [[[0 0] inc] [[0 (dec (count board))] dec]]]\n                                     (map #(get-in board %)\n                                          (take (count board) (iterate (fn [[x y]] [(inc x) (y-mod y)]) v)))))))\n                   second))\n     (map first)\n     set))","problem":119,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":119,"code":"(fn [p board]\n  (letfn [(win-pos? [loc]\n            (reduce #(or % %2) (map (fn [s] (= 2 (count (filter #(= p (get-in board %)) s)))) (necessary-pos loc))))\n          (necessary-pos [[x y]]\n            (set [(set (for [dx (range -2 3) :when (not= dx 0)] [(+ x dx) y]))\n                  (set (for [dy (range -2 3) :when (not= dy 0)] [x (+ y dy)]))\n                  (set (for [dx (range -2 3) dy (range -2 3) :when (and (not= 0 dx dy) (= dx dy))]\n                         [(+ x dx) (+ y dy)]))\n                  (set (for [dx (range -2 3) dy (range -2 3) :when (and (not= 0 dx dy) (=  dy (- dx)))]\n                         [(+ x dx) (+ y dy)]))]))]\n    (set (remove nil? (for [i (range (count board)) j (range (count (board 0)))]\n                        (if (and (= :e ((board i) j)) (win-pos? [i j])) [i j]\n                            nil))))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [winning-val b]\n  (let [b-flat (flatten b)\n        to-check [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n        to-return [[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]]\n        rows-to-use (for [i to-check] (into [] (map #(nth b-flat %) i)))\n        freqs-to-use (map frequencies rows-to-use)\n        struct-to-use (partition 3 (interleave freqs-to-use rows-to-use to-check))\n        winning-lines (filter #(= (first %) {winning-val 2 :e 1}) struct-to-use)\n        winning-vals (into [] (map #(nth (last %) (.indexOf (second %) :e)) winning-lines))\n        ]\n  (set (map #(nth to-return %) winning-vals))))","problem":119,"user":"525c575be4b0cb4875a45d38"},{"code":"(fn [side board]\n  (letfn [(count-wins [board]\n  \t      (let [indexes [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n\t\t\t    all-rows (concat board\n\t\t\t\t\t     (map (fn [col]\n\t\t\t\t\t\t    (map (fn [row idx] (nth row idx)) board col))\n\t\t\t\t\t\t  indexes))]\n\t\t\t(count\n\t\t\t (filter (fn [row] (and (apply = row)\n\t\t\t\t\t\t(#{side} (first row))))\n\t\t\t\t all-rows))))]\n    (set\n     (let [wins (count-wins board)]\n       (for [x [0 1 2]\n\t     y [0 1 2]\n\t     :when (and (= :e (get-in board [x y]))\n\t\t\t(> (count-wins (assoc-in board [x y] side))\n\t\t\t   wins))]\n\t [x y])))))","problem":119,"user":"4e513ecf535dc968683fc4f6"},{"problem":119,"code":"(fn [p b]\n  (into #{}\n     (for [y [0 1 2] x [0 1 2]\n           :when (and (= (get-in b [y x]) :e)\n                      (= p ((fn [b] \n                              (first (some #{[:o :o :o] [:x :x :x]}\n                                           (concat b\n                                                   (apply map vector b)\n                                                   [(for [i [0 1 2]]\n                                                      (get-in b [i i]))]\n                                                   [(for [i [0 1 2]]\n                                                      (get-in b [i (- 2 i)]))]))))\n                            (assoc-in b [y x] p))))]\n      [y x])))","user":"52bacfa8e4b07a9af57922d6"},{"problem":119,"code":"(fn [p b]\n  (letfn [(winner [xy]\n    (let [[[a b c] [d e f] [g h i]] (assoc-in b xy p)] \n      (or (= p a b c) (= p d e f) (= p g h i) (= p a d g) (= p b e h) (= p c f i) (= p a e i) (= p c e g))))]\n    (->> (for [x (range 3) y (range 3)] [x y]) (filter #(= (get-in b %) :e)) (filter winner) set)))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(letfn [(winners [board]\n          (let [[& rows] board\n                [& cols] (apply map list board)\n                [[a1 _ b1] [_ c] [b2 _ a2]] board\n                diags [[a1 c a2] [b1 c b2]]]\n            (filter #{:o :x} (map first (filter (partial apply =) (concat rows cols diags))))))]\n  (fn [player board]\n    (let [moves (filter #(= (get-in board %) :e)\n                        (for [r (range 3)\n                              c (range 3)]\n                          [r c]))]\n      (set (filter #(= [player] (winners (assoc-in board % player))) moves)))))","problem":119,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn [mark board]\r\n  (let [side-length (count board)\r\n        diagonal-lines [(map (fn [idx] [idx idx]) (range side-length))\r\n                        (map (fn [idx] [idx (- (dec side-length) idx)]) (range side-length))]]\r\n    (letfn [(lines-include [[y x :as point]]\r\n              (concat [(map (fn [line-x] [y line-x]) (range side-length))\r\n                       (map (fn [line-y] [line-y x]) (range side-length))]\r\n                      (filter #((set %) point) diagonal-lines)))]\r\n      (set (for [x (range side-length)\r\n                 y (range side-length)\r\n                 :let [point [y x]\r\n                       mark-at-point (get-in board point)]\r\n                 :when (and (= :e mark-at-point)\r\n                            (some (fn [line]\r\n                                    (every? (fn [line-point]\r\n                                              (or (= line-point point)\r\n                                                  (= mark (get-in board line-point))))\r\n                                            line))\r\n                                  (lines-include point)))]\r\n             point)))))","problem":119,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [y b]\r\n  (let [r (range 3)\r\n        w-table (concat (for [x r] (for [y r] [x y]))\r\n                        (for [x r] (for [y r] [y x]))\r\n                        (list (for [x r] [x x]))\r\n                        (list (for [x r] [x (- 2 x)])))]\r\n    (set (for [w w-table\r\n            :when (= (reduce + (map (fn [p] (let [px (get-in b p)] (cond (= px y) 1 (= px :e) 0 :else -100))) w)) 2)\r\n            :let [r (some #(when (= (get-in b %) :e) %) w)]]\r\n            r))))","problem":119,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":119,"code":"(fn [c rows] (let [\n  n (count rows)\n  lines (fn [rows]\n     (concat rows\n       (apply map vector rows)\n       (list (map-indexed #(%2 %) rows))\n       (list (map-indexed #( (vec (reverse %2)) %) rows))))\n  check (fn [rows] (some true? (map (fn [x] (every? #(= c %) x))\n           (lines rows))))\n  part-list (fn [x] (map vec (partition n x)))\n  part-numb (fn [m] (vector (int (/ m n)) (mod m n)))\n  ans (loop [ [f & r :as x] (flatten rows), a '(), b [], i 0 ]\n    (if (seq x)\n       (if (= f :e)\n        (recur r (cons (list i (concat  b (list c) r)) a) (conj b f) (inc i))\n        (recur r a (conj b f) (inc i)))\n      a))\n  ]\n      (set (filter identity (map (fn[x] (if (check (part-list (second x)))\n                      (part-numb (first x)))) ans  )))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [q b]\n  (let [[[a b c :as u] [d e f :as v] [g h i :as w]]\n            (mapv vec (partition 3 (for [x [0 1 2]\n                                         y [0 1 2]]\n                                     [(get-in b [x y]) [x y]])))\n        p (fn [row]\n            (let [fr (frequencies (map first row))]\n              (if (and (= 1 (:e fr))\n                       (pos? (get fr q))\n                       (not= (:x fr) (:o fr)))\n                (-> (filter #(= (first %) :e) row) first second))))]\n    (set (filter identity (map p [u v w [a d g] [b e h] [c f i] [a e i] [c e g]])))))","problem":119,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn winning [piece board]\n  (let [find-empty (fn [board]\n                     (for [r [0 1 2] c [0 1 2]\n                           :when (= :e (get-in board [r c]))]\n                       [r c]))\n       winner (fn [board]\n                (let [combs (concat board\n                                    (map (fn [n] (mapv #(% n) board)) (range 3))\n                                    [(mapv #(get-in board %) [[0 0] [1 1] [2 2]])\n                                     (mapv #(get-in board %) [[0 2] [1 1] [2 0]])])]\n                  (ffirst (filter (fn [row] (and\n                                     (not-any? #(= :e %) row)\n                                     (apply = row)))\n                          combs))))]\n    (set (for [empty-space (find-empty board)\n            :let [new-board (assoc-in board empty-space piece)]\n            :when (= piece (winner new-board))]\n        empty-space))))","problem":119,"user":"50217818e4b00bba4502f7a7"},{"problem":119,"code":"(fn [p board]\n   (letfn [(winner [rows]\n                   (let [indices (range (count rows))\n                         all (-> (apply conj rows (apply map vector rows))\n                                 (conj (map nth rows indices)\n                                       (map nth rows (reverse indices))))]\n                     (ffirst (filter #(and (not (= [:e :e :e] %))\n                                           (apply = %)) all))))]\n     (let [empties (for [x (range (count board))\n                         y (range (count (first board)))\n                         :when (= :e (get-in board [x y]))]\n                     [x y])]\n       (set (filter (fn [empty]\n                      (not (nil? (winner (assoc-in board empty p)))))\n                    empties)))))","user":"538ca203e4b0b51d73faae5f"},{"code":"(fn [p b]\n  (letfn [(winner [b]\n      (some {[:o :o :o] :o [:x :x :x] :x}\n            (concat b (partition 3 (apply interleave b))\n                      (for [i [[0 4 8][2 4 6]]]\n                        (map #(nth (flatten b) %) i)))))]\n  (set\n    (for [y (range 3) x (range 3)\n            :when (= :e (get-in b [x y]))\n            :when (= p (winner (assoc-in b [x y] p)))]\n      [x y]))))","problem":119,"user":"4f1b92d1535d64f60314647b"},{"problem":119,"code":"(fn [piece boarda]\n   (let [boardb (apply mapv vector boarda)\n         x1 [[0 0] [1 1] [2 2]]\n         x2 [[0 2] [1 1] [2 0]]\n         x3 (= {piece [piece piece] :e [:e]} (group-by identity (map #(get-in boarda %) x1)))\n         x4 (= {piece [piece piece] :e [:e]} (group-by identity (map #(get-in boarda %) x2)))]\n     (set (for [x (range 3)\n                y (range 3)\n                :when (or (and (= :e (get-in boarda [x y]))\n                               (or (= 2 (reduce + (map #(if (= piece %) 1 0) (get boarda x))))\n                                   (= 2 (reduce + (map #(if (= piece %) 1 0) (get boardb y))))\n                                   (and x3 (some x1 [x y]))\n                                   (and x4 (some x2 [x y])))))]\n            [x y]))))","user":"557c6ca6e4b05c286339e0c4"},{"code":"(fn [e b] \n  (let [allsol (for [x (range 3) y (range 3)] [x y])]\n  (letfn [\n    (win? [[[a11 a12 a13] [a21 a22 a23] [a31 a32 a33] :as r]]\n    (cond (some (partial = [:x :x :x]) r) :x\n        (some (partial = [:o :o :o]) r) :o\n        (some (partial = [:x :x :x]) [[a11 a21 a31] [a12 a22 a32] [a13 a23 a33]]) :x\n        (some (partial = [:o :o :o]) [[a11 a21 a31] [a12 a22 a32] [a13 a23 a33]]) :o \n        (some (partial = [:x :x :x]) [[a11 a22 a33] [a13 a22 a31]]) :x\n        (some (partial = [:o :o :o]) [[a11 a22 a33] [a13 a22 a31]]) :o\n        :else nil))\n    (nest [v]  (into {} (map vector (range 3) (map (fn [row] (into {} (map vector (range 3) row))) v))))\n    (unest [v] (into [] (map #(into [] (map second (second %))) v)))\n    (update [b p e] (if-not (= :e (get-in b p)) nil (update-in b p (constantly e)))) \n    (step [p e board] (-> board nest (update p e) unest))]\n    (into #{} (remove empty? (map #(if (win? (step % e b)) % []) allsol))))))","problem":119,"user":"4ede8789535d10e5ff6f5337"},{"code":"(fn [piece board]\n  (let [get-pos (fn [board [x y]] (nth (nth board y) x))\n        win? (fn [board]\n               (some #(every? (partial = piece) %)\n                     (map (fn [positions]\n                            (map (partial get-pos board) positions))\n                          (concat\n                           [[[0 0] [1 1] [2 2]]\n                            [[0 2] [1 1] [2 0]]]\n                           (for [x (range 0 3)]\n                             (for [y (range 0 3)]\n                               [x y]))\n                           (for [y (range 0 3)]\n                             (for [x (range 0 3)]\n                               [x y]))))))]\n    (set (for [x (range 0 3)\n               y (range 0 3)\n               :let [board' (update-in board [y x] #(if (= % :e) piece %))]\n               :when (win? board')]\n           [y x]))))","problem":119,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn win-tic-tac-toe [player board]\n  (let [empty :e rng3 (range 3)\n        paths (clojure.set/union #{(for [i rng3] [i i]) (for [i rng3] [i (- 2 i)])}\n                                 (for [i rng3] (for [j rng3] [i j]))\n                                 (for [i rng3] (for [j rng3] [j i])))\n        win-position (fn [path] (let [path-map (for [[i j] path] [((board i) j) [i j]])\n                                      groups (group-by first path-map)]\n                                  (when (and (= 1 (count (groups empty))) (= 2 (count (groups player)))) \n                                    (second (first (groups empty))))))] \n    (->> (map win-position paths) (filter (complement nil?)) set)))","problem":119,"user":"51729002e4b044b2ef48a850"},{"code":"(fn wins [player board]\n  (letfn [(win? [row]\n            (let [fs (frequencies row)]\n              (and (= 1 (fs :e))\n                   (= 2 (fs player)))))\n          (row [r] (nth board r))\n          (col [c] (map #(nth % c) board))\n          (diag1 [r c] \n            (when (= r c)\n              (for [i (range 3)] (get-in board [i i]))))\n          (diag2 [r c] \n            (when (= (+ r c) 2)\n              (for [i (range 3)] (get-in board [i (- 2 i)]))))]\n    (set\n      (for [r (range 3) \n            c (range 3)\n            :when (and (= :e (get-in board [r c]))\n                       (some win? [(row r) (col c) (diag1 r c) (diag2 r c)]))]\n        [r c]))))","problem":119,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":119,"code":"(fn [x fld]\n    (let [win (fn [p] (let [f (assoc-in fld p x)\n                            g (fn [i j] (get-in f [i j]))\n                            l (into [[(g 0 0) (g 1 1) (g 2 2)] [(g 0 2) (g 1 1) (g 2 0)]]\n                                    (concat f (apply map vector f)))]\n                (some #(every? (fn [q] (= x q)) %) l)))]\n  (into #{} (filter win (for [i [0 1 2] j [0 1 2] :when (= :e (get-in fld [i j]))] [i j]))) ))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn win-game [player board]\n  (let [\n    check      (fn [[y x]] (get-in board [y x]))\n    mark       (fn [[y x]] [(check [y x])[y x]]) ;[value [coordinates]]\n    mapyx      (fn [ys xs] (map vector ys xs))   ;[[y1 x1] [y2 x2] ... [yn xn]]\n        \n    board-range (fn [ys xs]\n                  (map mark (mapyx ys xs)))     ;[[v1 [y1 x1]], [v2 [y2 x2]], ... , [vn [yn xn]]]\n         \n    main-diagonal (board-range [0 1 2] [0 1 2])\n    anti-diagonal (board-range [0 1 2] [2 1 0])\n    diagonals     [main-diagonal anti-diagonal]\n        \n    lines         (for [y [0 1 2]] (board-range [y y y] [0 1 2]))\n    collumns      (for [x [0 1 2]] (board-range [0 1 2] [x x x]))\n\n    all-ranges    (reduce into [diagonals lines collumns])\n    \n    range-marks   (fn[b-range] (map first  b-range))\n    range-coords  (fn[b-range] (map second b-range))\n    \n    filter-mark   (fn[b-range mk] (filter #(= (first %) mk) b-range))\n    \n    range-state   (fn [b-range] (frequencies (range-marks b-range))) ; Frequencies of :x, :o and :e in a range.\n    \n    winnable-state {player 2, :e 1}\n    \n    winnable-ranges (filter #(= (range-state %) winnable-state) all-ranges)\n    \n    win-positions   (for [rng winnable-ranges] (->> (filter-mark rng :e)\n                                                    (first)    ; get only entry left\n                                                    (second))) ; get coordinates\n    ]\n    \n    (set win-positions)))","problem":119,"user":"52f818a6e4b047fd55836fcc"},{"problem":119,"code":"(fn [piece [[r11 r12 r13] [r21 r22 r23] [r31 r32 r33]]]\n  (letfn [(same [& s]\n                (ffirst (filter \n                         (fn [[k v]] (and (#{:x :o} k) (= (count s) v))) (frequencies s))))\n          (win [[r11 r12 r13 r21 r22 r23 r31 r32 r33]] \n               (or \n                 (same r11 r21 r31)\n                 (same r12 r22 r32)\n                 (same r13 r23 r33)\n                 (same r11 r22 r33) \n                 (same r13 r22 r31) \n                 (same r11 r12 r13) \n                 (same r21 r22 r23) \n                 (same r31 r32 r33)))]\n    \n    \n    \n  (set (for [x (range 3) \n             y (range 3) \n             :when (let [gv (vector r11 r12 r13 r21 r22 r23 r31 r32 r33)\n                         i (+ (* x 3) y)] \n                     (and \n                      (#{:e} (get gv i))\n                       (win (assoc gv i piece))))] \n         [x y])\n  )))","user":"4f3b5219e4b0e243712b1f2a"},{"problem":119,"code":"(fn find-winners [x-or-o board]\n  (let [winner? (fn [board]\n                  (let [r0 (first board)\n                        r1 (second board)\n                        r2 (last board)\n                        c0 (map first board)\n                        c1 (map second board)\n                        c2 (map last board)\n                        d1 [(first r0) (second r1) (last r2)]\n                        d2 [(last r0) (second r1) (first r2)]\n                        win-lines [r0 r1 r2 c0 c1 c2 d1 d2]\n                        won-lines (->> win-lines\n                                       (map set)\n                                       (filter #(= #{x-or-o}  %))\n                                       (map first))\n                        win? ((comp not empty?) won-lines)]\n                    win?))\n        coords (for [y [0 1 2]\n                     x [0 1 2]\n                     :when (= :e (get-in board [y x]))]\n                 [y x])\n        update-board (fn [board coord] (update-in board coord (fn [_] (identity x-or-o))))]\n    (set\n     (filter identity\n             (map\n              (fn [coord] (when (winner? (update-board board coord)) coord))\n              coords)))))","user":"56069006e4b08b23635d3174"},{"problem":119,"code":"(fn [player field]\n  (let\n   [index\n    (fn [field]\n      (map-indexed\n       (fn [y yi]\n         (map-indexed\n          (fn [x xv]\n            (if (= :e xv)\n              [y x]\n              xv))\n          yi))\n       field))\n    opponent\n      (first (remove\n       #{player}\n       #{:o :x}))\n    to-lists\n      (fn [field]\n        (concat\n         field\n         (apply map vector field)\n         (vector\n          (map\n            #(nth (nth field %) %)\n            (range 0 (count field))))\n         (vector\n          (map\n            #(nth (nth (reverse field) %) %)\n            (range 0 (count field))))))\n    ]\n   (->> field\n        index\n        to-lists\n        (map set)\n        (filter\n         #(and\n           (not\n            (contains?\n             %\n             opponent))\n           (contains? % player)\n           (= (count %) 2)))\n        (map\n         #(first\n           (remove\n            #{player}\n            %)))\n        set)))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn tic-tac-toe\r\n  [player board]\r\n\t(letfn [(get-xy [x y] \r\n\t\t\t\t\t  (if (or (or (< x 0) (< y 0)) \r\n\t\t\t\t\t\t\t\t\t  (or (> x 2) (> y 2))) \r\n\t\t\t\t\t\t\t\t\t\t:e\r\n\t\t\t\t\t\t\t\t\t  (get-in board [x y])))\r\n\r\n\t\t\t\t\t(put-xy [x y value]\r\n\t\t\t\t\t\t(assoc board x (assoc (nth board x) y value)))\r\n\r\n\t\t\t\t\t(ttt [board]\r\n\t\t\t\t\t\t(let [board (map (fn [lista] (replace {:e nil} lista)) board)]\r\n\t\t\t\t\t\t\t(letfn [(line-winner [line] \r\n\t\t\t\t\t\t\t\t\t\t\t\t(reduce (fn [c1 c2] (if (= c1 c2) c1 nil)) line))\r\n\t\t\t\t\t\t\t\t\t\t\t(third [x]\r\n\t\t\t\t\t\t\t\t\t\t\t\t(second (next x)))]\r\n\t\t\t\t\t\t\t\t(or\r\n\t\t\t\t\t\t\t\t\t(line-winner (first board))\r\n\t\t\t\t\t\t\t\t\t(line-winner (fnext board))\r\n\t\t\t\t\t\t\t\t\t(line-winner (third board))\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t(line-winner [(ffirst board) (first (second board)) (first (third board))])\r\n\t\t\t\t\t\t\t\t\t(line-winner [(second (first board)) (second (second board)) (second (third board))])\r\n\t\t\t\t\t\t\t\t\t(line-winner [(third (first board)) (third (second board)) (third (third board))])\r\n\r\n\t\t\t\t\t\t\t\t\t(line-winner [(ffirst board) (second (second board)) (third (third board))])\r\n\t\t\t\t\t\t\t\t\t(line-winner [(first (third board)) (second (second board)) (third (first board))])))))]\r\n\r\n\t\t(set (for [row (range 3) col (range 3) \r\n\t\t\t\t\t :when (and (= (get-xy row col) :e) (= player (ttt (put-xy row col player))))]\r\n\t\t\t\t\t\t [row col]))))","problem":119,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn [piece board]\n  (let [empty-positions (for [i (range 3) j (range 3) :when (= :e ((board i) j))] [i j])\n        winner? (fn [piece position board]\n                  (let [updated-board (assoc-in board position piece)\n                        row (updated-board (position 0))\n                        col (for [i (range 3)] ((updated-board i) (position 1)))\n                        d1 [[0 0][1 1][2 2]]\n                        d2 [[0 2][1 1][2 0]]\n                        diag1 (if (some #{position} d1) (map #(get-in updated-board %) d1) nil)\n                        diag2 (if (some #{position} d2) (map #(get-in updated-board %) d2) nil)\n                        triplets (keep identity (list row col diag1 diag2))]\n                    (some #{[piece piece piece]} triplets)))]\n    (set (filter #(winner? piece % board) empty-positions))))","problem":119,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":119,"code":"(fn [player board]\n  (letfn [(winner [[top mid bottom :as board]]\n                  (let [all-comb (concat board (apply mapv vector board) [[(top 0) (mid 1) (bottom 2)] [(top 2) (mid 1) (bottom 0)]])]\n                    (cond\n                     (some (fn [row] (every? #(= % :x) row)) all-comb) :x\n                     (some (fn [row] (every? #(= % :o) row)) all-comb) :o\n                     :else nil)))\n          (fill [pos] (update-in board pos #(if (= :e %) player %)))]\n    (set (for [x [0 1 2] y [0 1 2]\n\t          :when (= player (winner (fill [x y])))]\n    \t  [x y]))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":119,"code":"(fn [p c]\n  (letfn [(analyse [coll] (let [x coll cl [[0 1 2] [3 4 5] [6 7 8]\n                                                          [0 3 6] [1 4 7] [2 5 8]\n                                                          [0 4 8] [2 4 6]]]\n                            (reduce (fn [res [a b c]](if (and (= a b c) (not= a :e)) a res))\n                                                      nil\n                                                     (map (fn [[a b c]](vector (x a) (x b) (x c))) cl))))]\n    (let [s (vec (flatten c))]\n      (loop [x 0 res #{}]\n        (if (= x (count s)) res\n          (recur (inc x) (if (= (s x) :e)\n                           (if (= (analyse (assoc s x p)) p)\n                             (conj res [(quot x 3) (rem x 3)])\n                             res)\n                           res)))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"problem":119,"code":"(fn [piece board]\n\n  (let [a [0 0] b [0 1] c [0 2]\n        d [1 0] e [1 1] f [1 2]\n        g [2 0] h [2 1] i [2 2]\n\n      rcd [[a b c][d e f][g h i] ;; rows\n           [a d g][b e h][c f i] ;; cols\n           [a e i][c e g]]]      ;; diags\n\n    (letfn [(winner [piece board]\n              (let [position (map (fn [xs] (map #(get-in board %) xs)) rcd)]\n                (reduce \n                  #(let [ft (first %2)]\n                    (if (and (apply = %2)(= piece ft)) ft %1))\n                  nil\n                  position)))]\n      (reduce\n        (fn [acc index] \n          (if (and \n                (= :e (get-in board index))\n                (winner piece (assoc-in board index piece)))\n            (conj acc index) acc))\n        #{}\n        [a b c d e f g h i]))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":119,"code":"(fn __ [tic board]\n  (letfn [(checkboard [tick boardd]\n  (some true?\n   (map #(= % [tick tick tick]) \n  (concat \n   boardd \n   (partition 3 3 (apply interleave boardd)) \n   (vector (map #(get-in boardd %) [[0 0][1 1][2 2]]))\n   (vector (map #(get-in boardd %) [[0 2][1 1][2 0]])) ))))]\n    (set (map first\n     (filter #(true? (last %))\n     (for[a [0 1 2] b [0 1 2]]\n      [[a b] (checkboard tic (update-in board [a b] #(if (= % :e) tic %)))] \n      ))))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn [pl brd]\n  (let [won? (fn [p brd]\n    (reduce #(or %1 %2)\n       (flatten\n          [ (for [y (range 0 3)] (= p ((brd 0) y) ((brd 1) y) ((brd 2) y)))\n            (for [x (range 0 3)] (= p ((brd x) 0) ((brd x) 1) ((brd x) 2)))\n            (= p ((brd 0) 0) ((brd 1) 1) ((brd 2) 2))\n            (= p ((brd 0) 2) ((brd 1) 1) ((brd 2) 0))])))]\n    (set (filter coll?\n          (for [x (range 0 3) y (range 0 3)]\n               (if (= (nth (nth brd y) x) :e)\n                           (if (won? pl (assoc-in brd [y x] pl))\n                             [y x])))))))","problem":119,"user":"50bce014e4b0594b91591c63"},{"problem":119,"code":"(fn [p board]\n  (let [wins [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]\n              [[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]]]\n    (->> wins\n         (map-indexed (fn [i pos] [i (frequencies (map (partial get-in board) pos))]))\n         (filter (fn [[i f]] (= {:e 1 p 2} f)))\n         (mapcat (fn [[i _]] (filter #(= :e (get-in board %)) (get wins i))))\n         (into #{}))))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn [m b]\n  (letfn [(win? [m b]\n            (or\n              (some identity (map (fn [v] (every? #{m} v)) b))\n              (some identity (map (fn [n] (every? #{m} (map (fn [v] (v n)) b))) (range 3)))\n              (= m ((b 0) 0) ((b 1) 1) ((b 2) 2))\n              (= m ((b 0) 2) ((b 1) 1) ((b 2) 0))))\n          (b2i [b]\n            (apply concat (keep-indexed (fn [i v] (keep-indexed (fn [j v] [i j v]) v)) b)))\n          (i2b [i]\n            (vec (map vec (partition 3 (map (fn [[_ _ v]] v) i))))) \n          (rpl [m b [y x]]\n            (i2b (map (fn [[i j v]] [i j (if (and (= i y) (= j x)) m v)]) (b2i b))))\n          (pos [m b]\n            (map (fn [[y x _]] [y x])\n                 (filter (fn [[_ _ v]] (= v m))\n                         (b2i b))))]\n    (set (filter (fn [p] (win? m (rpl m b p))) (pos :e b)))))","problem":119,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":119,"code":"(fn make-win [piece board]\n  (letfn [(win [indexes]\n           (and (> (count indexes) 2)\n                (or\n                 (some #(> (count %) 2) (vals (group-by identity (map first indexes))))\n                 (some #(> (count %) 2) (vals (group-by identity (map second indexes))))\n                 (> (count (filter #{[0 0] [1 1] [2 2]} indexes)) 2)\n                 (> (count (filter #{[0 2] [1 1] [2 0]} indexes)) 2))))\n          (winner [board key]\n            (let [key-to-indexes (->> (map-indexed\n                                       (fn [i row]\n                                         (map-indexed (fn [j e] {:key e :index [i j]}) row))\n                                       board)\n                                      flatten\n                                      (group-by :key))]\n              (win (map :index (key key-to-indexes)))))]\n    (reduce\n     into\n     #{}\n     (for [x (range (count board))]\n       (for [y (range (count (first board)))\n             :when (and (= (get-in board [x y]) :e)\n                        (winner (assoc-in board [x y] piece) piece))]\n         [x y])))))","user":"51852961e4b0da5a5be3babb"},{"problem":119,"code":"(fn get-winning-moves [player board]\n  (let [find-empty-positions (fn [board] (map second (filter #(= (first %) :e) (map #(vector (get-in board %) %) (for [x (range 3) y (range 3)] [x y])))))\n        is-winning-position (fn is-winning-position ([board player]\n                                               (let [[p1 p2 p3 p4 p5 p6 p7 p8 p9] (flatten board)]\n                                                 (or\n                                                   (= p1 p2 p3 player)\n                                                   (= p4 p5 p6 player)\n                                                   (= p7 p8 p9 player)\n                                                   (= p1 p4 p7 player)\n                                                   (= p2 p5 p8 player)\n                                                   (= p3 p6 p9 player)\n                                                   (= p1 p5 p9 player)\n                                                   (= p3 p5 p7 player))))\n                           ([board]\n                            (or (is-winning-position board :o)\n                                (is-winning-position board :x))))]\n    (set (filter  #(is-winning-position (assoc-in board % player)) (find-empty-positions board)))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [peice board]\n           (let [soln? (fn [rows]\n                         (let [cols (apply map vector rows)\n                               diag (fn [x] (map-indexed #(nth %2 %) x))\n                               diags [(diag rows) (diag (map reverse rows))]\n                               lines (concat rows cols diags)\n                               line-sets (map set lines)]\n                           (first (some #{#{:x} #{:o}} line-sets))))]\n             \n             (loop [pointer [0 0]\n                    acc #{}]\n               (if (= pointer [0 3])\n                 acc\n                 (do (when (= :e (get-in board pointer))\n                       (println \"pointer:\" pointer))\n                     (recur (if (= 2 (first pointer))\n                              [0 (inc (second pointer))]\n                              [(inc (first pointer)) (second pointer)])\n                            (if (and (= :e (get-in board pointer))\n                                     (or (soln? (assoc-in board pointer :x))\n                                         (soln? (assoc-in board pointer :o))))\n                              (conj acc pointer)\n                              acc)))))))","problem":119,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":119,"code":"(fn [piece board]\n  (let [winning-rows [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n        is-empty? (partial = :e)\n        winning? (fn [board]\n                   (->> (map (fn [row board] (map #(nth %2 %1) row board)) winning-rows (repeat board))\n                        (concat board)\n                        (remove #(some is-empty? %))\n                        (filter #(apply = %))\n                        (ffirst)))]\n    (set (for [r (range 3)\n               c (range 3)\n               :when (is-empty? (get-in board [r c]))\n               :when (winning? (assoc-in board [r c] piece))]\n           [r c]))))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn [piece board]\n  (let [size (count board)\n        lines1 (for [row (range size)]\n                    (map (partial vector row) (range size)))\n        lines (concat [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]] lines1 (map (partial map reverse) lines1))]\n    (set\n      (for [line lines\n            :let [f (-> (map (partial get-in board) line)\n                       frequencies\n                       ((juxt piece :e)))]\n            :when (= f [2 1])]\n        (first (remove #(= piece (get-in board %)) line))))))","problem":119,"user":"525431dfe4b0541d1855b970"},{"problem":119,"code":"(fn [el board]\n  (let [win? (fn [[[a b c] [d e f] [g h k]]]\n                    (or (= el a b c)\n                        (= el d e f)\n                        (= el g h k)\n                        (= el a d g)\n                        (= el b e h)\n                        (= el c f k)\n                        (= el a e k)\n                        (= el c e g)))]\n    (->> [[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]]\n         (filter #(= :e (get-in board %)))\n         (filter #(win? (assoc-in board % el)))\n         set)))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn [player board]\n    (let [win? (fn [board]\n                 (letfn [(all-same [[x y z]]\n                           (when (and (= x y z) (not= x :e))\n                             x))\n                         (transpose [coll]\n                           (apply map list coll))\n                         (reverse-transpose [coll]\n                           (apply map list (map reverse coll)))\n                         (diagonal [coll]\n                           (map-indexed (fn [idx xs]\n                                          ((vec xs) idx))\n                                        coll))]\n                   (some #{:x :o} (concat (keep all-same board)\n                                          (keep all-same (transpose board))\n                                          (list (all-same (diagonal board)))\n                                          (list (all-same (-> (reverse-transpose board) diagonal)))))))]\n      (->> (for [x (range 0 (inc 2))\n                 y (range 0 (inc 2))] [x y])\n           (filter #(= :e (get-in board %)))\n           (filter #(win? (assoc-in board % player)))\n           set)))","problem":119,"user":"4dc0ff08535d020aff1edf84"},{"problem":119,"code":"(fn __ [piece board]\n  (letfn [(possible-moves [board]\n            (for [row (range 3)\n                  col (range 3)\n                  :when (= :e (get-in board [row col]))]\n              [row col]))\n          (winner [rows]\n            (let [columns   (apply map vector rows)\n                  diagonals (map (partial map get rows) [(range 3) (reverse (range 3))])\n                  longest   (fn [player] (->> (concat rows columns diagonals)\n                                              (map (comp count (partial filter #{player})))\n                                              (reduce max)))]\n              (cond\n                (= (longest :x) 3) :x\n                (= (longest :o) 3) :o\n                :else nil)))]\n    (set (filter (comp (partial = piece) winner #(assoc-in board % piece)) (possible-moves board)))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":119,"code":"(fn [player v]\n  (let [has-won (fn [player v]\n                  (let [cols (apply map vector v)\n                        diag1 (map #(nth %1 %2) v (range 3))\n                        diag2 (map #(nth %1 %2) v (reverse (range 3)))\n                        all-rows (concat v cols [diag1 diag2])]\n                    (->> all-rows\n                         (map #(into #{} %))\n                         (filter #(= 1 (count %)))\n                         (apply concat)\n                         (some #{player}))))\n        empty-coords (fn [v]\n                       (apply concat (map-indexed (fn [r row]\n                                                    (filter identity\n                                                            (map-indexed (fn [c cell]\n                                                                           (if (#{:e} cell)\n                                                                             [r c]\n                                                                             nil)) row))) v)))\n        move-wins? (fn [player v coord]\n                     (has-won player (assoc-in v coord player)))]\n    (set (filter (partial move-wins? player v) (empty-coords v)))))","user":"530b8580e4b02e82168697cc"},{"problem":119,"code":"(fn win-tic-tac-toe [piece board]\n  (let [winner? (fn [board]\n                  (let [vertical [(vec (map first board)) (vec (map second board)) (vec (map #(nth % 2) board))]\n                        diag [[(first (first board)) (second (second board)) (nth (nth board 2) 2)]\n                              [(nth (first board) 2) (second (second board)) (first (nth board 2))]]\n                        all (concat board vertical diag)\n                        fe (filter #(not (some (fn [v] (= :e v)) %)) all)\n                        xs (filter #(every? (fn [v] (= :x v)) %) fe)\n                        os (filter #(every? (fn [v] (= :o v)) %) fe)]\n                    (cond (> (count xs) 0) :x\n                          (> (count os) 0) :o\n                          :otherwise nil)\n                    )\n                  )\n        all-pos (for [x (range 3) y (range 3)] [x y])\n        winners (reduce (fn [acc v] (if (and (= :e (get-in board v)) (winner? (update-in board v (fn [_] piece)))) (conj acc v) acc)) #{} all-pos)\n        ]\n    winners\n    ))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":119,"code":"(fn win-at-tic-tac-toe [game-piece rows]\n  (let [get-indexes (fn [coll item-to-find] \n                      (filter identity (map \n                                        (fn [item index]\n                                          (if (= item-to-find item) index nil))\n                                        coll (range))))\n        get-matrix-indexes (fn [rows item-to-find]\n                             (reduce concat (map \n                                             (fn [row row-index] \n                                               (map (fn [column-index] [row-index column-index]) \n                                                    (get-indexes row item-to-find))) \n                                             rows (range))))\n        update-matrix (fn [rows [row-index column-index] new-val]\n                        (assoc rows row-index (assoc (nth rows row-index) column-index new-val)))\n        analyze-tic-tac-toe-board (fn \n                                    [rows]\n                                    (let [columns (apply map (fn [& args] args) rows)\n                                          diag1 (map (fn [row index] (nth row index)) rows (range))\n                                          diag2 (map (fn [row index] (nth (reverse row) index)) rows (range))\n                                          all (concat rows columns (vector diag1 diag2))\n                                          all-items-are-the-same? (fn [coll] (= 1 (count (set coll))))\n                                          winner (first (first (filter #(not= :e (first %)) (filter all-items-are-the-same? all))))]\n                                      winner))\n        empty-places (get-matrix-indexes rows :e)]\n    (set (filter\n          (fn [empty-place]\n            (= game-piece (analyze-tic-tac-toe-board (update-matrix rows empty-place game-piece))))\n          empty-places))))","user":"5e805895e4b085ba37836e44"},{"problem":119,"code":"(fn [w s]\n  (let [els-with-coord (for [x (range 3) y (range 3)] [(get-in s [x y]) x y])\n        table (partition 3 els-with-coord)\n        positions (concat (map #(repeat 3 %) (range 3)) [[0 1 2] [2 1 0]])\n        get-line (fn [tr] (map nth table tr))\n        rcd (concat table (map get-line positions))\n        winners (filter #(#{[w w :e] [w :e w] [:e w w]} (map first %)) rcd)]\n    (set (mapcat #(for [[p x y] % :when (= p :e)] [x y]) winners))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":119,"code":"(fn [t ts]\n  (let [bar (fn [bs]\n               (or (apply = t (bs 0))\n                   (apply = t (bs 1))\n                   (apply = t (bs 2))\n                   (= t ((bs 0) 0) ((bs 1) 0) ((bs 2) 0))\n                   (= t ((bs 0) 1) ((bs 1) 1) ((bs 2) 1))\n                   (= t ((bs 0) 2) ((bs 1) 2) ((bs 2) 2))\n                   (= t ((bs 0) 0) ((bs 1) 1) ((bs 2) 2))\n                   (= t ((bs 2) 0) ((bs 1) 1) ((bs 0) 2))))\n        baz (fn [x y]\n              (vec (for [i [0 1 2]]\n                (vec (for [j [0 1 2]]\n                  (if (and (= x i) (= y j) (= :e ((ts x) y)))\n                    t\n                    ((ts i) j)))))))]\n    (set (for [x [0 1 2] y [0 1 2]\n               :when (bar (baz x y))]\n                  (vector x y)))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":119,"code":"(fn immediate-wins [party table]\n  (let [get (fn [y x] (-> table (nth y) (nth x)))\n        is? (fn [elem] (fn [[y x]] (= elem (get y x))))\n        is-party? (is? party)\n        is-empty? (is? :e)\n        trans-x (fn [x] (fn [n] [n x]))\n        trans-y (fn [y] (fn [n] [y n]))\n        trans-diag1 (fn [n] [n n])\n        trans-diag2 (fn [n] [(- 2 n) n])\n        transformations (concat \n                          (map trans-x (range 3))\n                          (map trans-y (range 3))\n                          [trans-diag1 trans-diag2])\n        trans-to-coords (fn [trans] (map trans (range 3)))\n        has-two? (fn [trans]\n                   (->> trans\n                     trans-to-coords\n                     (filter is-party?)\n                     count\n                     (= 2)))\n        first-not-party (fn [trans]\n                          (->> trans\n                            trans-to-coords\n                            (remove is-party?)\n                            first))]\n    (->> transformations\n      (filter has-two?)\n      (map first-not-party)\n      (filter is-empty?)\n      (into #{}))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [piece board]\n  (letfn [(win? [piece board]\n           (cond\n            (some #(= [piece piece piece] %) board) true\n            (some #(= [piece piece piece] %) (apply map (fn [x y z] [x y z]) board)) true\n            (= (first (first board)) (second (second board)) (last (last board)) piece) true\n            (= (last (first board)) (second (second board)) (first (last board)) piece) true\n            :else false))]\n    (set (filter (complement nil?) \n            (apply concat\n              (map-indexed\n                (fn [r row]\n                 (map-indexed (fn [c cell] \n                               (if (= cell :e) \n                                 (if (win? piece (assoc-in board [r c] piece)) [r c]))) row))\n                board))))))","problem":119,"user":"514721c6e4b0d520409ed392"},{"problem":119,"code":"(fn tic-tac [p b]\n  (let [r [0 1 2]]\n    (set (for [x r\n               y r\n               :when (and (= :e ((b x) y))\n                          (let [nb (assoc-in b [x y] p)\n                                w? (fn [s] (= [p] (distinct s)))]\n                            (or (w? (nb x))\n                                (w? (map #(% y) nb))\n                                (and (= #{0 2} (into #{0 2} [x y]))\n                                     (or (w? (map #((nb %) %) r))\n                                         (w? (map #((nb %) (- 2 %)) r)))))))]\n           [x y]))))","user":"53973e7be4b0b51d73faaee6"},{"code":"(fn [nextmove col]\n  (let [cell-vaule (fn [n m] (nth (nth col n) m))\n          h-line (for [x (range 3) ]  [[x 0] [x 1] [x 2]])\n          v-line (for [y (range 3) ]  [[0 y] [1 y] [2 y]])\n          d-line [  [[0 0] [1 1] [ 2 2] ]    [[2 0] [1 1] [0 2]]  ]\n          all-lines (concat h-line  v-line d-line)\n\n\n          check-move (fn [theline]\n            (let [line-values (map-indexed (fn [idx item] [idx (cell-vaule (first item) (last item))])  theline )\n                  empty-pos (count (filter #(= :e (last %)) line-values))\n                  used-pos  (count (filter #(= nextmove  (last %)) line-values))]\n\n             (if (and  (= 1 empty-pos) (= 2 used-pos) )\n                 (nth theline (first (first (filter #(= :e (last %)) line-values)) ))\n                 nil)))]\n\n         (set (filter identity (map check-move all-lines))) ))","problem":119,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":119,"code":"(fn prob119b [piece board]\n  (letfn\n      [(winner [triple]\n         (cond\n           (apply = :o triple) :o\n           (apply = :x triple) :x))\n       (find-winner [board]\n         (or\n          (when-first [w (filter winner board)] (first w))\n          (when-first\n              [w (filter winner\n                    (map (fn [col] (map #(nth % col) board)) (range 3)))]      \n            (first w))\n          (winner (map #((board %) %) (range 3)))\n          (winner (map #((board %) (- 2 %)) (range 3)))))\n       (find-empties [board]\n         (for [r (range 3) c (range 3)\n               :when (= :e (get-in board [r c]))]\n           [r c]))\n       (fill-cell [board [r c] v]\n         (assoc board r (assoc (board r) c v)))]\n    (set\n     (filter #(= piece (find-winner (fill-cell board % piece)))\n             (find-empties board)))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":119,"code":"(fn tic-tac-toe [p b]\n  (letfn [\n          (cell \n            ([[i j]] (cell i j))\n            ([i j]\n              (get (get b i) j)))\n          \n          (row [[i j]]\n            (filter (fn [[i _]] (and (>= i 0) (<= i 2)))\n                    [[(- i 2) j] [(dec i) j] [i j] [(inc i) j] [(+ i 2) j]]))\n          \n          (col [[i j]]\n            (filter (fn [[_ j]] (and (>= j 0) (<= j 2)))\n                    [[i (- j 2)] [i (dec j)] [i j] [i (inc j)] [i (+ j 2)]]))\n          \n          (diag-left [[_ _]]\n            [[0 2] [1 1] [2 0]])\n          \n          (diag-right [[_ _]]\n            [[0 0] [1 1] [2 2]])\n          \n          (lines [[i j]]\n            (cond \n              (= i j) (vector (row [i j]) (col [i j]) (diag-right [i j]))\n              (= (+ i j) 2) (vector (row [i j]) (col [i j]) (diag-left [i j]))\n              :else (vector (row [i j]) (col [i j]))))\n          \n          (add-cell [acc i j]\n            (if (= :e (cell i j))\n              (conj acc [i j])\n              acc))\n          \n          (options []\n            (reduce \n              (fn [acc i]\n                (reduce (fn [acc j] (add-cell acc i j)) acc (range 3)))\n              [] (range 3)))\n          \n          (line? [l o]              \n            (= (count (filter #(and (not= o %) (= (cell %) p)) l)) 2)) \n          \n          (option? [o]\n            (not (empty? (filter #(line? % o) (lines o)))))]\n    \n    (set (filter option? (options)))))","user":"57d9bca1e4b0bd073c202405"},{"problem":119,"code":"(fn find-ttt-wins [player board]\n  (let [->winner (fn [board] ;; via problem 73\n                   (let [wins  #{#{:x} #{:o}}\n                         diags [(for [i (range (count board))]\n                                  (nth (nth board i) (dec (- (count board) i))))\n                                (for [i (range (count board))]\n                                  (nth (nth board i) i))]\n                         lines  (concat board\n                                        (apply map vector board)\n                                        diags)]\n\n                     (ffirst (filter #(wins (into #{} %)) lines))))]\n\n    (->> (for [x (-> board first count range)\n               y (-> board count range)]\n           [y x])\n         (map (fn [[y x]]\n                (when (= :e (get-in board [y x]))\n                  [[y x] (assoc-in board [y x] player)])))\n         (filter identity)\n         (filter #(= player (->winner (second %))))\n         (map first)\n         set)))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn winning-moves [xo board]\n  (let [\n  n 3\n  board-complete? (fn [board]\n    (let [rows (for [y (range n)] (for [x (range n)] [x y]))\n          cols (for [x (range n)] (for [y (range n)] [x y]))\n          diags (list (for [x (range n)] [x x])\n                      (for [x (range n)] [(- (- n 1) x) x]))\n          lines (concat rows cols diags)\n          positions (fn [board points]\n            (map (fn [[col row]] (-> board (nth row) (nth col))) points))\n          all? (fn [xo board line]\n            (when (every? (partial = xo) (positions board line))\n              xo))]\n      (some identity (concat (map (partial all? :x board) lines)\n                             (map (partial all? :o board) lines)))))\n  empty-positions (fn [board]\n    (->> (for [y (range n) x (range n)] [y x])\n         (filter #(= (get-in board %) :e))))\n  set-in (fn [board xo [row col]]\n    (assoc board row (assoc (nth board row) col xo)))\n  ]\n  (->> board\n       empty-positions\n       (filter #(board-complete? (set-in board xo %)))\n       set)))","problem":119,"user":"4e691c79535d8ccf87e9fe97"},{"problem":119,"code":"(fn win [side rows]\n  (letfn [(analyze [rows]\n            (let [cols (apply map vector rows)\n                  diag (fn [x] (map-indexed #(nth %2 %) x))\n                  diags [(diag rows) (diag (map reverse rows))]\n                  lines (concat rows cols diags)\n                  line-sets (map set lines)]\n              (first (some #{#{:x} #{:o}} line-sets))))]\n    (set\n      (filter\n        (fn [coordinates] (= side (analyze (assoc-in rows coordinates side))))\n        (for [x (range 3)\n              y (range 3)\n              :when (= :e (get-in rows [x y]))]\n          [x y])))))","user":"56ac81ace4b03c432f187347"},{"problem":119,"code":"(fn [side board]\n          (let [val (partial get-in board)\n                rows (map (fn [x] (map (fn [y] [x y]) (range 3))) (range 3))\n                cols (map (fn [x] (map (fn [y] [y x]) (range 3))) (range 3))\n                diags (list (map (fn [x] [x x]) (range 3))\n                            (map (fn [x] [x (- 2 x)]) (range 3)))]\n            (->> (concat rows cols diags)\n                  (filter (fn [line] (= 1 (count (filter #(= :e (val %)) line)))))\n                  (filter (fn [line] (= 3 (count (filter #(#{:e side} (val %)) line)))))\n                  (mapcat (fn [line] (filter #(= :e (val %)) line)))\n                  (set)\n)))","user":"4f463dfde4b0d56e7bb92b99"},{"problem":119,"code":"(fn tttwin[side board]    \n  (letfn[(ttt[b]\n           (let [size (count b)\n                 r (range size)\n                 s1 (into b (map vec (partition size (apply interleave b))))\n                 s2 (conj s1 (vec (map #(nth (nth b %)%) r)))\n                 s3 (conj s2 (vec (map #(nth (nth b %1)%2) r (reverse r))))\n                 res (ffirst (filter #(apply = %) s3))]\n             (if (= :e res) nil res)))\n         (winning-move? [board x y]\n           (let [curr (get (get board x) y)]\n             (if (= :e curr)\n                (ttt (assoc-in board [x y] side))                   \n                false)))]\n    (into #{}                                                          \n      (for [x (range 3) \n            y (range 3)\n            :when (winning-move? board x y)] \n        [x y]))))","user":"52f426fce4b05e3f0be25f1e"},{"problem":119,"code":"(fn\n  [piece board]\n  (letfn [(pRow [board value row]\n            (every? (partial = value) (board row)))\n          (pCol [board value col]\n            (every? (partial = value) (map #(% col) board)))\n          (pDiag [board value]\n            (or (= value\n                   (get-in board [0 0])\n                   (get-in board [1 1])\n                   (get-in board [2 2]))\n                (= value\n                   (get-in board [0 2])\n                   (get-in board [1 1])\n                   (get-in board [2 0]))))\n          (win [board value]\n            (or (some (partial pRow board value) (range 3))\n                (some (partial pCol board value) (range 3))\n                (pDiag board value)))]\n    (set (for [row (range 3)\n               col (range 3)\n               :when (= :e (get-in board [row col]))\n               :when (win (update-in board [row col] (fn [old] piece)) piece)]\n           [row col]))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn wattt [p b]\n  (let [win-cords [[[0 0] [0 1] [0 2]]  ; 1st row\n                   [[1 0] [1 1] [1 2]]  ; 2nd row\n                   [[2 0] [2 1] [2 2]]  ; 3rd row\n                   [[0 0] [1 0] [2 0]]  ; 1st column\n                   [[0 1] [1 1] [2 1]]  ; 2nd column\n                   [[0 2] [1 2] [2 2]]  ; 3rd column\n                   [[0 0] [1 1] [2 2]]  ; left to right diagonale\n                   [[0 2] [1 1] [2 0]]] ; right to left diagonale\n        get-value-at (fn  [b cords] \n                       {:val ((b (cords 0)) (cords 1)), :cords cords})       \n        get-values-at (fn  [b ps]\n                        (loop [ps1 ps, result []]\n                          (if (empty? ps1)\n                            result\n                            (recur (rest ps1) (conj result (get-value-at b (first ps1))))\n                            )))   \n        get-values-at-cordss (fn [b cordss]\n                               (loop [result [], cords1 cordss]\n                                 (if (empty? cords1)\n                                   result\n                                   (let [f (first cords1)\n                                         v (get-values-at b f)]\n                                     (recur (conj result v) (rest cords1))\n                                     ))))\n        winnable? (fn [win-cords p e]\n                    (loop [cp 0, ce 0, wc1 win-cords]\n                      (if (empty? wc1)\n                        (and (= (-> win-cords count dec) cp) (= 1 ce))\n                        (let [v ((first wc1) :val)]\n                          (cond\n                            (= v p) (recur (inc cp) ce (rest wc1))\n                            (= v e) (recur cp (inc ce) (rest wc1))\n                            :else (recur cp ce (rest wc1)))\n                          ))))\n        get-empty-cords (fn [cords e]\n                          (filter #(= (% :val) e) cords))\n        values-at-cordss (get-values-at-cordss b win-cords)\n        winnable-cordss (filter #(winnable? % p :e) values-at-cordss)\n        empty-cords (map #(get-empty-cords % :e) winnable-cordss)\n        empty-cords2 (map #((first %) :cords) empty-cords)\n        ]\n    (set empty-cords2) \n    ))","problem":119,"user":"52cf084ce4b07d0d72b27399"},{"problem":119,"code":"(fn [turn table]\n  (let [xs (vec (apply concat table))\n        winning-index [[0 1 2] [3 4 5]\n                       [6 7 8] [0 3 6]\n                       [1 4 7] [2 5 8]\n                       [0 4 8] [2 4 6]]\n        indexed (fn [n l] (filter #(= n (xs %)) l))\n        turn-indexed (map #(indexed turn %) winning-index)\n        empty-indexed (map #(indexed :e %) winning-index)]\n    (->> (map vector turn-indexed empty-indexed)\n         (filter #(and (= 2 (count (first %)))\n                       (= 1 (count (second %)))))\n         (map #(-> % second first))\n         (map #(vector (quot % 3) (rem % 3)))\n         (into #{}))))","user":"5cb41c40e4b026601754b911"},{"problem":119,"code":"(fn winning-moves\n  [team board]\n  (let [rows (into []\n                   (for [i (range (count board))]\n                     (into [] (for [j (range (count (first board)))]\n                                [i j]))))\n        cols (apply map vector rows)\n        diags (apply map vector\n                     (for [r (range (count board))\n                           :let [c (dec (count (first board)))]]\n                       [[r r]\n                        [r (- c r)]]))\n        all (into [] (concat rows cols diags))\n        candidates (map \n                    (fn [x] (vector x \n                                    (mapv #(get-in board %) x))) \n                    all)\n        winning-positions (filter \n                           #(= 2 (team (frequencies (second %))))\n                           candidates)\n        individual-moves (into #{}\n                               (mapv first\n                                     (filter #(= (second %) :e)\n                                             (mapcat #(apply map vector %) \n                                                     winning-positions))))]\n    individual-moves))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn [p b]\n  (let [w? #(some #{[p p p]}\n                  (concat\n                   % (apply map vector %)\n                   (for [d [[[0 2] [1 1] [2 0]] [[0 0] [1 1] [2 2]]]]\n                     (for [[y x] d]\n                       ((% y) x)))))]\n  (set\n    (for [y [0 1 2] x [0 1 2]\n          :when (and (= :e ((b y) x))\n                     (w? (assoc b y (assoc (b y) x p))))]\n      [y x]))))","problem":119,"user":"4dbb0b6c535d1e037afb21b0"},{"problem":119,"code":"(fn winning-moves [piece board]\n  (letfn [(mates [[i j]]\n            (let [row (for [x (range 3)] [i x])\n                  col (for [y (range 3)] [y j])\n                  diag1 (for [i (range 3)] [i i])\n                  diag2 (for [i (range 3)] [i (- 2 i)])\n                  result (filter #(some #{[i j]} %) #{row col diag1 diag2})]\n              (map #(remove #{[i j]} %) result)))]\n    (reduce\n     (fn [moves [i j]]\n       (if (some\n            (fn [[p1 p2]]\n              (= (map #(get-in board %) [p1 p2 [i j]])\n                 [piece piece :e]))\n            (mates [i j]))\n         (conj moves [i j])\n         moves))\n     #{}\n     (for [i (range 3) j (range 3)] [i j]))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [elt b]\n  (let [win-lines\n    (map #(into #{} %)\n      (mapcat\n        #(partition 3 %)\n        (concat\n          ((juxt (partial map first) (partial map last))\n                   (for [x (range 3) y (range 3)] [[x y] [y x]]))\n          [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]])\n        ))\n        win? (fn [e brd]\n               (some\n                 #(every?\n                    (fn [f] (= e f))\n                    (map (fn [cell] (get-in brd cell)) %))\n                 win-lines)\n               )]\n    (set\n      (filter\n        #(and\n          (= :e (get-in b %))\n          (win? elt (assoc-in b % elt)))\n        (for [x (range 3) y (range 3)] [x y])))))","problem":119,"user":"504c8165e4b09724c857af31"},{"problem":119,"code":"(let [gen (fn [s1 s2] (map vector s1 s2))\n      threes (concat (list (gen (range 3) (range 3)))\n                     (list (gen (range 3) (reverse (range 3))))\n                     (map (partial gen (range 3)) (map repeat (range 3)))\n                     (map #(gen (repeat %) (range 3)) (range 3)))\n      marks (fn [b coll] (map (partial get-in b) coll))\n      winner (fn [s symbol-row] (= {:e 1 s 2} (frequencies symbol-row)))]\n  (fn [s board] (set (filter #(= :e (get-in board %)) (apply concat (filter #(winner s (marks board %)) threes))))))","user":"554680cbe4b0a04f7929953e"},{"problem":119,"code":"(fn [piece board]\n  (letfn [(Win? [board]\n                (letfn [(f [x]\n                           (if (apply = x)\n                             (let [y (get x 0)]\n                               (if (= y :e)\n                                 nil\n                                 y))))]\n                  (or (reduce #(or %1 %2) (map f board))\n                      (reduce #(or %1 %2) (map #(f (vec (map (fn [x] (get x %)) board))) (range 3)))\n                      (f (vec (map #(get (get board %) %) (range 3))))\n                      (f (vec (map #(get (get board %) (- 2 %)) (range 3))))\n                      )))]\n    (set (filter (fn [loc]\n              (if (= :e (get-in board loc))\n                (Win? (assoc-in board loc piece))\n                false)) \n            (mapcat (fn [i] (map #(vector i %)\n                                 (range 3)))\n                    (range 3))))))","user":"55f73078e4b06e875b46cea4"},{"problem":119,"code":"(fn makeWinner [elem board]\n  (letfn [(winnerTicTacToe [board]\n            (letfn [(row [i] (board i))\n                    (col [i] (mapv #(nth % i) board))\n                    (lr [] [(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])])\n                    (rl [] [(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])])\n                    (elemWin [elem]\n                      (or\n                       (every? #(= elem %) (row 0))\n                       (every? #(= elem %) (row 1))\n                       (every? #(= elem %) (row 2))\n                       (every? #(= elem %) (col 0))\n                       (every? #(= elem %) (col 1))\n                       (every? #(= elem %) (col 2))\n                       (every? #(= elem %) (lr))\n                       (every? #(= elem %) (rl))))]\n              (cond\n                (elemWin :x) :x\n                (elemWin :o) :o\n                :else nil)))]\n    (into #{}   \n          (for [x (range 3)\n                y (range 3)\n                :when (= (get-in board [x y]) :e)\n                :when (= elem (winnerTicTacToe (assoc-in board [x y] elem)))]\n            [x y]))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [piece board]\n    (letfn\n      [(indexed-board\n         [board]\n         (map (fn [cells]\n                  (let [y-idx (first cells)\n                        indexed-cells (map-indexed list (second cells))]\n                    (map #(list [y-idx (first %)] (second %))\n                         indexed-cells)))\n              (map-indexed list board)))\n       (winnable-cells?\n         [cells piece]\n         (and (= (count-piece cells piece) 2)\n              (= (count-piece cells :e) 1)))\n       (count-piece\n         [cells piece]\n         (count (filter #(= (second %) piece) cells)))\n       (get-diagonal-cells\n         [board]\n         (let [f #(map (fn [[x y]] (get-cell board x y)) %)]\n           (list (f [[0 0] [1 1] [2 2]])\n                 (f [[2 0] [1 1] [0 2]]))))\n       (get-cell\n         [board x y]\n         ((vec ((vec board) y)) x))\n       (get-winnable-cell\n         [cells]\n         (first (filter #(= (second %) :e) cells)))]\n      (let [idxed-board (indexed-board board)]\n        (set\n          (map\n            #(first (get-winnable-cell %))\n            (filter\n              #(winnable-cells? % piece)\n              (concat idxed-board\n                      (apply map list idxed-board)\n                      (get-diagonal-cells idxed-board)\n                      )))))))","problem":119,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":119,"code":"(fn f [a b]\n  (let [p (for [x (range 3) y (range 3)] [x y])\n        c #(group-by (fn [[x y]]\n            (let [e [x y (= x y) (= 2 (+ x y))]] (e %))) p)\n        s (mapcat (comp vals c) (range 4))\n        g (fn f [e]\n            (let [v (mapv #(get-in b %) e)]\n              (if (= (frequencies v) {a 2 :e 1})\n                  (keep-indexed #({:e (e %1)} %2) v))))]\n    (set (mapcat g s))))","user":"548b7db8e4b0e286459a11fd"},{"problem":119,"code":"(fn wt[p b] \n  (letfn [(at[a] \n            (let [lines (vector (into [] (get a 0)) \n                                (into [] (get a 1))\n                                (into [] (get a 2))\n                                (vector (aget a 0 0) (aget a 1 0) (aget a 2 0))\n                                (vector (aget a 0 1) (aget a 1 1) (aget a 2 1))\n                                (vector (aget a 0 2) (aget a 1 2) (aget a 2 2))\n                                (vector (aget a 0 0) (aget a 1 1) (aget a 2 2))\n                                (vector (aget a 0 2) (aget a 1 1) (aget a 2 0)))]\n              (cond \n                (not (empty? (filter #(= [:o :o :o] %) lines))) :o\n                (not (empty? (filter #(= [:x :x :x] %) lines))) :x\n                :else nil)))]\n    (let [a (to-array-2d b)]\n      (set (for [i [0 1 2]\n                 j [0 1 2]\n                 :let [l (aget a i j)\n                       e (= :e l)\n                       _ (aset a i j p)\n                       t (= p (at a))\n                       _ (aset a i j l)]\n                 :when (and e t)]\n             (vector i j))))))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn [piece board]\n  (let [wins [[[0 0] [0 1] [0 2]]\n              [[1 0] [1 1] [1 2]]\n              [[2 0] [2 1] [2 2]]\n              [[0 0] [1 0] [2 0]]\n              [[0 1] [1 1] [2 1]]\n              [[0 2] [1 2] [2 2]]\n              [[0 0] [1 1] [2 2]]\n              [[0 2] [1 1] [2 0]]]]\n    (->>\n     (for [points wins]\n       (apply merge-with concat\n              (for [p points] {(get-in board p) [p]})))\n     (filter #(and (= 2 (count (% piece)))\n                   (= 1 (count (% :e)))))\n     (map #(first (% :e)))\n     (set))))","problem":119,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":119,"code":";; Just copied in analyse function from Problem 73.\n(fn win [p b]\n  (letfn [ (analyse [v]\n                    (let [verts (partition 3 (apply interleave v))\n                          diags [ [((v 0) 0) ((v 1) 1) ((v 2) 2)]\n                                  [((v 0) 2) ((v 1) 1) ((v 2) 0)]]\n                          complete (concat v verts diags)]\n                      (if (some #(= % [:x :x :x]) complete)\n                        :x\n                        (if (some #(= % [:o :o :o]) complete)\n                          :o\n                          nil))))\n           ]\n    (->> (for [x (range 3) y (range 3)] [x y])\n         (filter #(= :e (get-in b %)) )\n         (filter #(= p (analyse (assoc-in b % p) )))\n         set))\n  )","user":"53c1ce3ee4b00fb29b221268"},{"problem":119,"code":"(fn [piece board]\n    (letfn [;; unoccupied cells on the board\n            (available [board] (for [x (range 3) y (range 3) :when (= :e (get-in board [x y]))] [x y]))\n\n            (make-diagonal [board diagonal xy] (if ((set diagonal) xy) (map #(get-in board %) diagonal) []))\n            (row [board [x y]] (nth board x))\n            (column [board [x y]] (map #(nth % y) board))\n            (up-diag [board xy] (make-diagonal board [[0 0] [1 1] [2 2]] xy))\n            (down-diag [board xy] (make-diagonal board [[2 0] [1 1] [0 2]] xy))\n\n            ;; every row, column, or diagonal containing this xy coordinate\n            (containers [board xy] (remove empty? [(row board xy) (column board xy) (up-diag board xy) (down-diag board xy)]))\n\n            ;; test that a row, column, or diagonal wins for the given playing piece\n            (rcd-wins? [rcd piece] (every? #(= piece %) rcd))\n\n            (play-wins? [board piece xy] (some #(rcd-wins? % piece) (containers (assoc-in board xy piece) xy)))\n\n            (winning-moves [piece board] (set (filter #(play-wins? board piece %) (available board))))\n            ]\n      (winning-moves piece board)))","user":"52485f02e4b05ef8e38e63d3"},{"code":"(fn tic-tac-toe-winning-moves [player board]\n  (letfn [(transpose [board]\n            (map (fn [col]\n                   (map #(nth % col) board)) (range (count board))))\n          (label-board [board]\n            (map-indexed (fn [row-idx row]\n                           (map-indexed #(vector row-idx %1 %2) row)) board))\n          (is-row-almost-filled? [player row]\n            (= 2 (count (filter #(= (nth % 2) player) row))))\n          (position-of-empty-square [row]\n            (take 2 (first (filter #(= (nth % 2) :e) row))))\n          (almost-filled-rows [player board]\n            (filter (partial is-row-almost-filled? player) board))\n          (diagonal [board]\n            (map #(nth (nth board %) %) (range (count board))))\n          (winning-positions [player labeled-board]\n            (reduce into [] (map position-of-empty-square\n                                 (almost-filled-rows player labeled-board))))]\n    (let [labeled-board (label-board board)\n          transposed-labeled-board (transpose labeled-board)\n          flipped-board (map reverse labeled-board)]\n      (->> (list (winning-positions player labeled-board)\n                 (winning-positions player transposed-labeled-board)\n                 (winning-positions player (list (diagonal labeled-board)))\n                 (winning-positions player (list (diagonal flipped-board))))\n           (remove empty?) distinct set))))","problem":119,"user":"4ff355a1e4b0678c553fc34d"},{"problem":119,"code":"(fn [me board]\n  (set (for [x [0 1 2]\n             y [0 1 2]\n             :when (and (= :e (get-in board [y x]))\n                        (let [[[a b c] [d e f] [g h i]] (assoc-in board [y x] me)]\n                          (or (= me a b c) (= me d e f) (= me g h i) (= me a e i)\n                              (= me a d g) (= me b e h) (= me c f i) (= me c e g))))]\n         [y x])))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":119,"code":"(fn [piece board]\n  (letfn [(winner? [b]\n            (letfn [(check [cs]\n                      (let [ps (map (partial get-in b) cs)]\n                        (when (and (apply = ps)\n                                   (not= (first ps) :e))\n                          (first ps))))]\n              (some check [[[0 0] [0 1] [0 2]]\n                           [[1 0] [1 1] [1 2]]\n                           [[2 0] [2 1] [2 2]]\n                           [[0 0] [1 0] [2 0]]\n                           [[0 1] [1 1] [2 1]]\n                           [[0 2] [1 2] [2 2]]\n                           [[0 0] [1 1] [2 2]]\n                           [[0 2] [1 1] [2 0]]])))]\n    (->> (for [i (range 3) j (range 3)] [i j])\n         (filter (fn [[i j]]\n                   (= :e (get-in board [i j]))))\n         (filter (fn [[i j]]\n                   (winner? (assoc-in board [i j] piece))))\n         (set))))","user":"55c4e48be4b0e31453f649a7"},{"problem":119,"code":"(fn [player board]\n  (letfn [(ttt [board]\n            (letfn [(rows [board]\n                      board)\n                    (cols [[[a b c]\n                            [d e f]\n                            [g h i]]]\n                      [[a d g]\n                       [b e h]\n                       [c f i]])\n                    (diags [[[a b c]\n                             [d e f]\n                             [g h i]]]\n                      [[a e i] [g e c]])\n                    (lines [board]\n                      (concat (rows board)\n                              (cols board)\n                              (diags board)))\n                    (winner [p board]\n                      (if (some (partial every? (partial = p)) (lines board)) p nil))]\n              (winner player board)))]\n    (->> (for [i (range 3) j (range 3)] [i j])\n         (filter #(= (get-in board %) :e))\n         (filter #(ttt (update-in board % (constantly player))))\n         (into #{}))))","user":"57a4fa50e4b0a966079561f1"},{"code":"(fn [player board]\n  (let [empty-cells\n        (for [[row-index row] (map-indexed vector board)\n              [col-index cell] (map-indexed vector row)\n              :when (= :e cell)]\n          [row-index col-index])\n\n        horizontal-row-cells\n        (fn [[row _]]\n          (vec (map #(vector row %) (range 3))))\n\n        vertical-row-cells\n        (fn [[_ column]]\n          (vec (map #(vector % column) (range 3))))\n\n        top-left-to-bottom-right-diagonal\n        [[0 0] [1 1] [2 2]]\n\n        bottom-left-to-top-right-diagonal\n        [[0 2] [1 1] [2 0]]\n\n        diagonal-row-cells\n        (fn [cell]\n          (condp contains? cell\n            #{[0 0] [2 2]} top-left-to-bottom-right-diagonal\n            #{[0 2] [2 0]} bottom-left-to-top-right-diagonal\n            nil))\n\n        rows-of-cell\n        (fn [cell]\n          (->>\n           (map #(% cell) [horizontal-row-cells\n                           vertical-row-cells\n                           diagonal-row-cells])\n           (remove nil?)))\n\n        get-values\n        (fn [cells]\n          (map (partial get-in board) cells))\n\n        count-player-pieces\n        (fn [cells]\n          (count (filter #{player} (get-values cells))))\n\n        player-pieces-per-row-from-cell\n        (fn [cell]\n          (map #(count-player-pieces %) (rows-of-cell cell)))\n\n        winning-cell?\n        (fn [ cell]\n          (and (= :e (get-in board cell))\n               (some (partial = 2) (player-pieces-per-row-from-cell cell))))]\n    (set (filter winning-cell? empty-cells))))","problem":119,"user":"4e68c434535d8ccf87e9fe89"},{"problem":119,"code":";; Dit heb ik niet zelf gemaakt! Gewoon om te kijken wat de oplossing kon zijn!\n\n(fn win [p b]\n  (let [win? (fn [board]\n               (let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n                     rows (map same? board)\n                     cols (map same? (apply map vector board))\n                     diagonal1 (same? (map get board [0 1 2]))\n                     diagonal2 (same? (map get board [2 1 0]))]\n                 (some #{:x :o} (concat rows cols [diagonal1] [diagonal2]))))\n        free (for [y (range 3) \n                   x (range 3)\n                   :when (= :e (get-in b [y x]))]\n               [y x])]\n    (set (filter #(= p (win? (assoc-in b % p))) free))))","user":"560d2a2be4b05f002753df35"},{"problem":119,"code":"(fn [pl brd]\n  (let [winner (fn [[[a b c] [d e f] [g h i]]]\n                 (or (ffirst (filter #(apply = %)\n                                     [[a b c] [d e f] [g h i] [a e i]\n                                      [c e g] [a d g] [b e h] [c f i]]))\n                     :draw))\n        tp (fn [xy] (when (= :e (get-in brd xy)) (assoc-in brd xy pl))) ;; try play\n        moves (for [x (range 3) y (range 3)] [x y])\n        winners (map winner (map tp moves))\n        wm (map vector winners moves)] \n    (into #{} (map second (filter #(= pl (first %)) wm)))))","user":"4e8768f6535dceadca469850"},{"code":"(let [wins (fn [s t]\n(cond\n  (some identity (for [x (range 3)] (every? #(= s (nth % x)) t))) s\n  \n  (some identity (for [x (range 3)] (every? #(= s %) (nth t x)))) s\n  \n  (every? #(= s %) (for [x (range 3)] (nth (nth t x) x))) s\n  (every? #(= s %) (for [x (range 3)] (nth (nth t x) (- 2 x)))) s\n  \n  ))\n\nr (fn [t [x y] s]\n   ;(println ((t x) y))\n     (assoc t x (assoc (t x) y s)))\n]\n\n  (fn [s t]\n    (set (filter #(wins s (r t % s)) \n(for [x (range 3) y (range 3) :when (= ((t x) y) :e)] [x y]))\n)))","problem":119,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn tic-tac-toe-win [piece board]\n  (let [size (count board)\n        rng (range size)\n        winner? (fn [sqs] (every? #{piece} sqs))\n        rows board\n        cols (apply mapv vector rows)\n        diag1 (vec (for [d rng] (get-in board [d d])))\n        diag2 (vec (for [d rng] (get-in board [d (- size d 1)])))]\n    (set (for [r rng c rng\n          :let [square [r c]]\n          :when (= :e (get-in board square))\n          :when (or (winner? (assoc (rows r) c piece))\n                    (winner? (assoc (cols c) r piece))\n                    (and (= r c) (winner? (assoc diag1 r piece)))\n                    (and (= r (- size c 1)) (winner? (assoc diag2 r piece))))]\n      [r c]\n    ))))","problem":119,"user":"4df3d4f4535d08e6dec9fe2c"},{"code":"(fn [p b]\n    (let [all-moves #{[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]} \n          allowed? #(= :e (get-in b %))\n          new-board-for #(assoc-in b % p)\n          are-all-p #(= [p p p] %)\n          as-cols #(apply (partial map vector) %)\n          pieces-at (fn [b coords] (map #(get-in b %) coords))\n          has-winning-row? #(some are-all-p %)\n          has-winning-col? #(some are-all-p (as-cols %))\n          has-winning-diagonal? #(or (are-all-p (pieces-at % [[0 0] [1 1] [2 2]]))\n                                     (are-all-p (pieces-at % [[0 2] [1 1] [2 0]])))\n          winning? #(some identity\n                      ((juxt\n                         has-winning-row?\n                         has-winning-col?\n                         has-winning-diagonal?)\n                       (new-board-for %)))]\n      (set \n        (filter winning? \n                (filter allowed? all-moves)))))","problem":119,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn t-t-t [k m]\n  (let [dim-x (range (count m))\n        dim-y (range (count (first m)))\n        k-locs (vec (filter #(not (nil? %))\n                            (for [i dim-x, j dim-y]\n                              (if (= k (get-in m [i j]))\n                                [i j]\n                                nil))))\n        k-pairs (set (for [i k-locs, j k-locs :while (not= i j)] #{i j}))\n        e-locs (vec (filter #(not (nil? %))\n                            (for [i dim-x, j dim-y]\n                              (if (= :e (get-in m [i j]))\n                                [i j]\n                                nil))))\n        shapes #{#{[0 0] [0 1] [0 2]}\n                 #{[1 0] [1 1] [1 2]}\n                 #{[2 0] [2 1] [2 2]}\n                 #{[0 0] [1 1] [2 2]}\n                 #{[2 0] [1 1] [0 2]}\n                 #{[0 0] [1 0] [2 0]}\n                 #{[0 1] [1 1] [2 1]}\n                 #{[0 2] [1 2] [2 2]}}]\n    (set (for [e e-locs, k k-pairs :when (shapes (clojure.set/union #{e} k))] e))))","problem":119,"user":"50733b31e4b0e3170b5a869a"},{"problem":119,"code":"(letfn\n  [  ; First test: horizontal line of key \"k\"?\n    (test1 [board k]\n      (some (partial = #{k}) (map set board)))\n\n    ; Second test: diagonal of key \"k\"?\n    (test2 [board k]\n      ( = #{k} (set (map #(get-in board [% %]) [0 1 2]))))\n    \n    ; Third test: the other diagonal of key \"k\"?\n    (test3 [board k]\n      (= #{k} (set (map #(get-in board %) [[2 0] [1 1] [0 2]]))))\n    \n    ; Transpose board.\n    (transpose [board]\n      (apply map list board))\n\n    ; Full test for key \"k\".\n    (full-test [k board]\n      (or (test1 board k)\n          (test2 board k)\n          (test1 (transpose board) k)\n          (test3 board k)))\n\n    ; Full test\n    (winner? [k board]\n      (full-test k board))\n   \n   (empty-pos [board]\n     (for [i (range 3) j (range 3) :when (= :e (get-in board [i j]))]\n       [i j]))]\n  \n  (fn [k board]\n    (set (filter #(winner? k (assoc-in board % k)) (empty-pos board)))))","user":"53065acbe4b02e8216869792"},{"code":"(fn [sym board]\n  (letfn [\n    (sym-at [y x] (= sym (get-in board [y x])))\n    (finishes-row [y x]\n      (or\n        (every? #(or (= y %) (sym-at % x)) (range 3))\n        (every? #(or (= x %) (sym-at y %)) (range 3))\n        (and (= x y) (every? #(or (= y %) (sym-at % %)) (range 3)))\n        (and (= x (- 2 y)) (every? #(or (= x %) (sym-at (- 2 %) %)) (range 3)))))\n    (is-win [y x]\n      (and \n        (= :e (get-in board [y x]))\n        (finishes-row y x)))]\n    (set\n      (for [\n        y (range 3) \n        x (range 3)\n        :when (is-win y x)]\n        [y x]))))","problem":119,"user":"4f050dec535dcb61093f6bef"},{"problem":119,"code":"(fn winning-moves\n  [player board]\n  (let [i-range (range 0 (count board))\n        h (for [i i-range] (vector (nth board i) [i :i]))\n        v (for [i i-range] (vector (map #(nth % i) board) [:i i]))\n        diag-tl-br (vector (for [i i-range] (nth (nth board i) i)) [:i :i])\n        diag-bl-tr (vector (for [i (reverse i-range)] (nth (nth board i) (- (last i-range) i))) [:im :i])\n        opponent (first (disj #{:x :o} player))]\n    (->> ;; :i means the index of :e, :im means the maximum index minus the index of :e\n     (remove #(or ((set (first %)) opponent)\n                  (> (count (filter (partial = :e) (first %))) 1)) (concat h v [diag-tl-br] [diag-bl-tr]))\n     (map #(let [move-idx (.indexOf (first %) :e)\n                 idx-keys {:i move-idx :im (- (last i-range) move-idx)}\n                 f (fn [tuple-val] (if-let [idx-key-val (idx-keys tuple-val)] idx-key-val tuple-val))]\n             (mapv f (second %))))\n     set)))","user":"55a9e0fee4b0988bba2ad945"},{"problem":119,"code":"(fn [symbol b]\n  (letfn\n      [(ttt [b]\n       (let [rows (map identity b)\n             cols (apply mapv vector b)\n             diags (conj [] (map-indexed #(nth %2 %1) b)\n                         (map-indexed #(nth %2 %1) (reverse b)))\n             freqs (map frequencies (concat rows cols diags))\n             xwon (some #(= (:x %) 3) freqs)\n             owon (some #(= (:o %) 3) freqs)]\n         (cond (true? xwon) :x\n               (true? owon) :o\n               :else nil)))]\n    (let [coords (for [x (range 3) y (range 3)] [x y])\n          boards (map #(if (= :e (get-in b %)) (assoc-in b % symbol) b) coords)]\n      (set (filter (complement nil?)\n                   (map #(if (= (ttt %1) symbol) %2 nil) boards coords))))))","user":"589037b4e4b00487982d51d0"},{"code":"(fn [sub board]\n  (letfn [(columns [b] (apply map vector b))\n          (lrdiag [b] (map #(nth (nth b %) %) (-> b count range)))\n          (rldiag [b] (map #(nth (nth b %) (-' (count b) % 1)) (-> b count range)))\n          (winner-slice [r]\n            (cond\n             (not (every? #(= (first r) %) r)) nil\n             (= (first r) :e) nil\n             :else (first r)))\n          (all-slices [b] (concat b (columns b) [(lrdiag b)] [(rldiag b)]))\n          (winner [b] (first (remove nil? (map winner-slice (all-slices b)))))\n          (find-empties [b]\n            (let [esinr (fn [r] (filter #(= :e (nth r %)) (range (count r))))\n                  esinrs (map-indexed #(vector %1 (esinr %2)) b)\n                  coords (fn [er] (if (empty? (last er))\n                                   nil\n                                   (map #(vector (first er) %) (last er))))]\n              (mapcat coords esinrs)))\n          (replace-empties [r b]\n            (let [es (find-empties b)\n                  rep (fn [e ri]\n                        (if (= ri (first e))\n                          (assoc (nth b ri) (last e) r)\n                          (nth b ri)))\n                  repb (fn [e] (map #(rep e %) (range (count b))))]\n              (map #(vector % (repb %)) es)))\n          (wins [r b]\n            (let [res (replace-empties r b)\n                  win? (fn [el] (if (= r (winner (last el))) (first el) nil))]\n              (set (remove nil? (map win? res)))))]\n    (wins sub board)))","problem":119,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn [s b] ( set (for [x [0 1 2]\n                        y [0 1 2 ]\n                        :when (= (get-in b [x y]) :e)\n                        :let [\n                              tboard (update-in b [x y] (fn [c] s))\n                              sidewin (let [\n                         cols (partition 3 (apply interleave tboard))\n                         rows tboard\n                         diags [[(get-in tboard [0 0]) (get-in tboard [1 1]) (get-in tboard [2 2])]\n                                [(get-in tboard [0 2]) (get-in tboard [1 1]) (get-in tboard [2 0])]\n                               ]\n                         C (concat cols rows diags)\n                         freqs (set (map #(frequencies %1) C))]\n                   (cond \n                     (contains? freqs {s 3 }) true\n                     :else false))\n                             ]\n                        :when sidewin\n                        ]\n          [x y ])))","problem":119,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn tic-tac-toe [p board]\n  (let [get (fn [l c] ((board l) c))\n\n        but-one (fn [p v] (cond\n                            (and (= :e (v 2)) (= p (v 0) (v 1))) 2\n                            (and (= :e (v 1)) (= p (v 0) (v 2))) 1\n                            (and (= :e (v 0)) (= p (v 1) (v 2))) 0\n                            :else nil))\n        but-one-hor (fn [p v l]\n                      (when (but-one p v)\n                        [l (but-one p v)]))\n        but-one-ver (fn [p v c]\n                      (when (but-one p v)\n                        [(but-one p v) c]))\n        but-one-ldiag (fn [p v]\n                        (when (but-one p v)\n                          [(but-one p v) (but-one p v)]))\n        but-one-rdiag (fn [p v]\n                        (when (but-one p v)\n                          [(- 2 (but-one p v)) (but-one p v)]))]\n (set\n   (remove nil?\n     (concat\n       (map but-one-hor (repeat p) [(board 0) (board 1) (board 2)] (range 3))\n       (map but-one-ver (repeat p) [[(get 0 0) (get 1 0) (get 2 0)] \n                                    [(get 0 1) (get 1 1) (get 2 1)] \n                                    [(get 0 2) (get 1 2) (get 2 2)]] (range 3))\n       (map but-one-ldiag (repeat p) [[(get 0 0) (get 1 1) (get 2 2)]])\n       (map but-one-rdiag (repeat p) [[(get 2 0) (get 1 1) (get 0 2)]])\n)))))","problem":119,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":119,"code":"(fn [p b]\n  (let [f (fn [[x y z :as horz]]\n            (let [verts (map vector x y z)\n                  diags [[(nth x 0) (nth y 1) (nth z 2)]\n                         [(nth x 2) (nth y 1) (nth z 0)]]\n                  winner? (fn [k] (some true? (map #(every? (partial = k) %) (concat horz verts diags))))]\n              (cond\n                (winner? :x) :x\n                (winner? :o) :o\n                :else nil)))]\n    (->> (for [x [0 1 2] y [0 1 2]] [x y])\n         (filter #(and (= :e (get-in b %))(= p (f (assoc-in b % p)))))\n         set)))","user":"567c63f6e4b05957ce8c61bb"},{"problem":119,"code":"(fn an [pi l]\n  (let [p (for [r (range 0 3) \n                 c (range 0 3)\n                :let [pos [r c]]]\n            {pos (get-in l pos)})\n        pp (partition-all 3 p)\n        rotated ((juxt (partial map first) (partial map second) (partial map last)) pp)\n        [[q1 _ q3] [_ q2 _] [q4 _ q5]] pp\n        f (fn [l]\n            (let [k (mapv (partial apply val) l)\n                  e (.indexOf k :e)\n                  r (filter #(= pi %) k)\n                  z (and (= 2 (count r)) (apply = r) (< -1 e))]\n              (when z (first (keys (nth l e))))))\n        all (concat pp rotated (list [q1 q2 q5]) (list [q3 q2 q4]))]\n     (->> \n     (map f all)\n       (filter not-empty)\n      (into #{})\n      )))","user":"51aefceee4b09397d5109797"},{"problem":119,"code":"(fn [player board]\n          (let [pos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [6 4 2]] \n                board0 (flatten board)\n                lines (for [[a b c] pos] [(nth board0 a)(nth board0 b)(nth board0 c)]) ]\n            (set (filter (complement nil?) (reduce \n              (fn [acc idx0] \n                (let [v1 (nth lines idx0)\n                      posM1 (nth pos idx0)] \n                  (concat acc (map (fn [elem apos idx] \n                         (let [newvec (if (= :e (nth v1 idx)) (assoc v1 idx player) v1)\n                               dis0 (distinct newvec)\n                               win (and (= (count dis0) 1) (= player (first dis0)))\n                               convert (fn [idx] (let [i2 idx x (quot i2 3) y (rem i2 3)] [x y ])) ]\n                           (if (true? win)  (convert (nth posM1 idx)) )) \n                         )\n                       v1 posM1 [0 1 2]))))\n              #{}\n              (range 0 (count pos)))))))","user":"533c2605e4b0e30313ee6cd7"},{"problem":119,"code":"(fn try-moves [piece board]\n  (let [length (count board)\n        range (range length)]\n    (letfn [(to-matrix [board]\n              (mapv\n               (fn [row]\n                 (mapv #(case %\n                          :e 0\n                          :x 1\n                          :o -1)\n                       row))\n               board))\n\n            (major [matrix]\n              (mapv\n               #(nth (nth matrix %) %)\n               range))\n\n            (minor [matrix]\n              (mapv\n               #(nth (nth matrix %) (- 2 %))\n               range))\n\n            (diagonals [matrix]\n              [(major matrix) (minor matrix)])\n\n            (columns [matrix]\n              (apply mapv vector matrix))\n\n            (solutions [matrix]\n              (reduce into [matrix\n                            (diagonals matrix)\n                            (columns matrix)]))\n\n            (score [matrix]\n              (condp = (->> matrix\n                            solutions\n                            (map (partial reduce +))\n                            (filter #{length (- length)})\n                            first)\n                length :x\n                (- length) :o\n                nil))\n\n            (set-pos [r c v matrix]\n              (assoc matrix r (assoc (nth matrix r) c v)))]\n      (let [matrix (to-matrix board)]\n        (reduce\n         (fn [winners row]\n           (let [current-row (nth matrix row)]\n             (reduce\n              (fn [winners column]\n                (if (or (not= 0 (nth current-row column))\n                        (not= piece (score (set-pos row column (if (= :x piece) 1 -1) matrix))))\n                  winners\n                  (conj winners [row column])))\n              winners\n              range)))\n         #{}\n         range)))))","user":"55fbc657e4b0f488688e0666"},{"problem":119,"code":"(fn [turn board]\n  (letfn [(rows [board] board)\n          (columns [board] (apply map vector board))\n          (diagonal-top-to-bottom [board] [(mapv get board (range))])\n          (diagonal-bottom-to-top [board] [(mapv get (reverse board) (range))])\n          (winning-board? [board] (some #(apply = turn %) (reduce into [(rows board)\n                                                                   (columns board)\n                                                                   (diagonal-top-to-bottom board)\n                                                                   (diagonal-bottom-to-top board)])))]\n    (set (filter #(winning-board? (update-in board % (fn [& _] turn)))\n                 (for [x (range 3) y (range 3) :when (= (nth (nth board y) x) :e)]\n                   [y x])))))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn [mark board]\n  (letfn [(win? [board k]\n            (some #(every? (conj #{} k) %)\n                  (concat board\n                          (apply map vector board)\n                          (conj []\n                                (for [idx (range 3)]\n                                  (get-in board [idx idx]))\n                                (for [idx (range 3)]\n                                  (get-in board [idx (- 2 idx)]))))))]\n    (set\n     (filter #(win? (assoc-in board % mark) mark)\n             (set (for [ncol (range 3) nrow (range 3)\n                        :when (= (get-in board [nrow ncol]) :e)]\n                    [nrow ncol]))))))","problem":119,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn tic-tac-winner [player board]\n  ;; Most code copied from Problem 73: Analyze a Tic-Tac-Toe Board\n  (letfn [(transpose [b]\n            (apply map vector b))\n          (check-diag [f [[a _ e][_ b _][d _ c]]]\n            (or (f (list a b c))\n                (f (list d b e))))\n          (check-board [f b]\n            (or (some identity (map f b))\n                (some identity (map f (transpose b)))\n                (check-diag f b)))\n          (tic-tac-won [b]\n             (check-board #(every? (partial = player) %) b))]\n    (into #{}\n          (for [x (range 3) y (range 3)\n                :let [pos [x y]]\n                :when (and (= (get-in board pos) :e)                     \n                           (tic-tac-won (assoc-in board pos player)))]\n            [x y]))))","problem":119,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn [x m]\n  (let [g #(nth (nth m (first %)) (second %))\n        up (range 3)\n        dn (range 2 -1 -1)\n        zs (repeat 0)\n        os (repeat 1)\n        ts (repeat 2)\n        zip #(take 3 (partition 2 (interleave %1 %2)))\n        all [up dn zs os ts]\n        fe (fn [e xs] (filter #(= e (first %)) xs))\n        c= #(= (count %2) %1)]\n    (set (for [a all b all \n               :let [z (zip a b) m (map #(vec [(g %) %]) z) e (fe :e m)]\n               :when (and (c= 2 (fe x m)) (c= 1 e))]\n           (vec (second (first e)))))))","problem":119,"user":"4f32a7f1e4b0d6649770a095"},{"problem":119,"code":"(fn [? grid]\n  (letfn\n   [(checks [? [[a b c] [d e f] [g h i]]]\n      (or (= a b c ?)\n          (= d e f ?)\n          (= g h i ?)\n          (= a d g ?)\n          (= b e h ?)\n          (= c f i ?)\n          (= a e i ?)\n          (= c e g ?)))\n    (modify [? grid [x y]] (assoc-in grid [x y] ?))\n    (calc [? grid]\n          (into #{}\n                (for [x     (range 3)\n                      y     (range 3)\n                      :when (not= (get-in grid [x y]) :o)\n                      :when (checks ? (modify ? grid [x y]))] [x y])))]\n    (calc ? grid)))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":119,"code":"(fn [piece all]\n  (let [pos (fn [[x y z]] (cond (and (= :e x) (= piece y z)) 0\n                              (and (= :e y) (= piece x z)) 1\n                              (and (= :e z) (= piece y x)) 2\n                              :else nil))\n        transpose (into [] (apply map #(vector %1 %2 %3) all)) \n        hor (remove nil? (map #(let [a (pos (get-in all %))] (if (not (nil? a)) (conj % a)))  [[0] [1] [2]]))\n        ver (remove nil? (map #(let [a (pos (get-in transpose %))] (if (not (nil? a)) (vector a (first %))))  [[0] [1] [2]]))\n        d1 (into [] (remove nil? (let [indices [[2] [1] [0]] a (pos (map get-in all indices))] \n              (if (not (nil? a)) \n                   (vector a (first (get indices a)))))))\n        d2 (into []  (remove nil? (let [indices [[0] [1] [2]] a (pos (map get-in all indices))] \n              (if (not (nil? a)) \n                   (vector a (first (get indices a)))))))]\n   (into #{} (remove empty? (conj (into #{} (concat hor ver)) d1 d2)))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":119,"code":"(fn[p m]\n  (let[w? (fn[b] (let [a (concat b (apply map vector b) [[((b 0) 0) ((b 1) 1) ((b 2) 2)] [((b 2) 0) ((b 1) 1) ((b 0) 2)]])]\n    (some #(every? (fn[a] (= a p)) %) a)))]\n  (set (for [[i r] (map-indexed vector m)\n         [j e] (map-indexed vector r)\n    :when (and (= :e e) (w? (assoc-in m [i j] p)))]\n    [i j]))))","user":"56824e1be4b0945ebc182a91"},{"problem":119,"code":"(fn [sy original]\n(set (filter (fn [[y x]]\n          (let [board (assoc original y (assoc (get original y) x sy))]\n             (some (fn [s] \n                   (apply = (conj (map #(get-in board %) s) sy))) \n                   (concat \n                     [[[0 0] [1 1] [2 2]]]\n                     [[[0 2] [1 1] [2 0]]]\n                     (map (fn [x] [[0 x] [1 x] [2 x]]) (range 3))\n                     (map (fn [x] [[x 0] [x 1] [x 2]]) (range 3))))))\n        (for [y (range 0 3) x (range 0 3) \n          :when (= :e (get-in original [y x]))]\n         [y x]))))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [player board]\n  (let [win-row? (fn [p b row] (every? #(= p %) row))\n        win? (fn [p b]\n               (or\n                 (win-row? p b (first b))\n                 (win-row? p b (second b))\n                 (win-row? p b (nth b 2))\n                 (win-row? p b (map first b))\n                 (win-row? p b (map second b))\n                 (win-row? p b (map #(nth % 2) b))\n                 (win-row? p b [(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])])  \n                 (win-row? p b [(get-in b [2 0]) (get-in b [1 1]) (get-in b [0 2])])  \n                 ))]\n    (set\n      (for [y (range 3) x (range 3)\n            :when (= (get-in board [y x]) :e)\n            :let [b (update-in board [y x] (fn [o] player))]\n            :when (win? player b)]\n        [y x]))))","problem":119,"user":"52a88c4de4b0c58976d9ac30"},{"problem":119,"code":"(fn winning-moves [sym board]\n  (->> [0 1 2 3 4 5 6 7 8 0 3 6 1 4 7 2 5 8 0 4 8 2 4 6]\n       (map #(let [x (vector (quot % 3) (mod % 3))] (vector (get-in board x) x)))\n       ((fn [xs] (map #(group-by first %) (partition 3 xs))))\n       (filter #(and (-> % :e count (= 1)) (-> % sym count (= 2))))\n       (reduce #(conj %1 (-> %2 :e first last)) #{})))","user":"5383668ee4b06839e8705edd"},{"code":"(fn __ [p b]\n  (let [judge (fn [board]\n                (let [bt (apply map vector board)\n                      cross [(map #(-> board (nth %) (nth %)) (range 3))\n                             (map #(-> board (nth (- 2 %)) (nth %)) (range 3))]]\n                  (cond\n                    (some #(= (distinct %) [:x]) board) :x\n                    (some #(= (distinct %) [:x]) bt) :x\n                    (some #(= (distinct %) [:x]) cross) :x\n                    (some #(= (distinct %) [:o]) board) :o\n                    (some #(= (distinct %) [:o]) bt) :o\n                    (some #(= (distinct %) [:o]) cross) :o\n                    :else nil)\n                  ))]\n    (into #{} (for [x (range 3) y (range 3) \n                    :when (and (= :e (-> b (nth x) (nth y)))\n                               (= p (judge (assoc-in b [x y] p))))]\n                [x y]))))","problem":119,"user":"52828298e4b0757a1b17145b"},{"problem":119,"code":"(fn [v b]\n   (letfn [(upd [s i f] (let [[p1 p2] (split-at i s)]\n                          (concat p1 [(f (first p2))] (rest p2))))\n           (win [b] (or (some true? (map #(every? (fn[x] (= x v)) %) b))\n                        (= v (ffirst b) (second (second b)) (last (last b)))\n                        (= v (last (first b)) (second (second b)) (first (last b)))))\n           (rotate [b] (for [i (range 3)]\n                         (mapv #(nth % i) b)))]\n     (set (filter (complement nil?)\n                  (for [i (range 3) j (range 3)]\n                    (let [bu (upd b i #(upd % j (fn [x] (if (= x :e) v x))))]\n                      (if (or (win bu) (win (rotate bu)))\n                        [i j])))))))","user":"5d764e52e4b02e6b30c93524"},{"problem":119,"code":"(fn wins [p t]\n  (letfn [(tic-tac-toe [b]\n            (letfn [(rev [rows]\n              (map (fn [i] (map (fn [r] (nth r i)) rows))\n                (range (count rows))))\n                (diagonal [rows]\n                  (map (fn [i] (nth (nth rows i) i)) (range (count rows))))\n                (wins? [p row] (= (count row) (count (filter #(= % p) row))))]\n                  (->> [b (rev b) [(diagonal b) (diagonal (reverse b))]]\n                      (reduce concat)\n                      (map (fn [x]\n                              (cond (wins? :x x) :x\n                                    (wins? :o x) :o\n                                    :else :e)))\n                      (filter #(not= % :e))\n                      first)))\n          (get-item [pos table] (nth (nth table (first pos)) (last pos)))\n          (get-move [w pos table]\n            (map (fn [x] (if (= x (first pos))\n                             (map (fn [i] (if (= i (last pos))\n                                              w\n                                              (nth (nth table x) i))) (range (count table)))\n                             (nth table x)))\n                 (range (count table))))]\n    (->>\n      (for [x (range (count t))\n            y (range (count t))]\n            [x y])\n      (filter #(= :e (get-item % t))) ; empty positions\n      (filter #(= p (tic-tac-toe (get-move p % t))))\n      (into #{}))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":119,"code":"(fn win-ttt [p board]\n  (let [rows [\n              [\n               [0 0] [0 1] [0 2]]\n              [\n               [1 0] [1 1] [1 2]]\n              [\n               [2 0] [2 1] [2 2]]\n              [\n               [0 0] [1 0] [2 0]]\n              [\n               [0 1] [1 1] [2 1]]\n              [\n               [0 2] [1 2] [2 2]]\n              [\n               [0 0] [1 1] [2 2]]\n              [\n               [0 2] [1 1] [2 0]]]\n        e_rows (map (fn [row]\n                      (map #(get-in board %) row))\n                    rows)\n        freqs (map frequencies e_rows)\n        win-rows (map #(list (first %) (.indexOf (nth e_rows (first %)) :e))\n                      (filter second\n                              (map-indexed\n                               #(list %1 (= %2 {p 2 :e 1})) freqs)))\n        ]\n    (set (map #(nth (nth rows (first %)) (second %)) win-rows))))","user":"587ee260e4b052da650a6353"},{"problem":119,"code":"(fn [xo b]\n  (letfn [(winner [b]\n            (letfn [(win [ts xo] (if (some identity (map #(every? #{xo} %) ts)) xo))\n                    (diag [b] (vector (flatten (partition 1 4 (flatten b)))))]\n              (let [rs (concat b (apply map list b) (diag b) (diag (map reverse b)))]\n                (some identity (map #(win rs %) [:x :o])))))]\n    (let [bs (for [i (range 3) j (range 3) :when (= :e (get-in b [i j]))]\n               [[i j] (winner (assoc-in b [i j] xo))])]\n         (set (map first (filter #(= xo (second %)) bs))))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn [x t]\n  (set (keep\n        #(if % [(quot % 3) (rem % 3)])\n        (map\n         #({[x x :e] (% 2) [x :e x] (% 1) [:e x x] (% 0)} (map (vec (apply concat t)) %))\n         [[0 1 2] [0 3 6] [0 4 8] [1 4 7] [2 5 8] [2 4 6] [3 4 5] [6 7 8]]))))","problem":119,"user":"4f296a80e4b0d6649770a02a"},{"problem":119,"code":"(fn [a board]\n  (letfn [(v [x y]\n              (nth (nth board x) y))\n            (same? [x y cc]\n              (->> cc\n                   (filter #(not= [x y] %))\n                   (map #(apply v %))\n                   (every? #(= a %))))\n            (any-same? [x y ccc]\n              (some #(same? x y %) ccc))\n            (win? [x y]\n              (let [n (count board)\n                    rows (map #(map (partial list %) (range n)) (range n))\n                    cols (apply mapv list rows)\n                    diag (->> (range n)\n                              (map #(list [% %] [(- (dec n) %) %]))\n                              (apply mapv list))]\n                (or (any-same? x y rows)\n                    (any-same? x y cols)\n                    (any-same? x y diag))))]\n      (let [n (count board)]\n        (set (for [x (range n) y (range n) :when (and (= :e (v x y)) (win? x y))]\n               [x y])))))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":119,"code":"(fn winning-moves [piece board]\n  (let [empty-spaces\n        (filter identity\n                (mapcat identity\n                        (map-indexed (fn [i row] (map-indexed (fn [j val] (if (= val :e) [i j] nil)) row)) board)))\n        get-diagonal (fn get-diagonal [rows] (reduce (fn [diag row]\n                                                       (conj diag (get row (count diag)))) [] rows))\n        winning-move? (fn winning-move? [piece [r c] board]\n                        (let [board (assoc-in board [r c] piece)\n                              row (get board r)\n                              col (map #(get % c) board)]\n                          (some (fn [row] (every? #(= piece %) row))\n                                [row col (get-diagonal board) (get-diagonal (reverse board))])))]\n    (set (filter #(winning-move? piece % board) empty-spaces))))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn [p b]\n  (let [r [0 1 2]]\n    (set (filter\n          (fn [[y x]]\n            (first (filter #(= [:e p p] (sort %))\n                           [(b y) (map #(% x) b)\n                            (if (= x y) (map #(get-in b [% %]) r))\n                            (if (= y (- 2 x)) (map #(get-in b [(- 2 %) %]) r))])))\n          (for [x r y r :when (= :e (get-in b [y x]))] [y x])))))","problem":119,"user":"4e52d815535d302ef430da77"},{"problem":119,"code":"(fn [v t]\n  (let [n (count t)\n        f (fn [t]\n            (some (fn [r] (every? #(= v %) r))\n                  (concat t\n                          (partition n (apply interleave t))\n                          (map \n                            #(take-nth (inc n) (flatten %))\n                            [t (map reverse t)]))))\n        p (for [x (range n) y (range n)\n                :when (= (get-in t [x y]) :e)\n                :when (f (assoc-in t [x y] v))]\n            [x y])]\n    (set p)))","user":"57d9f603e4b0bd073c20240a"},{"problem":119,"code":"(fn tic-tac-toe [piece board] \n  (set\n  (let [board2 (apply map vector board)\n        diag #{[0 0] [1 1] [2 2]}\n        diag2 #{[0 2] [1 1] [2 0]}\n        ]\n    (letfn [(value [column row] (nth (nth board row) column))\n            (drop-nth [coll n] (concat (take n coll) (drop (inc n) coll)))\n            (winning? [coll] (every? #{piece} coll))\n            (wins-column [column row] (winning? (drop-nth (nth board2 column) row)))\n            (wins-row [column row] (winning? (drop-nth (nth board row) column)))\n            (wins-diagonal [column row d] (and (contains? d [column row]) (winning? (map #(apply value %) (remove #{[column row]} d)))))\n            (wins [column row] (and (= :e (value column row))\n                                    (or (wins-column column row)\n                                        (wins-row column row)\n                                        (wins-diagonal column row diag)\n                                        (wins-diagonal column row diag2))))]\n      (for [row [0 1 2]\n            column [0 1 2]\n            :when (wins column row)] [row column])))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn ttt-win [piece board]                                                                                                                                                                                 \n  (letfn [(winner [p row] (apply = p row))                                                                                                                                                                  \n          (row [n b] (nth b n))                                                                                                                                                                             \n          (col [n b] (nth (apply map vector b) n))                                                                                                                                                          \n          (d1 [b] [(get-in b [0 0]) (get-in b [1 1]) (get-in b [2 2])])                                                                                                                                     \n          (d2 [b] [(get-in b [2 0]) (get-in b [1 1]) (get-in b [0 2])])                                                                                                                                     \n          (game-win [p b] (some identity                                                                                                                                                                    \n                                (concat (list (winner p (d1 b)) (winner p (d2 b)))                                                                                                                          \n                                        (for [i (range 3)]                                                                                                                                                  \n                                          (or (winner p (row i b))                                                                                                                                          \n                                              (winner p (col i b)))))))                                                                                                                                     \n          (add-piece [board [p x y]]                                                                                                                                                                        \n            (let [curr (get-in board [x y])]                                                                                                                                                                \n              (if (= curr :e)                                                                                                                                                                               \n                (assoc-in board [x y] p)                                                                                                                                                                    \n                board))                                                                                                                                                                                     \n               )]                                                                                                                                                                                           \n                                                                                                                                                                                                            \n    (set (for [x (range 3) y (range 3) :when (game-win piece (add-piece board [piece x y]))] [x y]))                                                                                                        \n))","problem":119,"user":"4f1d1299535d64f603146487"},{"problem":119,"code":"(fn [p t]\n\t(let [won? (fn [t] \n\t\t\t\t\t(= p (let [line (fn [l] (let [d (distinct l)] (if (= (count d) 1) (first d) :e)))\n\t\t\t\t\t\t  c (fn [x y] (fn [s] (comp (nth (nth s x) y))))\n\t\t\t\t\t\t  diags (fn [x] [((juxt (c 0 0) (c 1 1) (c 2 2)) x)\n\t\t\t\t\t\t\t\t\t\t ((juxt (c 2 0) (c 1 1) (c 0 2)) x)])]\n\t\t\t\t\t\t(first (filter #(not (= % :e)) (map line (concat t (vec (apply map vector t)) (diags t))))))))]\n\t\t\t\t\t(set (map first (filter #(won? (second %))\n\t\t\t\t\t(for [x (range 3) y (range 3) :when (= :e (get-in t [x y]))] \n\t\t\t\t\t\t[[x y] (update-in t [x y] (fn [_] p))]))))))","user":"53e19461e4b0d874e779ae59"},{"problem":119,"code":"(fn f [x b]\n  (let [e-locs (for [i (range 3) j (range 3)\n                     :when (= :e (get-in b [i j]))] [i j])\n        ok? (fn [[i j]]\n              (let [newb (assoc-in b [i j] x )]\n                (->> (filter #(some #{[i j]} %) [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]])\n                     (map #(map (partial get-in newb) %))\n                     (concat (vector  (newb i) (map #(nth % j) newb)))\n                     (some #(every? #{x} %))\n                     )))]\n    (set (filter ok? e-locs))))","user":"56102f50e4b05f002753df6b"},{"problem":119,"code":"(fn win-tic-tac-toe\n  [side b]\n  (let [b (->> b\n               flatten\n               (map-indexed vector))\n        check-win (fn\n                    [[a b c d e f g h i]]\n                    (->> [[a b c] [d e f] [g h i]\n                          [a d g] [b e h] [c f i]\n                          [a e i] [c e g]]\n                         (filter (partial apply =))\n                         (map first)\n                         (drop-while (partial = :e))\n                         first))]\n    (->> b\n         (filter #(= :e (second %)))\n         (map first)\n         (filter (comp check-win\n                       vals\n                       #(assoc (into (sorted-map) b) % side)))\n         (map (juxt #(quot % 3) #(mod % 3)))\n         (into #{}))))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn [pl tb]\n  (letfn [\n    (at [ [y x :as xy] ] \"value at coordinates\"\n      (nth (nth tb y) x))\n    (ats [ line ] \"coordinates mapped to values\"\n      (group-by at line))]\n    (let [\n      lines [ [ [0 0] [0 1] [0 2] ] ;; horizontals\n              [ [1 0] [1 1] [1 2] ]\n              [ [2 0] [2 1] [2 2] ],\n              [ [0 0] [1 0] [2 0] ] ;; verticals\n              [ [0 1] [1 1] [2 1] ]\n              [ [0 2] [1 2] [2 2] ],\n              [ [0 0] [1 1] [2 2] ] ;; diagonals\n              [ [2 0] [1 1] [0 2] ] ]\n      ]\n      (set\n        (map \n          (comp first :e)\n          (filter\n            #(= [1 2] (map count [(get % :e) (get % pl)]))\n            (map ats lines)))))))","problem":119,"user":"4f569218e4b0a7574ea71826"},{"problem":119,"code":"(fn [p s]\n  (set\n    (remove nil?\n      (for [x (range 3) y (range 3)]\n        (if (= (get-in s [x y]) :e)\n          (let [[[a b c] [d e f] [g h k]] (assoc-in s [x y] p)]\n            (let [s (set [[a e k] [g e c] [a d g] [b e h] [c f k] [a b c] [d e f] [g h k]])]\n              (if (s [p p p]) [x y])\n              )\n            )\n          )\n        )\n      )\n    )\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":119,"code":"(fn [k B]\n  (let [A (map-indexed (fn [i r] (map-indexed (fn [j v] [v [i j]]) r)) B)\n        R (range 3)\n        C (lazy-cat [R (reverse R)] (map (fn [r] (repeat 3 r)) R))\n        S (lazy-cat A (map (fn [c] (map nth A c)) C))]\n    (set (map second (mapcat (fn [l] (if (= 2 (count (filter (comp #{k} first) l))) (filter (comp #{:e} first) l))) S)))))","user":"55f6fe09e4b06e875b46cea2"},{"code":"(fn [s g]\r\n  (letfn [(col-vec [i] [(nth (nth g 0) i)(nth (nth g 1) i)(nth (nth g 2) i)])\r\n          (w [r] (condp = r [s s :e] 2 [s :e s] 1 [:e s s] 0 nil))]\r\n    (let [res (into [] (map-indexed (fn [i r] (if-let [v (w r)] [i v])) g))\r\n          res (into res (map-indexed (fn [i r] (if-let [v (w r)] [v i])) (map col-vec (range 3))))\r\n          res (into res [(condp = (w [(nth (nth g 0) 0) (nth (nth g 1) 1) (nth (nth g 2) 2)])\r\n                          0 [0 2]\r\n                          1 [1 1]\r\n                          2 [2 2]\r\n                          nil)])\r\n          res (into res [(condp = (w [(nth (nth g 2) 0) (nth (nth g 1) 1) (nth (nth g 0) 2)])\r\n                          0 [2 0]\r\n                          1 [1 1]\r\n                          2 [0 2]\r\n                          nil)])\r\n          ]\r\n      (into #{} (remove nil? res)))))","problem":119,"user":"4e79ff2a535db169f9c796a9"},{"code":"(fn [g o c t b]\n  (set\n  (for [y o\n        x o\n        :when (= (g b [y x]) :e)\n  \t\t:when (some #(= (count (filter (fn [n] (= t n)) %)) 2)\n        \t\t(map (fn [r] (map #(g b %) r)) \n                     (c o repeat #(map list % %2) y x)))]\n    [y x])))\n\nget-in\n[0 1 2]\n\n(fn [o r m y x]\n  (concat\n   [(m o (r x)) (m (r y) o)]\n   (case [y x]\n     ([0 0] [2 2]) [(m o o)]\n     ([0 2] [2 0]) [(m o [2 1 0])]\n     [])))","problem":119,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn [toe m]\n  (letfn [(safe [[y x]]\n            (some #(apply = (map (fn [pos] (get-in (assoc-in m [y x] toe) pos)) %))\n                  (list '([0 0][1 1][2 2]) '([0 2][1 1][2 0])\n                        (map (fn [i] [y i]) (range 3))\n                        (map (fn [i] [i x]) (range 3)))))]\n    (set (filter #(safe %) (filter #(= (get-in m %) :e) (for [i (range 3) j (range 3)] [i j]))))))","problem":119,"user":"52afbc69e4b0c58976d9acc0"},{"code":"(fn [p b]\n  (let [h (count b)\n        w (count (first b))\n        vert (fn [m]\n               (map first\n                 (map #(% %2)\n                   (iterate (partial comp next) identity) m)))\n        won (fn [m]\n              (some #(apply = (cons p %))\n                (concat\n                  m\n                  (apply (partial map list) m)\n                  (list (vert m))\n                  (list (vert (reverse m)))))) ]\n    (set          \n      (for [y (range h) x (range w)\n            :when (won (update-in b [y x] #(if (= :e %) p :e))) ]\n        [y x]))))","problem":119,"user":"4fd96694e4b05e33b9224f37"},{"problem":119,"code":"(fn [x brd]\n (letfn [(xs [line] (vec (filter #(= x (% 1)) line)))\n\t (es [line] (vec (filter #(= :e (% 1)) line)))]\n  (let [lines (vec (map (fn [v] (vec (map (fn [z] [z (get-in brd z)]) v)))\n  [[[0 0] [0 1] [0 2]]\n   [[1 0] [1 1] [1 2]]\n   [[2 0] [2 1] [2 2]]\n   [[0 0] [1 0] [2 0]]\n   [[0 1] [1 1] [2 1]]\n   [[0 2] [1 2] [2 2]]\n   [[0 0] [1 1] [2 2]]\n   [[0 2] [1 1] [2 0]]]))]\n      (reduce  #(if (and (= 2 (count (xs %2))) (= 1 (count (es %2)))) (conj %1 (get-in (es %2) [0 0])) %1)  #{} lines)\n       )))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(let [\n  lines [\n    [[0 0] [0 1] [0 2]]\n    [[1 0] [1 1] [1 2]]\n    [[2 0] [2 1] [2 2]]\n    [[0 0] [1 0] [2 0]]\n    [[0 1] [1 1] [2 1]]\n    [[0 2] [1 2] [2 2]]\n    [[0 0] [1 1] [2 2]]\n    [[0 2] [1 1] [2 0]]]\n  get-line (fn [board line]\n    (let [vals (map #(get-in board %) line)]\n      (if (apply = vals)\n        (if (= (first vals) :e)\n          nil\n          (first vals))\n        nil)))\n  who-wins (fn [board]\n    (some identity (map #(get-line board %) lines)))]\n  (fn [player board]\n    (into #{} (for [x (range 3) y (range 3) :when (and (= (get-in board [x y]) :e) (= player (who-wins (assoc-in board [x y] player))))] [x y]))))","problem":119,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn tic-tac-toe [player board]\n  (letfn [\n      (rows [bd] (seq bd))\n      (cols [bd] (for [i (range 3)] (map #(nth % i) (rows bd))))\n      (diags [bd] [(map #(get-in bd %) [[0 0] [1 1] [2 2]])\n                      (map #(get-in bd %) [[0 2] [1 1] [2 0]])])\n      (winner1 [v] (let [s (set v)]\n                    (and (= 1 (count s)) (not= (first s) :e) (first s))))\n      (horiz [bd] (some winner1 (rows bd)))\n      (vert [bd] (some winner1 (cols bd)))\n      (diag [bd] (some winner1 (diags bd)))\n      (winner [board] (or (horiz board) (vert board) (diag board)))\n      (indexed [s] (map-indexed #(apply vector %&) (seq s)))\n      (points [board]\n        (for [[i row] (indexed board) [j v] (indexed row)]\n              [[i j] v]))\n      (points-where [pred board]\n        (map first (filter (fn [[p v]] (pred v)) (points board))))\n      (empty-cell? [c] (= c :e))\n      (valid-points [board] (points-where empty-cell? board))]\n    (->> board\n         valid-points\n         (map (fn [p] [p (assoc-in board p player)])) \n         (filter #(winner (second %)))\n         (map first)\n         set)))","problem":119,"user":"4ed188c8535d44c135fd68cf"},{"problem":119,"code":"(fn [x board]\n  (letfn [(won? [board]\n            (letfn [(f [xs] (every? #(= % x) xs))]\n              (or\n                (some f board)\n                (some f (map (fn [j] (map #(nth % j) board)) (range 3)))\n                (f (map #(get-in board %) '([0 0] [1 1] [2 2])))\n                (f (map #(get-in board %) '([0 2] [1 1] [2 0]))))))]\n    (set\n      (for [i (range 3) j (range 3)\n            :when (and (= :e (get-in board [i j]))\n                       (won? (assoc-in board [i j] x)))]\n        [i j]))))","user":"508157b2e4b0946d0443855c"},{"problem":119,"code":"(fn win [s [[a b c][d e f][x y z]]]\n  (set (for [[x y c & p]\n             [[0 1 b e y a c] [0 2 c a b e x f z]\n              [1 1 e d f b y a z c x] [1 2 f d e c z]\n              [2 0 x a d e c y z] [2 2 z x y a e c f]]\n            :when (and (= c :e)\n                       (some (fn [[a b]] (= a b s))\n                             (partition 2 p)))]\n          [x y])))","user":"53500869e4b084c2834f4ad3"},{"problem":119,"code":"(fn [i s]\n  (letfn [(f [t]\n             (map #(if (apply = %) (first %) nil) t))\n          (w [s]\n             (->> (mapcat f [s\n                             (apply map vector s)\n                             [[(first (first s)) (second (second s)) (last (last s))]]\n                             [[(last (first s)) (second (second s)) (first (last s))]]])\n                  (filter #{:x :o})\n                  (first)))\n          (r [l]\n            (->>\n              (for [x (range 3)\n                    y (range 3)]\n                (if (= l [x y])\n                  i\n                  (get (get s x) y)))\n              (partition 3)))]\n    (let [e (filter identity\n              (for [x (range 3)\n                    y (range 3)]\n                (when (= :e (get (get s x) y))\n                  [x y])))]\n      (->>\n        (filter #(= i (w (r %))) e)\n        (set)))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":119,"code":"(fn [p board]\n    (let [check (fn [ [[a b c]\n                       [d e f]\n                       [g h i]] p]\n\n                    (println [a b c d e f g h i] p)\n                    (or (= p a b c) ; horz\n                        (= p d e f)\n                        (= p g h i)\n                        (= p a d g) ; vert\n                        (= p b e h)\n                        (= p c f i)\n                        (= p a e i) ; diag\n                        (= p c e g)))\n\n          empties (fn [board]\n                (for [r (range 3) c (range 3)\n                      :when (= :e (get-in board [r c]))] [r c]))\n\n          winner? (fn [p board pos]\n                    (check (assoc-in board pos p) p)) ]\n\n          (println board (empties board))\n\n          (set (filter #(winner? p board %) (empties board)))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":119,"code":"(fn \n  [p b]\n  (set\n   (for [l [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n          :let [{[o & _ :as e] :e f p} (group-by #(nth (flatten b) %) l)]\n          :when (and (= (count e) 1) (= (count f) 2))]\n        [(quot o 3) (rem o 3)])))","user":"576df252e4b0979f8965156f"},{"code":"(fn win-positions [piece board]\n  (letfn [\n    (lines [board]\n      (let [rows board,\n            cols (apply map vector board),\n            diags [(map first (partition-all 4 (flatten rows)))\n                   (map first (partition-all 4 (flatten (map reverse rows))))]]\n        (concat rows cols diags)))\n    (win? [board]\n      (not\n        (empty?\n          (filter\n            #(and (apply = %1)\n                  (not= :e (first %1)))\n            (lines board)))))]\n    (set\n      (for [f (range 3), c (range 3)\n          :when (and\n                  (= :e (get-in board [f c]))\n                  (win? (assoc-in board [f c] piece)))]\n      [f c]))))","problem":119,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn [p board]\n  (let [win? #(let [b (concat % (apply map list %) \n                    [(map nth % (range)) (map nth (map reverse %) (range))])]\n                (some #{[p p p]} b))]\n    (set\n      (for [y (range 3), x (range 3),\n            :when (and (= :e (get-in board [y x]))\n                       (win? (assoc-in board [y x] p)))]\n        [y x]))))","problem":119,"user":"4fb1d907e4b081705acca282"},{"problem":119,"code":"(fn [mark board]\n  (letfn [\n          (p [board]\n            (let [b (map\n                      (fn [p] (map #(cond (= % :e) 0\n                                          (= % :x) 1\n                                          (= % :o) -1)\n                                   p))\n                      board)\n                  naname (fn [x]\n                           (loop [x x s 0 i 0]\n                             (if (empty? x)\n                               s\n                               (recur (rest x) (+ s (nth (first x ) i)) (+ 1 i)))))\n                  naname2 (fn [x]\n                            (loop [x x s 0 i 0]\n                              (if (empty? x)\n                                s\n                                (recur (rest x) (+ s (nth (first x ) (- 2 i))) (+ 1 i)))))\n                  c (fn [x] (cond (some #(= % 3) x) :x\n                                  (some #(= % -3 )x) :o\n                                  :else nil))]\n              (c (concat\n                   (list (naname b))\n                   (list (naname2 b))\n                   (map #(reduce + %) b)\n                   (map #(+ %1 %2 %3)\n                        (nth b 0)\n                        (nth b 1)\n                        (nth b 2))))))]\n    (set (filter\n           #(not (false? %))\n           (apply concat\n                  (for [i (range 3)]\n                    (for [j (range 3)]\n                      (if (and (= (get-in board [i j]) :e) (= mark (p (assoc-in board [i j] mark))))\n                        [i j]\n                        false))))))))","user":"53664e3be4b0243289761e74"},{"code":"(let [winner (fn [board]\n               (let [rows (concat board\n                                  (apply map list board)\n                                  (for [pos-seq [[0 0 1 1 2 2]\n                                                 [0 2 1 1 2 0]]]\n                                    (for [pos (partition 2 pos-seq)]\n                                      (get-in board pos))))]\n                 (first (for [[who :as row] rows\n                              :when (and (not= :e who)\n                                         (apply = row))]\n                          who))))]\n  (fn [piece board]\n    (set\n     (for [x (range 3), y (range 3)\n           :let [where [x y]]\n           :when (and (= :e (get-in board where))\n                      (winner (assoc-in board where piece)))]\n       where))))","problem":119,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":119,"code":"(fn [ p board]\n  (let [ win?   (fn  [board] (let [ rows \tboard\n                                   cols   (apply map vector board) \n                                   diags  [(map get board [0 1 2]) (map get board [2 1 0])] \n                                   all    (concat cols rows diags)    \n                          \n                                   wins?  (fn [x ls]  (= 3 (count (filter #(= % x) ls)))) \n                                   check  (fn [bools] (reduce #(or %1 %2)  bools)) \n                                   \n                                   win-x? (check (map #(wins? :x %) all))\n                                   win-o? (check (map #(wins? :o %) all))]\n                              \n                              (cond \n                                 win-x? :x\n                                 win-o? :o ))) ;; Reusing my solution at problem #73\n         \n           empties (filter #(= :e (get-in board %)) (for [x (range 3) y (range 3)] [x y]))\n         \n         ]\n    \n        (reduce #(if (win? (assoc-in board %2 p)) (conj %1 %2) %1) #{} empties)\n        \n    ))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn [player board]\n  (letfn [(has-won? [[[v11 _ v13] [_ v22 _] [v31 _ v33] :as xss]]\n                    (or\n                     (some #(every? (partial = player) %) xss)\n                     (every? #(= (first %) player) xss)\n                     (every? #(= (second %) player) xss)\n                     (every? #(= (nth % 2) player) xss)\n                     (= v11 v22 v33 player)\n                     (= v13 v22 v31 player)))\n          (make-move [move]\n                     (for [i (range 0 3)]\n                       (for [j (range 0 3) :let [coord [i j]]]\n                         (if (= move coord)\n                           player\n                           (get-in board coord)))))]\n    (let [possible-moves (for [i (range 0 3)\n                               j (range 0 3)\n                               :let [coord [i j]]\n                               :when (= :e (get-in board coord))]\n                           coord)]\n      (set (filter #(has-won? (make-move %)) possible-moves)))))","problem":119,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":119,"code":"(fn [s b]\n  (letfn [\n          (find-empty [b]\n                      (set (apply concat (filter (complement empty?) (keep-indexed (fn [i l] (keep-indexed #(if (= :e %2) [i %1]) l)) b))))\n                      )\n          (winner? [sym brd]\n                   ((complement empty?) (filter #(= % 3)\n                                                (map (fn [r] (count (filter #(= sym %) r)))\n                                                     (concat brd\n                                                             (apply map vector brd)\n                                                             (vector (map #(%1 %2) brd (range (count brd))))\n                                                             (vector (map #(%1 (- (dec (count brd)) %2)) brd (range (count brd)))))\n                                                     )\n                                                ))\n                   )\n          ]\n\n    (set (filter #(winner? s (assoc-in b %1 s)) (find-empty b)))\n    ))","user":"52593207e4b0cb4875a45cd3"},{"code":"(fn winBox[k cols]\r\n  (let[getVal (fn[[x y]]\r\n                 (nth  (nth cols x) y)\r\n                ),\r\n       getLine (fn[gen]\r\n                 (for[x (range 0 3)]\r\n                   (for [y (range 0 3)]\r\n                        (gen x y)\r\n                      )\r\n                     )\r\n                  ),\r\n       getX (fn[gen]\r\n               (for[n (range 0 3)]\r\n                 (gen n) \r\n                )\r\n              ),\r\n       fullList (concat \r\n                        (getLine #(vector %1 %2) )\r\n                        (getLine #(vector %2 %1) )\r\n                        (list\r\n                        (getX #(vector % %) )\r\n                        (getX #(vector % (- 2 %)) )\r\n                         )\r\n                        ),\r\n       specVal (fn[col]               \r\n               (reduce\r\n                 (fn[mp v]\r\n                    (let[val (getVal v)]\r\n                      (assoc mp val \r\n\t                       (conj (get mp val '()) v)\r\n\t                    )\r\n                    )\r\n                   )\r\n                {}\r\n                col \r\n               )\r\n             ),\r\n        isWin (fn[mp]\r\n\t                (and (= (count (k mp)) 2)\r\n\t                     (= (count (:e mp)) 1)\r\n\t                     )\r\n                 )\r\n       ]\r\n   (set (map #(first (:e %))\r\n        (filter isWin (map specVal fullList) )\r\n      ))\r\n  \r\n  )\r\n)","problem":119,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":119,"code":"(fn [piece board]\n  (let [lanes #(apply conj % \n                           (map get % [0 1 2]) \n                           (map get % [2 1 0]) \n                           (apply map vector %))\n        winners {[piece piece piece] piece}]\n    (loop [coord (for [x (range 3) y (range 3)] [x y]) \n           moves #{}]\n      (cond \n       (empty? coord) moves\n       (and (= :e (get-in board (first coord))) \n            (some winners (lanes (assoc-in board (first coord) piece)))) (recur (rest coord) (conj moves (first coord)))\n        :else (recur (rest coord) moves)))))","user":"56d63729e4b0ea9b8538f7ca"},{"code":"(fn [p b]\n  (let [rang [0 1 2]\n        horiz (map (fn [i r] (map (fn [j e] [e i j]) rang r)) rang b)\n        vert  (apply map list horiz)\n        diag1 (list (map (fn [i r] (nth r i)) rang horiz))\n        diag2 (list (map (fn [i r] (nth r i)) (reverse rang) horiz))\n        all (concat horiz vert diag1 diag2)\n        win-coord (fn [r]\n                    (let [m (group-by first r)]\n                      (when (= 2 (count (m p))) \n                        (first (m :e)))))]\n    (set (map (comp vec rest) \n              (filter identity (map win-coord all))))))","problem":119,"user":"5246e945e4b0644eb7b0783b"},{"problem":119,"code":"(fn myf [who board]\n\t\t(letfn [(who-win [coll]\n            (let [row1 (nth coll 0)\n                  row2 (nth coll 1)\n                  row3 (nth coll 2)\n                  col1 (map first coll)\n                  col2 (map second coll)\n                  col3 (map #(nth % 2) coll)\n                  dia1 [(first  (first coll)) (second (second coll)) (nth (nth coll 2) 2)]\n                  dia2 [(nth (first coll) 2) (second (second coll)) (first (nth coll 2))]\n                  all [row1 row2 row3 col1 col2 col3 dia1 dia2]\n                  check (fn [e] (reduce #(or %1 %2) (map #(apply = (conj % e)) all)))]      \n              (cond (check :x) :x\n                    (check :o) :o\n                    :else nil)))\n\t\t\t\t      (check [m n who board]\n            (if (not= :e (nth (nth board m) n)) false\n              (= who (who-win (assoc board m (assoc (nth board m) n who))))))]\n    (->> (for [m [0 1 2], n [0 1 2]] [m n who board])\n\t\t\t\t  (filter #(apply check %))\n\t\t\t\t  (map #(vector (first %) (second %)))\n\t\t\t\t  (apply hash-set)\n\t\t\t\t  )))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":119,"code":"(fn [player board]\n  (let [board-size (count board)\n        top-index (dec board-size)\n        winner (fn [board]\n                 (->> (concat board\n                              (apply map vector board)\n                              [(for [i (range board-size)] (get-in board [i i]))\n                               (for [i (range board-size)] (get-in board [i (- top-index i)]))])\n                      (filter (partial apply =))\n                      (remove (partial apply = :e))\n                      first\n                      first))]\n    (into #{}\n          (for [i (range board-size)\n                j (range board-size)\n                :when (and\n                       (= (get-in board [i j]) :e)\n                       (= player (winner (assoc-in board [i j] player))))]\n            [i j]))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":119,"code":"(fn win [piece board]\n  (let [interpose-matrix\n          #(for [i (range (count (first %)))]\n              (for [row %] (nth row i))\n          )\n        win-position \n          (fn [row piece]\n            (if (and\n                  (= 1 (count (filter (partial = :e) row)))\n                  (= 2 (count (filter (partial = piece) row)))\n                )\n              (.indexOf row :e)\n              nil\n            )\n          )\n        rows board\n        cols (interpose-matrix board)\n        d1 [(nth (nth board 0) 0)\n            (nth (nth board 1) 1)\n            (nth (nth board 2) 2)]\n        d2 [(nth (nth board 0) 2)\n            (nth (nth board 1) 1)\n            (nth (nth board 2) 0)]\n       ]\n    \n    (set (filter #(not (some nil? %))\n      (concat\n        ;for rows and cols\n        (loop [positions #{} rs rows cs cols]\n          (if (and (empty? rs) (empty? cs))\n            positions\n            (recur (conj positions \n                [(.indexOf rows (first rs)) (win-position (first rs) piece)]\n                [(win-position (first cs) piece) (.indexOf cols (first cs))]\n              ) (rest rs) (rest cs))\n          )\n        )\n      \n        ;for diagonal d1\n        (let [pos (win-position d1 piece)]\n          #{[pos pos]}\n        )\n      \n        ;for diagonal d2\n        (let [pos (win-position d2 piece)]\n          (if (nil? pos)\n            #{}\n            #{[pos (- 2 pos)]}\n          )\n        )\n      )\n    ))\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":119,"code":"(fn ticTacToeWinX [sym m]\n\t(letfn[\n\n\t\t(row[m n] (get m n))\n\t\t(column [m n] (mapv #(get % n) m))\n\t\t(diagonalLeft [m] (mapv (fn[row i] (get row i)) m '(0 1 2)))\n\t\t(diagonalRight [m] (mapv (fn[row i] (get row i)) m '(2 1 0)))\n\t\t(countSymbol [x sym] (count (filter #(= % sym) x)))\n\t\t(winnable [x sym] \n\t\t\t(and \n\t\t\t\t(= (countSymbol x sym) 2)\n\t\t\t\t(= (countSymbol x :e) 1)\n\t\t\t)\n\t\t)\n\n\t\t(emptyPos[v] \n\t\t\t(first \n\t\t\t\t(filter (fn[n] (= (get v n) :e )) '(0 1 2) )\n\t\t\t)\n\t\t)\n\n\t\t(emptyPosInRow[m n]\n\t\t\t[n (emptyPos (row m n))]\n\t\t)\n\n\t\t(emptyPosInColumn[m n]\n\t\t\t[(emptyPos (column m n)) n]\n\t\t)\n\n\t\t(emptyPosInDiagonalLeft[m]\n\t\t\t(let [n (emptyPos (diagonalLeft m))]\n\t\t\t\t[n n]\n\t\t\t)\n\t\t)\n\n\t\t(emptyPosInDiagonalRight[m]\n\t\t\t(let [n (emptyPos (diagonalRight m))]\n\t\t\t\t[n (- 2 n)]\n\t\t\t)\n\t\t)\n\n\n\t\t]\n\t\t(set (concat\n\t\t(map #(emptyPosInRow m %) (filter #(winnable (row m %) sym) '(0 1 2)))\n\t\t(map #(emptyPosInColumn m %) (filter #(winnable (column m %) sym) '(0 1 2)))\n\t\t(if (winnable (diagonalLeft m) sym) (list (emptyPosInDiagonalLeft m)) '())\n\t\t(if (winnable (diagonalRight m) sym) (list (emptyPosInDiagonalRight m)) '())\n\t\t))\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [t rs]\n   (let [win (fn [r] (empty? (disj (set r) t)))\n         m map\n         p [0 1 2]\n         c (for [x p y p] [x y])\n         l (concat\n             (m #(for [e p] [% e]) p)\n             (m #(for [e p] [e %]) p)\n             [(m #(vector % %) p)]\n             [(m #(vector % (- 2 %)) p)])\n         y (fn [exc [r e]]\n             (let [x ((rs r) e)]\n               (if (and (= :e x) (= exc [r e])) t x)))\n         z (fn [exc] (partition 3 (m (partial y exc) (apply concat l))))]\n     (set (filter #(some win (z %)) c))))","problem":119,"user":"4fa30027e4b081705acca187"},{"code":"(fn [x s]\n  (set (filter\n        #((fn [v] (some (fn [[a b c]] (or (= :x a b c) (= :o a b c)))\n                    (concat v (apply map vector v)\n                      (let [[[a _ b] [_ o _] [c _ d]] v] [[a o d] [b o c]]))))\n          (assoc-in s % x))\n       (for [i (range 3) j (range 3) :when (= :e (get-in s [i j]))] [i j]))))","problem":119,"user":"4fdb02aae4b05e33b9224f56"},{"problem":119,"code":"(fn win-moves [piece board]\n  (letfn [(analize [rows]\n            (let [columns (apply map list rows)\n                  diagonals (map #(map nth % (range)) [rows (rseq rows)])]\n              (->> (concat rows columns diagonals)\n                   (some #(when (apply = %) (#{:o :x} (first %)))))))\n          (get-win-moves [acc pos]\n            (let [i (quot pos 3)\n                  j (rem pos 3)\n                  x (get-in board [i j])]\n              (if (= :e x)\n                (let [future-board (assoc-in board [i j] piece)]\n                  (if (= piece (analize future-board))\n                    (conj acc [i j])\n                    acc))\n                acc)))]\n    (reduce get-win-moves #{} (range 9))))","user":"5f82609ae4b0c071e6c840f9"},{"code":";; this is obviously not the right solution.\n\n#(reify clojure.lang.IPersistentCollection (equiv [_ _] (= %&)))","problem":119,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn [side board]\n  (let [winState {side 2 :e 1}\n        lines (concat (for [i (range 3)] [[ i 0] [i 1] [i 2]])\n                       (for [i (range 3)] [[0 i] [1 i] [2 i]] )\n                      [ [[ 0 0] [1 1] [2 2]]\n                        [[2 0] [1 1] [0 2]]\n                       ]\n               )\n        get-in (fn [x y] (nth (nth board x) y))]\n    (set (for [line lines :when (= winState (frequencies (map #(apply get-in %) line)))\n               point line :when (= :e (apply get-in point))]\n           point))))","problem":119,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn win-tic-tac-toe [player board]\n\t(letfn [(board-set [board pos value]\n\t\t\t\t(let [[row col] pos]\n\t\t\t\t\t(assoc board row (assoc (nth board row) col value))\n\t\t\t\t)\n\t\t\t)\n\t\t\t(empty-cells [board]\n\t\t\t\t(let [size (count board)]\n\t\t\t\t\t(for [x (range size) \n\t\t\t\t\t\t  y (range size)\n\t\t\t\t\t\t  :when (= :e (nth (nth board x) y))]\n\t\t\t\t\t\t[x y]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(analyze-tic-tac-toe [board]\n\t\t\t\t(letfn [(row-filled? [board row value]\n\t\t\t\t\t\t\t(every? #(= value %) (nth board row))\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(col-filled? [board col value]\n\t\t\t\t\t\t\t(every? #(= value %) (map #(nth % col) board))\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(board-at [board x y]\n\t\t\t\t\t\t\t(nth (nth board x) y)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(diag-filled? [board value]\n\t\t\t\t\t\t\t(or (every? #(= value %) (map #(board-at board % %) (range 3)))\n\t\t\t\t\t\t\t\t(every? #(= value %) (map #(board-at board % (- 2 %)) (range 3)))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(value-wins? [board value]\n\t\t\t\t\t\t\t(or (some #(row-filled? board % value) (range 3))\n\t\t\t\t\t\t\t\t(some #(col-filled? board % value) (range 3))\n\t\t\t\t\t\t\t\t(diag-filled? board value)\n\t\t\t\t\t\t\t)\t\n\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t\t(first (filter #(value-wins? board %) '(:x :o))) \n\t\t\t\t)\n\t\t\t)]\n\t\t\t(into #{} (filter #(analyze-tic-tac-toe (board-set board % player)) (empty-cells board)))\n\t)\n)","problem":119,"user":"52763696e4b03e8d9a4a74d7"},{"problem":119,"code":"(fn wttt [p b]\n  (let [cnt (count b) rc (range cnt)\n        epos (fn [tttb]\n               (let [diags [(for [i (range cnt)] ((tttb i) i)) (for [i (range cnt)] ((tttb (- cnt i 1)) i))]\n                     cols (for [x (range cnt)] (for [y (range cnt)] ((tttb y) x)))\n                     full-axes (remove (fn [a] (some #(= :e %) a)) (concat tttb diags cols))]\n                 (first (first (filter #(apply = %) full-axes)))))]\n    (set (filter (fn [c] (= p (epos (update-in b c (constantly p)))))\n            (filter #(= :e (get-in b %)) (for [x rc y rc] [x y]))))))","user":"53e745a1e4b036ad0777e479"},{"problem":119,"code":"(fn [t xs]\n  (let [a (apply concat xs)\n        e (->> (map-indexed #(vector %1 %2 ) a)\n                     (filter #(= :e (second %)))\n                     (map first))\n        c (fn [x] [(quot x 3) (rem x 3)])\n        r (fn [x l] (concat (take x l)\n                               [t]\n                               (drop (inc x) l)))\n        w? (fn [l lst]\n              (every? #{t} (map #(nth l %) lst)))\n        w?s (fn [l]\n               (some #(w? l %)\n                     [[0 1 2] [3 4 5] [6 7 8]\n                      [0 3 6] [1 4 7] [2 5 8]\n                      [0 4 8] [2 4 6]]))]\n    (loop [[y & ys] e rs #{}]\n      (if y\n        (recur ys\n               (if (w?s (r y a))\n                 (conj rs (c y))\n                 rs))\n        rs))))","user":"528a3e14e4b0239c8a67ae72"},{"problem":119,"code":"(fn win-ttt [s board]\n  (letfn [\n    (ttt [board]\n      (let [ series (conj board (map first board) (map second board) (map last board)\n                          [(first (first board)) (second (second board)) (last (last board))]\n                          [(last (first board)) (second (second board)) (first (last board))])\n           ]\n      (cond\n          (some true? (map (fn [x] (every? #(= :x %) x)) series)) :x\n          (some true? (map (fn [x] (every? #(= :o %) x)) series)) :o\n          :else nil\n      )) \n    )\n  ]\n    (set (for [i (range 3) j (range 3) \n      :when (and (= :e (nth (nth board i) j))\n                 (= s (ttt (assoc board i (assoc (nth board i) j s))))\n          )] [i j]))\n  )  \n)","user":"59a0262ee4b0871e7608b82d"},{"problem":119,"code":"(fn [team board]\n    (let [winning\n          (fn [board]\n            (first\n              (for [row\n                    (map\n                      (fn [x] (map #(get-in board [(quot % 3) (mod % 3)]) x))\n                      [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]])\n                    :when (and (apply = row) (not= (first row) :e))]\n                (first row))))]\n      (set (for [x (range 3)\n                 y (range 3)\n                 :let [b (assoc-in board [x y] team)]\n                 :when (and (= (get-in board [x y]) :e) (= (winning b) team))]\n             [x y]))))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn win-at-tic-tac-toe [flag board]\n  (letfn [(cols  [board]      (apply map vector board))\n          (diags [[r1 r2 r3]] [[(r1 0) (r2 1) (r3 2)]\n                               [(r1 2) (r2 1) (r3 0)]])\n          (three-in-row [colls] (some #(apply = flag %) colls))\n          (win          [board] (some #(three-in-row %)\n                                      [board (cols board) (diags board)]))]\n    (set (for [i (range 3), j (range 3)\n               :when (and (= :e (get-in board [i j]))\n                          (win (assoc-in board [i j] flag)))]\n           [i j]))))","problem":119,"user":"50586354e4b06522596eba78"},{"code":"(fn [turn board]\r\n        (let [point (fn [[y x]] (nth (nth board y) x))\r\n       lines [\r\n              (map #(vector %1 %2) (range 0 3) (take 3 (repeat 0)))\r\n              (map #(vector %1 %2) (range 0 3) (take 3 (repeat 1)))\r\n              (map #(vector %1 %2) (range 0 3) (take 3 (repeat 2)))\r\n              (map #(vector %1 %2) (take 3 (repeat 0)) (range 0 3))\r\n              (map #(vector %1 %2) (take 3 (repeat 1)) (range 0 3))\r\n              (map #(vector %1 %2) (take 3 (repeat 2)) (range 0 3))\r\n              (map #(vector %1 %2) (range 0 3) (range 0 3))\r\n              (map #(vector %1 %2) (range 0 3) (range 2 -1 -1))]\r\n       stones (map #(map point %) lines)\r\n       points (map #(if (and (= 2 (count ((group-by identity %1) turn))) (= 1 (count ((group-by identity %1) :e))))\r\n                     (reduce (fn [a b] (if (= :e (point a)) a b)) %2))\r\n                   stones lines)\r\n       result (into #{} (filter #(not (nil? %)) points))\r\n      ]\r\n        result))","problem":119,"user":"506fd0afe4b07bd6ad9b9f23"},{"code":"(fn [player board]\n  (let [ rows [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]]\n         cols [[[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]]\n         diags [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n         squares (for [x (range 3) y (range 3)] [x y])\n         winpaths (concat rows cols diags)\n         wonpath? (fn [trialboard path] (every? #(= player %) (map #(get-in trialboard %) path)))\n         winner? (fn [trialboard] (some true? (map #(wonpath? trialboard %) winpaths)))\n         ]\n    (reduce\n      #(if (= (get-in board %2) :e)\n        (if (winner? (assoc-in board %2 player))\n           (conj % %2)\n           %)\n         %)\n      #{} squares)))","problem":119,"user":"52015698e4b0d7096e99ddba"},{"problem":119,"code":"(fn win-ttt\n  [color board]\n  (letfn [(analyze-ttt\n            [board]\n            (letfn [(analyze[[f & r :as values]]\n                      (if (apply = values)\n                        (if (= f :e)\n                          nil\n                          f)))\n                    (get-columns [[[one two three] [four five six] [seven eight nine]]]\n                      [[one four seven]\n                       [two five eight]\n                       [three six nine]])\n                    (get-diagonal [[[one two three] [four five six] [seven eight nine]]]\n                      [[one five nine]\n                       [seven five three]])]\n              (let [row-win\n                    (map analyze board)\n\n                    column-win\n                    (map analyze (get-columns board))\n\n                    diagonal-win\n                    (map analyze (get-diagonal board))]\n                (first (filter #(boolean %) (concat row-win column-win diagonal-win))))))]\n    (into #{}\n          (filter #(boolean %) (mapcat (fn [row]\n                                         (map (fn [column]\n                                                (let [value (get-in board [row column])]\n                                                  (if-not (= :e value)\n                                                    false\n                                                    (if (analyze-ttt (update-in board [row column] (fn [& _] color)))\n                                                      [row column]\n                                                      false)))) (range 0 3))) (range 0 3))))))","user":"5b759ca8e4b047b03b2036d0"},{"code":"(fn [piece rows]\n  (reduce\n    (fn [found idx]\n      (let [winner  (fn [rows]\n                      (let [cols (partition 3 (apply interleave rows))\n                            d1   [(map-indexed #(%2 %1) rows)]\n                            d2   [(map-indexed #(%2 (- 2 %1)) rows)]\n                            sets (concat rows cols d1 d2)]\n                        (some \n                          #(cond\n                            (apply = :x %) :x\n                            (apply = :o %) :o\n                            :else nil)\n                          sets)))\n            board (update-in rows idx (constantly piece))]\n        (if (and (= (winner board) piece) (= (get-in rows idx) :e))\n          (conj found idx)\n          found)))\n        #{}\n        (for [i (range 0 3) j (range 0 3)] [i j])))","problem":119,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [s m]\n  (let [analyze (fn [s m]\n    (if (or (and (= s ((m 0) 0)) (= s ((m 0) 1)) (= s ((m 0) 2)))\n            (and (= s ((m 1) 0)) (= s ((m 1) 1)) (= s ((m 1) 2)))\n            (and (= s ((m 2) 0)) (= s ((m 2) 1)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 0)) (= s ((m 1) 0)) (= s ((m 2) 0)))\n            (and (= s ((m 0) 1)) (= s ((m 1) 1)) (= s ((m 2) 1)))\n            (and (= s ((m 0) 2)) (= s ((m 1) 2)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 0)) (= s ((m 1) 1)) (= s ((m 2) 2)))\n            (and (= s ((m 0) 2)) (= s ((m 1) 1)) (= s ((m 2) 0))))\n          s\n        false))\n        all-key [[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]]\n        empty-key (filter #(= :e ((m (first %)) (last %))) all-key)\n        change (fn [k]\n                  (assoc m (first k) (assoc (m (first k)) (last k) s)))\n        boards (map #(vector % (change %)) empty-key)\n        result (set (map first (filter #(analyze s (last %)) boards)))]\n        result))","problem":119,"user":"507fbd77e4b089ade05efbd3"},{"problem":119,"code":"(fn tictak-nxt-wins [piece gamefld]\n  (let [height (count gamefld)\n        width (count gamefld)\n        fldidx (for [i (range 0 height) j (range 0 width)] [i j])]\n    (letfn [\n\n      (flatten-seqs [colls] (reduce (fn [acc b] (into acc b)) [] colls))\n      (in-fld? [[i j]]\n        (and (>= i 0) (>= j 0) (< i height) (< j width)))\n      (move-left [[i j]] [i (dec j)])\n      (move-right [[i j]] [i (inc j)])\n      (move-up [[i j]] [(dec i) j])\n      (move-down [[i j]] [(inc i) j])\n      (move-upleft [[i j]] [(dec i) (dec j)])\n      (move-upright [[i j]] [(dec i) (inc j)])\n      (move-downleft [[i j]] [(inc i) (dec j)])\n      (move-downright [[i j]] [(inc i) (inc j)])\n      (get-pt-arrow [point movefn]\n        (letfn [(loc-grow-arrow [pt]\n                  (when (in-fld? pt)\n                    (lazy-seq (cons pt (loc-grow-arrow (movefn pt))))))]\n          (vec (loc-grow-arrow point))))\n      (stroke-right [pt] (get-pt-arrow pt move-right))\n      (stroke-down [pt] (get-pt-arrow pt move-down))\n      (get-item [[i j]] (get-in gamefld [i j]))\n      (point-for-win [stk]\n        (let [empts (filter #(= :e (get-item %)) stk)\n              my-cnt (count (filter #(= piece (get-item %)) stk))]\n          (if (and (= 1 (count empts)) (= 2 my-cnt))\n            (first empts)\n            nil)))]\n      (let [fst-row [[0 0] [0 1] [0 2]]\n            fst-col [[0 0] [1 0] [2 0]]\n            d-strokes (-> [] (conj ,,, (get-pt-arrow [0 0] move-downright))\n                             (conj ,,, (get-pt-arrow [0 2] move-downleft)))\n            h-strokes (vec (map stroke-right fst-col))\n            v-strokes (vec (map stroke-down fst-row))\n            all-strokes (vec (concat d-strokes h-strokes v-strokes))\n            win-points (remove nil? (map point-for-win all-strokes))]\n        (set win-points) ))))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn f[x board]\n   (let [ r        (range 3)\n          rows     (for [ i r ] (for [ j r ] [ i j ]))\n          cols     (apply map vector rows)\n          digs     [ (map vector r r), (map vector r (reverse r)) ]\n          all      (concat rows cols digs)\n          v        #(get-in board %)\n          can-win  #(= (group-by identity (map v %)) { x [x x] :e [:e] })\n          space    (fn [s] (some #(if (= :e (v %)) %) s)) ]\n\n     (set (map space\n            (filter can-win all)))))","problem":119,"user":"4e860e85535db62dc21a62f1"},{"problem":119,"code":"(letfn\n[\n  (ccomp [a & fs]\n    (let [fs (reverse fs)]\n      (fn [& xs]\n        (loop [xs xs\n               f (first fs)\n               fs (rest fs)]\n          (if (nil? f)\n            xs\n          (let [xs [(apply f a xs)]]\n            (recur xs (first fs) (rest fs))))))))\n\n  (get-cell [b [y x]]\n    (nth (nth b y) x))\n\n  (get-coords [b s]\n    (for [x (range (count (first b)))\n          y (range (count b))\n          :when (= s (get-cell b [y x]))]\n      [y x]))\n\n  (place [b [y x] s]\n    (assoc b y (assoc (nth b y) x s)))\n    \n  (boards [b s]\n    (map #(identity [%, (place b % s)]) (get-coords b :e)))\n  \n  (won? [board]\n    (let [\n          transposed (apply (partial map vector) board)\n          flipped (reverse board)\n          row-of      (fn [b s] (when (some (fn [row] (every? #(= s %) row)) b) s))\n          ldiag-of    (fn [b s] (when (every? #(= s %) (map nth b (range))) s))\n          won         (fn [s] (some identity [(row-of board s) (row-of transposed s) (ldiag-of board s) (ldiag-of flipped s)]))]\n          (some won [:x :o])\n      ))\n  \n  (solve [s b]\n    (->> (boards b s)\n      (filter #(= s (won? (second %))))\n      (map first)\n      set))\n      \n]\n  solve)","user":"57717915e4b0979f896515b3"},{"code":"(fn [next-play board]\n    (let [\n          winner (fn [board]\n              (first\n               (some #{#{:x} #{:o}}\n                     (map set\n                          (concat\n                           board\n                           (apply map vector board)\n                           [ (map get board (range))\n                             (map get (reverse board) (range) )])))))\n          empty-slots\n          (for [row (range (count board)) col (range (count (first board)))\n                :when (= :e (get-in board [ row col]))] [row col])\n          play-move #(assoc-in board % next-play)\n          winnable? #(= next-play (winner  (play-move %)))]\n      (set\n       (filter\n        winnable?\n        empty-slots)))\n    )","problem":119,"user":"4e6f578c535d5021c1a8961b"},{"problem":119,"code":"(fn winningMoves [player-c board]\n  (letfn [(boardWinner [b] ; Solution for problem 73\n                       (letfn [(transpose [m] (apply mapv vector m) )\n                               (diagonal [[r1 r2 r3]] [(first r1) (second r2) (last r3)])\n                               (diagonals [m] [(diagonal m) (diagonal (map reverse m))])\n                               (rowWinner [row] (case row\n                                                  [:x :x :x] [:x]\n                                                  [:o :o :o] [:o]\n                                                  nil))]\n                         (let [rows b\n                               columns (transpose b)\n                               diags (diagonals b)\n                               potentialWins (concat rows columns diags)]\n                           (first (apply concat (map rowWinner potentialWins))))))\n          (wouldBeWin? [[r c]] ; Addition: Check if we win by placing our mark on position (r,c)\n            (and              \n              (= :e (nth (nth board r) c)) \n              (= player-c (boardWinner (map-indexed (fn [i row] \n                                                      (if (not= i r) row \n                                                        (map-indexed \n                                                          (fn [j cell] \n                                                            (if (not= j c) cell player-c)) row))) board)))))] \n    (set (filter wouldBeWin? (for [x [0 1 2] y [0 1 2]] [x y])))\n    )\n  )","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn [pl b]\n  (letfn [(w [[a b c]] (= a b c pl))\n          (won [b]\n            (or (some w b)\n                (some w (apply map list b))\n                (w (map #((b %) %) [0 1 2]))\n                (w (map #((b %) (- 2 %)) [0 1 2]))))\n          (wins [p] (and (= (get-in b p) :e)\n                         (won (assoc-in b p pl))))]\n    (set (filter wins (for [x [0 1 2] y [0 1 2]] [y x])))))","problem":119,"user":"4e8612f8535db62dc21a62f2"},{"problem":119,"code":"(fn win-at-ttt [player board]\n  (let [lines (partition 3 (concat (for [x (range 3) y (range 3)] [x y])\n                                   (for [x (range 3) y (range 3)] [y x])\n                                   [[0 0] [1 1] [2 2]\n                                    [2 0] [1 1] [0 2]]))\n        winning-lines (filter #(= 2\n                                  (count\n                                    (filter\n                                      (fn [coord] (= player\n                                                   (get-in board coord)))\n                                      %)))\n                              lines)]\n    (set (filter #(= :e (get-in board %))\n                 (apply concat winning-lines)))))","user":"540e8d13e4b0addc1aec671e"},{"problem":119,"code":"(fn [c m]\n    (letfn [(ttt [xs]\n              (letfn [(win [xs]\n                        (cond\n                          (apply = :o xs) :o\n                          (apply = :x xs) :x\n                          ))]\n                (->> (map #(map (fn [k] (get-in\n                                          xs k)) %)\n                          (concat\n                            (partition 3 (for [i (range 3) j (range 3)] [j i]))\n                            (partition 3 (for [i (range 3) j (range 3)] [i j]))\n                            (partition 3 (for [i (range 3)] [i i]))\n                            (partition 3 (for [i (range 3)] [i (- 2 i)]))\n                            ))\n                     (map win)\n                     (filter #(or (= :x %) (= :o %)))\n                     (first)\n                     ))\n              )]\n      (->>\n        (filter #(= (get-in m %) :e)\n                (for [i (range 3) j (range 3)]\n                  [i j]))\n        (filter (fn [[i j]] (ttt (assoc-in m [i j] c))))\nset\n        )\n\n      ))","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn win-coordinates [player board]\n  (letfn [\n          (on-left-diagonal? [x y]\n            (= x y))\n\n          (on-right-diagonal? [x y]\n            (= 2 (+ x y)))\n\n          (win-move? [player [x y] board]\n            (let [row (nth board x)\n                  col (mapv #(get-in board [% y]) (range 3))\n                  left-diagonal (mapv #(get-in board [% %]) (range 3))\n                  right-diagonal (mapv #(get-in board [% (- 2 %)]) (range 3))\n                  win-pattern (repeat 3 player)]\n              \n              (if (= :e (get-in board [x y]))\n                (or (= win-pattern (assoc row y player)) \n                    (= win-pattern (assoc col x player))\n                    (and (on-left-diagonal? x y) (= win-pattern (assoc left-diagonal x player)))\n                    (and (on-right-diagonal? x y) (= win-pattern (assoc right-diagonal x player))))\n                false)))]\n\n    (set \n      (filter #(win-move? player % board) \n              (for [x (range 3) y (range 3)] [x y])))))","problem":119,"user":"5244a10de4b0d8acf9ed6ab3"},{"code":"(fn [side board]\n    (let [lines (concat (for [x [0 1 2]]\n                          (for [y [0 1 2]]\n                            [x y]))\n                        (for [y [0 1 2]]\n                          (for [x [0 1 2]]\n                            [x y]))\n                        [[[0 0] [1 1] [2 2]]]\n                        [[[2 0] [1 1] [0 2]]])]\n      (set (for [line lines\n                 place line\n                 :let [newline (map #(if (and (= place %)\n                                              (= :e (get-in board %)))\n                                       side\n                                       (get-in board %)) line)]\n                 :when (every? #{side} newline)]\n             place))))","problem":119,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [p b] (set\n  (for [x [0 1 2]\n        y [0 1 2]\n        :when (= :e (get-in b [x y]))\n        :let [[a b c] (assoc-in b [x y] p)]\n        :when ((set (into [a b c\n                           [(a 0) (b 1) (c 2)]\n                           [(a 2) (b 1) (c 0)]]\n                          (mapv vector a b c)))\n               [p p p])]\n      [x y])))","problem":119,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn ttt-win [p b]\n  (let [win? (fn [board]\n               (let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n                     rows (map same? board)\n                     cols (map same? (apply map vector board))\n                     diag1 (same? (map get board [0 1 2]))\n                     diag2 (same? (map get board [2 1 0]))]\n                 (some #{:x :o} (concat rows cols [diag1] [diag2]))))\n        free (for [y (range 3) \n                   x (range 3)\n                   :when (= :e (get-in b [y x]))]\n               [y x])]\n    (set (filter #(= p (win? (assoc-in b % p))) free))))","problem":119,"user":"5032b066e4b00c0952a257ea"},{"problem":119,"code":"(fn [piece board]\n  (let [rows (map (fn [row row-num]\n                    (map #(hash-map :index [row-num %2] :val %1) row (range)))\n                  board (range))\n        cols (apply map vector rows)\n        diags [(map nth rows [0 1 2])\n               (map nth rows [2 1 0])]\n        fetch (fn [piece r] (filter #(= piece (:val %)) r))\n        winner? (fn [r]\n                  (and (= 2 (count (fetch piece r)))\n                       (= 1 (count (fetch :e r)))))]\n    (loop [[x & xs] (concat rows cols diags), positions #{}]\n      (cond\n       (not x)     positions\n       (winner? x) (recur xs (conj positions (:index (first (fetch :e x)))))\n       :else       (recur xs positions)))))","user":"541b1f25e4b01498b1a71a63"},{"problem":119,"code":"(fn [play board]\n  ;; let's brute force this\n  (let [win? (fn [board]\n               (let [win? (comp #(and % (first %)) #{[:x :x :x] [:o :o :o]})\n                     board' (apply mapv vector board)\n                     p (fn [i j] (get-in board [i j]))]\n                 (or\n                  (some win? board)\n                  (some win? board')\n                  (win? [(p 0 0) (p 1 1) (p 2 2)])\n                  (win? [(p 2 0) (p 1 1) (p 0 2)]))))]\n    (set (for [row [0 1 2] col [0 1 2] :when (and (= :e (get-in board [row col]))\n                                                  (win? (assoc-in board [row col] play)))] [row col]))))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":119,"code":"(fn [gp board]\n  (letfn [(num-occurences [for-gp p-seq]\n            (count (filter #(= % for-gp) p-seq)))\n          \n          (win-seq? [p-seq]\n            (and (= 2 (num-occurences gp p-seq))\n                     (= 1 (num-occurences :e p-seq)))\n            \n            )\n          (empty-spaces [b] (reduce-kv (fn [r-a r-idx r-v]\n                                     (reduce-kv (fn [c-a c-idx v]\n                                                  (if (= v :e) \n                                                    (conj c-a [r-idx c-idx])\n                                                    c-a\n                                                    )\n                                                  ) r-a r-v)\n                                     ) [] b ))\n          (vertical-row [c-idx] (map #(get-in board [% c-idx]) [0 1 2] ))\n          (diagonal-rows [coord]\n            (cond (some #(= coord %) [ [0 0] [2 2]] )\n                    [(map #(get-in board %) [[0 0] [1 1]  [2 2]] )]\n                  (some #(= coord %) [ [0 2] [2 0]])\n                  [(map #(get-in board % ) [[0 2] [1 1] [2 0]] )]\n                  (= coord [1 1])\n                 [ (map #(get-in board %) [[0 0] [1 1]  [2 2]] )\n                  (map #(get-in board % ) [[0 2] [1 1] [2 0]] ) ]\n                  :else []\n              )\n            )\n          ]\n    (let [empty-list (empty-spaces board)\n          all-rows (map #(conj  (conj (diagonal-rows %) (vertical-row (second %))) (nth board (first %))) empty-list)\n          ]\n\n     (reduce-kv (fn [a idx v] (if (= true v)\n                                (conj a (nth empty-list idx))\n                                a\n                                )) #{} (into [] (map (fn [v] (some #(win-seq? %) v)) all-rows)))\n      )))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn [player board]\n    (let [column\n          (fn [[x y]]\n            (for [newy [0 1 2]]\n              [x newy]))\n\n          row\n          (fn [[x y]]\n            (for [newx [0 1 2]]\n              [newx y]))\n\n          diags\n          (fn [[x y :as pos]]\n            (let [up [[0 2] [1 1] [2 0]]\n                  down [[0 0] [1 1] [2 2]]]\n              (filter #(some (partial = pos) %) [up down])))\n\n          triples\n          (fn [pos]\n            (into (diags pos) [(row pos) (column pos)]))\n\n          winning?\n          (fn [board triple]\n            (every? #(= player (get-in board %)) triple))\n\n          empties\n          (fn [board]\n            (for [x [0 1 2]\n                  y [0 1 2]\n                  :when (= :e (get-in board [x y]))]\n              [x y]))\n          ]\n      (apply hash-set \n             (filter\n              (fn [pos]\n                (let [new-board (assoc-in board pos player)\n                      lines (triples pos)]\n                  (some #(winning? new-board %) lines)))\n              \n              (empties board)))))","problem":119,"user":"4daea889edd6309eace4d15b"},{"problem":119,"code":"(fn [piece board] (let [analyze (fn [board] (condp #(some #{%1} %2) (map first (filter #(apply = %)\n                                                                                       (concat board (apply map vector board)\n                                                                                               (vector (vec (map #(nth %1 %2) board (range 3))) ;first diag\n                                                                                                       (vec (map #(nth %1 %2) board (reverse (range 3))))))))\n                                              :x :x\n                                              :o :o\n                                              nil))]\n                    (set (filter #(= piece (analyze (assoc-in board % piece)))\n                                 (filter #(= :e (get-in board %))\n                                         (set (mapcat #(map vector (repeat %) (range 3)) (range 3))))))))","user":"56baab13e4b0f26550335948"},{"problem":119,"code":"(fn [move in-board]\n    (let [solved  (fn [board]\n                    (->> (for [r (range 3)]\n                           [(set (for [c (range 3)] (get-in board [r c]) )) ;; rows\n                            (set (for [c (range 3)] (get-in board [c r]) )) ;; colums\n                            ]\n                           )\n                         (cons (set (for [r (range 3)] (get-in board [r r]))))\n                         (cons (set (for [r (range 3)] (get-in board [r (- 2 r)]))))\n                         flatten\n                         (filter #(= (count %) 1))\n                         (filter #(not (= #{:e} %)))\n                         empty?\n                         not)\n                    ) ] \n      (->> (for [r (range 3)\n                 c (range 3)]\n             (if (= (get-in in-board [r c]) :e)\n               [ (solved (assoc-in in-board [r c] move)) r c ]\n               nil))\n           (filter (comp not nil?))\n           (filter first)\n           (map rest)\n           set)\n      )\n    )","user":"57aa290de4b0b8559636fc65"},{"code":"(fn [chess board]\n  (letfn [(win [v]\n                (let [m \n                      (reduce \n                       #(conj % {(nth v %2) (conj (% (nth v %2) []) %2)}) \n                       {} '(0 1 2))]\n                  (if (and (= 2 (count (m chess))) (= 1 (count (m :e))))\n                    (first (m :e)) -1)))]\n    (set (partition 2 (concat \n                            (reduce #(let [r (win (nth board %2))]\n                                       (if (neg? r) %\n                                         (conj % %2 r))) [] '(0 1 2))\n                            (reduce (fn [coll i]\n                                       (let [r (win (map #(nth % i) board))]\n                                       \t(if (neg? r) coll\n                                        \t (conj coll r i)))) [] '(0 1 2))\n                            (let [r (win (map #(nth (nth board %) %) '(0 1 2)))]\n                              (if (neg? r) [] [r r]))\n \t\t\t\t\t\t\t(let [r (win (map #(nth (nth board %) (- 2 %)) '(0 1 2)))]\n                              (if (neg? r) [] [r (- 2 r)])))))))","problem":119,"user":"51780f88e4b03d69594194c9"},{"problem":119,"code":"(fn [piece board]\n  (let [subs (for [x (range 3) y (range 3) :when (= :e (get-in board (list y x)))] \n               (list [y x] (update-in board (list y x) (fn [_] piece))))]\n         (letfn [(win? [se] (and (apply = se) (not (= :e (first se)))))\n                 (cols [b] (map (fn [colno] (map #(nth % colno) b)) (range 3)))\n                 (diags [b] (map #(map (fn [c] (get-in b c)) %) [[[0 0] [1 1] [2 2]]\n                                                                 [[0 2] [1 1] [2 0]]]))\n                 (boardwin? [b] (some identity (map win? (concat b (cols b) (diags b)))))]\n           (set (map first (filter #(boardwin? (second %)) subs))))))","user":"56018dd4e4b04bb52996e18f"},{"problem":119,"code":"(fn [who board]\n  (let [win? (fn [move]\n               (let [board (assoc-in board move who)]\n                 (some #{(repeat 3 who)}\n                       (concat board\n                               (apply map vector board)\n                               (map\n                                #(for [i (range 3)] ((% i) i))\n                                [board (vec (reverse board))])))))\n        moves (for [x (range 3)\n                       y (range 3)\n                       :when (= :e (get-in board [x y]))] [x y])]\n    (set (filter win? moves))))","user":"4e6a4950535d8ccf87e9febf"},{"code":"(fn [player matrix]\n  (letfn \n    [(entry [x y] ((matrix x)y))\n     (m01 [x y] \n       (let [e (entry x y)]\n         (cond \n           (= e :e) 0\n           (= e :x) 1\n           :else   -1))) \n     (row+  [x y]\n        (reduce + (for [y (range 0 3)] (m01 x y))))\n     (col+  [x y]\n  \t(reduce + (for [x (range 0 3)] (m01 x y))))\n     (diag+ [x y]\n        (reduce + (for [i (range 0 3)] (m01 (mod (+ x i) 3) (mod (+ y i) 3)))))\n     (anti+ [x y]\n\t\t(reduce + (for [i (range 0 3)] (m01 (mod (- x i) 3) (mod (+ y i) 3))))) \n     (win? [f x y]  \n       (let \n          [play  (if (= player :x) 1 -1)]\n          (= (Math/abs (+ play (f x y))) 3)))\n     (check [player x y]\n          (and (zero? (m01 x y)) \n\t\t\t   (or (win? row+ x y) (win? col+ x y)\n                   (if (zero? (mod (+ x y) 2)) \n                     (or (if (= x y) (win? diag+ x y)) \n                         (if (not= x y) (win? anti+ x y))\n                         (if (= x y 1) (win? anti+ x y)))\n                     false))))]     \n     (loop [x 0 y 0 winset #{}]\n\t   (if (= y 3)\twinset\n         (recur (mod (inc x) 3) \n                (if (= x 2) (inc y) y) \n                (if (check player x y) (conj winset [x y]) winset))))))","problem":119,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn [k b]\n  (letfn [(get-row [b [[x1 y1] [x2 y2]]]\n            [(get-in b [y1 x1]) (get-in b [y2 x2])])\n          (complete-rows [[x y]]\n            [[[(- x 2) (- y 2)] [(dec x) (dec y)]]\n            [[x (- y 2)] [x (- y 1)]]\n            [[(+ x 2) (- y 2)] [(inc x) (dec y)]]\n            [[(+ x 2) y] [(inc x) y]]\n            [[(+ x 2) (+ y 2)] [(inc x) (inc y)]]\n            [[x (+ y 2)] [x (inc y)]]\n            [[(- x 2) (+ y 2)] [(dec x) (inc y)]]\n            [[(- x 2) y] [(dec x) y]]\n            [[x (dec y)] [x (inc y)]]\n            [[(dec x) y] [(inc x) y]]\n            [[(dec x) (dec y)] [(inc x) (inc y)]]\n            [[(dec x) (inc y)] [(inc x) (dec y)]]])]\n    (set (remove nil?\n      (for [y (range 3)\n            x (range 3)]\n        (if (= :e (get-in b [y x]))\n          (if (< 0 (count (filter #(let [d (distinct %)] (and (= 1 (count d)) (= k (first d)))) (map (partial get-row b) (complete-rows [x y])))))\n            [y x])))))))","problem":119,"user":"50843a4ae4b0c98812d0788b"},{"problem":119,"code":"(fn [player board]\n    (let [\n          omni-get-winner\n          (fn [board]\n              (let [\n                    get-win\n                    (fn [vals] (if (apply = vals) (first vals) nil))\n                    get-tile-vals\n                    (fn [board tiles]\n                        (map #(nth (nth board (second %)) (first %)) tiles))\n                    get-win-over-tiles\n                    (fn [board tiles]\n                        (get-win (get-tile-vals board tiles)))\n                    cols  \n                    (fn []\n                        (for [x [0 1 2]]\n                             (vec (for [y [0 1 2]] [x y]))))\n                    rows\n                    (fn []\n                        (for [x [0 1 2]]\n                             (vec (for [y [0 1 2]] [y x]))))\n                    diag1\n                    (fn []\n                        (vec (for [n [0 1 2]]\n                                  [n n])))\n                    diag2\n                    (fn []\n                        (vec (for [n [0 1 2]]\n                                  [(- 2 n) n])))\n                    searches\n                    (fn []\n                        (conj (apply conj (rows) (cols)) (diag1) (diag2)))\n                    first-matching\n                    (fn [symbols input]\n                        (first (filter #(not= nil (some #{%} symbols)) input)))\n                    ]\n                  (first-matching [:x :o]\n                            (map #(get-win-over-tiles board %) (searches)))))\n          would-win\n          (fn would-win [board player [x y]]\n              (= player (omni-get-winner (assoc-in board [y x] player))))\n          avail-spaces\n          (fn avail-spaces [board]\n              (for [x (range 3) y (range 3)\n                    :when (= :e (nth (nth board y) x))]\n                  [x y]))\n          dumb-hack-swap\n          (fn dumb-hack-swap [vals] (map (fn [[x y]] [y x]) vals))  \n          ]\n        (set (dumb-hack-swap (filter (partial would-win board player) (avail-spaces board))))))","user":"5a21d34ce4b0ff51aa4b32b9"},{"code":"(fn f[k [a b c :as rows]]\n  (letfn [(with-coord [vs] (map (fn [v r] (map #(-> [% [r %2]]) v (range))) vs (range)))\n          (win-pos [v] (let [grouped  (sort-by (comp count second) (group-by first v))\n                             winner (->> grouped first second first)\n                             other (->> grouped last second first)]\n                         (if (and (= (count grouped) 2) (= (first winner) :e) (= (first other) k))\n                           #{(second winner)}\n                           #{})))]\n    (let [rows (with-coord rows)\n          cols (apply map vector rows)\n\t\t  d1 (map #(nth % %2) rows (range))\n          d2 (map #(nth % %2) rows (range (dec (count a)) -1 -1))\n          diags [d1 d2]]\n      (->\n       (->>\n        (concat rows cols diags)\n        (map win-pos)\n        (reduce into #{}))\n       (disj #{})))))","problem":119,"user":"51efd397e4b0249c592fbdeb"},{"code":"(fn [step board]\n    (letfn [(win-line [board poss]\n                      (let [line (map #(get-in board %) poss)]\n                        (and (not (= :e (first line))) (apply = line)))\n                      )\n            (is-win [board]\n                    (or \n                      (win-line board [[0 0] [0 1] [0 2]])\n                      (win-line board [[1 0] [1 1] [1 2]])\n                      (win-line board [[2 0] [2 1] [2 2]])\n                      \n                      (win-line board [[0 0] [1 0] [2 0]])\n                      (win-line board [[0 1] [1 1] [2 1]])\n                      (win-line board [[0 2] [1 2] [2 2]])\n                      \n                      (win-line board [[0 0] [1 1] [2 2]])\n                      (win-line board [[2 0] [1 1] [0 2]])\n                      ))]\n           (into #{} \n                 (for [r (range 0 3) c (range 0 3) \n                       :when (and \n                               (= :e (get-in board [r c]))\n                               (is-win (assoc-in board [r c] step))) ] \n                   [r c]))\n           ))","problem":119,"user":"4dca8b6d535d5973398f9288"},{"code":"(fn [piece b]\n  (letfn [(transpose [board] (apply mapv vector board))\n          (diagonals [board] (mapv #(mapv get board %) [[0 1 2] [2 1 0]]))\n          (win-board [board] (some {[:x :x :x] :x [:o :o :o] :o}\n                                   (concat\n                                    board\n                                    (transpose board)\n                                    (diagonals board))))]\n    (set (for [i [0 1 2]\n              j [0 1 2]\n              :let [coords [i j]]\n              :when (and (= :e (get-in b coords))\n                         (win-board (assoc-in b coords piece)))]\n           coords))))","problem":119,"user":"510db6cde4b078ea71921145"},{"problem":119,"code":"(fn [w b]\n  (let [coords       (range 3)\n        all-rows     (map set\n                       (partition 3\n                         (concat\n                           (for [x coords y coords] [x y])\n                           (for [y coords x coords] [x y])\n                           (for [d [-1 1] x coords] [x (inc (* d (dec x)))]))))\n        winning-pos? (fn [p]\n                       (some #(every? #{w} %)\n                         (map (fn [r] (map #(get-in (assoc-in b p w) %) r))\n                           (filter #(contains? % p)\n                             all-rows))))]\n    (set\n      (filter winning-pos?\n        (for [x coords y coords :when (= :e (get-in b [x y]))] [x y])))))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":119,"code":"(fn [ply brd]\n  (letfn [(win? [[top mid bottom :as board]]\n            (->> (concat board (map vector top mid bottom)\n                    [[(top 0) (mid 1) (bottom 2)]\n                    [(top 2) (mid 1) (bottom 0)]])\n                  (some #(apply = ply %))\n                  (not= nil)))\n          (win-at? [pos]\n            (and (= (get-in brd pos) :e)\n                 (win? (assoc-in brd pos ply))))]\n    (set (for [x (range 3), y (range 3) :when (win-at? [x y])] [x y]))))","user":"5416b4a2e4b01498b1a71a01"},{"code":"(fn [w r p b]\n  (set\n    (for [i r j r\n          :when (= :e (get-in b [i j]))\n          :when (w (assoc-in b [i j] p) p)] [i j])))\n(fn [b p]\n  (->> [[0 0 0] [1 1 1] [2 2 2] [0 1 2] [2 1 0]]\n       (map #(map nth b %))\n       (concat b)\n       (some #(= [p p p] %))))\n(range 3)","problem":119,"user":"52b453b0e4b0c58976d9ad21"},{"problem":119,"code":"(fn [p b]          \n    (let [           \n          checkBoard   \n          (fn [v]\n            (let [q #(if (and (apply = %) (not= (last %) :e)) (last %)) w\n                  (fn[e]\n                    (some (fn[f] f)\n                          (map #(q (e %)) (range (count v)))\n                          )\n                    )\n                  ]\n              (or \n                (w #(nth v %))\n                (w (fn[x] (map #(nth % x) v)))\n                (q (map-indexed #(nth %2 (- (count v) % 1)) v))\n                (q (map-indexed #(nth %2 %) v))\n                )\n              )\n            )\n          ]\n      (set (filter #(and (= :e (get-in b %)) (checkBoard (assoc-in b % p)))\n                   (for [x (range 3) y (range 3)]\n                     [x y]\n                     )\n                   )\n           )\n      )    \n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn winners\n  [player state]\n  (letfn\n    [(filter-winners\n      [grouped]\n      (filter #(= (count %) 2) \n            (map #(filter (fn [x] (= player (:player x))) (second %)) grouped)))\n     (get-winning-spaces\n      [winners grouped grouping-fn]\n      (let [indexes (map #(grouping-fn (first %)) winners)\n            spaces  (mapcat #(filter (fn [x] (= :e (:player x))) (get grouped %)) indexes)]\n            spaces))\n     (right-diagonal\n      [indexed-state]\n      (let [left (first (filter #(and (= 0 (:row %)) (= 0 (:column %))) indexed-state))\n            center (first (filter #(and (= 1 (:row %)) (= 1 (:column %))) indexed-state))\n            right (first (filter #(and (= 2 (:row %)) (= 2 (:column %))) indexed-state))\n            diag [left center right]]\n        (if (= 2 (count (filter #(= player (:player %)) diag)))\n         (first (filter #(= (:player %) :e) diag))\n          nil)))\n     (left-diagonal\n      [indexed-state]\n      (let [left (first (filter #(and (= 2 (:row %)) (= 0 (:column %))) indexed-state))\n            center (first (filter #(and (= 1 (:row %)) (= 1 (:column %))) indexed-state))\n            right (first (filter #(and (= 0 (:row %)) (= 2 (:column %))) indexed-state))\n            diag [left center right]]\n        (if (= 2 (count (filter #(= player (:player %)) diag)))\n          (first (filter #(= (:player %) :e) diag))\n          nil)))]\n  (let \n    [indexed-state \n     (apply concat \n       (for [i (range (count state))]\n           (map-indexed #(hash-map :row i :column %1 :player %2) (state i))))\n     column-wise (group-by :column indexed-state)\n     row-wise    (group-by :row    indexed-state)\n     column-wins (filter-winners column-wise)\n     row-wins    (filter-winners row-wise)\n     winners (concat \n              (get-winning-spaces column-wins column-wise :column)\n              (get-winning-spaces row-wins row-wise :row)\n              (list (left-diagonal indexed-state))\n              (list (right-diagonal indexed-state)))]\n    (set (map #(vector (:row %) (:column %)) (remove empty? winners))))))","problem":119,"user":"5273e006e4b03e8d9a4a7495"},{"problem":119,"code":"(fn win [piece board]\n  (let [\n    empties \n      (mapcat\n        (fn [row ridx]\n          (map\n            (partial vector ridx) \n            (->>\n              (map-indexed\n                #(if (= :e %2) %1 nil)\n                row)\n              (filter (complement nil?)))))\n        board\n        (range 0 3))\n\n    htriples\n      (zipmap \n        empties\n        (map\n          board\n          (-> (map first empties))))\n\n    vtriples\n      (zipmap\n        empties\n        (map\n          #(vector \n            (get-in board [0 %]) \n            (get-in board [1 %]) \n            (get-in board [2 %]))\n          (-> (map second empties))))\n\n    dtriples\n        (let [\n          diags \n             {\n              :left (apply vector (map #(get-in board [% %]) (range 0 3)))\n              :right (apply vector (map #(get-in board [(% 0) (% 1)]) [[2 0] [1 1] [0 2]]))\n              }\n         ]\n          (->>\n              (map { \n                   [0 0] [(diags :left)]\n                   [2 0] [(diags :right)]\n                   [1 1] [(diags :left) (diags :right)]\n                   [0 2] [(diags :right)]\n                   [2 2] [(diags :left)]\n                }\n               empties)\n              \n              (zipmap empties)))\n    triples\n      (merge-with \n          #(if (nil? %2) %1 (concat %1 %2)) \n          (merge-with #(conj [] %1 %2) htriples vtriples)\n          dtriples)\n          \n  ]\n    (reduce-kv\n      (fn [A k v]\n          (if \n              (->\n                  (filter (fn [triple] (-> (filter #(= piece %) triple) (count) (> 1))) v)\n                  (count)\n                  (> 0))\n              (conj A k)\n              A))\n       #{}\n       triples) \n    ))","user":"5b02ab12e4b0cc2b61a3bd53"},{"code":"(fn [pc board]\n  (let  [\n    who-won (fn [board]\n      (first (some \n        #{[:o :o :o]  [:x :x :x]}\n        (partition 3\n          (map\n            board\n            [0 1 2 3 4 5 6 7 8\n             0 3 6 1 4 7 2 5 8\n             0 4 8 2 4 6])))))\n    flat-board (vec (flatten board))\n    empties (for [i (range 9) \n                :when (= :e (flat-board i))] i)\n    wins (for [e empties \n              :when (= pc (who-won (assoc flat-board e pc)))] e)]\n    (set \n      (map \n        (fn [win] [(quot win 3) (mod win 3)]) \n         wins))))","problem":119,"user":"4daa374930acd6ed13482a68"},{"problem":119,"code":"(fn sol [player board]\n  (letfn [(slots [v x] (filter (fn [[a b]] (= b v)) x))\n          (one-empty? [x] (= 1 (count (slots :e x))))\n          (player-has-two-slots? [x] (= 2 (count (slots player x))))\n          (empty-slot-pos [x] (first (first (slots :e x))))]\n    (reduce #(conj %1 (empty-slot-pos %2)) #{}\n            (filter #(and (one-empty? %) (player-has-two-slots? %))\n                    (map (fn [x] (map #(vector % (get-in board %)) x)) \n                         (concat (map (fn [x] (map #(vector % x) (range 3))) (range 3))\n                                 (map (fn [x] (map #(vector x %) (range 3))) (range 3))\n                                 (list (map #(vector % %) (range 3)))\n                                 (list (map #(vector % (- 2 %)) (range 3)))))))))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":119,"code":"(fn [sym board]\n    (let [transpose (fn [board] (apply mapv vector board))\n          rows      (fn [board] (map (partial get-in board) [[0] [1] [2]]))\n          cols      (fn [board] (rows (transpose board)))\n          diags     (fn [board]\n                      (list\n                       (map (partial get-in board) [[0 0] [1 1] [2 2]])\n                       (map (partial get-in board) [[2 0] [1 1] [0 2]])))\n          win?      (fn [sym v] (apply = sym v))]\n      \n      (set\n       (for\n           [r     [0 1 2]\n            c     [0 1 2]\n            :let  [b (if (= :e (get-in board [r c]))\n                       (assoc-in board [r c] sym)\n                       board)]\n            :when (seq\n                   (filter\n                    (partial win? sym)\n                    (concat (cols b) (rows b) (diags b))))]\n         [r c]))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn win [value border]\n  (let [combs\n        (concat\n          (for [x [0 1 2]] [[0 x] [1 x] [2 x]])\n          (for [y [0 1 2]] [[y 0] [y 1] [y 2]])\n          [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]])\n        check\n        (fn [comb]\n          (if (->> (map #(get-in border %) comb) frequencies (= {value 2 :e 1}))\n            (filter #(= :e (get-in border %)) comb)\n            nil))]\n  (->>\n    (map check combs)\n    (apply concat)\n    (remove nil?)\n    set)))","problem":119,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":119,"code":"(fn [p boards]\n  (let [diag-pos [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]]\n\t  (letfn [(get-ij [i j]\n\t\t\t\t\t  (get-in boards [i j]))\n\t\t\t  (get-adjs [i j]\n\t\t\t            (let [rows (map #(get-ij i %) [0 1 2])\n\t\t\t\t\t\t      cols (map #(get-ij % j) [0 1 2])\n\t\t\t\t\t\t\t  diags (filter #((set %) [i j]) diag-pos)]\n\t\t\t\t\t\t  (if (empty? diags)\n\t\t\t\t\t\t    (vector rows cols)\n\t\t\t\t\t\t\t(apply vector rows cols (map #(map (partial apply get-ij) %) diags)))))]\n\t\t\t  (->> (for [i [0 1 2] j [0 1 2]\n\t\t\t\t\t  :when (= (get-ij i j) :e)]\n\t\t\t\t\t  [i j])\n\t\t\t       (filter (fn [[i j]]\n\t\t\t\t\t\t\t(->> (get-adjs i j)\n\t\t\t\t\t\t\t     (filter #(= (count (filter (partial = p) %)) 2))\n\t\t\t\t\t\t\t\t ((complement empty?)))))\n\t\t\t\t\t(set)))))","user":"536f871de4b0fc7073fd6e7f"},{"problem":119,"code":"(fn tic-tac-toe [one-piece game-board]\n  (letfn [(win-game? [index]\n            (if (not= :e (get-in game-board index))\n              false\n              (let [new-board (assoc-in game-board index one-piece)\n                    test-index-list [[[0 0] [1 0] [2 0]]\n                                     [[0 1] [1 1] [2 1]]\n                                     [[0 2] [1 2] [2 2]]\n                                     [[0 0] [1 1] [2 2]]\n                                     [[0 2] [1 1] [2 0]]]\n                    test-lines (map (fn [line-index]\n                                      (map (fn [piece-index]\n                                             (get-in new-board piece-index))\n                                           line-index))\n                                    test-index-list)\n                    total-lines (remove #{'(:e :e :e)} (concat new-board test-lines))]\n                (some #(= 1 (count (set %))) total-lines))))]\n    (let [match-index (for [x (range 3)\n                            y (range 3)]\n                        (when (win-game? [x y]) [x y]))]\n      (set (filter (complement nil?) match-index)))))","user":"4eec82fe535d93acb0a668ae"},{"problem":119,"code":"(fn\n  [p board]\n  (set\n  (filter (fn [[i j]]\n            (let [b (assoc-in board [i j] p)\n                  ppp [p p p]]\n              (or (= ppp (get b i))\n                  (= ppp (map #(get-in b %) [[0 j] [1 j] [2 j]]))\n                  (= ppp (map #(get-in b %) [[0 0] [1 1] [2 2]]))\n                  (= ppp (map #(get-in b %) [[0 2] [1 1] [2 0]])))))\n          (for [i [0 1 2] j [0 1 2] :when (= :e (get-in board [i j]))] [i j]))))","user":"4e521cef535d302ef430da6d"},{"problem":119,"code":"(fn [side board]\n  (letfn [(getloc [board r c] (nth (nth board r) c))\n          (setloc [board r c side] (assoc board r (assoc (nth board r) c side)))\n          (wsides [board] \n                  (let [lines (concat board (apply map vector board) \n                                      [[(getloc board 0 0) (getloc board 1 1) (getloc board 2 2)]]\n                                      [[(getloc board 0 2) (getloc board 1 1) (getloc board 2 0)]])\n                        wsides (distinct (map first (filter #(= 1 (count %)) \n                                                            (map distinct lines)\n                                                    )))]\n                    wsides))\n          ]\n   (set (filter (fn [[r c]] (and (= :e (getloc board r c)) \n                                 (some #{side} (wsides (setloc board r c side)))\n                                 ))\n                (for [r (range 3) c (range 3)] [r c])\n           ))\n  ))","user":"52faec2ee4b047fd55837004"},{"problem":119,"code":"(fn [piece board]\r\n  (let [\r\n      zip (fn [& seq] (apply map list seq))\r\n      add-coord (fn [board] (into [] (map\r\n        (fn [[y row]]\r\n          (into [] (map\r\n            (fn [[x cell]] {:y y, :x x, :cell cell})\r\n            (zip (range) row))))\r\n        (zip (range) board))))\r\n      board (add-coord board)\r\n      cols (apply zip board)\r\n      diags [[((board 0) 0) ((board 1) 1) ((board 2) 2)]\r\n             [((board 0) 2) ((board 1) 1) ((board 2) 0)]]\r\n      lines (concat board cols diags)\r\n      moves (->> lines\r\n        (map #(-> [% (frequencies (map :cell %))]))\r\n        (filter (fn [[_ freq]] (= freq {piece 2, :e 1})))\r\n        (map first)\r\n        (map (fn [line] (filter #(= :e (:cell %)) line)))\r\n        (map (fn [[point]] [(point :y) (point :x)])))]\r\n    (set moves)))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [e b]\n   (let [wins [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\n         flatb (flatten b)\n         coords (fn [x] (identity [(quot x 3) (rem x 3)]))\n         valid-moves (filter (comp not nil?) (map-indexed #(if (= :e %2) % nil) flatb))\n         make-move (fn [x] (concat (take x flatb) [e] (drop (inc x) flatb)))\n         iswin (fn [b] (some identity (map (fn [w] (every? #(= (nth b %) e) w)) wins)))\n         ]\n     (into #{} (map coords (filter (comp not nil?) (map #(if (iswin (make-move %)) %) valid-moves))))))","problem":119,"user":"513b77f3e4b00f740c76c403"},{"problem":119,"code":"(fn wins [fg brd]\n  (letfn [(row-gen [n] (map (fn [x] [x n]) [0 1 2]))\n          (col-gen [n] (map (fn [y] [n y]) [0 1 2]))\n          (same? [b ms] (every? true? (map (fn [m] (= fg (b m))) ms)))\n          (wins? [bm mv]\n            (let [b (assoc bm mv fg)\n                  diag1-gen (map (fn [a] [a a]) [0 1 2])\n                  diag2-gen (map (fn [a] [(- 2 a) a]) [0 1 2])]\n              (or (same? b (row-gen 0)) (same? b (row-gen 1)) (same? b (row-gen 2))\n                  (same? b (col-gen 0)) (same? b (col-gen 1)) (same? b (col-gen 2))\n                  (same? b diag1-gen) (same? b diag2-gen ))))\n          ]            \n    (let [brd-idx (->> brd\n                       (map-indexed (fn [yi y] (map-indexed (fn [xi x] [[xi yi] x] ) y)))\n                       (apply concat))\n          brd-map (into {} brd-idx)\n          moves (map first (filter (fn [[c f]] (= :e f)) brd-idx))]\n\n      (->> moves\n           (filter (fn [m] (wins? brd-map m)))\n           (map (fn [[x y]] [y x]))\n           (into #{})))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [c b]\n  (let [elem-at (fn [b c y x] \n                  (let [e (get (get b y) x)] \n                    (if (= e c) true false)))\n        subst (fn [b c y_new x_new]\n                (vec (for [y (range 0 3)]\n                       (vec (for [x (range 0 3)] \n                              (if (and (= x_new x) (= y_new y)) c (get (get b y) x)))))))\n        won? (fn [b c] \n                (or (and (elem-at b c 0 0)(elem-at b c 0 1)(elem-at b c 0 2))\n                    (and (elem-at b c 1 0)(elem-at b c 1 1)(elem-at b c 1 2))\n                    (and (elem-at b c 2 0)(elem-at b c 2 1)(elem-at b c 2 2))\n                    (and (elem-at b c 0 0)(elem-at b c 1 0)(elem-at b c 2 0))\n                    (and (elem-at b c 0 1)(elem-at b c 1 1)(elem-at b c 2 1))\n                    (and (elem-at b c 0 2)(elem-at b c 1 2)(elem-at b c 2 2))\n                    (and (elem-at b c 0 0)(elem-at b c 1 1)(elem-at b c 2 2))\n                    (and (elem-at b c 0 2)(elem-at b c 1 1)(elem-at b c 2 0))))]\n    (set (for [y (range 0 3) x (range 0 3) \n               :when (and (elem-at b :e y x) (won? (subst b c y x) c))]\n           [y x]))))","problem":119,"user":"4ed286d4535d44c135fd68d7"},{"code":"(fn [p board]\n  (let [win? (fn [[[a b c] [d e f] [g h i]] p]\n               (or (= p a b c)\n                 (= p d e f)\n                 (= p g h i)\n                 (= p a d g)\n                 (= p b e h)\n                 (= p c f i)\n                 (= p a e i)\n                 (= p c e g)))]\n    (set\n      (for [x (range 3) y (range 3)\n            :when (= :e (get-in board [x y]))\n            :when (win? (assoc-in board [x y] p) p)]\n        [x y]))))","problem":119,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn xo [p b] ;b like [[:x :o :e] ...]\n  (let [xorows (fn [bb] ;add coords to rows like (([:x [0 0]] [:o [0 1]] [:e [0 2]]) ...)\n          (for [i (range 3)] \n            (for [j (range 3)] [(get-in bb [i j]) [i j]]))),\n        xocols (fn [bb] ;and to columns\n          (for [i (range 3)] \n            (for [j (range 3)] [(get-in bb [j i]) [j i]]))),\n        xodiag (fn [bb] ;and to diagonals\n          (for [f [identity (fn [n] (- 2 n))]] \n            (for [i (range 3)] [(get-in bb [i (f i)]) [i (f i)]]))),          \n        xowin (fn [pp r] ;winning coords or nil\n          (when (= 2 (count (filter #(= pp (first %)) r)))\n            (first (keep #(when (= :e (first %)) (last %)) r))))]\n    (set (keep #(xowin p %)\n      (concat (xorows b) (xocols b) (xodiag b))))))","problem":119,"user":"4ee82a02535d93acb0a66879"},{"code":"(fn [piece board]\n  (letfn [(step [board]\n            (filter (complement nil?) (map\n                                        (fn [index]\n                                          (let [line (board index)]\n                                            (if (and\n                                                  (= 2 (count (filter #(= % piece) line)))\n                                                  (= 1 (count (filter #(= % :e ) line))))\n                                              (first (filter (complement nil?) (map\n                                                                                 (fn [jndex]\n                                                                                   (if (= :e (line jndex))\n                                                                                     [index jndex]))\n                                                                                 (range 0 (count line))))))))\n                                        (range 0 (count board)))))]\n    (set (concat\n           (step board)\n           (map #(vec (reverse %)) (step (vec (apply (partial map #(vec [%1 %2 %3])) board))))\n           (let [line [(first (first board)) (second (second board)) (last (last board))]]\n             (if (and\n                   (= 2 (count (filter #(= % piece) line)))\n                   (= 1 (count (filter #(= % :e ) line))))\n               (if (= :e (first line))\n                 [[0 0]]\n                 (if (= :e (second line))\n                   [[1 1]]\n                   (if (= :e (last line))\n                     [[2 2]])))\n               []))\n           (let [line [(last (first board)) (second (second board)) (first (last board))]]\n             (if (and\n                   (= 2 (count (filter #(= % piece) line)))\n                   (= 1 (count (filter #(= % :e ) line))))\n               (if (= :e (first line))\n                 [[0 2]]\n                 (if (= :e (second line))\n                   [[1 1]]\n                   (if (= :e (last line))\n                     [[2 0]])))\n               []))))))","problem":119,"user":"514d7e29e4b019235f6c0587"},{"problem":119,"code":"(fn placements [piece mat]\n  (letfn [(win? [p [[a b c] [d e f] [g h i]]]\n            (or (= a d g p)\n                (= b e h p)\n                (= c f i p)\n                (= a b c p)\n                (= d e f p)\n                (= g h i p)\n                (= a e i p)\n                (= c e g p)))]\n    (set (for [i [0 1 2] j [0 1 2]\n               :when (= :e (get-in mat [i j]))\n               :let [n-mat (assoc-in mat [i j] piece)]\n               :when (win? piece n-mat)]\n           [i j]))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":119,"code":"(fn ttt-wins [player rows]\n  (let [range3 (range 3)]\n    (set\n     (for [i range3, j range3\n           :when (= :e (get-in rows [i j]))\n           :let [rows (assoc-in rows [i j] player)]\n           :when (some #(apply = player %)\n                       (concat\n                        rows\n                        (partition 3 (apply interleave rows))\n                        [(map nth rows range3)\n                         (map nth rows (reverse range3))]))]               \n       [i j]))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [player board]\n  (set (let [player-positions-map \n               (reduce (fn [positions-map [player pos]] \n                              (update-in positions-map [player] #(conj (or %1 #{}) %2) pos))\n                       {}\n                       (for [y (range 3), x (range 3)]\n                         [(get-in board [y x]) [y x]]))\n             winning-combinations\n               #{[[0 0] [0 1] [0 2]]\n                 [[1 0] [1 1] [1 2]]\n                 [[2 0] [2 1] [2 2]]\n                 [[0 0] [1 0] [2 0]]\n                 [[0 1] [1 1] [2 1]]\n                 [[0 2] [1 2] [2 2]]\n                 [[0 0] [1 1] [2 2]]\n                 [[0 2] [1 1] [2 0]]}]\n    (filter (fn [empty-slot]\n              (let [player-positions (conj (player player-positions-map) empty-slot) ]\n                 (some #(every? player-positions %) winning-combinations)))\n            (:e player-positions-map)))))","problem":119,"user":"53300924e4b019098a6f8b55"},{"problem":119,"code":"(fn [piece board]\n  (letfn [(winner [b] \n          (let [N (count (first b))]\n          ((comp first first) \n           (filter #(or (apply = :o %) (apply = :x %))\n              ; horizontals\n             (concat b\n              ; verticals\n              (for [x (range N)] (map #(nth % x) b))\n              ; diagnal nw to se\n              [(for [x (range N)] (nth (nth b x) x))]\n              ; diagnal ne to sw\n              [(for [x (range N)] (nth (reverse (nth b x)) x))])))))]\n    (set (for [x (range (count (first board))) \n          y (range (count board))\n          :let [spot (get-in board [x y])\n                newb (assoc-in board [x y] piece)]\n          :when (and (= spot :e) (= piece (winner newb)))]\n      [x y]))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":119,"code":"(fn [el board]\n   (let [xs '(:0 :1 :2)\n         rows (zipmap xs board)\n         columns (zipmap xs (apply map vector board)) ;get columns\n         diagonals (zipmap xs [(into [] (map get board [0 1 2])) (into [] (map get board [2 1 0]))])]\n   \t (letfn [\n   \t      (filter-by-element [el m] (into {} (filter (fn [[k v]] (= (count (filter #{el} v)) 2) ) m)))\n   \t      (filter-by-empty [m] (into {} (filter (fn [[k v]] (= (count (filter #{:e} v)) 1) ) m)))\n          (find-position-for-rows [n] (into [] (map (fn [[k v]] [(Integer/parseInt (name k)) (.indexOf v :e)]) n )))\n          (find-position-for-cols [n] (into [] (map (fn [[k v]] [(.indexOf v :e) (Integer/parseInt (name k))]) n )))\n          (find-position-for-diag [n] (into [] (map (fn [[k v]] [(.indexOf v :e) (Math/abs (- (* (Integer/parseInt (name k)) 2) (.indexOf v :e)))]) n)))]\n\t\t(into #{} \n      (apply concat \n          (filter not-empty [\n            ( ->> (filter-by-element el rows)\n                   filter-by-empty\n                   find-position-for-rows)\n            ( ->> (filter-by-element el columns)\n                   filter-by-empty\n                   find-position-for-cols)\n            ( ->> (filter-by-element el diagonals)\n                   filter-by-empty\n                   find-position-for-diag)]))))))","user":"55d7312ee4b0e31453f64a9f"},{"problem":119,"code":"(fn tttwins [plr b] (let [\n\tlines [\n\t\t[[0 0][0 1][0 2]]\n\t\t[[1 0][1 1][1 2]]\n\t\t[[2 0][2 1][2 2]]\n\t\t[[0 0][1 0][2 0]]\n\t\t[[0 1][1 1][2 1]]\n\t\t[[0 2][1 2][2 2]]\n\t\t[[0 0][1 1][2 2]]\n\t\t[[0 2][1 1][2 0]]\n\t]\n\twins (mapcat (fn [l] (let [\n\t\tgl (map (fn [lp] (get-in b lp)) l)\n\t\tt1 (println :test1 gl)\n\t\tfrq (frequencies gl)\n\t\thaswin (and (= (frq :e) 1) (= (frq plr) 2))\n\t\twinind (if haswin (.indexOf gl :e))\n\t\twinpos (if haswin (nth l winind))\n\t\twinvec (if haswin [winpos] [])\n\t] winvec)) lines)\n\tresult (into #{} wins)\t\n] result))","user":"571aad45e4b07c98581c3b59"},{"problem":119,"code":"(fn [p b] (let [a (for [n (range 3)\n                        n*(range 3)] [n n*])\n                w (map set(concat (vals(group-by #(%1 0) a)) (vals(group-by #(%1 1) a))[[[0 0][1 1][2 2]]][[[0 2][1 1][2 0]]]))\n                m (set(filter #(= p (get-in b %)) a))\n                me(set(filter #(= :e (get-in b %)) a))]\n            (into #{}(apply concat(for[ws w\n                                       :when (and(= 2 (count (clojure.set/intersection m ws)))\n                                                 (= 1 (count (clojure.set/intersection me ws))))]\n                                    (clojure.set/intersection me ws))))\n            ))","user":"566a3a26e4b0a866af689699"},{"code":"(letfn [(winner? [b]\n           (let [lines (map #(set %)\n                            (concat b\n                                    (map #(map (fn [r] (nth r %)) b)\n                                         (range 3))\n                                    [(map-indexed #(nth %2 %1) b)]\n                                    [(map-indexed\n                                      #(nth %2 (- (dec (count b)) %1)) b)]))]\n             (cond\n              (some #(and (= 1 (count %)) (= :x (first %))) lines) :x\n              (some #(and (= 1 (count %)) (= :o (first %))) lines) :o\n              :else nil)))\n         (update-board [b r c p]\n           (map (fn [row-num]\n                  (map (fn [col-num]\n                         (if (and (= row-num r)\n                                  (= col-num c)\n                                  (= (get-in b [r c]) :e))\n                           p\n                           (get-in b [row-num col-num])))\n                       (range (count (first b)))))\n                (range (count b))))]\n   (fn [p b]\n     (into #{} (for [r (range 3)\n                     c (range 3)\n                     :when (= ( winner? (update-board b r c p)) p)]\n                 [r c]))))","problem":119,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":119,"code":"(fn [p bd]\n  (let [wls\n        (apply concat\n               (for [a (range 3)] (for [b (range 3)] [a b]))\n               (for [a (range 3)] (for [b (range 3)] [b a]))\n               [[(for [a (range 3)] [a a])]\n                [(for [a (range 3)] [a (- 2 a)])]])\n        win?\n        (fn [bd']\n          (not-every?\n           not\n           (map (fn [wl]\n                  (every? identity\n                          (map #(= p (get-in bd' %)) wl))) wls)))]\n    (set\n     (for [i (range 3) j (range 3)\n           :let [x (get-in bd [i j])]\n           :when (and\n                  (= x :e)\n                  (win? (assoc-in bd [i j] p)))]\n       [i j]))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [p b] \n (let [trans (fn [m] (apply map vector m))\n       diags (fn [b] (let [len (count b)]\n                          [(map-indexed #(nth %2 %1) b)\n                           (map-indexed #(nth %2 (- len %1 1)) b)]))\n       threes (fn [b] (concat b (trans b) (diags b)))\n\n       winner (fn [b] (some (fn [r] (or (and (every? #(= :x %) r) :x)\n                                        (and (every? #(= :o %) r) :o)))\n                            (threes b)))\n       empty (fn [b] (for [x (range 3) y (range 3) \n                           :when (= (get-in b [x y]) :e)] [x y]))\n       would-win (fn [b move p] (= p (winner (assoc-in b move p))))]\n  (set (filter #(would-win b % p) (empty b)))))","problem":119,"user":"4e7e3cc4535db169f9c7970a"},{"problem":119,"code":"(fn tic [piece board]\n  (letfn [(find-win [config]\n            (let \n              [row (map (partial get-in board) config)]\n              (when\n                (= 2 (count (filter #(= piece %) row)))\n                (->> config\n                     (map vector row)\n                     (filter #(= :e (first %)))\n                     first\n                     second))))]\n    (let\n      [configs (concat\n                 [[[0 0] [1 1] [2 2]]\n                  [[2 0] [1 1] [0 2]]]\n                 (for [x (range 3)] (for [y (range 3)] [x y]))\n                 (for [y (range 3)] (for [x (range 3)] [x y])))]\n      (->> configs\n           (map find-win)\n           (filter identity)\n           set))))","user":"521e8227e4b0dd19981ad082"},{"problem":119,"code":"(fn win-tic-tac-toe [piece board]\n   (let [won? (fn [rows]\n                (let [cols (apply map vector rows)\n                      diagonals [(for [i [0 1 2]] (get-in rows [i i]))\n                                 (for [i [0 1 2]] (get-in rows [i (Math/abs (- i 2))]))]\n                      colls (concat rows cols diagonals)\n                      win? (fn [target] (some #(every? #{target} %) colls))]\n                  (cond (win? :x) :x\n                        (win? :o) :o)))]\n     (set (remove nil? (for [x (range 3) y (range 3)\n                             :when (= :e (get-in board [x y]))]\n                         (when (won? (assoc-in board [x y] piece))\n                           [x y]))))))","user":"5a062e07e4b01bb0ae8afdc5"},{"problem":119,"code":"(fn winning-placements [mark board]\n  (let [winning-positions\n        [(fn [[[a _ _]\n               [b _ _]\n               [c _ _]]]\n           [a b c])\n         (fn [[[_ a _]\n               [_ b _]\n               [_ c _]]]\n           [a b c])\n         (fn [[[_ _ a]\n               [_ _ b]\n               [_ _ c]]]\n           [a b c])\n         (fn [[[a b c]\n               [_ _ _]\n               [_ _ _]]]\n           [a b c])\n         (fn [[[_ _ _]\n               [a b c]\n               [_ _ _]]]\n           [a b c])\n         (fn [[[_ _ _]\n               [_ _ _]\n               [a b c]]]\n           [a b c])\n         (fn [[[a _ _]\n               [_ b _]\n               [_ _ c]]]\n           [a b c])\n         (fn [[[_ _ a]\n               [_ b _]\n               [c _ _]]]\n           [a b c])]\n        won? (fn [mark board]\n               (some #(if (apply = mark (% board))\n                       mark)\n                     winning-positions))]\n    (set (for [row (range 3)\n               col (range 3)\n               :when (and (= :e (get-in board [row col]))\n                          (won? mark (assoc-in board [row col] mark)))]\n           [row col]))))","user":"5353afa0e4b084c2834f4b03"},{"problem":119,"code":"(fn wins4 [player given-posn]\n  (let [won? (fn [posn]\n               (let [complete? (fn [line] (every? #{player} line))\n                     transpose (apply mapv vector posn)\n                     reflect (map rseq posn)\n                     diag (fn [matrix] (map-indexed #(nth %2 %1) matrix))]\n                 (or (some complete? posn)\n                     (some complete? transpose)\n                     (complete? (diag posn))\n                     (complete? (diag reflect)))))\n        empties (for [i (range (count given-posn))\n                      j (range (count (given-posn 0)))\n                      :when (= :e ((given-posn i) j))]\n                  [i j])]\n    (set \n      (filter\n        #(won? (assoc-in given-posn % player))\n        empties))))","user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn [v s] (into #{} \n  (for [x [0 1 2]\n        y [0 1 2]\n  :when ((fn [[[a b c]\n      [d e f]\n      [g h k]]]\n  (reduce #(or % %2) (map \n    (fn [[x y z]]\n      (if (and (= x y z) (not= x :e))\n        x\n        nil))\n  [[a b c] [d e f] [g h k]\n   [a d g] [b e h] [c f k]\n   [a e k] [c e g]]))) \n        (update-in s [x y] #(if (= % :e) v %)))]\n    [x y])))","problem":119,"user":"4f01c938535dcb61093f6a39"},{"code":"(fn [v c]\n  (set (for [x (range 3) y (range 3)\n           :when (and (= :e (get-in c [x y]))\n                      (let [p (assoc-in c [x y] v)\n                            w? #(= % (repeat 3 v))]\n                        (or (w? (map #(get-in p [x %]) (range 3)))\n                            (w? (map #(get-in p [% y]) (range 3)))\n                            (w? (map #(get-in p %) [[0 0] [1 1] [2 2]]))\n                            (w? (map #(get-in p %) [[0 2] [1 1] [2 0]])))))]\n        [x y])))","problem":119,"user":"52479487e4b05ef8e38e6373"},{"problem":119,"code":"(fn next-move [player board]\n  \n  (letfn [ (set-in [board val [x y]]\n             (assoc board x (assoc (board x) y val)))\n           \n           (find-winner [b]\n\n            (let [horizontal\n                  (fn [b]\n                    (cond\n                     (some #(= % [:x :x :x]) b) :x\n                     (some #(= % [:o :o :o]) b) :o\n                     :else nil))\n                  rotated-board (apply map vector b)\n                  diag-a (map #(nth %1 %2) b (range 0 3))\n                  diag-b (map #(nth %1 %2) b [2 1 0])\n                  ]\n\n              (or\n               (horizontal (concat b [diag-a diag-b]))\n               (horizontal rotated-board))))]\n\n    (set (for [x (range 3) y (range 3)\n                :when\n                (when (= :e (get-in board [x y]))\n                  (find-winner (set-in board player [x y])))] [x y]))\n    \n    ))","user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn [type board]\n  (letfn [(winner [ds]\n            (let [ r (range 3)\n                   l (concat \n                        (map (fn [x] (map #(vector x %) r)) r)\n                        (map (fn [x] (map #(vector % x) r)) r)\n                        [[ [0 0] [1 1] [2 2] ] [ [2 0] [1 1] [0 2] ]]) ]\n              ( { type type } \n                (first \n                  (map first \n                    (filter #(= (count %) 1) \n                      (map distinct (map #(map (fn [[a b]] ((ds a) b)) %) l))))))))\n              \n          (moves []\n            (filter #(= ((board (% 0)) (% 1)) :e) (for [x (range 3) y (range 3)] [x y])))\n\n          (col-rep [i v]\n            [\n              (if (= i 0) type (v 0))\n              (if (= i 1) type (v 1))\n              (if (= i 2) type (v 2))\n            ])\n\n          (row-rep [i x y]\n            (if (= i x)\n              (col-rep y (board i))\n              (board i)))\n\n          (test-move [[x y]]\n            (winner \n              [\n                (row-rep 0 x y)\n                (row-rep 1 x y)\n                (row-rep 2 x y)\n              ]))]\n\n    (set (filter test-move (moves)))))","problem":119,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":119,"code":"(fn tic-tc-toe [player v]\n  (let [three-same? (fn [co-ords] (-> co-ords frequencies vals (#(apply max %)) ((partial = 3))))\n        forward-slash #{[0 2] [1 1] [2 0]}\n        back-slash #{[0 0] [1 1] [2 2]}\n        winner? (fn [co-ords]\n                  (or\n                    (-> (map first co-ords) three-same?)\n                    (-> (map second co-ords) three-same?)\n                    (= forward-slash (clojure.set/intersection forward-slash (set co-ords)))\n                    (= back-slash (clojure.set/intersection back-slash (set co-ords)))\n                    ))\n        board->winner #(->> %\n                            (remove (fn [[k _]] (= k :e)))\n                            (map (fn [[k co-ords]] [k (winner? co-ords)]))\n                            (some (fn [[k b?]] (when b? k))))\n        start-board (->> v\n                         (map-indexed (fn [row-num row] (map-indexed (fn [col-num val] [val [row-num col-num]]) row)))\n                         (mapcat identity)\n                         (group-by first)\n                         (map (fn [[k v]] [k (mapv second v)]))\n                         (into {}))\n        empty-spots (-> (filter (fn [[k _]] (= k :e)) start-board) first second)\n        ]\n    (set (filter (fn [co-ord]\n                   (board->winner (update-in start-board [player] conj co-ord)))\n                 empty-spots))))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn wingame [piece board]\n(letfn [(won? [b]\n(let [pos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [6 4 2]] board (flatten b)]\n((fn [res] (cond (some #{:x} res) :x (some #{:o} res) :o :else nil))\n    (map (fn [v] (reduce (fn [x y] (if (= x y) x false)) \n\t\t(map (fn [x] (nth (flatten board) x)) v))) \n\t\tpos))\n))]\n\t(into #{} (remove nil? (apply concat (map (fn [idx row] (map #(cond (= :e (get-in board [idx %1])) \n\t                               (if (= piece (won? (assoc-in board [idx %1] piece)))\n\t\t\t\t\t\t\t\t\t   [idx %1]\n\t\t\t\t\t\t\t\t\t   nil\n\t\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t\t\t   :else nil       \n\t\t\t\t\t\t\t\t   ) (range (count row)))) \n\t                   (iterate inc 0) board))))\n)\n)","problem":119,"user":"50588af1e4b06522596eba7d"},{"problem":119,"code":"(fn wins [player b]\n  (let [wp [[[[0 1 0 2][1 0 1 2][1 1 2 2]][[0 0 0 2][1 1 2 1]][[0 0 0 1][1 2 2 2][1 1 2 0]]]\n           [[[0 0 2 0][1 1 1 2]][[0 0 2 2][0 2 2 0][0 1 2 1][1 0 1 2]][[1 0 1 1][0 2 2 2]]]\n           [[[0 0 1 0][2 1 2 2][0 2 1 1]][[2 0 2 1][0 1 1 1]][[2 0 2 1][0 2 1 2][0 0 1 1]]]]\n        brc (fn [r c] (get-in b [r c]))\n        wp? (fn [r c s]\n              (and (= :e (brc r c))\n                (not-empty\n                  (for [i (get-in wp [r c])\n                        :let [[r1 c1 r2 c2] i\n                              s1 (brc r1 c1)\n                              s2 (brc r2 c2)]\n                        :when (and (= s s1 s2))]\n                    1))))]\n    (set (for [r (range 3)\n               c (range 3)\n               :when (wp? r c player)]\n      [r c]))))","user":"53f7820be4b0de5c41848560"},{"code":"(fn [p board]\n (let [rows (map-indexed (fn [i a] (map-indexed (fn [j b] [b [i j]]) a)) board)\n       cols (apply map vector rows)\n       d1 [(map (fn [n] [(get (get board n) n) [n n]]) (range 3))]\n       d2 [(map (fn [n] [(get (get board (- 2 n)) n) [(- 2 n) n]]) (range 3))]\n       all (concat rows cols d1 d2)]\n   (set\n    (map (fn [y] (second (first y)))\n         (filter (fn [x] (and (= 1 (count x))\n                              (= :e (ffirst x))))\n                 (map (fn [a] (filter (fn [b] (not= p (first b))) a)) all))))))","problem":119,"user":"5097b556e4b00ad8bab4e970"},{"problem":119,"code":"(fn winning-moves [player board]\n  (letfn [(column-indices \n            [rows]\n            (partition (count rows)\n                     (for [row    (range (count rows))\n                           column (range (count rows))]\n                       [column row])))\n          (row-indices [rows]\n            (partition (count rows)\n                       (for [row    (range (count rows))\n                             column (range (count rows))]\n                         [row column])))\n          (diagonal-indices [rows]\n            (->> (for [row (range (count rows))]\n                   [[row row]\n                   [(- (count rows) row 1) row]])\n                 (apply map vector)))]\n  (let [rows (row-indices board)\n        columns (column-indices board)\n        diagonals (diagonal-indices board)]\n    (->> (concat rows columns diagonals)\n         (filter (fn [indices]\n                   (let [elems (map #(get-in board %) indices)\n                         freqs (frequencies elems)]\n                     (and (= (player freqs) 2)\n                          (= (:e freqs) 1)))))\n         (apply concat)\n         (filter #(= (get-in board %) :e))\n         set))))","user":"571c2babe4b07c98581c3b73"},{"problem":119,"code":"(fn canwin [s bo]\n      (let [b '(0,1 2)\n      \t   alle (for [x b y b :when (= :e (get-in bo [x y]))]\n\t   \t     [x y])\n           gen (for [x b y b :when (or (= x 0) (= y 0))] [x y])\n\t   inbound? (fn [[x y]] (and (>= x 0) (>= y 0) (< x 3) (< y 3)))\n\t   valid-path? (fn [v] (and (every? inbound? v) (= 3 (count v))))\n\t   go-  (fn [[x y]] (map #(vector x       (+ y %)) b))\n\t   gox1  (fn [[x y]] (map #(vector (+ x %) (+ y %)) b))\n\t   gox2  (fn [[x y]] (map #(vector (- x %) (+ y %)) b))\n\t   goI  (fn [[x y]] (map #(vector (+ x %) y      ) b))\n\t   allv (filter valid-path? (for [c gen p [go- gox1 gox2 goI] ] (p c)))\n\t   winpath? (fn [nbo, p] (let [se (into #{} (map #(get-in nbo %) p))] (and (not (contains? se :e) ) (= (count se) 1))))\n           win? (fn [nbo] (some #(winpath? nbo %) allv))\n\t   winhere? (fn [v] (win? (assoc-in bo v s)))\n \t   ]\n\t(into #{} (filter winhere? alle))\n       )\n)","user":"54a1d643e4b09f271ff37c50"},{"problem":119,"code":"(fn [p board]\n   (let [vr-coords (for [i (range 3)\n                         :let [x (+ i 0) y (+ i 0)]]\n                     [x y])\n         vr (with-meta (for [[x y] vr-coords]\n                         (get-in board [x y])) {:coords vr-coords})\n         vl-coords (for [i (range 3)\n                         :let [x (+ i) y (- 2 i)]]\n                     [x y])\n         vl (with-meta (for [[x y] vl-coords]\n                         (get-in board [x y])) {:coords vl-coords})\n         meta-board (map-indexed (fn [idx item]\n                                (let [coords (map-indexed (fn [ix it]\n                                                            [idx ix]\n                                                            ) item)]\n                                  (with-meta item {:coords coords}))\n                                ) board)\n         columns (map-indexed (fn [idx item]\n                                (let [coords (map-indexed (fn [ix it]\n                                                            [ix idx]\n                                                            )item) ]\n                                  (with-meta item {:coords coords})))\n                              (apply map vector board))\n         checks (concat meta-board [vl] [vr] columns)]\n     (letfn [(check-board [[row & res] acc]\n               (if row\n                 (let [can-win? (and (= 1 (count (filter #(= :e %) row))) (= [p] (distinct (replace {:e p} row))))]\n                   (if can-win?\n                     (let [idx (.indexOf row :e)\n                           coord (nth (:coords (meta row)) idx)]\n                       (recur res (conj acc coord)))\n                       (recur res acc)))\n                 acc))]\n       (set (check-board checks [])))))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":119,"code":"(fn [piece board]\n  (let [won? (fn [[x & r]] (and (apply = x r) (not= :e x)))\n        winning? (fn [[a b c]]\n                   (let [q (into [a b c\n                                  [(first a) (second b) (last c)]\n                                  [(first c) (second b) (last a)]]\n                                 (map vector a b c))]\n                     (some won? q)))]\n    (set (for [x (range 3)\n               y (range 3)\n               :when (and (= (get-in board [x y]) :e)\n                          (winning? (assoc-in board [x y] piece)))]\n           [x y]))))","user":"56874171e4b0dcc4269f405c"},{"problem":119,"code":"(fn [side board]\n  (let [rows (vec (map vec (partition 3 (for [y (range 3) x (range 3)] [y x]))))\n        cols (vec (map vec (partition 3 (for [y (range 3) x (range 3)] [x y]))))\n        diags  [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n        all (vec (concat rows cols diags))\n        b-map (map (fn [tr] {(first tr) (get-in board (first tr))\n                             (second tr) (get-in board (second tr))\n                             (last tr) (get-in board (last tr))}) all)\n        w-map (filter (fn [mp]\n                        (and\n                         (= 2 (count (filter #(= side %) (vals mp))))\n                         (= 1 (count (filter #(= :e %) (vals mp))))))\n                      b-map)]\n    (reduce (fn [s mp]\n              (conj s (first (for [n mp :when (= (second n) :e)] (first n)))))\n            #{}\n            w-map)))","user":"586615e6e4b0f14aab7c8858"},{"problem":119,"code":"(fn winttt [a x v]\n  (cond\n   (and (= x (get-in v [0 0])) (= x (get-in v [0 1])) (= (get-in v [0 2]) :e) (not (contains? a [0 2]))) (winttt (conj a [0 2]) x v)\n   (and (= x (get-in v [1 0])) (= x (get-in v [1 1])) (= (get-in v [1 2]) :e) (not (contains? a [1 2]))) (winttt (conj a [1 2]) x v)\n   (and (= x (get-in v [2 0])) (= x (get-in v [2 1])) (= (get-in v [2 2]) :e) (not (contains? a [2 2]))) (winttt (conj a [2 2]) x v)\n   (and (= x (get-in v [0 0])) (= x (get-in v [0 2])) (= (get-in v [0 1]) :e) (not (contains? a [0 1]))) (winttt (conj a [0 1]) x v)\n   (and (= x (get-in v [1 0])) (= x (get-in v [1 2])) (= (get-in v [1 1]) :e) (not (contains? a [1 1]))) (winttt (conj a [1 1]) x v)\n   (and (= x (get-in v [2 0])) (= x (get-in v [2 2])) (= (get-in v [2 1]) :e) (not (contains? a [2 1]))) (winttt (conj a [2 1]) x v)\n   (and (= x (get-in v [0 0])) (= x (get-in v [0 2])) (= (get-in v [0 1]) :e) (not (contains? a [0 1]))) (winttt (conj a [0 1]) x v)\n   (and (= x (get-in v [1 0])) (= x (get-in v [1 2])) (= (get-in v [1 1]) :e) (not (contains? a [1 1]))) (winttt (conj a [1 1]) x v)\n   (and (= x (get-in v [2 0])) (= x (get-in v [2 2])) (= (get-in v [2 1]) :e) (not (contains? a [2 1]))) (winttt (conj a [2 1]) x v)\n   (and (= x (get-in v [0 0])) (= x (get-in v [1 0])) (= (get-in v [2 0]) :e) (not (contains? a [2 0]))) (winttt (conj a [2 0]) x v)\n   (and (= x (get-in v [0 1])) (= x (get-in v [1 1])) (= (get-in v [2 1]) :e) (not (contains? a [2 1]))) (winttt (conj a [2 1]) x v)\n   (and (= x (get-in v [0 2])) (= x (get-in v [1 2])) (= (get-in v [2 2]) :e) (not (contains? a [2 2]))) (winttt (conj a [2 2]) x v)\n   (and (= x (get-in v [0 0])) (= x (get-in v [2 0])) (= (get-in v [1 0]) :e) (not (contains? a [1 0]))) (winttt (conj a [1 0]) x v)\n   (and (= x (get-in v [0 1])) (= x (get-in v [2 1])) (= (get-in v [1 1]) :e) (not (contains? a [1 1]))) (winttt (conj a [1 1]) x v)\n   (and (= x (get-in v [0 2])) (= x (get-in v [2 2])) (= (get-in v [1 2]) :e) (not (contains? a [1 2]))) (winttt (conj a [1 2]) x v)\n   (and (= x (get-in v [1 0])) (= x (get-in v [2 0])) (= (get-in v [0 0]) :e) (not (contains? a [0 0]))) (winttt (conj a [0 0]) x v)\n   (and (= x (get-in v [1 1])) (= x (get-in v [2 1])) (= (get-in v [0 1]) :e) (not (contains? a [0 1]))) (winttt (conj a [0 1]) x v)\n   (and (= x (get-in v [1 2])) (= x (get-in v [2 2])) (= (get-in v [0 2]) :e) (not (contains? a [0 2]))) (winttt (conj a [0 2]) x v)\n   (and (= x (get-in v [0 0])) (= x (get-in v [1 1])) (= (get-in v [2 2]) :e) (not (contains? a [2 2]))) (winttt (conj a [2 2]) x v)\n   (and (= x (get-in v [0 0])) (= x (get-in v [2 2])) (= (get-in v [1 1]) :e) (not (contains? a [1 1]))) (winttt (conj a [1 1]) x v)\n   (and (= x (get-in v [1 1])) (= x (get-in v [2 2])) (= (get-in v [0 0]) :e) (not (contains? a [0 0]))) (winttt (conj a [0 0]) x v)\n   (and (= x (get-in v [0 2])) (= x (get-in v [1 1])) (= (get-in v [2 0]) :e) (not (contains? a [2 0]))) (winttt (conj a [2 0]) x v)\n   (and (= x (get-in v [0 2])) (= x (get-in v [2 0])) (= (get-in v [1 1]) :e) (not (contains? a [1 1]))) (winttt (conj a [1 1]) x v)\n   (and (= x (get-in v [1 1])) (= x (get-in v [2 0])) (= (get-in v [0 2]) :e) (not (contains? a [0 2]))) (winttt (conj a [0 2]) x v)\n   :else a)) #{}","user":"586b6a0ae4b01531a375e957"},{"code":"(fn [p b]\n  (letfn [(s [x y] (if (= ((b y) x) :e) (assoc b y (assoc (b y) x p)) nil))\n          (w [[a b c :as x]] \n             (if (nil? x) x\n             (let [t (apply map vector x)\n                   l (concat x t [[(a 0) (b 1) (c 2)] [(a 2) (b 1) (c 0)]])]\n               (some #(= (repeat 3 p) %) l))))]\n    (set (map second (filter first (for [y [0 1 2] x [0 1 2]] [(w (s x y)) [y x]]))))))","problem":119,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":119,"code":"(fn [k b]\n  (set (let [w (fn [B]\n                 (let [T (partial repeat 3)\n                       R (range 3)\n                       V (concat [R (reverse R)] (map #(T %) R))\n                       L (concat B (map #(map nth B %) V))]\n                   (some {(T :x) :x (T :o) :o} L)))\n             n (range 3)]\n         (for [r n \n               c n\n               :let [x [r c]]\n               :when (and (= :e (get-in b x)) (w (assoc-in b x k)))]\n           x))))","user":"5c1aadcde4b01240ff567209"},{"code":"(fn [np b] \r\n    (let [n (count b)\r\n      pos (reduce \r\n            #(apply conj %1 %2) '() \r\n            (list \r\n              (for [x (range 0 n)]\r\n                (for [y (range 0 n)]\r\n                  [x y])) \r\n              (for [x (range 0 n)]\r\n                (for [y (range 0 n)]\r\n                  [y x])) \r\n              (list (for [x (range 0 n)] [x x]))\r\n              (list (for [x (range 0 n)] \r\n                      [x (- (dec n) x)]))))\r\n      check (fn [p] \r\n              (let [pv (map #(get-in b %) p)\r\n                    es (filter (partial = :e) pv)\r\n                    noenp (filter #(and (not= np %) (not= :e %)) pv)]\r\n                (if (and (empty? noenp) (= 1 (count es)))\r\n                  (reduce #(if (= (get-in b %2) :e)\r\n                             (list %2)\r\n                             %1) '() p)\r\n                  '())\r\n                ))]\r\n      (set (->> (map check pos)\r\n           (filter seq)\r\n           (map first)))))","problem":119,"user":"4f0da4e4535d0136e6c22319"},{"problem":119,"code":"(fn [sign board]\n  (loop [x (range 3) y (range 3) result #{}]\n    (if (empty? x)\n      (if (empty? y)\n        result\n        (recur (range 3) (drop 1 y) result))\n      (let [xpos (first x) ypos (first y)]\n        (if (= (get-in board [ypos xpos]) :e)\n          (if (loop [incs [[2 1] [1 -1] [-1 -2]] pairs [[0 1] [1 0] [1 1] [-1 1]]]\n                (if (empty? incs)\n                  (if (= 1 (count pairs))\n                    false\n                    (recur [[2 1] [1 -1] [-1 -2]] (into [] (drop 1 pairs)) ))\n                  (let [x1 (+ xpos (* (get-in incs [0 0]) (get-in pairs [0 0])))\n                        x2 (+ xpos (* (get-in incs [0 1]) (get-in pairs [0 0])))\n                        y1 (+ ypos (* (get-in incs [0 0]) (get-in pairs [0 1])))\n                        y2 (+ ypos (* (get-in incs [0 1]) (get-in pairs [0 1])))]\n                    (if (and (= (get-in board [y1 x1]) sign) (= (get-in board [y2 x2]) sign)) true (recur (into [] (drop 1 incs)) pairs)))))\n            (recur (drop 1 x) y (conj result [ypos xpos])) (recur (drop 1 x) y result))\n          (recur (drop 1 x) y result))))))","user":"5968d73fe4b069c0a1a197d7"},{"code":"(fn tic-tac-toe-winning-moves [player board]\n  (letfn [(tic-tac-toe-winner [board]\n            (let [v {:o -1 :e 0 :x 1}\n                  len (count board)\n                  cols (partition len (apply interleave board))\n                  diag (conj\n                        [(for [i (range len)] ((board i) i))]\n                        (for [i (range len)] ((board i) (- len i 1))))\n                  all (concat board cols diag)\n                  sum (fn [coll] (apply + (map #(v %) coll)))\n                  values (map sum all)\n                  max-value (apply max values)\n                  min-value (apply min values)]\n              (cond\n               (= max-value len) :x\n               (= min-value (- len)) :o\n               :else nil)))]\n    (->> (for [i (range 3)\n               j (range 3)\n               :when (and\n                      (= ((board i) j) :e)\n                      (= player\n                         (tic-tac-toe-winner\n                          (assoc board i (assoc (board i) j player)))))]\n           [i j])\n         set)))","problem":119,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn[piece board]\n   (letfn[\n     (winner [[[xl _ xr] [_ y _] [zl _ zr] :as xs]]\n       (ffirst \n        (filter #(and (= 1 (count %)) (not= [:e] %))\n         (map distinct \n          (concat [[xl y zr] [xr y zl]]\n                  xs \n                  (apply map vector xs))))))]\n     \n     (set\n      (remove nil?\n       (for [x (range 3)\n             y (range 3)\n             :let [pos [x y]]]\n       (if (and (= :e (get-in board pos)) \n                (= piece (winner (assoc-in board pos piece))))\n           pos))))))","problem":119,"user":"506406c8e4b075d771da6f9f"},{"problem":119,"code":"(fn [p board]\n  (letfn [(empty-cells [board]\n            (for [i (range 3)\n                  j (range 3)\n                  :when\n                  (= :e (get-in board [i j]))]\n              [i j]))\n          (wins-with?  [p board cell]\n            (= p (winner (choose-cell p board cell))))\n          (choose-cell [p board cell]\n            (assoc-in board cell p))\n          (winner [board]\n            (let [x-row (repeat 3 :x)\n                  o-row (repeat 3 :o)\n                  straight #(or (some #{x-row} %)\n                                (some #{o-row} %)\n                                nil)]\n              (or (first (straight board)) ; win by row\n                  (let [transposed (apply map list board)]\n                    (first (straight transposed))) ; win by column\n                  (let [diagonals [(map #(get-in board [% %])\n                                        [0 1 2])\n                                   (map #(get-in board [%1 %2])\n                                        [0 1 2] [2 1 0])]]\n                    (first (straight diagonals))) ; win by diagonal\n                  nil)))]\n  (set (filter (partial wins-with? p board) (empty-cells board)))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(fn [mine board]\n    (letfn [(win [a-board]\n              (let [rows a-board\n                    cols [(map first rows)\n                          (map second rows)\n                          (map #(nth % 2) rows)]\n                    gi #(get-in a-board [%1 %2])\n                    diags [[(gi 0 0) (gi 1 1) (gi 2 2)]\n                           [(gi 2 0) (gi 1 1) (gi 0 2)]]\n                    all (concat rows cols diags)]\n                (some #{[mine mine mine]} all)))]\n      (into #{}\n            (for [r (range 3) c (range 3)\n                  :when (and (= :e (get-in board [r c]))\n                             (win (assoc-in board [r c] mine)))]\n              [r c]))))","problem":119,"user":"50bca033e4b0594b91591c5d"},{"code":"(fn [p b]\r\n  (letfn [(at [b i j] (nth (nth b i) j))\r\n          (h [b n] (nth b n))\r\n          (v [b n] (map #(nth % n) b))\r\n          (d [b n] (cond (= n 0) [(at b 0 0) (at b 1 1) (at b 2 2)]\r\n                         (= n 1) [(at b 0 2) (at b 1 1) (at b 2 0)]))\r\n          (fill? [b ox line] (every? #(= ox %) line))\r\n          (fill-o? [b line] (fill? b :o line))\r\n          (fill-x? [b line] (fill? b :x line))\r\n          (win? [b]\r\n            (let [lines [(h b 0) (h b 1) (h b 2) (v b 0) (v b 1) (v b 2) (d b 0) (d b 1)]]\r\n              (cond (some #(fill-o? b %) lines) :o\r\n                    (some #(fill-x? b %) lines) :x\r\n                    :else nil)))]\r\n    (set (filter (complement empty?)\r\n                 (for [i [0 1 2] j [0 1 2] :when (= (at b i j) :e)]\r\n                   (if (= p (win? (assoc b i (assoc (nth b i) j p))))\r\n                     [i j]\r\n                     []))))))","problem":119,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [r v]\r\n(let [f (fn [v t]\r\n     (let [f (fn [t] (vector (map-indexed #(nth %2 %1) t))) \r\n           s \r\n\t\t(first (filter\r\n\t\t #(or (apply = (conj % :x)) (apply = (conj % :o)))\r\n\t\t (concat v (partition 3 (apply interleave v)) (f v) (f (reverse v)))))] (= t (first s))))]\r\n\t  (disj (into #{} (for [i (range 3) j (range 3)]\r\n\t\t(if (and (= :e ((v i) j)) (f (assoc-in v [i j] r) r)) [i j]))) nil)))","problem":119,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":119,"code":"(fn winning-pos [piece board]\n  (let [winner? (fn [board [a b]]\n                  (or (every? #(= % piece) (get board a))\n                      (every? #(= % piece) (for [i (range 3)]\n                                             (get (get board i) b)))\n                      (if (or (= b 0) (= b 2) (and (= 1 a) (= 1 b)))\n                        (or (every? #(= % piece) (for [i (range 3)]\n                                                   (get (get board i) i)))\n                            (every? #(= % piece) (for [i (range 3)]\n                                                   (get (get board i) (- 2 i)))))\n                        false)))]\n    (set (for [a (range 3)\n               b (range 3)\n               :let [val (get (get board a) b)]\n               :when (and (= :e val) (winner? (assoc-in board [a b] piece) [a b]))]\n           [a b]))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn [p b]\r\n  (let [b0 (vec (flatten b))\r\n        b1 (vec (map #(if (= (b0 %) :e) % (b0 %)) (range 9)))\r\n        b2 (map #(map b1 %) [[0 1 2][3 4 5][6 7 8][0 3 6][1 4 7][2 5 8][0 4 8][2 4 6]])\r\n        b3 (filter #(not(keyword? %)) (flatten (filter #(= ((frequencies %) p) 2) b2)))]\r\n    (set (for [x b3] [(quot x 3) (mod x 3)]))))","problem":119,"user":"4dc1ee85535d020aff1edf91"},{"problem":119,"code":"(fn [player board]\n  (letfn [(lines [board]\n            (set (concat board\n                         (for [i (range 3)] (map #(nth % i) board))\n                         (vector (for [i (range 3)] (get-in board [i i])))\n                         (vector (for [i (range 3)] (get-in board [i (- 3 1 i)]))))))\n          (winner? [lines]\n            (or (some #(every? #{player} %) lines) false))\n          (empty-positions []\n            (set\n             (for [[ridx row] (map-indexed vector board)\n                   [cidx itm] (map-indexed vector row)\n                   :when (= itm :e)]\n               [ridx cidx])))\n          (win-position? [position]\n            (winner? (lines (assoc-in board position player))))]\n\n    (set (filter #(win-position? %) (empty-positions)))))","user":"5344fe13e4b084c2834f4a32"},{"problem":119,"code":"(fn [player board]\n  (letfn [(tic-tac-toe-res [[r1 r2 r3 :as board]]\n            (let [rotated-board (vec (map vector r3 r2 r1))\n                  won-row? (fn [player board] (some true? (map #(apply = %) (map #(conj % player) board))))\n                  won-col? (fn [player] (won-row? player rotated-board))\n                  won-lft-diag? (fn [player board] (apply = (conj (map #((board %) %) (range 3)) player)))\n                  won-rgt-diag? (fn [player] (won-lft-diag? player rotated-board))\n                  won? #(or (won-row? % board) (won-col? %) (won-lft-diag? % board) (won-rgt-diag? %))]\n              (cond\n                (won? :x) :x\n                (won? :o) :o\n                :else nil)))]\n    (let [wins? (fn [player cell i j]\n                  (if (= :e cell)\n                    (= player (tic-tac-toe-res (assoc-in board [i j] player)))\n                    false))]\n      (set (for [i (range 3)\n                 j (range 3)\n                 :let [cell (get-in board [i j])]\n                 :when (and (= :e cell) (wins? player cell i j))]\n             [i j])))))","user":"5879d577e4b01531a375ead8"},{"code":"(fn [kw bd] (let \n[a (for [i (range 3) j (range 3)] \n[[i j] (nth (nth bd i) j)])\nb ((juxt #(map first %) \n#(map second %) \n#(map last %)) (partition 3 a))\nc (map\n#(nth (nth (partition 3 a) (first %)) (second %))\n [[0 0] [1 1] [2 2] [2 0] [1 1] [0 2]])\n]\n  (into #{} (keep #(if (= :e (second %)) (first %))\n (apply concat (filter   \n #(= {kw 2 :e 1} \n (frequencies (map second %))) \n (concat (partition 3 a) b\n (partition 3 c)))) ))\n))","problem":119,"user":"517945dce4b0684c1c981a43"},{"problem":119,"code":"(fn [kw grid] (let [\nkgrid (map #(= kw %) (flatten grid))\negrid (map #(= :e %) (flatten grid))\ngoal (fn [index f]\n            (let [wins (into #{} (take 3 (iterate f index)))]\n              (map #(contains? wins %) (take 9 (range)))))\ngoals (concat (map #(goal % inc) '(0 3 6))\n                   (map #(goal % (partial + 3)) '(0 1 2))\n                   (map #(goal % (partial + 4)) '(0))\n                   (map #(goal % (partial + 2)) '(2)))\nall-plays (map #(goal % identity) (range 9))\nplay (fn [agrid aplay] (map #(or %1 %2) agrid aplay))\ncheck (fn [agrid aplay] (map #(and %1 %2) agrid aplay))\ndefined? (fn [coll] (seq (filter #(= true %) coll)))\nplays (filter #(defined? %)  (map #(check egrid %) all-plays))\ncandidates (map #(play kgrid %) plays)\nwinners (filter (fn [elem] (seq (filter #(= elem %) (map #(play elem %) goals)))) candidates)\nwinner-plays (filter (fn [elem] (seq (filter #(= elem %) (map #(check elem %) winners)))) plays)\nmake-position (fn [winner]\n                     (let [index (count (first (split-with #(= false %) winner)))\n                           x (int  (/ index 3))\n                           y (mod index 3)] [x y]))\npositions (set (map make-position winner-plays))]\npositions))","user":"5272645de4b03e8d9a4a742c"},{"code":"(fn [w ttt]\n  (let\n    [\n      v #(get-in ttt %)\n      r3 (range 3)\n      lines\n        (conj \n          (mapcat (juxt #(for [x r3] [% x]) #(for [x r3] [x %])) r3) \n          (for [x r3] [x x]) \n          (for [x r3] [(- 2 x) x]))\n      win_line? (fn [w l] (= (sort (list w w :e)) (sort (map v l))))\n      win_pos (fn [l] (some #(when (= :e (v %)) %) l))]\n    (->> lines\n      (filter #(win_line? w %))\n      (reduce #(conj % (win_pos %2)) #{}))))","problem":119,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":119,"code":"(fn [sym rows]\n  (let [rows (->> rows\n                  (map-indexed\n                   (fn [y row] (->> row\n                                    (map-indexed (fn [x val] [val [y x]]))\n                                    vec)))\n                  vec)\n        columns (apply map vector rows)\n        diagonals [(map #(get-in rows [% %]) (range 3))\n                   (map #(get-in rows [% (- 2 %)]) (range 3))]]\n    (->> (concat rows columns diagonals)\n         (filter #(= (sort (map first %)) (sort [:e sym sym])))\n         (map #(some (fn [[val coords]] (and (= val :e) coords)) %))\n         set)))","user":"583e27e2e4b089d5ab817daa"},{"problem":119,"code":"(fn won[px sx](\n              letfn [\n                     (w[st](\n              some #(= (% 0) (% 1) (% 2) px) [(st 0) (st 1) (st 2) \n                   [((st 0) 0) ((st 1) 0) ((st 2) 0)]\n                   [((st 0) 1) ((st 1) 1) ((st 2) 1)]\n                   [((st 0) 2) ((st 1) 2) ((st 2) 2)]\n                   [((st 0) 0) ((st 1) 1) ((st 2) 2)]\n                   [((st 0) 2) ((st 1) 1) ((st 2) 0)]\n                   ]\n                      ))\n                    \n                    (e[st] (\n                            keep-indexed (fn [y r] (\n                              map #(identity [y %]) (keep-indexed (fn [x c] ( if (= c :e) x)) r)                                              \n                              )) st\n                             ))\n                           \n                     (r[x y st p] (vec (\n                        concat (take y st) \n                        [(vec (#(concat [] (take x %) [p] (take-last (- 2 x) %) ) (st y)))]\n                        (take-last (- 2 y) st)\n                                    )))\n                    ]\n\n              (reduce #(\n                         if (w (r (%2 1) (%2 0) sx px))\n                         (conj %1 %2)\n                        %1\n                        \n                        ) #{} (apply concat (e sx)))\n              \n              ))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn win-ttt [t [[a b c][d e f][g h i]]]\n  (let [k [[[a [0 0]][b [0 1]] [c [0 2]]][[d [1 0]][e [1 1]][f [1 2]]][[g [2 0]][h 21][i [2 2]]]]\n        v [[[a [0 0]][d [1 0]][g [2 0]]][[b [0 1]][e [1 1]][h [2 1]]][[c [0 2]][f [1 2]][i [2 2]]]]\n        d [[[a [0 0]][e [1 1]][i [2 2]]][[c [0 2]][e [1 1]][g [2 0]]]]\n        all (concat k v d)\n        filtered (filter #(= 2 (count ((group-by (partial = t) (map first %)) true))) all)]\n    (set (map second (filter #(= :e (first %)) (apply concat filtered))))))","problem":119,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn [player grid]\n(let [column (fn [f grid] (map f grid))\n      grid-by-columns (fn [grid] (map #(column % grid) [first second last]))\n      diagonal (fn [grid] (map #(%1 %2) [first second last] grid))\n      diagonals (fn [grid] (map diagonal [grid (reverse grid)]))\n      is-every (fn [symbol coll] (every? #(= symbol %) coll))\n      is-winner (fn [player grid] (some #(is-every player %) (concat grid (grid-by-columns grid) (diagonals grid))))\n      winner (fn [grid] (cond (is-winner :x grid) :x\n                              (is-winner :o grid) :o\n                              :else nil))\n      positions (for [x (range 3) y (range 3)] (vector x y))\n      is-empty (fn [x y] (= :e ((grid x) y)))\n      next-grid (fn [x y] (assoc grid x (assoc (grid x) y player)))\n      is-winning-move (fn [[x y]] (and (is-empty x y) (= player (winner (next-grid x y)))))]\n  (set (filter is-winning-move positions))\n  )\n)","problem":119,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":119,"code":"(fn winning-moves [p board]\n               (let [empty-pos (apply concat (map (fn [row-index] (keep-indexed #(when (= :e %2) [row-index %1]) (get board row-index))) (keep-indexed #(when (contains? (into (hash-set) %2) :e) %1) board)))]\n                 (letfn [(is-winning? [s]\n                           (and (apply = s) (= p (first s))))\n                         (is-winning-row? [b]\n                           (loop [rows b]\n                             (if (empty? rows)\n                               false\n                               (if (is-winning? (first rows))\n                                 (is-winning? (first rows))\n                                 (recur (rest rows))))))\n                         (is-winning-col? [b]\n                           (loop [cols (map (fn [i] (map #(nth % i) b)) (range 3))]\n                             (if (empty? cols)\n                               false\n                               (if (is-winning? (first cols))\n                                 (is-winning? (first cols))\n                                 (recur (rest cols))))))\n                         (is-winning-diag? [b]\n                           (let [diag (map #(get-in b [% %]) (range 3))]\n                             (is-winning? diag)))\n                         (is-winning-anti-diag? [b]\n                           (let [anti-diag (map #(get-in b [% (- 2 %)]) (range 3))]\n                             (is-winning? anti-diag)))\n                         (is-winning-board? [b]\n                           (if (is-winning-row? b)\n                             (is-winning-row? b)\n                             (if (is-winning-col? b)\n                               (is-winning-col? b)\n                               (if (is-winning-diag? b)\n                                 (is-winning-diag? b)\n                                 (is-winning-anti-diag? b)))))]\n                   (loop [positions empty-pos ans (hash-set)]\n                     (if (empty? positions)\n                       ans\n                       (if (is-winning-board? (assoc-in board (first positions) p))\n                         (recur (rest positions) (conj ans (first positions)))\n                         (recur (rest positions) ans)))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":119,"code":"(fn [a xss]\n  (let [coords (for [x (range 3) y (range 3)] [x y])\n        fields (zipmap coords (flatten xss))\n        rows (mapv #(filter (fn [[[x _] _]] (= % x)) fields) (range 3))\n        cols (mapv #(filter (fn [[[_ y] _]] (= % y)) fields) (range 3))\n        diag (vector (filter (fn [[[x y] _]] (= x y)) fields))\n        dieg (vector (filter (fn [[[x y] _]] (= 2 (+ x y))) fields))\n        all  (concat rows cols diag dieg)\n        wins (filter #(= {:e 1 a 2} (frequencies (vals %))) all)\n        ]\n    (into #{} (mapcat (fn [w] (map first (filter #(= :e (val %)) w))) wins))))","user":"5d81b40ce4b0915913b1d379"},{"problem":119,"code":"(fn ttt-win [p b]\n  (let [win? (fn [board]\n               (let [same? (fn [sec] (if (apply = sec) (first sec) nil))\n                     rows (map same? board)\n                     cols (map same? (apply map vector board))\n                     diag1 (same? (map get board [0 1 2]))\n                     diag2 (same? (map get board [2 1 0]))]\n                 (some #{:x :o} (concat rows cols [diag1] [diag2]))))\n        free (for [y (range 3)\n                   x (range 3)\n                   :when (= :e (get-in b [y x]))]\n               [y x])]\n    (set (filter #(= p (win? (assoc-in b % p))) free))))","user":"5bbdd136e4b07a9b28b0ffab"},{"problem":119,"code":"(fn [p b]\n  (let [r (range 3)\n        win-row? (fn [b c] (= #{p} (into #{} (map #(get-in b %) c))))\n        win? (fn [b]\n               (or\n                 (win-row? b (for [i r] [i i]))\n                 (win-row? b (for [i r] [i (- 2 i)]))\n                 (reduce #(or % %2) (map #(win-row? b (for [i r] [% i])) r))\n                 (reduce #(or % %2) (map #(win-row? b (for [i r] [i %])) r))))]\n    (into #{} (filter #(and (= :e (get-in b %)) (win? (assoc-in b % p))) (for [i r j r] [i j])))))","user":"4faf97d8e4b081705acca258"},{"problem":119,"code":"(fn [player board]\n  (letfn [(marks [mark board]\n                 (set (for [x [0 1 2]\n                            y [0 1 2]\n                            :when (= mark (get-in board [x y]))]\n                        [x y])))]\n    (let [player-marks (marks player board)\n          empty-places (marks :e board)\n          win-states [#{[0 0] [0 1] [0 2]}\n                      #{[1 0] [1 1] [1 2]}\n                      #{[2 0] [2 1] [2 2]}\n                      #{[0 0] [1 0] [2 0]}\n                      #{[0 1] [1 1] [2 1]}\n                      #{[0 2] [1 2] [2 2]}\n                      #{[0 0] [1 1] [2 2]}\n                      #{[0 2] [1 1] [2 0]}]]\n      (set (for [move empty-places\n                 :when (some #(clojure.set/subset? % (conj player-marks move))\n                             win-states)]\n             move)))))","user":"54848141e4b0e286459a119e"},{"problem":119,"code":"(fn [p b]\n  (let [lines #(concat % (apply map vector %)\n                        [(map get % [0 1 2])]\n                        [(map get % [2 1 0])])\n        win? (fn [[x y]]\n              (let [nb (assoc-in b [x y] p)]\n                (some #(= [p p p] %) (lines nb))))\n        free (for [x [0 1 2] y [0 1 2] :when (= :e (get-in b [x y]))] [x y])]\n    \n  (set (filter win? free))))","user":"56bca51ae4b0f26550335963"},{"code":"(fn [p b]\n  (letfn [(winner? [board player]\n            (let [winners [[7 0 0] [0 7 0] [0 0 7]\n                           [4 4 4] [2 2 2] [1 1 1]\n                           [4 2 1] [1 2 4]]\n                  binified (partition 3 (map #(if (= % player) 1 0)\n                                             (flatten board)))\n                  multiplied (map #(map * [4 2 1] %) binified)\n                  summarized (map #(reduce + %) multiplied)]\n              (not (empty?\n                    (for [winner winners :when\n                          (= winner (map bit-and summarized winner))]\n                      true)))))]\n    (set (remove nil? \n                 (for [x [0 1 2] y [0 1 2]]\n                   (when (= :e (get-in b [x y]))\n                     (when (winner? (assoc-in b [x y] p) p)\n                       [x y])))))))","problem":119,"user":"512d3304e4b040332b905b2d"},{"problem":119,"code":"(fn ttt-wins [p board]\n  (letfn [\n          (ttt-win? [b]\n            (let [across [(first b) (second b) (last b)]\n                  down [(map first b) (map second b) (map last b)]\n                  zig [(first (first b)) (second (second b)) (last (last b))]\n                  zag [(first (last b)) (second (second b)) (last (first b))]\n                  candidates (concat across down [zig] [zag])\n                  x-wins (some #(every? #{:x} %) candidates)\n                  o-wins (some #(every? #{:o} %) candidates)]\n              (cond x-wins :x\n                    o-wins :o\n                    :else nil)))\n          (ttt-empties [board]\n            (filter (complement nil?) (for [x (range 3) y (range 3)]\n                                        (if (= :e (get-in board [y x]))\n                                          [y x]))))\n          (ttt-update [p board [y x]]\n            (assoc-in board [y x] p))\n          (ttt-moves [p board]\n            (let [empties (ttt-empties board)\n                  fill-cell (partial ttt-update p board)]\n              (map #(vector % (ttt-win? (fill-cell %))) empties)))\n          ]\n    (set (map first (filter #(= p (second %)) (ttt-moves p board))))))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn [m B]\n  (letfn [(p [b x y] (get-in b [x y]))\n          (W [b]\n            (let [p (partial p b)\n                  w (fn [& r] (let [R (reduce conj #{} r)] (cond (= #{:x} R) :x (= #{:o} R) :o)))]\n              (or\n               (w (p 0 0) (p 1 1) (p 2 2))\n               (w (p 0 2) (p 1 1) (p 2 0))\n               (some identity\n                     (for [i (range 3)]\n                       (or\n                        (w (p i 0) (p i 1) (p i 2))\n                        (w (p 0 i) (p 1 i) (p 2 i))))))))]\n    (apply hash-set\n     (filter\n      #(not (nil?\n             (W (assoc-in B % m))))\n      (for [x (range 3) y (range 3) :when (= :e (p B x y))] [x y])))))","problem":119,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn m2 [k b]\n  (let [merg (fn [board line]\n               (map #(vector % ((b (first %)) (second %))) line))\n        coun (fn [lined key]\n               (count (filter #(= (second %) key ) lined)))\n        result (fn [lined]\n                 (first (first (filter #(= (second %) :e ) lined))))\n        exam (fn exam [board k line]\n               (let [lined (merg board line)]\n                 (if (and (= 1 (coun lined :e))\n                          (= 2 (coun lined k)))\n                   (result lined)\n                   nil)))]\n  (set (filter identity  (map (partial exam b k) \n                         [\n                          [[0 0] [0 1] [0 2]]\n                          [[1 0] [1 1] [1 2]]\n                          [[2 0] [2 1] [2 2]]\n                          \n                          [[0 0] [1 0] [2 0]]\n                          [[0 1] [1 1] [2 1]]\n                          [[0 2] [1 2] [2 2]]\n                          \n                          [[0 0] [1 1] [2 2]]\n                          [[2 0] [1 1] [0 2]]\n                          ])))))","problem":119,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":119,"code":"(fn tic-tac-toe-wins [piece board]\n  (letfn [(line-winner [line]\n            (if (apply = line) (first line) nil))\n          (winner [board]\n            (let [rows (map line-winner board)\n                  cols (map line-winner (apply map vector board))\n                  diag-1 (line-winner (map get board (range 3)))\n                  diag-2 (line-winner (map get board (range 2 -1 -1)))]\n              (some #{:x :o} (concat rows cols [diag-1] [diag-2]))))]\n    (let [empty (for [row (range 3) \n                      col (range 3)\n                      :when (= :e (get-in board [row col]))]\n                  [row col])]\n      (set (filter #(= piece (winner (assoc-in board % piece))) empty)))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn [k t]\n  (if (> 3 (-> t set count)) #{}\n      (let [l (for [r t :let [y (.indexOf t r)]]\n                (map #(vector % [y %2]) r (range 0 3)))\n            [[c00 c01 c02] \n             [c10 c11 c12] \n             [c20 c21 c22]]   l]\n        (->> [[c00 c10 c20] [c01 c11 c21] [c02 c12 c22] [c00 c11 c22] [c20 c11 c02]]\n             (reduce conj l)\n             (filter  #(= 2 (reduce (fn [a [i]] (if (= i k) (inc a) a)) 0 %)) )\n             (map #(for [[n s] % :when (not= k n)] s) )\n             (map first)\n             set\n             ))))","problem":119,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"#(set\n  (keep\n   (fn [v]\n     (if (and\n          (= (count (filter (fn [[k e]] (= e %)) v)) 2)\n          (= (count (filter (fn [[k e]] (= e :e)) v)) 1))\n       (some (fn [[k e]] (if (= e :e) k)) v)))\n   (let [v (for [y (range 3)\n                 x (range 3)]\n             [[y x] (nth (nth %2 y) x)])]\n     (for [d [[0 1 2] [3 4 5] [6 7 8] [0 3 6]\n              [1 4 7] [2 5 8] [0 4 8] [2 4 6]]]\n       (map (partial nth v) d)))))","problem":119,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":119,"code":"(fn win-tic-tac-toe [player, board]\n  (let [winning-combinations [\n                              [[0 0] [0 1] [0 2]]  ; horizontal\n                              [[1 0] [1 1] [1 2]]\n                              [[2 0] [2 1] [2 2]]\n                              [[0 0] [1 0] [2 0]]  ; vertical\n                              [[0 1] [1 1] [2 1]]\n                              [[0 2] [1 2] [2 2]]\n                              [[0 0] [1 1] [2 2]]  ; diagonal\n                              [[2 0] [1 1] [0 2]]\n                              ]\n        ]\n    (->> winning-combinations\n         (map (fn [row] (group-by (fn [[i j]] (-> board (get i) (get j))) row)))\n         (filter (fn [plays] (and (= 1 (count (get plays :e))) (= 2 (count (get plays player))))))\n         (map (fn [plays] (first (get plays :e))))\n         set)))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn doit [xooo vvvv]\n  (let [\n               \nwinhq (fn [xo vv i]\n  (and (= xo ((vv i) 0)) (= xo ((vv i) 1)) (= xo ((vv i) 2)) )\n  ) \n\nwinvq ( fn [xo vv i]\n  (and (= xo  ((vv 0) i)) (= xo  ((vv 1) i)) (= xo  ((vv 2) i)) )\n  ) \n\nwind1q (fn [xo vv]\n  (and (= xo  ((vv 0) 0)) (= xo  ((vv 1) 1)) (= xo  ((vv 2) 2)) )\n  ) \n\nwind2q (fn [xo vv]\n  (and (= xo  ((vv 2) 0)) (= xo  ((vv 1) 1)) (= xo  ((vv 0) 2)) )\n  ) \n\nwinq (fn [xo vv]\n  (or \n    (winhq xo vv 0)\n    (winhq xo vv 1)\n    (winhq xo vv 2)      \n    (winvq xo vv 0)\n    (winvq xo vv 1)\n    (winvq xo vv 2)  \n    (wind1q xo vv)\n    (wind2q xo vv)\n    )\n  )  \n        \n                tryall (fn tall [xo vv i j]\n  (println i j)\n  (if (> j 2) \n    (tall xo vv (inc i) 0)\n    (if (> i 2)\n      []\n      (if (= :e ((vv i) j))\n        (if (winq xo (assoc vv i (assoc (vv i) j xo)))\n          (cons [i j] (tall xo vv i (inc j)) )\n          (tall xo vv i (inc j))\n          )\n        (tall xo vv i (inc j))\n        )\n      )  \n    )\n                 )\n        \n  ]\n    \n(set (tryall xooo vvvv 0 0))\n  )\n)","problem":119,"user":"4f2004a1535d64f6031464a7"},{"problem":119,"code":"(fn [v b]\n  (letfn [(deep-map [f x] (if (sequential? x) (map #(deep-map f %) x) (f x)))\n          (won? [b']\n                (let [cs (apply map vector b')\n                      b'' (flatten b')\n                      xs (deep-map #(nth  b'' %) [[0 4 8] [2 4 6]])]\n                  (some #(every? #{v} %) (concat b' cs xs))))\n          (put [i j]\n               (let [ri (nth b i)]\n                 (if (not= :e (nth ri j)) nil\n                   (concat (take i b)\n                           [(vec (concat (take j ri) [v] (drop (inc j) ri)))]\n                           (drop (inc i) b)))))]\n    (set (for [i (range 3)\n               j (range 3)\n               :when (if-let [b' (put i j)] (won? b'))]\n           [i j]))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [f p b]\n   (let [g (fn [c]\n             (keep-indexed\n              #(if (and ((f %2) :e) (= 2 ((f %2) p)))\n                 [% (.indexOf %2 :e)])\n              c))\n         [[[_ x]] [[_ y]] :as z] (for [i [[0 4 8][6 4 2]]] (g [(map #(nth (flatten b) %) i)]))]\n     (set (concat (g b)\n                  (map reverse (g (partition 3 (apply interleave b))))\n                  (if x [[x x]])\n                  (if y [[(- 2 y) y]]))))\n   ) frequencies","problem":119,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(letfn [(cells [v]\n           (for [y (range 0 (count v))\n                 x (range 0 (count (first v)))]\n             {:xy [y x] :v (get-in v [y x])}))\n         (subset [v grp]\n           (map val (group-by #(-> % :xy grp) (cells v))))\n         (rows [v]\n           (subset v (fn [[y _]] y)))\n         (cols [v]\n           (subset v (fn [[_ x]] x)))\n         (diags [v]\n           (concat (subset v (fn [[y x]] (+ x y))) \n                   (subset v (fn [[y x]] (- x y)))))\n         (lines [v]\n           (filter #(= (count %) 3) (concat (rows v) (cols v) (diags v))))\n         (winnable [line c]\n           (let [freqs (frequencies (map :v line))]\n             (if (and (= (freqs c) 2)\n                      (= (freqs :e) 1))\n               (filter #(= (:v %) :e) line))))]\n   (fn [c b] (set (map :xy (mapcat #(winnable % c) (lines b))))))","problem":119,"user":"5294e44de4b02ebb4ef75016"},{"problem":119,"code":"(fn [k board]\n  (let [lines-coordinates [[[0 0] [1 0] [2 0]]\n                           [[0 1] [1 1] [2 1]]\n                           [[0 2] [1 2] [2 2]]\n                           [[0 0] [0 1] [0 2]]\n                           [[1 0] [1 1] [1 2]]\n                           [[2 0] [2 1] [2 2]]\n                           [[0 0] [1 1] [2 2]]\n                           [[2 0] [1 1] [0 2]]]]\n    (set (keep (fn [line-coordinates]\n                 (let [line-vals (map #(get-in board %)\n                                      line-coordinates)\n                       line-vals-without-k (keep-indexed (fn [i v]\n                                                           (if (not= v k)\n                                                             [i v]))\n                                                         line-vals)]\n                   (if (= 1 (count line-vals-without-k))\n                     (let [[i v] (first line-vals-without-k)]\n                       (if (= v :e)\n                         (get line-coordinates i))))))\n               lines-coordinates))))","user":"55586905e4b0deb715856e2b"},{"problem":119,"code":"(fn win-tic-tac [player r]\n  (letfn [(rows [r]\n                (vec\n                 (map-indexed #(with-meta %2 {:transform (fn [i] [% i])}) \n                              r)))\n          (cols [r]\n                (vec\n                 (map-indexed #(with-meta %2 {:transform (fn [i] [i %])}) \n                              (apply map vector r))))\n          (diags [r]\n                 (let [c (dec (count r))]\n                   (vector\n                    (with-meta (map-indexed #(nth %2 %) r) {:transform (fn [i] [i i])})\n                    (with-meta (map-indexed #(nth %2 (- c %)) r) {:transform (fn [i] [i (- c i)])}))))\n          (all-combinations [r] \n                            (concat (rows r) (cols r) (diags r)))\n          (possible-win? [player row]\n                         (let [group (group-by identity row)\n                               stat (reduce #(update-in % [%2] count) group (keys group))]\n                           (and\n                            (= 2 (player stat))\n                            (= 1 (:e stat)))))]\n          (let [all (all-combinations r)\n                wins (filter (partial possible-win? player) all)]\n            (set\n             (remove nil? \n                     (mapcat (fn [row] \n                               (let [transform (:transform (meta row))]\n                                 (map-indexed #(if (= :e %2) (transform %)) row))) wins))))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn [p b]\n  (letfn\n    [\n      (v [p b] (reduce #(+ %1 %1 (if (= %2 p) 1 0)) 0 (flatten b)))\n      (win [p v] (some #(= (bit-and v %1) %1) '(0700 0070 0007 0444 0222 0111 0421 0124)))\n    ]\n    (loop [x 0 y 0 o #{}] \n      (if (> x 2)\n        (if (= y 2)\n          o\n          (recur 0 (inc y) o)\n        )\n        (recur (inc x) y \n          (let [t (bit-shift-right 256 (+ y y y x))]\n            (if \n              (and\n                (> (bit-and (v :e b) t) 0)\n                (win p (+ (v p b) t))\n              )  \n              (conj o [y x])\n              o\n            )  \n          )  \n        )  \n      )\n    )  \n  )                     \n)","problem":119,"user":"5176afd2e4b085adf681d889"},{"problem":119,"code":"(fn test-win [player board]\n  (letfn [(win [player board] \n            (let [a board \n                  b (conj [] (map first board) (map second board) (map last board)) \n                  c ((juxt (comp first first) (comp second second) (comp last last)) board)\n                  d ((juxt (comp first last) (comp second second) (comp last first)) board)\n                  z (concat a b [c] [d])] \n              (some identity (map (partial apply = player) z))))] \n    (set (for [i [0 1 2] j [0 1 2] :when \n          (and (= (get-in board [i j]) :e) \n               (win player (update-in board [i] assoc j player)))] [i j]))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":119,"code":"(fn [c b]\n  (letfn [(t [b i j]\n             (nth (nth b i) j))\n          (w [b]\n             (or (some #(= % [c c c]) b)\n                 (= c (t b 0 0) (t b 1 1) (t b 2 2))\n                 (= c (t b 0 2) (t b 1 1) (t b 2 0))\n                 (some #(= c (t b 0 %) (t b 1 %) (t b 2 %)) (range 3))))]\n    (set (filter (fn [[i j]]\n                   (and (= :e (t b i j))\n                        (w (assoc b i (assoc (b i) j c)))))\n                 (for [i (range 3) j (range 3)] [i j])))))","user":"5799ff45e4b05b1deef9add1"},{"problem":119,"code":"(fn\n  [x\n   [[a00 a01 a02]\n    [a10 a11 a12]\n    [a20 a21 a22]]]\n  (let [ways [\n              [[a00 [0 0]] [a01 [0 1]] [a02 [0 2]]]\n              [[a10 [1 0]] [a11 [1 1]] [a12 [1 2]]]\n              [[a20 [2 0]] [a21 [2 1]] [a22 [2 2]]]\n              [[a00 [0 0]] [a10 [1 0]] [a20 [2 0]]]\n              [[a01 [0 1]] [a11 [1 1]] [a21 [2 1]]]\n              [[a02 [0 2]] [a12 [1 2]] [a22 [2 2]]]\n              [[a00 [0 0]] [a11 [1 1]] [a22 [2 2]]]\n              [[a02 [0 2]] [a11 [1 1]] [a20 [2 0]]]\n              ]\n        ]\n    (set (filter (fn [da] (not (nil? da))) (map #((comp second first) (filter (fn [sa] (= :e (first sa))) %)) (filter #(= 2 (count (filter (fn [aa] (= (first aa) x)) %))) ways))))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn [p b]\n    (let [cell  (fn [m x y] (get (get m x) y)),\n          update-cell (fn [m x y v]\n                        (into [] (for [i (range 3)]\n                                   (into [] (for [j (range 3)]\n                                              (if (and (= i x) (= j y)) v (cell m i j)))))))\n          cols  (fn [m] (into [] (for [y (range 3)] (into [] (for [x (range 3)] (get (get m x) y)))))),\n          rows  (fn [m] (into [] (for [y (range 3)] (into [] (get m y))))),\n          diags (fn [m] (vector [((m 0) 0) ((m 1) 1) ((m 2) 2)], [((m 0) 2) ((m 1) 1) ((m 2) 0)])),\n          seq-contains? (fn [sequence item]\n                          (if (empty? sequence)\n                            false\n                            (reduce #(or %1 %2) (map #(= %1 item) sequence))))\n          winner (fn [m]\n                   (let [v (concat (cols m) (rows m) (diags m))]\n                     (cond\n                       (seq-contains? v [:x :x :x]) :x\n                       (seq-contains? v [:o :o :o]) :o\n                       :else nil)))]\n\n      (into #{} (remove nil? (reduce into #{} (map #(into #{} %1) \n        (for [i (range 3)]\n          (for [j (range 3)]\n            (if (= :e (cell b i j))\n              (if (= p (winner (update-cell b i j p))) [i j] nil)\n              nil)))))))\n      ))","problem":119,"user":"4f038567535dcb61093f6b0c"},{"problem":119,"code":"(fn [p b]\n (let [r [0 1 2]\n       m (fn [x] (frequencies x))\n       c (fn [y] (if (and (= 2 ((m y) p)) (= 1 ((m y) :e))) (.indexOf y :e)))\n       i (map c b)\n       j (map c (apply map list b))\n       k (keep c [(map #((b %) %) r)])\n       l (keep c [(map #((b %) (- 2 %)) r)])](pr i j k l)\n  (set \n   (filter identity \n    (concat\n     (map-indexed #(and %2 (vec [% %2])) i)\n     (map-indexed #(and %2 (vec [%2 %])) j)\n     (map #([[0,0][1,1][2,2]],%) k)\n     (map #([[0,2][1,1][2,0]],%)l))))))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":119,"code":"#(letfn [\n          (test-ttt-vec [p v]\n          \"return position of :eif vector v contains :e exactly once and p twice; nil otherwise\"\n            (if (not= (filter (fn[x](not= x p)) v) '(:e))\n              nil\n              (loop [n 0 found -1]\n                (if (= n 3)\n                  (if (< found 0) nil found) \n                  (if (= (nth v n) :e)\n                    (if (>= found 0)\n                      (recur 3 -1)     ; failed: found p at least twice\n                      (recur (inc n) n) ; found p once at position n \n                    )\n                    (recur (inc n) found)  ; nothing found so far. Continue\n                  )\n                )\n              )\n            )\n          )\n\n          (win-ttt-vecs [p coll mode ret]\n          \"Get all winning situations for the vectors in coll. For transformed matrices the position indices must be transformed as well (mode)\"  \n            (let [dim (count (first coll))]\n              (loop [n 0 r ret]\n                (if (= n (count coll))\n                  r\n                  (let [a (test-ttt-vec p (nth coll n))]\n                    (if (nil? a)\n                      (recur (inc n) r)\n                      (case mode\n                        :t (recur (inc n) (conj r [a n]))\n                        :d (recur (inc n) (conj r (if (= n 0) [a a] [a (- dim 1 a)])))\n                           (recur (inc n) (conj r [n a]))\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n\n          (trans [mat]\n          \"The matrix mat is a vector of lines. Return the transposed of mat, i.e the vector of columns\"\n            (let [dim (count mat)]\n              (loop [m 0 ret []]\n                (if (= m dim)\n                  ret\n                  (recur (inc m) (conj ret (vec (for [n (range dim)] (nth (nth mat n) m)))))\n                )\n              )\n            )\n          )\n\n          (diags [mat]\n          \"The matrix mat is a vector of lines. Return the vector of the two diagonals\"\n            (let [dim (count mat)]\n              (conj []\n                    (vec (for [n (range dim)] (nth (nth mat n) n)))\n                    (vec (for [n (range dim)] (nth (nth mat n) (- dim 1 n))))\n              )\n            )\n          )\n        ]\n   \n\n  (let [ret []]\n    (into #{}\n          (concat []\n                 (win-ttt-vecs %1 %2 :n ret)\n                 (win-ttt-vecs %1 (trans %2) :t ret)\n                 (win-ttt-vecs %1 (diags %2) :d ret)\n          )\n    )\n  )\n)","user":"545537c1e4b0e397800069dd"},{"problem":119,"code":"(fn [s [[a b c] [d e f] [g h i]]]\n  (let [aa [a 0 0] bb [b 0 1] cc [c 0 2] dd [d 1 0] ee [e 1 1] ff [f 1 2] gg [g 2 0] hh [h 2 1] ii [i 2 2]\n        rows [[aa bb cc] [dd ee ff] [gg hh ii] [aa dd gg] [bb ee hh] [cc ff ii] [aa ee ii] [cc ee gg]]\n        fun (fn [r] (let [{:keys [x o e]} (group-by first r)]\n                      (when (and (= (count (if (= s :x) x o)) 2) (= (count e) 1))\n                        (first e))))]\n    (set (map rest (filter identity (map fun rows))))))","user":"5c379636e4b0d62ef62d9f76"},{"problem":119,"code":"(fn win [p b]\n        (let [v (vec (flatten b))]\n          (into #{} (for [i (range 9)\n                          :when (and (= (get v i) :e)\n                                     (or (= (count (filter #(= % p) (get b (quot i 3)))) 2)\n                                         (= (count (filter #(= % p) (map #(get % (mod i 3)) b))) 2)\n                                         (and (some #{i} '(0 4 8))\n                                              (= (count (filter #(= % p) (list (get v 0) (get v 4) (get v 8)))) 2))\n                                         (and (some #{i} '(2 4 6))\n                                              (= (count (filter #(= % p) (list (get v 2) (get v 4) (get v 6)))) 2))))]\n                      (vector (quot i 3) (mod i 3))))))","user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn ttt-rb [pl s]\n  (let [c1 (hash-map [0 0] (first (first s)) \t[1 0] (first (second s)) \t[2 0] (first (nth s 2)) )\n        c2 (hash-map [0 1] (second (first s)) \t[1 1] (second (second s)) \t[2 1] (second (nth s 2)))\n\t\tc3 (hash-map [0 2] (nth (first s) 2)\t[1 2] (nth (second s) 2) \t[2 2] (nth (nth s 2) 2) )\n\t\td1 (hash-map [0 0] (first (first s))\t[1 1] (second (second s))\t[2 2] (nth (nth s 2) 2) )\n\t\td2 (hash-map [0 2] (nth (first s) 2)\t[1 1] (second (second s))\t[2 0] (first (nth s 2)) )\n\t\tl1 (hash-map [0 0] (first (first s))\t[0 1] (second (first s))\t[0 2] (nth (first s) 2) )\n\t\tl2 (hash-map [1 0] (first (second s))\t[1 1] (second (second s))\t[1 2] (nth (second s) 2))\n\t\tl3 (hash-map [2 0] (first (nth s 2))\t[2 1] (second (nth s 2))\t[2 2] (nth (nth s 2) 2) )\n\n\t\tp (hash-map :l1 l1 :l2 l2 :l3 l3 :c1 c1 :c2 c2 :c3 c3 :d1 d1 :d2 d2)\n\t\te [:l1 :l2 :l3 :c1 :c2 :c3 :d1 :d2] ]\n\n\t\t(set (filter #(not (nil? %))\n                     (for [x e]\n                       (if (= (frequencies (vals (get p x))) {:e 1, pl 2})\n                         (nth (keys (get p x))\n                              (first (keep-indexed #(if (= %2 :e) %) (vals (get p x)))))))))))","problem":119,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn [x bd]\n  (let [t [[0 1 2 0 1 2] [0 1 2 2 1 0]]\n        xy #(if (= :x %) :o :x)\n        cols #(apply map vector %)\n        diags (fn [bd] \n                (map \n                 (fn [s] (map-indexed #(nth %2 %) s))\n                 [(map reverse bd)\n                  bd]))\n        win (fn [y bd]\n              (some \n               #(every? (partial = y) %)\n               (concat\n                bd\n                (cols bd)\n                (diags bd))))]\n    (set\n     (if (win (xy x) bd)\n       nil\n       (for [i (range 3) j (range 3)\n             :when (and (= :e (get-in bd [i j]))\n                    (win x (assoc-in bd [i j] x)))]\n         [i j])))))","problem":119,"user":"51944aaae4b0142f60b4aedc"},{"problem":119,"code":"#(set (for [x [0 1 2]\n            y [0 1 2]\n            :let [p [x y]\n                  [[a b c]\n                   [d e f]\n                   [g h i] :as r] (assoc-in %2 p %)]\n            :when (= :e (get-in %2 p))\n            :when (some #{[% % %]}\n                        (list* [c e g]\n                               [a d g]\n                               [b e h]\n                               [c f i]\n                               [a e i]\n                               r))]\n        p))","user":"51ad244fe4b09397d510977f"},{"problem":119,"code":"(fn [k b]\n  (let [rg\t(range 3)\n        fw\t#(\t(set (map set (concat % (apply map list %) \n\t\t\t\t\t\t\t\t\t  (map (partial map nth %) \n                        \t               [rg (reverse rg)])))) \n               \t#{k} )\n        prs\t(for [i rg j rg :let [pair [i j]]\n                   :when (= :e (get-in b pair))] pair) ]\n    (set (filter #(fw (assoc-in b % k)) prs))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn winning [c b]\n  (let [win? ; from #73\n         (fn [rows]\n           (let [rwin #(if (and (nil? ((set %) :e)) \n                       (= 1 (count (set %)))) (first (set %)) nil)\n                 cols (vec (apply map vector rows))\n                 hor (some rwin rows) vert (some rwin cols)\n                 dia1 (rwin (map-indexed #(%2 %) rows))\n                 dia2 (rwin (map-indexed #(%2 %) (reverse rows)))]\n                 (not= nil (some identity [hor vert dia1 dia2]))))\n\n       place (fn [brd clr [y x]] (assoc brd y (assoc (brd y) x clr)))\n       empty-in-row (fn [r] (remove nil? (map-indexed #(if (= :e %2) % nil) r)))\n       empts (apply concat (map-indexed #(map vector (repeat %) %2) (map empty-in-row b)))]\n  (set (filter #(win? (place b c %)) empts))))","problem":119,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":119,"code":"(let [winner (fn [bd]\n  (let [ldiag [[0 0] [1 1] [2 2]]\n        rdiag [[0 2] [1 1] [2 0]]\n        rows (map #(vector [% 0] [% 1] [% 2]) (range 3))\n        cols (map #(vector [0 %] [1 %] [2 %]) (range 3))]\n    (first (filter (comp not nil?)\n            (for [line (cons ldiag (cons rdiag (concat rows cols)))]\n      (let [res (distinct (map #(nth (nth bd (second %)) (first %)) line))]\n        (if (and (= (count res) 1) (not (= :e (first res))))\n          (first res)\n          nil)))))))]\n  (fn [player bd]\n    (set (keep identity (for [x (range 3)\n          y (range 3)]\n      (if (and (= :e (get-in bd [x y])) \n               (= player (winner \n                          (assoc bd x (assoc (bd x) y player))\n                          )))\n        [x y]\n        nil\n        )\n      )\n    )))\n  )","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn winning-moves [player board]\n  (let [check-win\n        (fn [rows]\n          (let [cols (apply map vector rows)\n                diag (fn [x] (map-indexed #(nth %2 %) x))\n                diags [(diag rows) (diag (map reverse rows))]\n                lines (concat rows cols diags)\n                lineSets (map set lines)]\n            (some #(= #{player} %) lineSets)))]\n    (set (for [i (range 3) j (range 3)\n               :let [mt? (= (get-in board [i j]) :e)]\n               :when (and mt? (check-win (assoc-in board [i j] player)))]\n           [i j]))))","problem":119,"user":"4f6160a7e4b0defedf855fbe"},{"problem":119,"code":"(fn [player board]\n  (letfn [(find-empty-squares [board]\n            (for [x (range 0 3) y (range 0 3) :when (= :e (get-in board [x y]))] [x y]))\n          (make-move [player board move]\n            (update-in board move (constantly player)))\n          (make-all-moves [player board]\n            (for [move (find-empty-squares board)] [move (make-move player board move)]))\n          (winner [board]\n            (let [positions (concat (map #(repeat 3 %) (range 3)) [[0 1 2] [2 1 0]])\n                  get-line (fn [tr] (map nth board tr))\n                  rcd (concat board (map get-line positions))]\n              (some {[:x :x :x] :x [:o :o :o] :o} rcd)))]\n    (set (map first (filter #(= (winner (get % 1)) player) (make-all-moves player board))))))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn ttt [piece board]\n  (let [m #(mod (+ %1 %2) 3)\n        row (fn [board i j] (map #(get-in board [i (m j %)]) (range 0 3)))\n        col (fn [board i j] (map #(get-in board [(m i %) j]) (range 0 3)))\n        diag1 (fn [board i j] (map #(get-in board [(m i %) (m j %)]) (range 0 3)))\n        diag2 (fn [board i j] (map #(get-in board [(m i %) (m j (- 0 %))]) (range 0 3)))\n        wins (fn [board i j]\n                (or (apply = (row board i j))\n                    (apply = (col board i j)) \n\t                (and (= i j) (apply = (diag1 board i j))) \n\t                (and (= i (- 2 j)) (apply = (diag2 board i j)))))  ] \n    (set (for [i (range 0 3) \n             j (range 0 3) \n\t\t\t :when (and (= :e (get-in board [i j])) \n\t\t\t            (wins (assoc-in board [i j] piece) i j)) ] [i j]))))","problem":119,"user":"523a9fc9e4b081681ca7adca"},{"problem":119,"code":"(fn [player board]\n  (let [invert  #(into [] (apply map vector %))\n        winner? (fn [brd]\n                  (some #(= #{player} (into #{} %))\n                        (concat brd\n                                (invert brd)\n                                [(map #(get-in brd %) [[0 0] [1 1] [2 2]])\n                                 (map #(get-in brd %) [[0 2] [1 1] [2 0]])])))\n        open-spots (for [r (range 3)\n                         c (range 3)\n                         :when (= :e (get-in board [r c]))]\n                     [r c])]\n    (into #{} (filter #(winner? (assoc-in board % player)) open-spots))))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [piece board] (letfn [\n(get-diags [board]\n  (let [diag1 (for [i (range 3)] (get-in board [i i]))\n\tdiag2 (for [i (range 3)] (get-in board [i (- 2 i)]))]\n    [diag1 diag2]))\n\n(get-cols [board]\n  (for [i (range 3)]\n    (for [j (range 3)]\n      (get-in board [j i]))))\n\n(count-piece [piece play]\n  (count (filter #(= piece %) play)))]\n\n\n  (let [board (vec (map vec (for [row (range 3)]\n                              (keep-indexed\n                               (fn [col elt] (if (= :e elt) [row col] elt))\n                               (nth board row)))))\n        more (concat board (get-diags board) (get-cols board))]\n    (set (apply concat\n                (map #(filter vector? %)\n                     (filter #(= 2 (count-piece piece %)) more))))))\n)","problem":119,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":119,"code":"(fn win-tic-tac-toe [key board] (let [tic-tac-toe (fn [board] (let [column  (fn [board n] ( reduce #(conj %1 (nth %2 n) ) [] board))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                columns (fn [board] (reduce #(conj %1 (column board %2)) [] (range 3)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                diag1 (fn [board] (for [x (range 3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          :let [y (nth (nth board x) x)]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          y))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                diag2 (fn [board] (for [x (range 3)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          :let [y (nth (nth board (- 2 x)) x)]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                          y))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                diags (fn [board] [(diag1 board) (diag2 board)])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                triplets  (concat board (columns board) (diags board))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                                identical? (fn [triplet x] (= triplet [x x x]))]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                            (if (seq (filter #(identical? %1 :x) triplets))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                              :x\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                              (if (seq (filter #(identical? %1 :o) triplets))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                              :o\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                              nil))))]\n                                    (set (for [x1 (range 3) x2 (range 3)\n                                           :let [newboard (assoc-in board [x1 x2] key)]\n                                           :when (and (= :e (get-in board [x1 x2])) (= (tic-tac-toe newboard) key))]\n                                           [x1 x2]))))","user":"5df0c6ffe4b093ff717275c2"},{"code":"(fn [p rs]\n  (letfn [(transpose [r] (apply map (cons list r)))\n          (diag [r] (map-indexed #(get (vec %2) %) r))\n          (mirrorv [r] (map reverse r))\n          (winner [r]\n            (->> (concat r (transpose r) [(diag r)] [(diag (mirrorv r))])\n                 (remove #(apply = :e %))\n                 (map #(partition-by list %))\n                 (filter #(apply = (first %) %))\n                 (map ffirst)\n                 first))]\n    (set\n     (for [x (range 3)\n           y (range 3)\n           :when (= :e (get-in rs [x y]))\n           :when (= p (winner (assoc rs x (assoc (nth rs x) y p))))]\n       [x y]))))","problem":119,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn win [p b]\n  (letfn [(w? [b]\n            (letfn [(w [[[a b c]\n                         [d e f]\n                         [g h i]] p] (or (= p a b c)\n                                         (= p d e f)\n                                         (= p g h i)\n                                         (= p a d g)\n                                         (= p b e h)\n                                         (= p c f i)\n                                         (= p a e i)\n                                         (= p c e g)))]\n              (cond (w b :x) :x\n                    (w b :o) :o\n                    :else nil)))]\n    (let [n (-> b first count)\n          r (range n)]\n      (set (for [x r\n                 y r\n                 :let [v [x y]\n                       e (get-in b v)]\n                 :when (and (= :e e) (= p (-> b (assoc-in v p) w?)))]\n             v)))))","problem":119,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn \n  [player board]\n  (let [a [0 0], b [0 1], c [0 2],\n        d [1 0], e [1 1], f [1 2],\n        g [2 0], h [2 1], i [2 2],\n        lines [[a b c], [d e f], [g h i], [a d g]\n               [b e h], [g f i], [a e i], [c e g]],\n        look-up-pos #(get-in board %),\n        count-played (fn\n                       [p posns]\n                       (count (filter #(= % p) posns))),\n        moves (map (fn \n                     [line]\n                     (let [plays (map #(look-up-pos %) line)]\n                       (when (and (= 1 (count-played :e plays)))\n                                  (= 2 (count-played player plays))\n                         (first (filter #(= :e (look-up-pos %1)) line)))))\n                   lines)]\n    (set (filter (complement nil?) moves))))","problem":119,"user":"5341b141e4b00652c8746ecf"},{"problem":119,"code":"(fn [ch v]\n  (let [winner (fn [s]\n                 (some {[:x :x :x] :x [:o :o :o] :o}\n                        (concat s (apply map list s)\n                                (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\n                                  (for [[x y] d] ((s x) y))))))]\n    (->> (for [x (range 3) y (range 3)] [x y])\n         (filter #(= (get-in v %) :e))\n         (map #(vector % (assoc-in v % ch)))\n         (filter #(= (winner (last %)) ch))\n         (map first)\n         (set))))\n;;cf. chouser's solution of problem 73 Analyze a Tic-Tac-Toe Board for winner function","user":"5e13a6b7e4b099d064963001"},{"code":"(fn [x s]\n  (let [l [0 1 2]\n        f #(->> (concat % (apply map list %)\n                        [(for [x [0 1 2]] ((% x) x))\n                         [((% 2) 0) ((% 1) 1) ((% 0) 2)]])\n                (map set)\n                (some #{#{:x} #{:o}})\n                first)\n        g #(and (= :e (get-in s %)) (f (assoc-in s % x)))]\n    (set (filter g (for [x l, y l] [y x])))))","problem":119,"user":"522b922ee4b0d34ee08e71c3"},{"problem":119,"code":"(fn solution\n  [player board]  \"Takes a player and the board and finds winnings on the next move\"\n  (let [rows       \"abc\"\n        cols       \"123\"\n        cross      (fn [rows cols] (for [i rows j cols] (keyword (str i j))))\n        squares    (cross rows cols)\n        linelist   (map set\n                    (concat\n                      (for [i rows] (cross (str i) cols))\n                      (for [j cols] (cross rows (str j)))\n                      [[:a1 :b2 :c3]]\n                      [[:a3 :b2 :c1]]))\n        peers      (for [id squares peer (filter #(contains? % id) linelist)]\n                       {:id id :peer peer})\n        where      (fn [field pred val coll] (filter #(pred val (get % field)) coll))\n        to-pos-row (fn [acc x] \"Takes a row of board position x, and appends it to board position acc\"\n                      (let [nextrow   (/ (count acc) 3)\n                            row       (char (+ nextrow 97))\n                            a1        (keyword (str row \"1\"))\n                            a2        (keyword (str row \"2\"))\n                            a3        (keyword (str row \"3\"))\n                            [e1 e2 e3] x]\n                        (concat acc [{:id a1 :occup e1}\n                                     {:id a2 :occup e2}\n                                     {:id a3 :occup e3}])))\n        position  (reduce to-pos-row [] board)\n        rc        (clojure.set/join position peers)\n\n        rc2       (map (fn [mp]\n                    (let [id   (:id mp)\n                          peer (:peer mp)\n                          woid (disj peer id)\n                          p1   (first woid)\n                          p2   (second woid)\n                          p1o  (:occup (first (where :id = p1 position)))\n                          p2o  (:occup (first (where :id = p2 position)))]\n                              (assoc mp :p1 p1 :p2 p2 :p1o p1o :p2o p2o))) rc)\n        rc3       (filter  (fn [mp] (and (= :e     (:occup mp))\n                                         (= player (:p1o mp))\n                                         (= player (:p2o mp)))) rc2)\n       rc4        (map :id rc3)\n       pos2board  (fn [x] \"Convert a short form :a2 coordinate into 4clojure's [0 1] coord\"\n                    (let [[r c] (name x)\n                          row   (- (int r) 97)\n                          col   (- (int c) 49)]\n                        [row col]))\n\n       rc5        (set (map pos2board rc4))]\n    rc5))","user":"4dc97aec535d5973398f9284"},{"problem":119,"code":"(fn [piece board]\n  (letfn [(place [pos] (assoc-in board pos piece))\n          (check-win [rows]\n            (let\n              [checkxo (fn [pred] (if (pred :x) :x (if (pred :o) :o nil)))\n               alleq (fn [c coll] (apply = c coll))\n               hasgroupeq (fn [c groups] (some (partial alleq c) groups))\n               cols (apply map vector rows)\n               diag (map-indexed #(nth %2 %1) rows)\n               bdiag (map-indexed #(nth %2 (- (dec (count (first rows))) %1)) rows)]\n              (checkxo #(hasgroupeq % (concat rows cols [diag bdiag])))))]\n    (set\n      (filter\n        #(check-win (place %))\n        (mapcat #(let [r (.indexOf board %)]\n                   (keep-indexed (fn [i v] (when (= :e v) (vector r i))) %))\n                (filter #(.contains % :e) board))))))","user":"553abb28e4b09218d5f44ffb"},{"problem":119,"code":"(fn [sign board]\n   (->> \n    (map  \n      (fn [x]\n        [\n         x\n         (map \n         #(get-in board %)\n         x\n         )]\n        )  \n      [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]] [[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]] [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]]]\n    )\n    (filter \n     (fn [[x y]] \n       (and \n        (= 1 (apply + (map #(if (= :e %) 1 0) y)))\n        (= 2 (apply + (map #(if (= sign %) 1 0) y)))\n        )\n       )\n     )\n    (mapcat \n     (fn [[x y]] \n       (mapcat \n        (fn [p v]\n          (if (= v :e)\n            [p]\n            []\n            )\n          )\n        x y )\n       ))\n    (into #{})\n    ))","user":"5094057fe4b097f48cc38593"},{"problem":119,"code":"(fn [kw board]\n  (let [w       (count (first board))\n        winner? (fn [kw [[a0 a1 a2] [b0 b1 b2] [c0 c1 c2] :as rows]]\n                  (let [columns   (apply map #(apply vector %&) rows)\n                        diagonals (list [a0 b1 c2] [a2 b1 c0])]\n                    (->> (concat rows columns diagonals)\n                         (some {(vec (repeat 3 kw)) true}))))]\n    (->> (apply concat board)\n         (keep-indexed\n          #(when (= %2 :e)\n             [(quot %1 w)\n              (rem  %1 w)]))\n         (filter\n          #(winner? kw (assoc-in board % kw)))\n         set)))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":119,"code":"(fn ticky-tacky [ent m]\n  (letfn [(analyze-ttt [entity m]\n            (letfn [(get-columns [m]\n                      (let [col-1 (reduce #(conj %1 (get %2 0)) [] m)\n                            col-2 (reduce #(conj %1 (get %2 1)) [] m)\n                            col-3 (reduce #(conj %1 (get %2 2)) [] m)]\n                        [col-1 col-2 col-3]\n                        )\n                      )\n                    (get-diagonals [m]\n                      (letfn [(get-diag [m]\n                                (conj [] (get-in m [0 0]) (get-in m [1 1]) (get-in m [2 2]))\n                                )]\n                        [(get-diag m) (get-diag (vec (map #(vec (reverse %)) m)))])\n                      )\n                    (get-possibilities [m]\n                      (into (into (get-columns m) (get-diagonals m)) m)\n                      )]\n\n              (let [ps (get-possibilities m)\n                    entity-wins (some (fn [v] (every? #(= entity %) v) ) ps)]\n                entity-wins)))] \n\n    (let [all-cords (for [x (range 3) \n                          y (range 3)]\n                      [x y])]\n      (loop [tail all-cords res #{}]\n        (let [cur-cord (first tail)\n              is-e (= :e (get-in m cur-cord))\n              new-m (when is-e (assoc-in m cur-cord ent))] \n          (if (nil? cur-cord)\n            res\n            (if (and is-e (analyze-ttt ent new-m))\n              (recur (rest tail) (conj res cur-cord))\n              (recur (rest tail) res)\n              )\n            )\n          \n          )\n        )\n      ))\n\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":119,"code":"(fn sol [p conf]\n  (letfn [\n          \n          (rowin [r p conf]\n      (= (conf r) [p p p])\n)  \n\n(cowin [c p conf]\n      (= [((conf 0) c) ((conf 1) c) ((conf 2) c)] [p p p])\n)  \n\n(d1win [p conf]\n    (= [((conf 0) 0) ((conf 1) 1) ((conf 2) 2)] [p p p])\n)\n\n(d2win [p conf]\n   (= [((conf 0) 2) ((conf 1) 1) ((conf 2) 0)] [p p p])\n)\n\n(zug [[r c] p conf]\n   (assoc conf r (assoc (conf r) c p))\n)\n\n(winset [p conf]\n    (for [r [0 1 2]\n          c [0 1 2]\n         :when (= ((conf r) c) :e)\n         ]\n       (let [nconf (zug [r c] p conf)]\n         (cond (rowin r p nconf) [r c]\n               (cowin c p nconf) [r c]\n               (and (= [r c] [1 1]) (or (d1win p nconf) (d2win p nconf))) [r c]\n               (and (= r c) (d1win p nconf)) [r c]\n               (and (or (= [r c] [0 2]) (= [r c] [2 0])) (d2win p nconf)) [r c]                :else []\n         )\n       )\n    )\n)  \n      ]\n  \n  \n  \n  \n   (set (filter #(not (empty? %)) (winset p conf)))\n    )\n)","user":"59ff9424e4b01bb0ae8afd24"},{"problem":119,"code":"(fn [p board] (                \n  let [coords (for [x (range 3)] \n                (for [y (range 3)] [x y]))\n       \n       ->vec (fn [[[a b c]\n          \t  \t   [d e f]\n                   [g h i]]] \n               (partition 3 [a b c \n                             d e f\n                             g i h \n                             a \n                             d \n                             g \n                             b \n                             e h c f i a e i c e g]))\n       \n       grp-by #(map vector %2 % (repeat %2))] \n       \n      (->> (mapcat grp-by (->vec coords) (->vec board))\n           (filter #(= :e (first %)))\n           (filter #(= {p 2 :e 1} (frequencies (last %))))\n           (map second)\n           (into #{}))\n))","user":"5603c31fe4b04bb52996e1c1"},{"problem":119,"code":"(fn [player board]\n  (let [dirs {:e  [ 0 1]\n              :s  [ 1 0]\n              :se [ 1 1]\n              :ne [-1 1]}\n        ps (concat (map-indexed #(hash-map :dir :e :start [%1 0] :p %2) board)\n                   (->> board\n                        (apply interleave)\n                        (partition 3)\n                        (map-indexed #(hash-map :dir :s :start [0 %1] :p %2)))\n                   [{:dir :se :start [0 0] :p (map-indexed #(nth %2 ([0 1 2] %1)) board)}]\n                   [{:dir :ne :start [2 0] :p (reverse (map-indexed #(nth %2 ([2 1 0] %1)) board))}]\n                   )\n        win? (fn [{p :p}]\n               (= {:e [:e] player [player player]} (group-by identity p)))\n        next-move (fn [{dir :dir [sx sy] :start p :p}]\n                    (let [[ox oy] (dirs dir)\n                          index (.indexOf p :e)]\n                      [(+ sx (* index ox))\n                       (+ sy (* index oy))]))]\n    (->> ps\n         (filter win?)\n         (map next-move)\n         (set))))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn[p [x y z]] \n    (let [w #{7 56 448 73 146 292 273 84}\n          l (concat x y z) \n          r (reduce (fn[x y] (let [i (x :i) ee (get x :ee)] \n                                (merge x {y (+ (get x y 0) i) \n                                         :i (* 2 i)\n                                         :ee (if (= y :e)(conj ee i)ee)\n                                         })))\n            {:i 1 :ee []} l)\n          s (reduce (fn[x y] \n                        (if (some #(= % (bit-and % (+ y (r p)))) w) (conj x y) x)\n                    ) #{} (r :ee))\n          log2 (Math/log 2)\n          s (map (fn[a](let [v (int (/ (Math/log a) log2))\n                             x (mod v 3)\n                             y (int (/ (dec (- v x)) 2))\n                            ] [y x])) s)            \n          ]\n          (set s)\n    )\n)","problem":119,"user":"5017eface4b02f523d7cc5e7"},{"problem":119,"code":"(fn winning-moves [player board]\n  (let [winning-lanes '(([0 0] [1 1] [2 2])\n                        ([0 2] [1 1] [2 0])\n                        ([0 0] [0 1] [0 2])\n                        ([1 0] [1 1] [1 2])\n                        ([2 0] [2 1] [2 2])\n                        ([0 0] [1 0] [2 0])\n                        ([0 1] [1 1] [2 1])\n                        ([0 2] [1 2] [2 2]))\n        board-lanes (for [wl winning-lanes] (map (fn [position] [position (get-in board position)]) wl))\n        about-to-win? (fn [bl] (= (sort [player player :e]) (sort (map second bl))))]\n    (into #{} (for [bl board-lanes\n          :when (about-to-win? bl)]\n      (first (first (filter #(= :e (second %)) bl)))))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":119,"code":"(fn[p b](into #{} (let [f #(first\n          (some #{[p p p]}\n                (-> %\n                    (into (apply map vector %))\n                    (conj (map nth % (range))\n                          (map nth (rseq %) (range))))))]\n  (for [i (range 3) j (range 3)\n        :let [cp (get-in b [i j]) \n              b (assoc-in b [i j] p)]\n        :when (and (= cp :e) (= p (f b)))]\n    [i j]))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn [x b] \n   (let [m (zipmap (for [i (range 3) j (range 3)] [i j]) (flatten b))\n         r1 '([0 0] [0 1] [0 2])\n         r2 '([1 0] [1 1] [1 2])\n         r3 '([2 0] [2 1] [2 2])\n         c1 '([0 0] [1 0] [2 0])\n         c2 '([0 1] [1 1] [2 1])\n         c3 '([0 2] [1 2] [2 2])\n         d1 '([0 0] [1 1] [2 2])\n         d2 '([0 2] [1 1] [2 0])]\n     (set (mapcat #(filter (fn [t] (not= x (m t))) %) \n                  (map second (filter #(= {x 2 :e 1} (first %)) \n                                      (map #(vector (frequencies (map m %)) %)\n                                           [r1 r2 r3 c1 c2 c3 d1 d2])))))))","problem":119,"user":"4eb13d60535d7eef3080733f"},{"problem":119,"code":"(fn [v m]\n  (set\n    (for [p (range 3)\n          q (range 3)\n          :let [[[a b c]\n                 [d e f]\n                 [g h i]] (assoc-in m [p q] v)]\n          :when (and (= :e (get-in m [p q]))\n                  (= v (first (some #{[:x :x :x]\n                                      [:o :o :o]}\n                                (partition 3 [a b c, d e f, g h i,\n                                              a d g, b e h, c f i,\n                                              a e i, c e g])))))]\n      [p q])))","user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(fn ttt [p b]\n  (let [wins {[:e p p] 0 [p :e p] 1 [p p :e] 2}\n        b (concat b (apply map list b) (map #(map get b %) [[0 1 2] [2 1 0]]))]\n    (set (for [[i c] (keep-indexed #(when-let [c (wins %2 nil)] [%1 c]) b)]\n      (case i\n        (0 1 2) [i c]\n        (3 4 5) [c (- i 3)]\n        6 [c c]\n        7 [c (- 2 c)])))))","problem":119,"user":"4effb663535dcb61093f6a2e"},{"problem":119,"code":"(fn immediate-tic-tac-toe-win-placements [piece board]\n  (let [tic-tac-toe-winner (fn tic-tac-toe-winner [board]\n                             (let [rows board\n                                   cols [(map first board) (map second board) (map last board)]\n                                   main-diag (map #(get-in board [% %]) (range 3)) \n                                   side-diag (map #(get-in board [% (- 2 %)]) (range 3))\n                                   seqs-to-check (concat rows cols [main-diag] [side-diag])]\n                               (cond\n                                 (some #(= % [:o :o :o]) seqs-to-check) :o\n                                 (some #(= % [:x :x :x]) seqs-to-check) :x\n                                 :else nil)))\n        empty-positions (filter #(= :e (get-in board %)) \n                                (for [row (range 3) \n                                      col (range 3)] \n                                  [row col]))]\n    (->> empty-positions\n         (filter #(= piece (tic-tac-toe-winner (assoc-in board % piece))))\n         set)))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":119,"code":"(fn [me board]\n    (letfn [(win? [board]\n              (or (some true? (map (fn [row] (every? #(= me %) row)) board))\n                  (some true? (apply map (cons (fn [& c] (every? #(= me %) c)) board)))\n                  (let [[[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]] board]\n                    (or (and (= me a1) (= me b2) (= me c3))\n                        (and (= me a3) (= me b2) (= me c1))))))]\n      (->> (for [r (range 3) c (range 3)\n                 :when (= :e (nth (nth board r) c))]\n             (let [row (nth board r)]\n               (when (win?\n                      (assoc board r (assoc row c me)))\n                 [r c])))\n           (filter identity)\n           (set))))","user":"5c995fa4e4b048ec896c5a96"},{"code":"(fn [f g j i s b]\n     (g (f j s b) s (apply merge (map hash-map j i))))\n\n   (fn [j s b]\n     (reduce #(if (#{s :e} (%2 0)) \n                        (update-in % [(%2 0)] conj (%2 1)) \n                        %) \n                     {s []\n                      :e []} \n                     (map vector (flatten b) j)))\n\n   #(set (for [a (% %2)\n               b (disj (set (% %2)) a)\n               e (% :e)\n               :when (= 12 (+ a b e))]\n           (%3 e)))\n\n   [3 2 7 8 4 0 1 6 5]\n   (for [x [0 1 2] y [0 1 2]] [x y])","problem":119,"user":"4e823ed7535db62dc21a62c7"},{"problem":119,"code":"(fn [k c]\n  (let [pos (fn [[x y]] (nth (nth c x) y))\n        coord (for [row (range 3) col (range 3)] [row col])\n        ack (remove nil? (map #(if (= k (pos %)) %) coord))\n        ept (set (remove nil? (map #(if (= :e (pos %)) %) coord)))\n        all (remove nil? (for [x ack y ack] (if (not= x y) [x y])))]\n    (clojure.set/intersection ept\n                              (clojure.set/union \n                               (set (filter #(every? (complement neg?) %) (map #(vec (map - [3 3] %)) (map (fn [[a b]] (map + a b)) (remove #(= #{[1 0] [0 2]} (set %)) all)))))\n                               (set (map (fn [[a b]] [(first a) (- 3 (+ (second a) (second b)))]) (filter #(= (ffirst %) (first (second %))) all)))\n                               (set (map (fn [[a b]] [(- 3 (+ (first a) (first b))) (second a)]) (filter #(= (second (first %)) (second (second %))) all)))\n                               ))))","user":"574abbfbe4b02ea114799200"},{"problem":119,"code":"(fn get-winning-moves [piece board]\n   (let [assign-coordinates (fn [board]\n                              (partition 3 (for [[x row] (map-indexed vector board)\n                                                 [y val] (map-indexed vector row)]\n                                             {:value val :coords [x y]})))\n         get-diagonals (fn [board]\n                         [[(nth (nth board 0) 0)\n                           (nth (nth board 1) 1)\n                           (nth (nth board 2) 2)]\n                          [(nth (nth board 0) 2)\n                           (nth (nth board 1) 1)\n                           (nth (nth board 2) 0)]])\n         get-all-rows (fn [board]\n                        (let [horizontals board\n                              verticals (apply mapv vector board)\n                              diagonals (get-diagonals board)]\n                          (concat horizontals verticals diagonals)))\n         almost-finished? (fn [row piece]\n                            (let [freqs (frequencies (map :value row))]\n                              (and (= (piece freqs) 2)\n                                   (= (:e freqs) 1))))\n         get-almost-finished (fn [rows piece]\n                               (filter #(almost-finished? % piece) rows))\n         get-all-piece-squares (fn [row piece]\n                                 (mapcat #(filter (fn [x] (= (:value x) piece)) %) row))\n         get-coords-set (fn [row]\n                          (set (reduce #(cons (:coords %2) %) '() row)))]\n     (get-coords-set\n       (get-all-piece-squares\n         (get-almost-finished\n           (get-all-rows\n             (assign-coordinates\n               board))\n           piece)\n         :e))))","user":"5cd639b4e4b0ccb061962940"},{"problem":119,"code":"(fn winner [move board]\n  (let [wins [ ;; rows\n              #{[0 0] [0 1] [0 2]}\n              #{[1 0] [1 1] [1 2]}\n              #{[2 0] [2 1] [2 2]}\n              ;; columns\n              #{[0 0] [1 0] [2 0]}\n              #{[0 1] [1 1] [2 1]}\n              #{[0 2] [1 2] [2 2]}\n              ;; diagonals\n              #{[0 0] [1 1] [2 2]}\n              #{[2 0] [1 1] [0 2]}]\n        mapped-board (for [w wins]\n                       (map #(vector (get-in board %) % ) w))\n        winning-rows (filter (fn [r]\n                               (let [freqs (frequencies (map first r))]\n                                 (and (= 2 (move freqs))\n                                      (= 1 (:e freqs))))) mapped-board)]\n    (set (for [r winning-rows]\n           (second (first (filter #(= :e (first %)) r)))))))","user":"5400e918e4b0de5c41848619"},{"code":"(fn moves [player rows]\n  (let [cells (for [x (range 3) y (range 3)] [x y])]\n    (letfn [(changed [i j]\n              (let [pre (nth rows i)\n                    post (if (= :e (nth pre j))\n                           (assoc pre j player) pre)]\n                (assoc rows i post)))\n            (line [player s]\n              (apply = (cons player s)))\n            (wins [rows]\n              (let [cols (apply map vector rows)\n                    c (second (second rows))\n                    d1 [(ffirst rows) c (last (last rows))]\n                    d2 [(last (first rows)) c (first (last rows))]\n                    lines (concat rows cols [d1 d2])]\n                (some identity (map (partial line player) lines))))]\n      (into #{} (filter #(wins (changed (first %) (second %))) cells)))))","problem":119,"user":"4fbd12a5e4b081705acca2fd"},{"problem":119,"code":"(fn [t c]\n  (letfn [(isvalue [cll a b old] \n            (let [x (mod a 3) y (mod b 3)]\n              (= (get-in cll [x y]) old)))\n           (validxy [cll a b old]\n               (cond\n                  (and (isvalue cll (inc a) b old) (isvalue cll (+ 2 a) b old)) true\n                  (and (isvalue cll a (inc b) old) (isvalue cll a (+ 2 b) old)) true\n                  (and (= a b) (isvalue cll (inc a) (inc b) old) (isvalue cll (+ 2 a) (+ 2 b) old)) true\n                  (and (= (+ a b) 2) (isvalue cll (inc a) (dec b) old) (isvalue cll (+ 2 a) (- b 2) old)) true\n                  :else false))]\n   (set (filter identity \n    (for [x (range 0 3) y (range 0 3) :when (isvalue c x y :e)]\n     (if (validxy c x y t) [x y]))))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":119,"code":"(fn[piece board]\n  (letfn [(win-state [acs]\n           (let [dns (apply map vector acs)\n                 [[a _ d]\n                  [_ b _]\n                  [e _ c]] acs\n\n                 diags (list [a b c] [d b e])]\n             (->> (concat acs dns diags)\n                  (map distinct)\n                  (filter #(and (= (count %) 1)(not= :e (first %))))\n                  ffirst)))]\n    (into #{}\n          (for [x (range 3)\n                y (range 3)\n                :let [pos (get-in board [x y])]\n                :when (and (= pos :e)\n                           (= piece (win-state (assoc-in board [x y] piece))))]\n       [x y]))))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [base data]\n(let [\n      solvable?\n      (fn [x] (let [fi (first x), se (second x), th (nth x 2) ]\n  \t(if (= (first fi) (second fi) (nth fi 2))\n\t\t  (if (= :e (first fi))\n\t\t    nil\n\t\t    (first fi))\n\t\t  (if (= (first se) (second se) (nth se 2))\n\t\t    (first se)\n\t\t    (if (= (first th) (second th) (nth th 2))\n\t\t      (first th)\n\t\t      (if (= (first fi) (first se) (first th))\n\t\t\t(first fi)\n\t\t\t(if (= (second fi) (second se) (second th))\n\t\t\t  (second fi)\n\t\t\t  (if (= (nth fi 2) (nth se 2) (nth th 2))\n\t\t\t    (nth fi 2)\n\t\t\t    (if (= (first fi) (second se) (nth th 2))\n\t\t\t      (first fi)\n\t\t\t      (if (= (nth fi 2) (second se) (first th))\n\t\t\t\t(first th)\n\t\t\t\tnil))))))))))]\n\n  (set (filter vector?\n  (for [x [0 1 2] y [0 1 2]]\n    (if (= base (solvable?\n\t\t (if (= :e ((data x) y))\n\t\t   (assoc data x (assoc (data x) y base))\n\t\t   data\n\t\t )))\n       [x y]\n      \n  )))))\n)","problem":119,"user":"4eb0afed535d7eef3080733e"},{"code":"(fn winning-moves [p board]\n  (letfn [(winner [board] \n                  (let [col (apply mapv (fn [& xs] (vec xs)) board)\n                        diag [(mapv nth board (range))\n                              (mapv nth board (range 2 -1 -1))]\n                        all (concat board col diag)]\n                    (cond\n                     (some #(= [:x :x :x] %) all) :x\n                     (some #(= [:o :o :o] %) all) :o\n                     :else nil)))\n          (empty-spots [board]\n                       (for [i (range 3)\n                             j (range 3)\n                             :when (= :e (get-in board [i j]))]\n                         [i j]))]\n    (->> board\n         empty-spots\n         (filter\n          (fn [spot]\n            (= p (winner (assoc-in board spot p)))))\n         set)))","problem":119,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn solve-it2 [e ls]\n  (letfn [(solve-it [ls]\n            (letfn [(get-cols [ls]\n                      [(vec (map first ls))\n                       (vec (map second ls))\n                       (vec (map last ls))])\n                    (get-diagonals [ls]\n                      (let [idx1 [[0 0] [1 1] [2 2]]\n                            idx2 [[2 0] [1 1] [0 2]]]\n                        [(vec (map #(get-in ls %) idx1))\n                         (vec (map #(get-in ls %) idx2))]))\n                    (get-cda [ls]\n                      (vec (concat ls (get-cols ls) (get-diagonals ls))))\n                    (all-e [e ls]\n                      (apply = e ls))]\n\n              (let [lls (get-cda ls)]\n                (cond\n                 (some (partial all-e :x) lls) :x\n                 (some (partial all-e :o) lls) :o\n                 :else nil))))]\n    (set (for [x (range 3)\n               y (range 3)\n               :let [idx [x y]]\n               :when (and (= :e (get-in ls idx)) (= e (solve-it (assoc-in ls idx e))))]\n           idx))))","problem":119,"user":"4dd62278535d2dad7130b5c7"},{"problem":119,"code":"(fn win-at-tic-tac-toe\n  [piece board]\n  (let [plays (for [x (range 3) y (range 3)] [x y])\n        vectors #{[0 1] [1 0] [1 1] [1 -1]}\n        valid? (fn [p] (every? #{0 1 2} p))\n        line (fn [p v]\n               (->>\n                 [-2 -1 1 2]\n                 (map (fn [x]\n                        (->>\n                          (map (partial * x) v)\n                          (map + p))))\n                 (filter valid?)))\n        line-win? (fn [p v]\n                    (let [pieces-in-line (map (partial get-in board) (line p v))]\n                      (and (= 2 (count pieces-in-line))\n                           (apply = piece pieces-in-line))))\n        win? (fn [p]\n               (and (= :e (get-in board p))\n                    (some (partial line-win? p) vectors)))]\n    (->> plays\n         (filter win?)\n         set)))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn\n  [player board]\n  (let [diagonal1 (for [i (range 0 3)] [((board i) i) [i i]])\n        diagonal2 (for [i (range 0 3)] [((board (- 2 i)) i) [(- 2 i) i]])\n        vertical1 (for [i (range 0 3)] [((board i) 0) [i 0]])\n        vertical2 (for [i (range 0 3)] [((board i) 1) [i 1]])\n        vertical3 (for [i (range 0 3)] [((board i) 2) [i 2]])\n        horizontal1 (for [i (range 0 3)] [((board 0) i) [0 i]])\n        horizontal2 (for [i (range 0 3)] [((board 1) i) [1 i]])\n        horizontal3 (for [i (range 0 3)] [((board 2) i) [2 i]])\n        board [horizontal1 horizontal2 horizontal3\n                    diagonal1 diagonal2 vertical1 vertical2 vertical3]\n        cnt (map #(hash-map :x (count (filter (fn [[x coord]]\n                                                (or (= :e x) (= :x x))) %))\n                            :o (count (filter (fn [[x coord]]\n                                                (or (= :e x) (= :o x))) %))\n                            :e (filter (fn [[x coord]]\n                                         (= :e x)) %))\n                 board)\n        result (map #(when (and (= 3 (% player)) (= 1 (count (% :e))))\n                                (first (rest (first (% :e)))))\n                    (filter #(= (% player) 3) cnt))]\n    (set (filter #(not (nil? %)) result))))","problem":119,"user":"4db53f87535d87e67b28fe08"},{"problem":119,"code":"(fn ttt [p b]\n  (letfn [(winner [b]\n            (let [all= (fn [coll vals]\n                         (if (and (= (count (set coll)) 1) (contains? (set vals) (first coll)))\n                           (first coll)\n                           nil))]\n              (some identity\n                    [ (some #(all= % [:x :o]) b)                                        ; 3 in a row                                        \n                      (some #(all= % [:x :o]) (apply map vector b))                     ; 3 in a col                                        \n                      (all= (map #(get %2 %1) (range (count b)) b) [:x :o])             ; 3 on \\ diag                                       \n                      (all= (map #(get %2 %1) (reverse (range (count b))) b) [:x :o])   ; 3 on / diag                                       \n                      ])))]\n    (set (filter (fn [[r c]]\n                   (and (= (get-in b [r c]) :e)\n                        (= p (winner (assoc-in b [r c] p)))))\n                 (for [r (range 3) c (range 3)] [r c])))))","user":"530bf87ee4b02e82168697d5"},{"code":"(fn ttt [p board]\n  (letfn [(M [b i j] (get-in b [i j]))\n          (win [b]\n               (let [triples (concat\n                              b\n                              (apply map vector b)\n                              [[(M b 0 0) (M b 1 1) (M b 2 2)]\n                               [(M b 0 2) (M b 1 1) (M b 2 0)]])]\n                 (some (partial every? (partial = p)) triples)\n                 ))]\n    (set (for [i (range 3)\n          j (range 3)\n          :when (and (= (M board i j) :e) (win (assoc-in board [i j] p)))]\n      [i j]\n      ))\n    )\n  )","problem":119,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [P M]\n  (set\n    (keep\n      (fn [[s v]]\n        (let [l (take 3 (iterate #(map + % v) s))\n              G get-in]\n          (if (= (map (frequencies (map #(G M %) l)) [:e P]) [1 2])\n            (some #(if (= (G M %) :e) %) l))))\n      (for [s [[0 0] [0 1] [0 2] [1 0] [2 0]]\n            v [[0 1] [1 0] [1 1] [-1 1]]]\n        [s v]))))","problem":119,"user":"4ee82539535d93acb0a66878"},{"problem":119,"code":"(fn winTicTacToe [m [a b c]]\n  (let [isVictory? (fn [[a b c]]\n                     (let [f_rx #(= m %)]\n                       (cond\n                         (or (every? f_rx a) (every? f_rx b) (every? f_rx c)) true\n                         (and (= (nth a 0) m) (= (nth b 0) m) (= (nth c 0) m)) true\n                         (and (= (nth a 1) m) (= (nth b 1) m) (= (nth c 1) m)) true\n                         (and (= (nth a 2) m) (= (nth b 2) m) (= (nth c 2) m)) true\n                         (and (= (nth a 0) m) (= (nth b 1) m) (= (nth c 2) m)) true\n                         (and (= (nth a 2) m) (= (nth b 1) m) (= (nth c 0) m)) true\n                         :else false)))\n        free_first_row (for [[x y] (map-indexed vector a) :when (and (= y :e) (isVictory? [(assoc a x m) b c]))] [0 x])\n        free_second_row (for [[x y] (map-indexed vector b) :when (and (= y :e) (isVictory? [a (assoc b x m) c]))] [1 x])\n        free_third_row (for [[x y] (map-indexed vector c) :when (and (= y :e) (isVictory? [a b (assoc c x m)]))] [2 x])]\n    (set (concat free_first_row free_second_row free_third_row))))","user":"5046f909e4b03b02161376b5"},{"problem":119,"code":"(fn [col board]\r\n  (let [cols (for [y (range 3) x (range 3)] [x y])\r\n        rows (for [x (range 3) y (range 3)] [x y])\r\n        diagonals '([0 0] [1 1] [2 2] [0 2] [1 1] [2 0])\r\n        all (partition 3 (concat cols rows diagonals))\r\n        freqs (map #(list (frequencies %1) %2)\r\n                   (map #(map (partial get-in board) %) all)\r\n                   all)\r\n        win (filter #(= {col 2 :e 1} (first %)) freqs)]\r\n    (letfn [(empty-sq? [c] (= :e (get-in board c)))\r\n            (get-empty [cs] (first (filter empty-sq? cs)))]\r\n      (reduce #(conj %1 (get-empty %2)) #{} (map second win)))))","user":"53c649d3e4b00fb29b221297"},{"problem":119,"code":"(fn [pl board]\n  (let [vert (apply map vector board)\n        diag1 [[0 0] [1 1] [2 2]]\n        diag2 [[0 2] [1 1] [2 0]]\n        winning-row (repeat 3 pl)\n        is-win (fn [i j] (some #(= winning-row %)\n                           (vector\n                             (apply conj (subvec (nth board i) 0 j) pl (subvec (nth board i) (inc j) 3))\n                             (apply conj (subvec (nth vert j) 0 i) pl (subvec (nth vert j) (inc i) 3))\n                             (if (some #(= [i j] %) diag1)\n                               (map (fn [[x y]] (if (= [i j] [x y]) pl (nth (nth board x) y))) diag1)\n                               (if (some #(= [i j] %) diag2)\n                                 (map (fn [[x y]] (if (= [i j] [x y]) pl (nth (nth board x) y))) diag2))))))]\n    (set\n      (remove nil?\n        (apply concat\n          (for [i (range 3)]\n            (for [j (range 3)]\n              (if (= :e (nth (nth board i) j))\n                (if (is-win i j) [i j])))))))))","user":"551c66dae4b07993ea3788de"},{"problem":119,"code":"(fn [s t]\n (letfn [(win? [x]\n           (->> (lazy-cat\n                 x\n                 (apply mapv vector x)\n                 [(mapv #(get-in x [% %]) (range 3))\n                  (mapv #(get-in x [% (- 2 %)]) (range 3))])\n                (some #(every? #{s} %))))]\n   (->> (for [r (range 3)\n              c (range 3)\n              :when (and (= :e (get-in t [r c]))\n                         (win? (assoc-in t [r c] s)))]\n          [r c])\n        (set))))","user":"4f5cc3b8e4b0030a34fb2b2b"},{"problem":119,"code":"(fn [p b]\n            (letfn [(f73 [b]\n                      (let [win   (fn [v]\n                                    (when (and (#{:x :o} (first v)) (apply = v))\n                                      (first v)))\n                            rows  b\n                            cols  (for [c (range 3)] (map #(nth % c) b))\n                            diag1 [(for [c (range 3)] (nth (nth b c) c))]\n                            diag2 [(for [c (range 3)] (nth (nth b c) (- 2 c)))]\n                            all   (concat rows cols diag1 diag2)]\n                        (some identity (map win all))))]\n              (set (for [r     (range 3)\n                       c     (range 3)\n                       :when (and (= :e (get-in b [r c])) (f73 (assoc-in b [r c] p)))]\n                     [r c]))))","user":"583048d9e4b051871117c007"},{"problem":119,"code":"(fn won-steps [turn board]\n  (letfn [(won? [board]\n                (let [three ((apply juxt\n                                    (concat\n                                      (for [row (range 3)] (fn [board] (nth board row)))\n                                      (for [column (range 3)] (fn [board] (mapv #(nth % column) board)))\n                                      [(fn [board] (mapv #(get-in board %) [[0 0] [1 1] [2 2]]))\n                                       (fn [board] (mapv #(get-in board %) [[0 2] [1 1] [2 0]]))]))\n                             board)]\n\n                  (cond\n                    (some (fn [line] (every? #(= :x %) line)) three) :x\n                    (some (fn [line] (every? #(= :o %) line)) three) :o)\n                  ))]\n    (->>\n      (for [x (range 3)\n            y (range 3)]\n        [x y])\n      (filter #(= :e (get-in board %)))\n      (filter #(won? (assoc-in board % turn)))\n      set)))","user":"5e0d948fe4b099d064962f98"},{"problem":119,"code":"(fn get-solutions [piece board]\n  (let [possible-solutions [\n                             #{[0 0] [0 1] [0 2]}\n                             #{[1 0] [1 1] [1 2]}\n                             #{[2 0] [2 1] [2 2]}\n                             #{[0 0] [1 0] [2 0]}\n                             #{[0 1] [1 1] [2 1]}\n                             #{[0 2] [1 2] [2 2]}\n                             #{[0 0] [1 1] [2 2]}\n                             #{[2 0] [1 1] [0 2]}\n                             ]]\n    (letfn [\n             (filter-solution [board piece solution]\n                              (let [\n                                     empty-cells (filter #(= :e (get-in board %)) solution)\n                                     opponent-cells (filter #(not (contains? #{:e piece} (get-in board %))) solution)\n                                     ]\n                                (if (and (empty? opponent-cells) (= 1 (count empty-cells)))\n                                  empty-cells\n                                  '())))\n             ]\n      (into #{}\n            (mapcat\n              #(filter-solution board piece %)\n              possible-solutions)))))","user":"5654e024e4b0f9d632dd848d"},{"problem":119,"code":"(fn [piece board]\n  (let [at (fn [[y x]] ((board y) x))\n        axes [#{[0 0] [0 1] [0 2]} #{[1 0] [1 1] [1 2]} #{[2 0] [2 1] [2 2]}\n              #{[0 0] [1 0] [2 0]} #{[0 1] [1 1] [2 1]} #{[0 2] [1 2] [2 2]}\n              #{[0 0] [1 1] [2 2]} #{[2 0] [1 1] [0 2]}]\n        winner? (fn [coords]\n                  (and (= (at coords) :e)\n                       (->> axes ; every possible axis\n                            (map #(disj % coords)) ; remove coords from each one\n                            (filter #(= 2 (count %))) ; find those which contained coords\n                            (map #(set (map at %))) ; turn each into set of members\n                            (filter #(= #{piece} %)) ; leave only those which only have piece\n                            count\n                            (< 0))))] ; true if at least one\n    (set (filter winner? (for [x (range 3) y (range 3)] [y x]))))) ; try every place and filter","user":"54febf4be4b07d26eda61d45"},{"problem":119,"code":"(fn winning-moves [piece board]\n  (let [bsize (count board)\n        columns (partition bsize (concat (for [x1 (range bsize) x2 (range bsize)] [x1 x2])\n                  (for [x1 (range bsize) x2 (range bsize)] [x2 x1])\n                  (for [x1 (range bsize)] [x1 x1])\n                  (for [x1 (range bsize)] [x1 (- bsize x1 1)])))\n        lines (map #(map (fn [ix] {:piece (get-in board ix) :ix ix}) %) columns)\n        winning-move (fn [col piece]\n                        (let [empties (map #(:ix %) (filter #(= (:piece %) :e) col))\n                              pieces (map #(:ix %) (filter #(= (:piece %) piece) col))\n                              winning (and (= (count empties) 1) (= (count pieces) 2))]\n                          (if winning (first empties) nil)))]\n          (into #{} (filter #(not (nil? %)) (map #(winning-move % piece) lines)))))","user":"59be62d5e4b0a024fb6ae435"},{"problem":119,"code":"(let [w [[[0 0] [0 1] [0 2]]\n         [[1 0] [1 1] [1 2]]\n         [[2 0] [2 1] [2 2]]\n         [[0 0] [1 0] [2 0]]\n         [[0 1] [1 1] [2 1]]\n         [[0 2] [1 2] [2 2]]\n         [[0 0] [1 1] [2 2]]\n         [[0 2] [1 1] [2 0]]\n         ]]\n  (fn [player board]\n    (set (for [x (range 3)\n               y (range 3)\n               :when (and (= :e (get-in board [x y])) \n                          (let [b (update-in board [x y] (constantly player))]\n                            (let [ws (map #(= [player player player] (map (partial get-in b) %)) w)]\n                              (reduce #(or %1 %2) ws))\n                            ))] [x y]))))","user":"563dfc02e4b0da801c4e4662"},{"problem":119,"code":"(fn [piece board]\n  (set (for [k (range 3) l (range 3)\n             :let [placement [k l]\n                   [[a b c] \n                    [d e f] \n                    [g h i] :as rows] (assoc-in board placement piece)\n                   columns   [[a d g] [b e h] [c f i]]\n                   diagonals [[a e i] [c e g]]]\n             :when (and (= :e (get-in board placement))\n                        (some #{[piece piece piece]}\n                              (concat columns diagonals rows)))]\n         placement)))","user":"544e9022e4b0e3978000698b"},{"problem":119,"code":"(fn tictactoewinner [mark boardgrid]\n  (let\n    [\n     swapElem (fn [col n elem] (into [] (concat (take n col) (vector elem) (drop (+ 1 n) col)))),\n     swapInGrid (fn [grid row col elem] (swapElem grid row (swapElem (nth grid row) col elem))),\n     indexBlock (for [row [0 1 2] col [0 1 2]] [row col]),\n     analyzeBoard\n     (fn [board]\n       (let\n         [flatboard (flatten board),\n          indices [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]],\n          sets (filter\n                 (fn [markset] (and (= (count markset) 1) (not= (first markset) :e)))\n                 (map\n                   (fn [indexblock]\n                     (set\n                       (map\n                         (fn [index]\n                           (nth flatboard index)\n                           )\n                         indexblock\n                         )\n                       )\n                     )\n                   indices\n                   )\n                 )\n          ]\n         (if (= 1 (count sets)) (first (first sets)) nil)\n         )\n       )\n     ]\n    (set (map (fn [[grid row col]] (vector row col)) (filter (fn [[grid row col]] (not (nil? (analyzeBoard grid)))) (map (fn [[elem row col]] (vector (swapInGrid boardgrid row col mark) row col)) (filter (fn [[elem row col]] (= :e elem)) (map (fn [[row col]] (vector (nth (nth boardgrid row) col) row col)) indexBlock))))))\n    )\n  )","user":"58950f29e4b00487982d5270"},{"code":"(fn n [v b]\n  (letfn [(w [m]\n            (some identity (concat \n                       (for [i [0 1 2]]\n                         (apply = v (map #(get m %) [[i 0] [i 1] [i 2]])))\n                       (for [i [0 1 2]]\n                         (apply = v (map #(get m %) [[0 i] [1 i] [2 i]])))\n                       (list\n                        (apply = v (map #(get m %) [[0 0] [1 1] [2 2]]))\n                        (apply = v (map #(get m %) [[0 2] [1 1] [2 0]]))))))]\n\n    (let [k (reduce merge\n                    (for [i [0 1 2]\n                          j [0 1 2]]\n                      {[i j] (nth (nth b i) j)}))]\n      (set (filter identity\n                   (for [i [0 1 2]\n                         j [0 1 2]]\n                     (if (and (= (get k [i j]) :e)\n                              (w (assoc k [i j] v)))\n                       [i j]\n                       false)))))))","problem":119,"user":"4facd2fae4b081705acca22f"},{"problem":119,"code":"(fn [piece rows]\n  (let \n    [is-winner? (fn [rows]\n                  (let \n                    [cols      (apply map vector rows)\n                     diags     (map #(map get rows %) [[0 1 2][2 1 0]])\n                     all       (concat rows cols diags)\n                     equals    (map #(if (apply = %) (first %)) all)\n                     is-winner ((complement not-any?) #{:x :o} equals)\n                    ]\n                    is-winner))\n     place-piece (fn [coor] (update-in rows coor #(if (#{:e} %) piece %)))\n     coors       (for [x (range 3) y (range 3)] [x y])\n    ]\n    (set (filter #(is-winner? (place-piece %)) coors))))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":119,"code":"(fn [+ s]\n  (let [? (fn [[[a d g] [b e h] [c f i]]]\n        (some #(first\n                ((set (partition 3 \n                                 [a d g b e h c f i a b c d e f g h i a e i g e c]))\n                 [% % %])) [:x :o]))\n        ]\n    (set (for [i [0 1 2] j [0 1 2]\n          :when (= :e (get-in s [i j]))\n          :when (? (assoc-in s [i j] +))]\n      [i j]))))","user":"55be39f9e4b01b9910ae2a06"},{"problem":119,"code":"(fn [ox bb]\n    (set\n     (for [y (range 3)\n           x (range 3)\n           :let [piece (get-in bb [y x])\n                 new-piece (if (= piece :e) ox piece)\n                 b (assoc-in bb [y x] new-piece)]\n           :when (or\n                  ;; diag:\n                  (every? #{ox}\n                          (for [i (range 3)]\n                            ((b i) i)))\n                  ;; anti-diag:\n                  (every? #{ox}\n                          (for [i (range 3)]\n                            ((b i) (- 2 i))))\n                  ;; across:\n                  (some (fn [i]\n                          (every? #{ox} (for [j (range 3)] ((b i) j))))\n                        (range 3))\n                  ;; down:\n                  (some (fn [i]\n                          (every? #{ox} (for [j (range 3)] ((b j) i))))\n                        (range 3)))]\n       [y x])))","user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn my-win-tic-tac-toe\n  [player ttt]\n  (let [getCrossElementIds (fn [tictactoe] (map vector (take (count tictactoe) (range)) tictactoe))\n        getCrossElements (fn [result tttCrosCount] (conj result (nth (second tttCrosCount) (first tttCrosCount))))\n        tttv ttt\n        ttth (apply map list ttt)\n        ttts1 (reduce getCrossElements [] (getCrossElementIds ttt))\n        ttts2 (reduce getCrossElements [] (getCrossElementIds (reverse ttt)))]\n    (letfn [(correct-to-finish? [val] \n                                (let [part (sort-by count (partition-by identity (sort-by identity val)))]\n                                  (if (= 2 (count part))\n                                    (if (and (= (first (first part)) :e) (= (first (second part)) player))\n                                      true\n                                      false)\n                                    false)))\n            (analyze-ttth [ttth] (loop [results [] i 0]\n                                   (if (= i (count ttth))\n                                     results\n                                     (recur (if (correct-to-finish? (get (into [] ttth) i))\n                                              (conj results (vector (.indexOf (get (into [] ttth) i) :e) i))\n                                              results) (inc i)))))\n            (analyze-tttv [tttv] (loop [results [] i 0]\n                                   (if (= i (count tttv))\n                                     results\n                                     (recur (if (correct-to-finish? (get (into [] tttv) i))\n                                              (conj results (vector i (.indexOf (get (into [] tttv) i) :e)))\n                                              results) (inc i)))))\n            (analyze-ttts2 [ttts] (when (correct-to-finish? ttts)\n                                   (vector (- 2 (.indexOf ttts :e)) (.indexOf ttts :e))))\n            (analyze-ttts1 [ttts] (when (correct-to-finish? ttts)\n                                   (vector (.indexOf ttts :e) (.indexOf ttts :e))))]\n      (set (filter (complement nil?) (into (into (vector (analyze-ttts1 ttts1) (analyze-ttts2 ttts2)) (analyze-ttth ttth)) (analyze-tttv tttv)))))))","problem":119,"user":"509a25b7e4b0efbae1fbc0a8"},{"problem":119,"code":"(letfn [(get-all-pos\n          ([board]\n           (->> board\n                (map-indexed (fn [i row]\n                               (map-indexed\n                                 (fn [k value] [value i k])\n                                 row)))\n                (reduce concat)))\n          ([board holder]\n           (->> board\n                get-all-pos\n                (filter (comp (partial = holder) first))\n                (map (comp vec drop) (repeat 1)))))\n\n        (all-winning-pos\n          []\n          (->> (concat (for [i (range 3) k (range 3)] [i k])        ;; wins for rows\n                       (for [i (range 3) k (range 3)] [k i])        ;; wins for columns\n                       (map vector (range 3) (range 3))             ;; wins for diagonal starting top left\n                       (map vector (range 3) (reverse (range 3))))  ;; wins for diagonal starting top right\n               (partition 3)\n               (map set)))\n\n        (winning-positions? [positions]\n          (some #(clojure.set/subset? % (set positions)) (all-winning-pos)))\n\n        (find-winning-moves [player board]\n          (let [current-pos (get-all-pos board player)\n                possible-next-moves (get-all-pos board :e)]\n            (->> possible-next-moves\n                 (filter (comp winning-positions? (partial conj current-pos)))\n                 set)))]\n  find-winning-moves)","user":"51f01925e4b0249c592fbdfc"},{"problem":119,"code":"(fn _119_ [turn board]\n  (letfn [(cols [board] (apply map vector board))\n          (diag [board] [(map #(get-in board %) [[0 0] [1 1] [2 2]])\n                         (map #(get-in board %) [[0 2] [1 1] [2 0]])])\n          (lines [board] (concat board (cols board) (diag board)))\n          (winner [board]\n            (let [cds (lines board)]\n              (cond\n                (some #{[:x :x :x]} cds) :x\n                (some #{[:o :o :o]} cds) :o)))\n          (available-steps [board]\n                           (for [i (range 0 3)\n                                 j (range 0 3)\n                                 :when (= :e (get-in board [i j]))]\n                             [i j]))\n          (win-steps [turn board]\n            (set (filter #(= (winner (assoc-in board % turn)) turn) (available-steps board))))]\n    (win-steps turn board)))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":119,"code":"(fn [p b]\n  (set (for [i (range 3), j (range 3)\n             :when (= (get-in b [i j]) :e)\n             :let [b* (assoc-in b [i j] p)]\n             :when (some (partial every? (partial = p))\n                         [(b* i) ; row\n                          (map #(% j) b*) ; column\n                          (map #(%1 %2) b* (range 3)) ; diag 1\n                          (map #(%1 %2) (reverse b*) (range 3))])] ; diag 2\n          [i j])))","user":"573d58c8e4b05c31a32c0811"},{"code":"(letfn [(as-lines [[[a b c]\n                      [d e f]\n                      [g h i]]] [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]])\n          (winner?\n            [p b] (seq (filter #(and (= (first %) p) (apply = %)) (as-lines b))))]\n    (fn [p b]\n      (reduce (fn [r i] (if (and (= (get-in b i) :e)\n                                (winner? p (assoc-in b i p)))\n                         (conj r i)\n                         r))\n              #{}\n              (for [y [0 1 2] x [0 1 2]] [y x]))))","problem":119,"user":"4ee88bfb535d93acb0a66881"},{"problem":119,"code":"(fn winning-set [p board]\n  (letfn [(check-board [s] \n  (let [dag (fn [s dir]\n    (let [[start end f f2] \n        (if (= dir :left-right)\n            [0 (count s) inc #(identity %)]\n            [(dec (count s)) -1 dec  #(- (dec (count s)) %)])]\n        (loop [cnt start ret []]\n            (if (= cnt end)\n                (vec ret)\n                (recur (f cnt) (conj ret (nth (nth s cnt) (f2 cnt) )))))))\n        col (fn [s i]\n    (vec (map #(nth % i) s)))\n        cols (fn [s]\n    (vec (map #(col s %) (range (count s)))))\n    expand-board (fn [s]\n    (concat s (cols s) [(dag s :left-right)] [(dag s :right-left)]))]\n    (let [res (->> s expand-board (map distinct) (filter #(= (count %) 1)) (filter #(not= (first %) :e)) flatten first)]\n        (if (not= :e res)\n            res\n            nil))))]\n    (into #{} (for [x (range 3) y (range 3)\n        :when (and\n               (= (get-in board [x y]) :e)\n               (= (check-board (assoc-in board [x y] p)) p))]\n    [x y]\n    ))))","user":"54f09599e4b024c67c0cf89d"},{"problem":119,"code":"(fn [m b]\n  (letfn [(row [b i] (nth b i))\n          (col [b j] (mapv #(nth % j) b))\n          (dex [b] (mapv #(get-in b [% %]) (range 3)))\n          (sin [b] (mapv #(get-in b [% (- 2 %)]) (range 3)))\n          (sets [b]\n            (concat\n              (map #(row b %) (range 3))\n              (map #(col b %) (range 3))\n              [(dex b) (sin b)]))\n          (winner* [m set]\n            (when (every? #(= m %) set)\n              m))\n          (winner [m b]\n            (first (keep #(winner* m %) (sets b))))]\n    (set\n      (for [i (range 3)\n            j (range 3)\n            :when (= :e (get-in b [i j]))\n            :when (winner m (assoc-in b [i j] m))]\n        [i j]))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":119,"code":"(fn win [p b]\n  (letfn [(winner [b]\n            (some {[:o :o :o] :o [:x :x :x] :x}\n                  (concat b \n                          (apply map vector b)\n                          (for [i [[0 4 8] [2 4 6]]] \n                            (map (vec (flatten b)) i)))))]\n    (set\n     (for [y (range 3) x (range 3)\n           :when (= :e (get-in b [x y]))\n           :when (= p (winner (assoc-in b [x y] p)))]\n       [x y]))))","user":"53b39d82e4b047364c0444a6"},{"problem":119,"code":"(fn [p b]\n    (let [ab   (map-indexed (fn [i r]\n                              (map-indexed\n                                (fn [j p] {:pos [i j] :p p}) r)) b)\n          rows (concat ab\n                       (apply map vector ab)\n                       (list\n                         (map-indexed (fn [i r] (nth r i)) ab)\n                         (map-indexed (fn [i r] (nth r i)) (reverse ab))))]\n      (->> (filter (fn [r]\n                     (= {p 2 :e 1} (frequencies (map :p r))))\n                   rows)\n           (map (fn [r] (:pos (first (filter #(= :e (:p %)) r)))))\n           set)))","user":"59fa241ee4b0ca45a743a358"},{"problem":119,"code":"(fn [player board]\n  (set\n    (for [line [[[0 0] [0 1] [0 2]]\n                [[1 0] [1 1] [1 2]]\n                [[2 0] [2 1] [2 2]]\n                [[0 0] [1 0] [2 0]]\n                [[0 1] [1 1] [2 1]]\n                [[0 2] [1 2] [2 2]]\n                [[0 0] [1 1] [2 2]]\n                [[0 2] [1 1] [2 0]]]\n          :when (= {player 2, :e 1}\n                   (frequencies (map (partial get-in board) line)))]\n      (->> line\n           (filter #(= :e (get-in board %)))\n           (apply concat)\n           vec))))","user":"58247423e4b051871117bec5"},{"code":"#(\n  reduce conj #{}\n        (for [x (range 3) y (range 3)\n                          :when (and\n                                 (= :e (get-in %2 [x y]))\n                                 ((fn [[[a b c] [d e f] [g h i] :as x]]\n                                    (some {[% % %] %}\n                                          (list* [a d g] \n                                                 [b e h]\n                                                 [c f i] \n                                                 [a e i]\n                                                 [c e g] \n                                                 x)))\n                                  (assoc-in %2 [x y] %)))] [x y]))","problem":119,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn [z b]\n  (letfn [(g [x y]\n            (nth (nth b x []) y :e))]\n    (set (filter #(not= nil %) (for [x [0 1 2] y [0 1 2]]\n              (let [a (- x 2)\n                    b (- x 1)\n                    c (+ x 1)\n                    d (+ x 2)\n                    m (- y 2)\n                    n (- y 1)\n                    p (+ y 1)\n                    q (+ y 2)]\n                (if (and (= :e (g x y))\n                         (or (= z (g a y) (g b y))\n                             (= z (g b y) (g c y))\n                             (= z (g c y) (g d y))\n                             (= z (g x m) (g x n))\n                             (= z (g x n) (g x p))\n                             (= z (g x p) (g x q))\n                             (= z (g a m) (g b n))\n                             (= z (g b n) (g c p))\n                             (= z (g c p) (g d q))\n                             (= z (g a q) (g b p))\n                             (= z (g b p) (g c n))\n                             (= z (g c n) (g d m))))\n                  [x y])))))))","problem":119,"user":"53460d02e4b084c2834f4a39"},{"problem":119,"code":"(fn [e board]\n   (let [win (fn [k x]\n               ((set\n                 (concat\n                  (map set x)            ; by row\n                  (->> x (apply map vector) (map set)) ; by column\n                  (list\n                   (->> x ((juxt ffirst #(second (second %)) #(last (last %)))) set) ; by diagonal\n                   (->> x ((juxt #(last (first %)) #(second (second %)) #(first (last %)))) set))))\n\n                #{k}))\n         empty-places (for [x (range 3) y (range 3)\n                            :when (= (get-in board [x y]) :e)]\n                        [x y])\n         possible-place (filter #(win e (update-in board % (fn ! [_] e))) empty-places)\n         ]\n\n     (set possible-place)\n     ))","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(letfn [(l [b]\n          (concat b (apply map list b) \n               (for [d [[[0 0] [1 1] [2 2]] [[2 0] [1 1] [0 2]]]]\n                 (for [[x y] d] ((b x) y)))))\n        (c [e r] (count (filter #{e} r)))\n        (t [e] ({:x 'x :o 'o :e 'e} e))\n        (f [r e] (some #(if (= % 'e) %) r))]\n(fn [e b]\n  (let [b (reduce\n            (fn [b k] (update-in b k #(with-meta (t %) {:c k})))\n            b\n            (for [i (range 3) j (range 3)] [i j]))]\n    (set (keep #(-> % (f e) meta :c) (filter #(= 2 (c (t e) %)) (l b)))))))","problem":119,"user":"4e82f85d535db62dc21a62ce"},{"problem":119,"code":"(fn [p g]\n  (let [tg   (apply mapv vector g)\n        d1   (mapv get g (range))\n        d2   (mapv get (reverse g) (range))\n\n        win? (every-pred #(every? #{p :e} %)\n                         #(= 2 (count (filter #{p} %))))\n\n        move (fn [r]\n               (when (win? r)\n                 (first \n                   (keep-indexed \n                     #(when-not (#{p} %2) %1) \n                     r))))\n\n        mk-moves\n        (partial keep-indexed\n                 #(when-let [m (move %2)] \n                    [% m]))]\n    (->> (concat\n           (mk-moves g)\n           (map (comp vec reverse) (mk-moves tg))\n           (when-let [m (move d1)]\n             [[m m]])\n           (when-let [m (move d2)]\n             [[(- 2 m) m]]))\n         (into #{}))))","user":"53dfdf01e4b0d874e779ae46"},{"code":"(fn wttt [piece board]\n  (let [rows        (for [x (range 3)] [[x 0] [x 1] [x 2]])\n        columns     (for [y (range 3)] [[0 y] [1 y] [2 y]])\n        diagonals   [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n        lines       (map #(apply hash-set %) (concat rows columns diagonals))\n        \n        winners     (for [line lines]\n                      (if (= 2 (count (filter #(= piece %) (map #(get-in board %) line))))\n                        (first (filter #(= :e (get-in board %)) line))))\n        ]\n    (apply hash-set (filter #(not (nil? %)) winners))))","problem":119,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [player board]\n  (letfn [(empty-positions [board]\n            (for [row-number (range 3)\n                  col-number (range 3)\n                  :let [row (get board row-number), pos [row-number col-number]]\n                  :when (= :e (get-in board pos))]\n              pos))\n\n          (winning-state? [board player]\n            (letfn [(get-line [board p1 p2 p3] [(get-in board p1) (get-in board p2) (get-in board p3)])\n                    (get-row [board row-number] (get-line board [row-number 0] [row-number 1] [row-number 2]))\n                    (get-col [board col-number] (get-line board [0 col-number] [1 col-number] [2 col-number]))]\n              (let [row (repeat 3 player)]\n                (not (empty? (filter #(= row %) [(get-row board 0) (get-row board 1) (get-row board 2)\n                                                 (get-col board 0) (get-col board 1) (get-col board 2)\n                                                 (get-line board [0 0] [1 1] [2 2]) (get-line board [0 2] [1 1] [2 0])]))))))]\n\n    (into #{}\n      (for [pos (empty-positions board)\n            :let [played-board (assoc-in board pos player)]\n            :when (winning-state? played-board player)]\n        pos))))","problem":119,"user":"517531c6e4b07031762f2eea"},{"code":"(fn winning-moves [p b]                                                                                            (let [winner (fn [board]                                                                                         \n                 (loop [remaining [[[0 0] [0 1] [0 2]]                                                             \n                                  [[1 0] [1 1] [1 2]]                                                              \n                                  [[2 0] [2 1] [2 2]]                                                              \n                                  [[0 0] [1 0] [2 0]]                                                              \n                                  [[0 1] [1 1] [2 1]]                                                              \n                                  [[0 2] [1 2] [2 2]]                                                              \n                                  [[0 0] [1 1] [2 2]]                                                              \n                                  [[2 0] [1 1] [0 2]]]]                                                            \n                   (if (empty? remaining)                                                                          \n                     nil                                                                                           \n                     (let [position (first remaining)                                                              \n                           items (map #((board (% 0)) (% 1)) position)                                             \n                           common? (apply = items)]                                                                \n                       (if (and common? (not (= (first items) :e)))                                                \n                         (first items)                                                                             \n                         (recur (rest remaining)))))))                                                             \n        place (fn [[x y] p]                                                                                        \n                (let [row (b y)                                                                                    \n                      new-row (assoc row x p)]                                                                     \n                  (assoc b y new-row)))]                                                                           \n    (set (filter identity (for [x (range 3) y (range 3)]                                                           \n      (let [slot (get-in b [y x])                                                                                  \n            is-empty? (= slot :e)                                                                                  \n            winning-move? (if is-empty?                                                                            \n                            (= p (winner (place [x y] p)))                                                         \n                            false)]                                                                                \n        (if winning-move?                                                                                          \n          [y x]                                                                                                    \n          nil)))))))","problem":119,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [player table]\n    (let [\n      range3 (range 3)\n      lns\n      #(map %\n        (concat\n          (for [i range3]\n            (for [j range3] [i j]))\n          (for [j range3]\n            (for [i range3] [i j]))\n          (list\n            (for [j range3] [j j])\n            (for [j range3] [(- 2 j) j]))))\n      of #(== %2 (count (% %3)))\n      ]\n      (->> table\n        (partial reduce nth)\n        (partial group-by)\n        (lns)\n        (filter (partial of :e 1))\n        (filter (partial of player 2))\n        (map :e)\n        (map first)\n        (set)\n        )))","problem":119,"user":"50901b2ee4b0ea685a20f774"},{"problem":119,"code":"(fn [el board]\n  (letfn [(is-winning [b e]\n            (= e (letfn [(tt [c] (when (= 1 (count (set c))) (first c)))\n                         (diag [c] (for [n (range 3)]\n                                     (nth (nth c n) n)))]\n                   (first (remove nil?\n                                  (filter #(not (= :e %))\n                                          (concat\n                                            (apply map (fn [& as] (tt as)) b)\n                                            (map tt b)\n                                            [(tt (diag b))]\n                                            [(tt (diag (reverse b)))])))))))]\n\n    (let [all (for [a (range 3)\n                    b (range 3)]\n                [a b])]\n      (set (filter (fn [c] (if (= :e (get-in board c el)) (is-winning (assoc-in board c el) el))) all)))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":119,"code":"(fn winner [piece board]\n  (-> (for [x (range 3) y (range 3)\n    :let [newboard (update-in board [x y] #(if (= % :e) piece %))\n          rows newboard\n          columns (for [i (range 3)] [((newboard 0) i) ((newboard 1) i) ((newboard 2) i)])\n          diag1 [((newboard 0) 0) ((newboard 1) 1) ((newboard 2) 2)]\n          diag2 [((newboard 0) 2) ((newboard 1) 1) ((newboard 2) 0)]\n          allpos (concat rows columns [diag1] [diag2])]\n        :when (some #(= (repeat 3 piece) %) allpos)]\n    [x y]) set))","user":"5705e404e4b0b0fb43fd0676"},{"problem":119,"code":"(fn win_tic_tac_toe [piece board]\n    (let\n        [\n            n (count board)\n            winner\n                (fn [board] \n                    (let\n                        [                    \n                            backward_diag (map #(get-in board [%1 %2]) (range n) (range n))\n                            forward_diag (map #(get-in board [%1 %2]) (range n) (reverse (range n)))\n                            cols (apply map list board)\n                            all (concat cols board [backward_diag forward_diag])\n                        ]\n                        (->> all\n                            (map set)\n                            (filter #(= (count %) 1))\n                            (apply concat)\n                            (some #{:x :o})\n                        )\n                    )\n                )\n        ]\n        (set (filter\n            (fn [[r c]] (= piece (winner (update-in board [r c] #(if (= :e %) piece %)))))\n            (for [r (range n) c (range n)] [r c])\n        ))\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":119,"code":"(fn __ [a v] \n(letfn [(tic [X]\n (let [wi [[0 1 2] [3 4 5] [6 7 8]\n      \t   [0 3 6] [1 4 7] [2 5 8]\n\t   [0 4 8] [2 4 6]]\n       xf (flatten X)]\n   (first (remove #(nil? %) (for [w wi]\n   \t(let [arn (map #(nth xf %) w)]\n\t     (when (and (not= (nth arn 0) :e) \n\t     \t (and (= (nth arn 0) (nth arn 1)) \n\t\t (= (nth arn 1) (nth arn 2))))\n\t\t (nth arn 0))))))))]\n   (let [vf (vec (flatten v))]\n   \t(->> vf \n\t     (map #(if (= :e %2) %1 nil) (range 0 9))\n\t     (remove #(nil? %))\n\t     (map #(list (partition 3 (assoc vf % a)) \n\t     \t  \t [(int (/ % 3)) (mod % 3)]))\n\t     (filter #(= a (tic (first %))))\n\t     (map second)\n\t     (into #{})))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":119,"code":"(fn win-tic-tac-toe-moves [piece board]\n  (letfn [(winning-moves [piece board cell-groups]\n            (reduce (fn [acc cell-group]\n                      (let [group-vals (mapv (fn [[i j]] ((board i) j)) cell-group)\n                            empty-idxs (keep-indexed #(when (= %2 :e) %1) group-vals)]\n                        (if (and (= 1 (count empty-idxs))\n                                 (= 2 (count (filter #(= piece %1) group-vals))))\n                          (conj acc (nth cell-group (first empty-idxs)))\n                          acc)))\n                    #{} cell-groups))\n\n          (make-groups [board]\n            (let [max-col (count board)\n                  max-row (count (first board))]\n              (concat\n               (for [i (range max-col)] (for [j (range max-row)] [i j]))\n               (for [j (range max-row)] (for [i (range max-col)] [i j]))\n               [(for [i (range max-row)] [i i])]\n               [(for [i (reverse (range max-row))] [i (dec (- max-row i))])])))]\n\n    (->> (make-groups board) (winning-moves piece board))))","user":"57c500f9e4b05aa3c4741cda"},{"problem":119,"code":"(fn [p board]\n    (let [\n          replacements (for [x (range 3)\n                             y (range 3)\n                             :when (= :e ((board y) x))]\n                         [x y (assoc board y (assoc (board y) x p))])]\n      (set(map #(vector (second %) (first %)) (filter\n                                            (fn winner [[x y [[a1 a2 a3] [b1 b2 b3] [c1 c2 c3]]]]\n                                              (let [winlines [\n                                                              [a1 a2 a3] [b1 b2 b3] [c1 c2 c3]\n                                                              [a1 b1 c1] [a2 b2 c2] [a3 b3 c3]\n                                                              [a1 b2 c3] [a3 b2 c1]]]\n                                                (first (first (filter (fn [line] (and (#{:x :o} (first line)) (every? #(= (first line) %) line))) winlines))))\n                                              )\n                                            replacements))\n      )))","user":"55f2c898e4b06e875b46ce4b"},{"problem":119,"code":"(fn [p b]\n  (let [d [0 1 2]\n        w (fn [b]\n            (let [v #((b %) %2)]\n              (some {[:x :x :x] :x [:o :o :o] :o}\n                    (concat\n                      b\n                      (apply map list b)\n                      [(map v d d) (map v d [2 1 0])]))))]\n    (set (for [x d\n               y d\n               :when (and\n                       (= :e (get-in b [x y]))\n                       (= p (w (assoc-in b [x y] p))))]\n           [x y]))))","user":"4eb70649535d7eef30807373"},{"code":"(fn ttt [color board]\n  (let [test-win\n  (fn test-win [b]\n          (let [[[p1 p2 p3] [p4 p5 p6] [p7 p8 p9]] b]\n            (reduce #(or %1 %2)\n                    (map (fn [[x y z]] (if (and (= x y) (= y z) (not= x :e)) x nil))\n                         [(b 0) (b 1) (b 2)\n                          [p1 p4 p7]\n                          [p2 p5 p8]\n                          [p3 p6 p9]\n                          [p1 p5 p9]\n                          [p3 p5 p7]]))))\n\n\tmove (fn [board color pos]\n\t       (assoc-in board pos color))\n        can-move (fn [board pos] (= :e (get-in board pos)))\n\tcan-win (fn [pos] (test-win (move board color pos)))\n\n        positions\n        (for [x (range 3) y (range 3)\n              :when (can-move board [x y])]\n          [x y])]\n\n    (set (filter can-win positions))))","problem":119,"user":"4f0d093b535d0136e6c22313"},{"problem":119,"code":"(fn winPos [piece board]\n  (letfn [(win? [p b]\n            (let [analyzeVec (fn [v] (if (apply = v) (first v) nil))\n                  getRow (fn [n] (nth b n))\n                  getCol (fn [n] (map #(nth % n) b))\n                  rows (map analyzeVec (map getRow (range 3)))\n                  cols (map analyzeVec (map getCol (range 3)))\n                  diag1 (map nth b (range 3))\n                  diag2 (map nth b (reverse (range 3)))\n                  diags (list (analyzeVec diag1) (analyzeVec diag2))]\n              (some #(= p %) (concat rows cols diags))))]\n    (set \n      (for [y (range 3) x (range 3)\n            :when (= :e (get-in board [y x])) \n            :when (win? piece (assoc-in board [y x] piece))]\n        [y x]))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [v b]\n   (set (for [l (range 3)\n              c (range 3)\n              :when (and (= :e (get-in b [l c]))\n                         (let [nb (assoc-in b [l c] v)\n                               [_ & [_ & t :as s] :as p] (flatten nb)]\n                           (some (fn [[x y z]] (and (= x v) (= x y z)))\n                                 (concat nb (map #(take-nth % %2) [3 3 3 4 2] [p s t p t])))))]\n          [l c])))","problem":119,"user":"52c8758be4b0c2d177d62135"},{"problem":119,"code":"(fn win-tic\n  [t cells]\n  (letfn\n    [(win-row\n       [cells t]\n       (#(and (= (get % :e) 1) (= (get % t) 2)) (frequencies cells))),\n     (get-win\n       ([cells t x]\n        (if (win-row cells t)\n          [x (.indexOf cells :e)]\n          []))\n       ([cells t x y]\n        (if (win-row cells t)\n          (let [i (.indexOf cells :e)]\n            (println \"t\" t \"x\" x \"y\" y \"cells\" cells \"i\" i)\n            {(nth y i) (nth x i)})\n          [])\n         )\n       ),\n     (win-horz\n       [cells t]\n       (mapv #(get-win %1 t %2) cells (range 3))\n       ),\n     (win-vert\n       [cells t]\n       (mapv (comp vec reverse) (map #(get-win %1 t %2)\n                                     (apply mapv vector cells)\n                                     (range 3)))),\n     (win-cross1\n       [cells t]\n       ((comp vector vec reverse) (#(get-win %1 t %2 %3)\n                                     (map #(nth (flatten cells) %) [0 4 8])\n                                     (range 3)\n                                     (range 3)))),\n     (win-cross2\n       [cells t]\n       ((comp vector vec reverse) (#(get-win %1 t %2 %3)\n                                     (map #(nth (flatten cells) %) [2 4 6])\n                                     (reverse (range 3))\n                                     (range 3)))),\n     ]\n    ((comp (fn [x] (into #{} x)) #(map vec %) #(partition 2 %) flatten)\n      ((juxt win-horz win-vert win-cross1 win-cross2) cells t)\n         )\n    )\n  )","user":"5545477fe4b0a04f79299531"},{"problem":119,"code":"(fn tic-tac [p board]\n  (let [tic #(get-in board [%1 %2])\n        line (fn [i j x y]\n               (let [a (* x 2) b (* y 2)]\n                 (filter identity [(tic (+ i x) (+ j y)) (tic (- i x) (- j y))\n                                   (tic (+ i a) (+ j b)) (tic (- i a) (- j b))])))\n        nice? (fn [[a b]]\n                (= p a b))]\n    (set\n      (for [i (range 3)\n            j (range 3)\n            :let [neighs [(line i j 0 1)\n                          (line i j 1 1)\n                          (line i j 1 0)\n                          (line i j -1 1)]]\n            :when (and (= :e (tic i j))\n                       (some nice? neighs))]\n        [i j]))))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [p b]\n  (let [n (-> b first count)\n        r (range n)\n        w? (fn [b]\n             (letfn [(w [[[a b c]\n                          [d e f]\n                          [g h i]] p] (or (= p a b c)\n                                          (= p d e f)\n                                          (= p g h i)\n                                          (= p a d g)\n                                          (= p b e h)\n                                          (= p c f i)\n                                          (= p a e i)\n                                          (= p c e g)))]\n               (cond (w b :x) :x\n                     (w b :o) :o\n                     :else nil)))]\n    (set (for [x r\n               y r\n               :let [v [x y]\n                     e (get-in b v)]\n               :when (and (= :e e) (= p (-> b (assoc-in v p) w?)))]\n           v))))","problem":119,"user":"4ee9ddb8535d93acb0a66896"},{"problem":119,"code":"(fn winners [player grid]\n  (let [improved-grid (map-indexed (fn [i row] (map-indexed (fn [j cell] (if (= cell :e) [i j] cell)) row)) grid)\n        groups (concat improved-grid \n                       (apply map list improved-grid) \n                       [(for [x [0 1 2]] (nth (nth improved-grid x) (- 2 x))) (for [x [0 1 2]] (nth (nth improved-grid x) x))])]\n    (set (filter #(not (nil? %)) (map #(let [group (disj (set (distinct %)) player)] \n                 (if (and (= (count group) 1) (sequential? (first group))) (first group) nil)) groups)))))","user":"55a74d46e4b09e57187da2a3"},{"problem":119,"code":"(letfn [\n\n  (indices-3x3 [] [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]])\n\n  ;; Functions for generating the indices in the sequence of cells evaluated\n  ;; for winning\n  (row-indices [k n]\n    (map (fn [i] [k i]) (range n)))\n\n  (col-indices [k n]\n    (map (fn [i] [i k]) (range n)))\n\n  (diag-indices [n]\n    (map (fn [i] [i i]) (range n)))\n\n  (anti-diag-indices [n]\n    (map (fn [i] [(- n (inc i)) i]) (range n)))\n\n\n  ;; Extract sequences of elements from the board\n  (from-indices [board indices]\n    (map (partial get-in board) indices))\n\n  (elements-from-index-fun [board index-fun]\n    (from-indices board (index-fun (count board))))\n\n\n  (deep-lift [d f]\n    (nth (iterate #(partial map %) f) d))\n\n\n  ;; Zip together n-dimensional arrays\n  (deep-zip\n    ([d]\n      (deep-lift d vector))\n    ([d & args]\n      (apply (deep-zip d) args)))\n\n\n  ;; Extract those sequences that need to be saturated for a win\n  (winning-seqs [board]\n    (let [board-size (count board)\n          seq-of-1d-indices (range board-size)]\n      (map\n        (partial elements-from-index-fun board)\n        ;; Assemble a list of the index functions that should be used to get the\n        ;; slices of the board that need to be saturated for a win.\n        (concat\n          ;; Full row?\n          (map #(partial row-indices %) seq-of-1d-indices)\n          ;; Full column?\n          (map #(partial col-indices %) seq-of-1d-indices)\n          ;; Full diagonals?\n          [diag-indices]\n          [anti-diag-indices]))))\n\n\n  (filter-decorated \n    ([key-fn]\n      (partial filter-decorated key-fn))\n    ([key-fn f]\n      (partial filter (comp f key-fn)))\n    ([key-fn f coll]\n      ((filter-decorated key-fn f) coll)))\n\n\n  ;; Is a winning sequence one away from being saturated with the given symbol?\n  (indexed-lines-one-from-winning [board player-symbol]\n    (let [indexed-seqs (apply (deep-zip 2) (map winning-seqs [board (indices-3x3)]))\n          num-player-marks #(get (frequencies %) player-symbol 0)\n          filter-indexed (partial filter-decorated (deep-lift 1 first))]\n      ((comp\n        (filter-indexed #(some #{:e} %))\n        (filter-indexed #(<= 2 (num-player-marks %))))\n       indexed-seqs)))\n\n\n  (indices-of-empty-spaces [tt-lines]\n    (let [indexed-empty-from-line\n          (fn [line] (filter #(= :e (first %)) line))]\n      (set\n        (map second (mapcat indexed-empty-from-line tt-lines)))))\n\n\n  (moves-to-make-player-win [player-symbol board]\n    (indices-of-empty-spaces\n        (indexed-lines-one-from-winning board player-symbol)))]\n\n  moves-to-make-player-win)","user":"57300c19e4b0cd1946bd0fa1"},{"code":"(fn win-tictactoe [piece board]\n    (letfn [(empties []\n              (for [x (range (count board))\n                    y (range (count (nth board x)))\n                    :when (= :e (get-in board [x y]))]\n                [x y]))\n            (new-board [move-pos]\n              (assoc-in board move-pos piece))\n            (column [b i]\n              (map #(get % i) b))\n            (aligned3-hori? [b k]\n              (some #(= (b %) (repeat 3 k)) (range 3)))\n            (aligned3-vert? [b k]\n              (some #(= (column b %) (repeat 3 k)) (range 3)))\n            (aligned3-diag? [b k]\n              (or (=\n                    (vector\n                      (-> b (get 0) (get 0))\n                      (-> b (get 1) (get 1))\n                      (-> b (get 2) (get 2)))\n                    (repeat 3 k))\n                (=\n                  (vector\n                    (-> b (get 2) (get 0))\n                    (-> b (get 1) (get 1))\n                    (-> b (get 0) (get 2)))\n                  (repeat 3 k))))\n            (won? [b k]\n              (or (aligned3-hori? b k) (aligned3-vert? b k) (aligned3-diag? b k)))]\n      (into #{} (filter #(won? (new-board %) piece) (empties))))\n    )","problem":119,"user":"5165a235e4b079ad97ec44ac"},{"code":";; This builds on my solution for the \"Analyze a Tic-Tac-Toe Board\"\n;; problem.\n\n(fn [player board]\n  (let [winner \n        (fn [board]\n          (let [v (fn [row col] (get-in board [row col]))\n                triples (concat board\n                                (apply map list board)\n                                [ [(v 0 0) (v 1 1) (v 2 2)]\n                                  [(v 0 2) (v 1 1) (v 2 0)] ])]\n            (if-let [t (first (filter #(let [p (partition-by identity %)]\n                                         (and (= 1 (count p))\n                                              (not= :e (ffirst p))))\n                                      triples))]\n              (first t))))]\n    (set\n     (for [row (range 3)\n           col (range 3)\n           :when (and (= :e (get-in board [row col]))\n                      (= player (winner (update-in board [row col]\n                                                   (constantly player)))))]\n       [row col]))))","problem":119,"user":"500d8c49e4b07ccb9a7ddb00"},{"code":"(fn [x y] (let [b (into {} (for [i (range 3) j (range 3)] [[i j] (get-in y [i j])]))\n                 rs (map #(filter (fn [[[i j] v]] (= % i)) b) (range 3))\n                 cs (map #(filter (fn [[[i j] v]] (= % j)) b) (range 3))\n                 d1 (list (filter (fn [[[i j] v]] (= i j)) b))\n                 d2 (list (filter (fn [[[i j] v]] (= 2 (+ i j))) b))\n                 all (concat rs cs d1 d2)\n                 test (fn [x r] (let [v (group-by val r)] (if (= 2 (count (v x)))\n                                                            (ffirst (v :e)))))]\n             (set (keep #(test x %) all ))))","problem":119,"user":"50563ae2e4b0ce54f56f0405"},{"code":"(fn how-to-win [x board]\n  (letfn [(winner [board]\n            (letfn [(ew [n]\n                      (if (apply = (board n)) (first (board n))))\n                    (nw [n]\n                      (if (apply = (map #(% n) board)) ((first board) n)))\n                    (nw-se []\n                      (let [[[x _ _] [_ y _] [_ _ z]] board]\n                        (if (= x y z) x)))\n                    (ne-sw []\n                      (let [[[_ _ x] [_ y _] [z _ _]] board]\n                        (if (= x y z) x)))]\n              (some #{:x :o} (conj (mapcat (juxt ew nw) (range 3)) (nw-se) (ne-sw)))))\n          (place [board x cell]\n            (if (= :e (get-in board cell))\n              (assoc-in board cell x)\n              board))]\n    (let [cells (for [x (range 3) y (range 3)] [x y])]\n      (set (filter #(winner (place board x %)) cells)))))","problem":119,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":119,"code":"(fn ttt [piece board]\n  (let [checktic (fn checktic [board]\n                   (let [winner? (fn [row]\n                                   (cond\n                                     (= row [:x :x :x]) :x\n                                     (= row [:o :o :o]) :o\n                                     :else nil))\n                         rotated (apply map vector board)\n                         pull-diag (fn [v] (map-indexed (fn [idx itm] (nth itm idx)) v))\n                         diags [(pull-diag board) (pull-diag (reverse board))]\n                         rows (concat board rotated diags)]\n                     (some identity (map winner? rows))))\n        board-wins (fn [[i j]]\n                     (= piece\n                        (checktic (map-indexed (fn [idx row] (if (not= idx j)\n                                                     row\n                                                     (concat (take i row) (list piece) (drop (inc i) row))))   board))))\n        ]\n    (into #{} (map reverse\n    (filter board-wins\n    (for [i [0 1 2] j [0 1 2]\n          :when (= :e (nth (nth board j) i))] (list i j)))))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [piece board]\n   (let [;; All coordinates on the board.\n         coords  (mapcat (fn [x] (map #(vec [x %]) (range 3))) (range 3))\n         ;; Coordinates of the diagonals.\n         diags   #{#{[0 0] [1 1] [2 2]} #{[0 2] [1 1] [2 0]}}\n         ;; Given a coordinate, return all collections of coordinates that threaten it.\n         threats (fn [x y]\n                   (concat\n                    ;; orthogonals\n                    [(disj (set (map #(vec [x %]) (range 3))) [x y])\n                     (disj (set (map #(vec [% y]) (range 3))) [x y])]\n                    ;; diagonals\n                    (map #(disj (set %) [x y])\n                         (filter #(some #{[x y]} %) diags))))]\n     (set (filter (fn [[x y]]\n                (and (= :e (get-in board [x y]))\n                     (some (fn [ps] (every? (fn [[x y]] (= piece (get-in board [x y]))) ps))\n                           (threats x y))))\n              coords))))","problem":119,"user":"4ea1b9e4535d7eef308072b8"},{"code":"; With thanks to:\n; https://github.com/ardumont/org/blob/master/clojure/4clojure-73-analyze-a-tic-tac-toe-board.org\n(fn winning-moves [piece board]\n  (let [coords (for [x (range 0 3)\n                     y (range 0 3)]\n                 [x y])\n        placements (filter #(= :e (get-in board %)) coords)\n        won? (fn [b]\n               (letfn [(w [[[a b c]\n                            [d e f]\n                            [g h i]] p] (or (= p a b c)\n                                        (= p d e f)\n                                        (= p g h i)\n                                        (= p a d g)\n                                        (= p b e h)\n                                        (= p c f i)\n                                        (= p a e i)\n                                        (= p c e g)))]\n                 (if (w b piece) true)))]\n    (into #{} (filter #(won? (assoc-in board % piece)) placements))))","problem":119,"user":"52463059e4b09dbe66b56198"},{"code":"#(set (for [i [0 1 2] j [0 1 2]\n            :when (= :e (get-in %2 [i j]))\n            :when (= %1 ((fn [[[a b c]\n                               [d e f]\n                               [g h i]]]\n                           (nth (some #{[:x :x :x]\n                                        [:o :o :o]}\n                                  (partition 3 [a b c  d e f  g h i\n                                                a d g  b e h  c f i\n                                                a e i  c e g]))\n                                0))\n                         (assoc-in %2 [i j] %1)))]\n        [i j]))","problem":119,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [pl b]\r\n  (let [wins [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\r\n        iswin #(some (fn [w] (= pl (% (w 0)) (% (w 1)) (% (w 2)))) wins)\r\n        b (vec (flatten b))]\r\n    (into #{} (map #(vector (quot % 3) (mod % 3)) (filter #(and (= (b %) :e) (iswin (assoc b % pl))) (range 9))))\r\n                ))","problem":119,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn [key coll]\r\n  (let [combos [[0 1 2] [3 4 5] [6 7 8] [0 3 6] [1 4 7] [2 5 8] [0 4 8] [2 4 6]]\r\n        win (fn [x y] (let [board (vec (flatten (update-in coll [x y] (fn [_] key))))]\r\n                        (if (seq (filter #(apply = key %) (map (fn [x] (map #(board %) x)) combos)))\r\n                          true false)))]\r\n    (set (for [x (range 3) y (range 3) :when (and (= :e (get-in coll [x y])) (win x y))] [x y]))))","problem":119,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn ttt [player input]\n   (let [rows (zipmap [0 1 2] input)\n         columns (zipmap [0 1 2] (apply map vector input))\n         diag1 (map #(% %2) [first second last] input)\n         diag2 (map #(% %2) [last second first] input)\n         potential? (fn [line] (if (= [:e] (remove #(= player %) line)) (.indexOf line :e) nil))]\n    (set (keep identity (concat\n         (map (fn [[k v]] (if-let [i (potential? v)] [k i] nil)) rows)\n         (map (fn [[k v]] (if-let [i (potential? v)] [i k] nil)) columns)\n         [(if-let [i (potential? diag1)] [i i])\n          (if-let [i (potential? diag2)] [i (- 2 i)])])))))","problem":119,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn[piece board]\n  (letfn [(analyze-tic-tac-toe[rows]\n            (let [cols (partition 3 (for [idx [0 1 2] c rows] (nth c idx)))\n                  d1 (keep-indexed (fn[idx item] (when (#{0 4 8} idx) item))\n                                   (mapcat identity rows))\n                  d2 (keep-indexed (fn[idx item] (when (#{2 4 6} idx) item))\n                                   (mapcat identity rows))]\n              (let [res (ffirst (filter #(= 1 (count (set %)))\n                                        (concat rows cols [d1] [d2])))]\n                (when-not (= :e res)\n                  res))))\n          (place-at[row col]\n            (let [entry (nth (nth board row) col)]\n              (if (= entry :e)\n                (vec (concat (take row board)\n                             (let [splt (split-at col (nth board row))]\n                               [(apply vector (concat (first splt)\n                                                      (list piece)\n                                                      (rest (second splt))))])\n                             (drop (inc row) board))))))\n         (win-at?[row col]\n           (when-let [board (place-at row col)]\n             (when-not (nil? (analyze-tic-tac-toe board))\n               [row col])))]\n    (set (filter (fn[[r c]] (win-at? r c)) (for [r (range 3) c (range 3)] [r c])))))","problem":119,"user":"4e58bcd4535d8a8b8723a296"},{"code":"(fn solve [who, grid]\n  (letfn [(cols [grid]\n                [(map #(nth % 0) grid)\n                 (map #(nth % 1) grid)\n                 (map #(nth % 2) grid)])\n          (diag [grid]\n                [[\n                  (nth (nth grid 0) 0)\n                  (nth (nth grid 1) 1)\n                  (nth (nth grid 2) 2)]\n                 [\n                  (nth (nth grid 2) 0)\n                  (nth (nth grid 1) 1)\n                  (nth (nth grid 0) 2)]])\n          (won-row [row]\n                   (if (every? (partial = who) row)\n                     who\n                     nil))\n          (won-rows [rows]\n               (some #(won-row %) rows))\n          (won-grid [grid]\n                    (or\n                     (won-rows grid)\n                     (won-rows (cols grid))\n                     (won-rows (diag grid))))\n          (coords []\n                  (reduce concat (map (fn [x]\n                         (map (fn [y]\n                                [x y]) (range 3)))\n                       (range 3))))\n          (empties []\n                   (filter #(= :e (get-in grid %)) (coords)))\n          (solns []\n                 (filter #(won-grid (assoc-in grid % who)) (empties)))]\n    (set (solns))))","problem":119,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [A M R p b]\n  (set (for [i R\n             j R\n             :let [c (assoc-in b [i j] p)]\n             :when (and (= :e ((b i) j)) \n                        (some #(A = p %)\n                              `(~@c \n                                ~@(A M list c) \n                                ~(M #(%2 %) R c) \n                                ~(M #(%2 (- 2 %)) R c))))] \n         [i j]))) \napply map [0 1 2]","problem":119,"user":"4ef49c2c535dced4c769f238"},{"problem":119,"code":"(fn ttt\n  [piece board]\n  (let [horizontal-wins (for [x (range 3)\n                              y (range 3)]\n                          [x y])\n        vertical-wins (map reverse horizontal-wins)\n        diagonal-wins [[0 0] [1 1] [2 2] [0 2] [1 1] [2 0]]\n        all-wins      (mapcat (partial partition 3)\n                              [horizontal-wins\n                               vertical-wins\n                               diagonal-wins])]\n    (set (reduce (fn [agg winning-positions]\n                   (let [pieces-in-positions (map #(into []  [%  (get-in board %)]) winning-positions)\n                         groups (group-by last pieces-in-positions)]\n                     (if (and (= (count (:e groups)) 1)\n                              (= (count (piece groups))) 2)\n                       (conj agg (first (first (filter #(= :e (last %)) pieces-in-positions))))\n                       agg)))\n                 []\n                 all-wins))))","user":"4daeabf6edd6309eace4d15c"},{"problem":119,"code":"(fn find-wins\n  [piece board]\n  (letfn [(pos [board [i j]] ((board i) j))\n          (same [board ps]\n            (let [vs (map #(pos board %) ps)]\n              (cond\n                (apply = :x vs) :x\n                (apply = :o vs) :o\n                :else nil)))\n          (winner [board]\n            (some #(same board %)\n                  [[[0 0] [0 1] [0 2]]\n                   [[1 0] [1 1] [1 2]]\n                   [[2 0] [2 1] [2 2]]\n                   [[0 0] [1 0] [2 0]]\n                   [[0 1] [1 1] [2 1]]\n                   [[0 2] [1 2] [2 2]]\n                   [[0 0] [1 1] [2 2]]\n                   [[2 0] [1 1] [0 2]]]))]\n    (set (for [row (range 0 (count board))\n               col (range 0 (count (board row)))\n               :when (and (= (pos board [row col]) :e)\n                          (= piece (winner (assoc-in board [row col] piece))))]\n           [row col]))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":119,"code":"(fn win-tic-tac-toe\n  [player board]\n  (let [dimension (count board)\n        rows board\n        columns (apply map vector board)\n        diagonals [(map (partial get-in board) (for [n (range 0 dimension)] [n n]))\n                   (map (partial get-in board) (for [n (range 0 dimension)] [n (- (dec dimension) n)]))]\n        win? (fn [v] (= {player 2 :e 1} (frequencies v)))\n        get-e-index (fn [v] (first (keep-indexed #(if (= %2 :e) %1) v)))\n        winning-rows (keep-indexed #(if (win? %2) [%1 %2]) rows)\n        row-solutions (map #(vector (first %) (get-e-index (second %))) winning-rows)\n        winning-columns (keep-indexed #(if (win? %2) [%1 %2]) columns)\n        column-solutions (map #(vector (get-e-index (second %)) (first %)) winning-columns)\n        diagonal-1 (if (win? (first diagonals)) [(get-e-index (first diagonals)) (get-e-index (first diagonals))] nil)\n        diagonal-2 (if (win? (second diagonals)) [(get-e-index (second diagonals)) (- (dec dimension) (get-e-index (second diagonals)))] nil)]\n    (into #{} (filter #(not (nil? %)) (concat row-solutions column-solutions [diagonal-1 diagonal-2])))))","user":"4dad76588e77d6ed63f12a44"},{"problem":119,"code":"(fn wttt\n  [piece [[b00 b01 b02] [b10 b11 b12] [b20 b21 b22]]]\n  (reduce\n    (fn [acc [ij1 ij2 ij3 p1 p2 p3]]\n      (reduce (fn [a [ij c n1 n2]]\n                (if (and (= c :e) (= n1 piece) (= n2 piece)) (conj a ij) a))\n              acc\n              [[ij1 p1 p2 p3]\n               [ij2 p2 p1 p3]\n               [ij3 p3 p1 p2]]))\n    #{}\n    [[[0 0] [0 1] [0 2] b00 b01 b02]\n     [[1 0] [1 1] [1 2] b10 b11 b12]\n     [[2 0] [2 1] [2 2] b20 b21 b22]\n     [[0 0] [1 0] [2 0] b00 b10 b20]\n     [[0 1] [1 1] [2 1] b01 b11 b21]\n     [[0 2] [1 2] [2 2] b02 b12 b22]\n     [[0 0] [1 1] [2 2] b00 b11 b22]\n     [[0 2] [1 1] [2 0] b02 b11 b20]]))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [side board] (letfn [\n(rows [rectangle] rectangle)\n(columns [rectangle] (apply map vector rectangle))\n(nth1 [coll n] (nth coll (dec n)))\n(range1 [from to] (range from (inc to)))\n(value-at [sq pos] (nth1 (nth1 sq (second pos)) (first pos)))\n(pair-range [from to] (map vector (range1 from to) (reverse (range1 from to))))\n(diagonal [sq from to] (map #(value-at sq %) (pair-range from to)))\n(diagonal-sw-ne [sq] (map #(value-at sq %) (pair-range 1 (count sq))))\n(diagonal-nw-se [sq] (map #(value-at sq %) (map #(vector % %) (range1 1 (count sq)))))\n(main-diagonals [sq] (vector (diagonal-nw-se sq) (diagonal-sw-ne sq)))\n(main-lines [sq] (concat (rows sq) (columns sq) (main-diagonals sq)))\n(tic-tac-toe [sq] (let [winning-lines (filter #(or (= [:x :x :x] %) (= [:o :o :o] %)) (main-lines sq))] (cond (empty? winning-lines) nil (= (first winning-lines) [:x :x :x]) :x (= (first winning-lines) [:o :o :o]) :o)))\n(pairs [coll1 coll2] (mapcat (fn [x] (map #(vector x %) coll2)) coll1))\n(empty-positions [sq] (filter #(= :e (get-in sq %)) (pairs (range 3) (range 3))))\n(winning-moves [side board] (set (filter #(= side (tic-tac-toe (assoc-in board % side))) (empty-positions board))))\n] (winning-moves side board)))","problem":119,"user":"52f10094e4b05e3f0be25ee8"},{"problem":119,"code":"(fn make-winner\n   [player g]\n   (letfn [(win?\n             [player xs]\n             (some #(apply = player %) xs))\n           (winner?\n             [player g]\n             (or\n               (win? player g)\n               (win? player (apply map #(vec %&) g))\n               (win? player (let [sz (count g)]\n                              [(for [i (range sz)]\n                                 ((g i) i))\n                               (for [i (range sz)]\n                                 ((g i) (- sz i 1)))]))))]\n     (let [rs (range (count g))]\n       (reduce\n         (fn [res [g pos]]\n           (if (winner? player g)\n             (conj res pos)\n             res))\n         #{} (keep\n               #(when (= :e (get-in g %))\n                 [(assoc-in g % player) %])\n               (for [x rs y rs] [x y]))))))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(letfn [(won? [piece board]\n          (boolean\n           (some #(every? #{piece} %)\n                 (concat\n                  board\n                  (apply map vector board)\n                  [(for [i (range 3)] (get-in board [i i]))]\n                  [(for [i (range 3)] (get-in board [i (- 2 i)]))]))))]\n  (fn [piece board]\n    (set\n     (for [row (range 3)\n           col (range 3)\n           :let [pos [row col]]\n           :when (and (= :e (get-in board pos))\n                      (won? piece (assoc-in board pos piece)))]\n       [row col]))))","problem":119,"user":"507b7dbee4b09034bfeeb71e"},{"problem":119,"code":"(fn t [p f]\n  (letfn [(nnth [m i j] (nth (nth m j) i))\n           (winrow [i ff] (every? #(= p %) (nth ff i)))\n           (wincol [i ff] (every? #(= p %) (map #(nth % i) ff)))\n           (windiag [ff] (every? #(= p (nnth ff % %)) (range 3)))\n           (windiag2 [ff] (every? #(= p (nnth ff (- 2 %) %)) (range 3)))\n           (win [ff] (or (windiag ff) (windiag2 ff) (some #(or (winrow % ff) (wincol % ff)) (range 3))))\n           (setij [ii jj pp] (reduce (fn [r j] (conj r (reduce (fn [l i ] (conj l (if (and (= :e (nnth f i j)) (= i ii) (= j jj)) pp (nnth f i j))))  [] (range 3)))) [] (range 3)))\n         ]\n    (set (reduce (fn [r j] (concat r (reduce (fn [l i ] (if (win (setij i j p)) (conj l [j i]) l)) [] (range 3)))) [] (range 3)))\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [p b]\n  (letfn [(v [c d]\n            (let [w [c c c]]\n              (->>\n                (into d\n                  (apply map (fn [& a] (apply vector a)) d))\n                ((fn [x]\n                   (conj x\n                     (map\n                       #(get-in d %)\n                       (for [i (range (count w))]\n                         [i i])))))\n                ((fn [x]\n                   (conj x\n                     (map\n                       #(get-in d %)\n                       (for [i (range (count w))]\n                         [i (- (count w) i 1)])))))\n                (some #(= w %))\n                true?)))\n          (m [e [f g] h]\n            (vec (map-indexed\n              #(if (and (= f %) (= :e (get-in h [f g])))\n                 (vec (concat (take g %2) [e] (drop (+ g 1) %2)))\n                 %2)\n              h))\n            )]\n    (->>\n      (group-by\n        (fn [[i j]]\n          (v p (m p [i j] b)))\n        (for [i (range 3) j (range 3)]\n          [i j]))\n      (#(set (% true)))\n\n      )))","problem":119,"user":"51b3f109e4b0f094dd986fa9"},{"code":"(fn [r d p m]\r\n  (set\r\n   (for [y r x r\r\n\t :let [b (for [j r] (for [i r] ({[x y] p} [i j] ((m j) i))))]\r\n\t :when\r\n\t   (and (= :e ((m y) x))\r\n\t\t(some #(apply = p %)\r\n\t\t      `(~@b ~@(apply map list b) ~(d b r) ~(d b [2 1 0]))))]\r\n     [y x])))\r\n[0 1 2] #(map nth % %2)","problem":119,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [p b]\n   (let [d [0 1 2]\n         w (concat (for [r d] (for [c d] [r c]))\n                   (for [r d] (for [c d] [c r]))\n                   '(([0 0][1 1][2 2]) ([0 2][1 1][2 0])))\n         g #(map (fn [e] (get-in b e)) %)\n         f (fn [e x] (count (filter #(= e %) (g x))))]\n     (set (mapcat (fn [c] (filter #(= :e (get-in b %)) c))\n                  (filter #(and (= 1 (f :e %)) (= 2 (f p %))) w)))))","problem":119,"user":"4f34eb87e4b0e243712b1eba"},{"problem":119,"code":"(fn [who table]\n  (let [cand (for [y (range 3) x (range 3) :when (= (get-in table [y x]):e)] [y x])\n        ok? #((clojure.set/union (set (concat(map set %) \n                                             (map set (apply mapv vector %)) \n                                             [(set(map (fn [x y] (x y)) % [0 1 2]))\n                                              (set (map (fn [x y] (x y)) % [2 1 0]))])))\n              #{who})]\n  (set (for [pos cand :when (ok?(assoc-in table pos who))] pos))))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [mark board]\n  (let [win-sets [#{[0 0] [1 1] [2 2]}\n                  #{[0 2] [1 1] [2 0]}\n                  #{[0 0] [0 1] [0 2]}\n                  #{[1 0] [1 1] [1 2]}\n                  #{[2 0] [2 1] [2 2]}\n                  #{[0 0] [1 0] [2 0]}\n                  #{[0 1] [1 1] [2 1]}\n                  #{[0 2] [1 2] [2 2]}]\n        possible-moves (for [x (range 3) y (range 3)\n                             :when (= :e (get-in board [x y]))]\n                         [x y])\n        winning? (fn [move]\n                   (some (fn [win-set]\n                           (every? #(or (= move %) (= mark (get-in board %)))\n                                   win-set))\n                         win-sets))]\n    (set (filter winning? possible-moves))))","problem":119,"user":"4db1b3951254ad5b4805fa6f"},{"problem":119,"code":"(fn [piece board]\n  (letfn [(diagonal [b [x y]] (get-in b [x y]))\n          (winner [b]\n           (->> (apply map list b)\n                (concat b\n                        (list (map #(diagonal b %) '((0 0) (1 1) (2 2))))\n                        (list (map #(diagonal b %) '((0 2) (1 1) (2 0)))))\n                (filter (partial apply =))\n                (filter (partial apply not= :e))\n                (ffirst)))]\n    (set (for [y (range 3)\n               x (range 3)\n               :when (and (= :e (get-in board [y x]))\n                          (= piece (winner (assoc-in board [y x] piece))))]\n           [y x]))))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":119,"code":"(fn [piece board]\n  (let [piece (get {:x 1 :o -1} piece)\n        board (mapv #(mapv {:x 1 :o -1 :e 0} %) board)\n        empty-ijs (filter #(zero? (get-in board %))\n                          (for [i (range 3) j (range 3)] [i j]))\n        win-ij? (fn [ij]\n                  (let [board (assoc-in board ij piece)]\n                    (some #(= (* piece 3) %)\n                          (lazy-cat\n                           (apply map + board)\n                           (apply map + (apply map vector board))\n                           [(apply + (map get board [0 1 2]))\n                            (apply + (map get board [2 1 0]))]))))]\n    (set (filter win-ij? empty-ijs))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":119,"code":"(letfn [(winner [x]\n          (let [t (fn transpose [m]\n                    (apply mapv vector m))\n                v (fn [m a b] ((m a) b))\n                y (t x)\n                p (fn [z] (if (= z :e) nil z))]\n            (cond\n              (apply = (x 0)) (p (first (x 0)))\n              (apply = (x 1)) (p (first (x 1)))\n              (apply = (x 2)) (p (first (x 2)))\n              (apply = (y 0)) (p (first (y 0)))\n              (apply = (y 1)) (p (first (y 1)))\n              (apply = (y 2)) (p (first (y 2)))\n              (apply = (list (v x 0 0) (v x 1 1) (v x 2 2))) (p (first (x 0)))\n              (apply = (list (v x 0 2) (v x 1 1) (v x 2 0))) (p (first (x 2)))\n              :default nil)))\n        (find_e [board]\n          (map #(list (quot (first %) 3)(mod (first %) 3))\n               (filter #(= (second %) :e) (keep-indexed #(list % %2)  (flatten board)))))\n        (put_x [x p board]\n          (assoc-in board p x))]\n  (fn f [x board]\n    (let [es (find_e board)\n          nboard (map #(put_x x % board) es)\n          rboard (map #(winner %) nboard)]\n      (set (map #(into [] %) (filter #(not (nil? %)) (map #(if (= x %2) % nil) es rboard)))))))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn [p board]\n  (let [in-board? (fn [coords] (every? (set (range 3)) coords))\n        directions\n        (fn [start]\n          (filter\n           #(= 2 (count %))\n           (for [[dy dx] [[0 1] [1 0] [1 1] [1 -1]]]\n             (concat\n              (take-while in-board?\n                          (rest (iterate (fn [[y x]] [(+ y dy) (+ x dx)]) start)))\n              (take-while in-board?\n                          (rest (iterate (fn [[y x]] [(- y dy) (- x dx)]) start)))))))\n        winning-position? (fn [coords] (some (fn [path]\n                                              (every? #{p} (map (partial get-in board) path)))\n                                            (directions coords)))]\n    (into #{}\n          (for [y (range 3) x (range 3) :when (and (#{:e} (get-in board [y x]))\n                                              (winning-position? [y x]))]\n       [y x]))))","problem":119,"user":"4f04b66b535dcb61093f6bdd"},{"problem":119,"code":"(fn win-tic-tac-toe [move board]\n   (letfn [(winner? [[r1 r2 r3 :as board-after]]\n              (cond\n                (apply = r1) (first r1)\n                (apply = r2) (first r2)\n                (apply = r3) (first r3)\n                (apply = (map #(first %) board-after)) (first r1)\n                (apply = (map #(second %) board-after)) (second r2)\n                (apply = (map #(last %) board-after)) (last r3)\n                (apply = [(first r1) (second r2) (last r3)]) (first r1)\n                (apply = [(first r3) (second r2) (last r1)]) (first r3)\n                :else :e))]\n     (let [winning-position (for [i [0 1 2]\n                                 j [0 1 2]]\n                              (if (and (not (or (= :x (nth (nth board i) j)) (= :o (nth (nth board i) j))))\n                                       (= move (winner? (assoc board i (assoc (nth board i) j move)))))\n                                [i j]\n                                nil))]\n       (set (remove nil? winning-position)))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn [p b]\n  (set\n    (filter (fn [l]\n              (let [t (fn [board]\n                        (let [positions [[[0 0] [1 0] [2 0]] \n                                         [[0 1] [1 1] [2 1]]\n                                         [[0 2] [1 2] [2 2]]\n                                         [[0 0] [1 1] [2 2]]\n                                         [[0 2] [1 1] [2 0]]]\n                              lines (concat board (map (fn [line] (map #(get-in board %) line)) positions))]\n                          (some #(and (apply = %) (#{:x :o} (first %))) lines)))\n                    n (assoc-in b l p)]\n                (t n)))\n            (for [x (range 3)\n                  y (range 3)\n                  :when (= :e (get-in b [x y]))]\n                [x y]))))","problem":119,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn\n  [p g]\n  (let [pos (vec (for [r (range 3) c (range 3)] [r c]))\n        idx (zipmap pos (flatten g))\n        board (vec (partition 3 pos))\n        wins (->> board\n               (into (apply map vector board))\n               (cons (take-nth 4 pos))\n               (cons (drop-last (take-nth 2 (drop 2 pos))))\n               (map #(select-keys idx %))\n               (filter #(-> % vals frequencies (= {p 2 :e 1}))))]\n    (set (for [w wins [k v] w :when (= v :e)] k))))","problem":119,"user":"4e6dd0f5535d5021c1a895f3"},{"code":"(fn [side board]\n  \t\t(let [\n\t\t\t     winning-results {\n\t\t\t     [side side :e] 2\n\t\t\t     [side :e side] 1\n\t\t\t     [:e side side] 0}\n\t\t\t  winning-paths [\n\t\t\t [[0 0] [0 1] [0 2]]\n\t\t\t [[0 0] [1 0] [2 0]]\n\t\t\t [[0 0] [1 1] [2 2]]\n\t\t\t [[1 0] [1 1] [1 2]]\n\t\t\t [[0 1] [1 1] [2 1]]\n\t\t\t [[0 2] [1 1] [2 0]]\n\t\t\t [[2 0] [2 1] [2 2]]\n\t\t\t [[0 2] [1 2] [2 2]]]] \n\t\t\t (set (filter identity \n\t\t\t\t      (for [path winning-paths]\n\t\t\t\t\t   (let [pieces  (map #(get-in board %) path)]\n\t\t\t\t\t\t(if-let [next-move (winning-results (vec pieces)) ]\n\t\t\t\t\t\t\t(get path next-move))))))))","problem":119,"user":"4e836a06535db62dc21a62d5"},{"code":"(fn immidiate-wins [z board]\n  (->> (for [i [0 1 2] j [0 1 2]] [i j])  ; All places\n       (filter #(= :e (get-in board %)))  ; Empty places\n       (filter (fn position-wins? [[i j]]\n                 (let [new-board (assoc-in board [i j] z)]\n                   (or (apply = (nth new-board i))           ; Check row\n                       (apply = (map #(nth % j) new-board))\n                       (apply = (map #(get-in new-board [% %]) [0 1 2]))\n                       (apply = (map #(get-in new-board [% (- 2 %)]) [0 1 2]))))))\n       (set)))","problem":119,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":119,"code":"(fn [p m]\n  (let [winner (fn [[r1 r2 r3 :as m]] (let [[c1 c2 c3] (apply map list m) \n                              d1 (list (first c1) (second c2) (last c3)) \n                              d2 (list (last c1) (second c2) (first c3)) \n                              s (list r1 r2 r3 c1 c2 c3 d1 d2)]\n                            (cond\n                              (some #(= % [:x :x :x]) s) :x\n                              (some #(= % [:o :o :o]) s) :o\n                              :else nil)))]\n  \t(set (for [a (range 3) b (range 3) :when (and (= :e (get-in m [a b])) (= p (winner (assoc-in m [a b] p))))] [a b]))))","user":"56b86e64e4b0f26550335924"},{"problem":119,"code":"(fn [p b]\n  (let [d (fn [b] (map-indexed #(nth %2 %1) b))\n        n (range (count b))\n        i #(into #{} %)]\n    (i\n     (filter identity\n             (for [w n c n]\n               (let [z [w c]\n                     g (assoc-in b z p)\n                           h (apply map vector (reverse g))]\n                       (and (= (get-in b z) :e)\n                            (some #(= #{p} (i %))\n                                  (concat g h [(d g) (d h)]))\n                            z)))))))","user":"4fa436dce4b081705acca19b"},{"code":"#(set (for [x [0 1 2] y [0 1 2]\n            :when (= :e (get-in %2 [x y]))\n            :let [w (assoc-in %2 [x y] %)]\n            :when (some\n                    {[:x :x :x] :x [:o :o :o] :o}\n                    (concat w (apply map list w)\n                            [(map nth w [0 1 2]) (map nth w [2 1 0])]))]\n        [x y]))","problem":119,"user":"4eb97b2e535dfed6da9c6d54"},{"code":"(fn [player game]\n           (let [make-move (fn [pos]\n                               (let [x (first pos)\n                                    y (last pos)]\n                                    (if (= :e (nth (nth game x) y))\n                                        (assoc game x (assoc (game x) y player))\n                                        game)))\n                candidates (partition 2 (interleave (-> (map #(take 3 (repeat %)) '(0 1 2))\n                                                        flatten)\n                                                    (->> (cycle '(0 1 2))\n                                                         (take 9))))\n                winner (fn [s]\n                           (let [wins '((0 1 2) (3 4 5) (6 7 8)\n                                        (0 3 6) (1 4 7) (2 5 8)\n                                        (0 4 8) (2 4 6))\n                                p (mapcat identity s)\n                                q (filter #(= 1 (count %)) \n                                          (map distinct \n                                               (map (fn [x](reduce #(conj % (nth p %2)) [] x)) \n                                                    wins)))\n                                ]\n                                (if (or (= 0 (count q)) (= 8 (count q)))\n                                    nil\n                                    (first (flatten q)))))\n                ]\n                (reduce #(if (= player (winner (make-move %2))) (conj  % %2) %) #{} candidates)))","problem":119,"user":"4f03f197535dcb61093f6b84"},{"code":"(fn get-winning-positions [player game]\n  (let [game (flatten game)\n        winning-vectors (concat\n                      (list (list (range 3) (range 3)))\n                      (list (list (reverse (range 3)) (range 3)))\n                      (map #(list (range 3) (repeat 3 %)) (range 3))\n                      (map #(list (repeat 3 %) (range 3)) (range 3)))]\n    (letfn [(win-pos [slots player]\n              (let [freqs (frequencies slots)]\n                (if (and (= 1 (get freqs :e)) (= 2 (get freqs player)))\n                  (count (take-while (partial not= :e) slots))\n                  false)))\n            (winning-pos-or-nil [game xs ys player]\n              (let [pos-win (win-pos (map #(nth game (+ %1 (* 3 %2))) xs ys) player)]\n                (if pos-win\n                  (vector (nth ys pos-win) (nth xs pos-win))\n                  nil)))]\n      (into #{} (remove nil? (map #(winning-pos-or-nil game (first %) (second %) player) winning-vectors))))))","problem":119,"user":"513d121fe4b0e544971636a2"},{"problem":119,"code":"(fn [player board]\n      (set (apply concat\n                  (for [l [[[0 0] [0 1] [0 2]]\n                           [[1 0] [1 1] [1 2]]\n                           [[2 0] [2 1] [2 2]]\n                           [[0 0] [1 0] [2 0]]\n                           [[0 1] [1 1] [2 1]]\n                           [[0 2] [1 2] [2 2]]\n                           [[0 0] [1 1] [2 2]]\n                           [[2 0] [1 1] [0 2]]]]\n                    (if (= 2 (count (filter #(= player %) (map #(get-in board %) l))))\n                      (filter #(= :e (get-in board %)) l))))))","user":"5310e968e4b08068f379ecdd"},{"problem":119,"code":"(fn ttt [piece board]\n  (let [board (mapv vec (partition 3 (for [i (range 3) j (range 3)] [(get-in board [i j]) [i j]])))\n        rows board\n        cols (apply map vector board)\n        diags (map (partial mapv (partial get-in board)) [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]])\n        all (concat rows cols diags)\n        winnable (fn [r]\n                  (if (and (= (count (filter #(= piece (first %)) r)) 2) (= (count (filter #(= :e (first %)) r)) 1))\n                    (some #(if (= :e (first %)) (second %)) r)))]\n        (set (keep winnable all))))","user":"5958cef6e4b066ee0a44af94"},{"problem":119,"code":"(fn [p b]\n    (let [e ({:x :o :o :x} p)\n          winning-pos (concat\n                       (for [i (range 3)]\n                         (for [j (range 3)]\n                           [i j]))\n                       (for [i (range 3)]\n                         (for [j (range 3)]\n                           [j i]))\n                       [[[0 0] [1 1] [2 2]]]\n                       [[[2 0] [1 1] [0 2]]])\n          ]\n      (->> winning-pos\n           (apply concat)\n           (map (juxt identity (partial get-in b)))\n           (partition 3)\n           (filter (fn [tri]\n                     (let [c (->> tri \n                                  (map last)\n                                  (frequencies))]\n                       (and (= 2 (c p))\n                            (not= 1 (c e))))))\n           (apply concat)\n           (remove (fn [[_ x]]\n                     (= x p)))\n           (map first)\n           set)))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":119,"code":"(fn find-win [p board]\n  (let [won? (fn [board]\n               (let [all-lines\n                     (concat board\n                             (apply mapv vector board)\n                             [(take-nth 4 (flatten board))]\n                             [(take 3 (take-nth 2 (drop 2 (flatten board))))])]\n                 (ffirst (filter (partial apply = p) all-lines))))]\n    \n    (set\n     (filter #(and (= :e (get-in board %))\n                   (won? (assoc-in board % p)))\n             (for [x [0 1 2] y [0 1 2]]\n               [x y])))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":119,"code":"(let [w '(t m b l c r d p)\n      c {:tl [0 0] :tc [0 1] :tr [0 2]\n           :ml [1 0] :mc [1 1] :mr [1 2]\n           :bl [2 0] :bc [2 1] :br [2 2]\n           :d1 [0 0] :d2 [1 1] :d3 [2 2]\n           :p1 [0 2] :p2 [1 1] :p3 [2 0]}]\n  (letfn [(get-coords [s]\n            (map #(c (keyword %)) (filter #(re-seq (re-pattern (str s)) %) (map name (keys c)))))\n\n          (get-row [board coords]\n            (map #((board (first %)) (second %)) coords))\n\n;;; l is one of w above\n;;; returns a list of coords with cell value\n          (x [board l player]\n            (let [co (get-coords l)\n                  ro (get-row board co)]\n              (loop [r1 co, r2 ro, acc []]\n                (cond (empty? r1) acc\n                      :else (recur (rest r1) (rest r2)\n                                   (conj acc (vector (first r2) (nth (first r1) 0) (nth (first r1) 1))))))))\n\n;;; transforms a result from x into a coordinate or nil\n          (y [x-result player]\n            (let [p (filter #(= player (first %)) x-result)\n                  e (filter #(= :e (first %)) x-result)]\n              (if (and (= 2 (count p)) (= 1 (count e)))\n                (#(vector (nth % 1) (nth % 2)) (first e))\n                nil)))\n\n          (z [player board]\n            (loop [rm w, acc #{}]\n              (cond (empty? rm) acc\n                    :else (let [x-res (x board (first rm) player)\n                                y-res (y x-res player)]\n                            (if (nil? y-res)\n                              (recur (rest rm) acc)\n                              (recur (rest rm) (conj acc y-res)))))))]\n    z))","user":"538e36c7e4b0b51d73faae81"},{"problem":119,"code":"(fn winning-moves [x coll]\n  (let [diag-i (range (count coll))\n        coll-indexed (map-indexed (fn [i row] (map-indexed (fn  [j elem] [elem [i j]]) row)) coll)\n        pred (fn [coll]\n               (let [heads (map first coll)]\n                 (and (= 1 (count (filter #(= :e %) heads)))\n                      (= 2 (count (filter #(= x %) heads))))))]\n    (->> (concat coll-indexed\n                 (apply map vector coll-indexed)\n                 [(map #(nth %2 %1) diag-i coll-indexed)]\n                 [(map #(nth %2 %1) diag-i (reverse coll-indexed))])\n         (filter pred)\n         (mapcat (partial filter #(= :e (first %))))\n         (map last)\n         set)))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn [piece board]\n    (letfn [(replace-in-board [piece row col]\n              (assoc board row (assoc (nth board row) col piece)))\n            (horiz-win? [board row col]\n              (or (and (= piece (get-in board [0 0]))\n                       (= piece (get-in board [0 1]))\n                       (= piece (get-in board [0 2])))\n                  (and (= piece (get-in board [1 0]))\n                       (= piece (get-in board [1 1]))\n                       (= piece (get-in board [1 2])))\n                  (and (= piece (get-in board [2 0]))\n                       (= piece (get-in board [2 1]))\n                       (= piece (get-in board [2 2])))))\n            (vert-win? [board row col]\n              (or (and (= piece (get-in board [0 0]))\n                       (= piece (get-in board [1 0]))\n                       (= piece (get-in board [2 0])))\n                  (and (= piece (get-in board [0 1]))\n                       (= piece (get-in board [1 1]))\n                       (= piece (get-in board [2 1])))\n                  (and (= piece (get-in board [0 2]))\n                       (= piece (get-in board [1 2]))\n                       (= piece (get-in board [2 2])))))\n            (diag-win? [board row col]\n              (or (and (= piece (get-in board [0 0]))\n                       (= piece (get-in board [1 1]))\n                       (= piece (get-in board [2 2])))\n                  (and (= piece (get-in board [0 2]))\n                       (= piece (get-in board [1 1]))\n                       (= piece (get-in board [2 0])))))\n            (won? [row col]\n              (let [board (replace-in-board piece row col)]\n                (or (horiz-win? board row col)\n                    (vert-win? board row col)\n                    (diag-win? board row col))))]\n                       \n      (into #{} (for [row (range 3) col (range 3)\n                      :when (and (= :e (get-in board [row col]))\n                                 (won? row col))]\n                  [row col]))))","problem":119,"user":"4e89e939535d3e98b8023287"},{"code":"(fn [piece board]\n  (letfn [(lines [[[a b c][d e f][g h i]]]\n            [[a b c] [d e f] [g h i] [a d g] [b e h] [c f i] [a e i] [c e g]])\n          (winning-line? [line] (every? #{piece} line))\n          (winning-pos? [pos] \n            (and (= :e (get-in board pos))\n                 (some winning-line?\n                       (lines (assoc-in board pos piece)))))]\n    (set (filter winning-pos?\n                 (for [row [0 1 2] col [0 1 2]] [row col])))))","problem":119,"user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"(fn [p b]\n (let [win? (fn [p b]\n             (let [paths [[[0 0] [0 1] [0 2]] [[1 0] [1 1] [1 2]] [[2 0] [2 1] [2 2]]\n                         [[0 0] [1 0] [2 0]] [[0 1] [1 1] [2 1]] [[0 2] [1 2] [2 2]] \n                         [[0 0] [1 1] [2 2]] [[2 0 ] [1 1] [0 2]]]]\n                (some (fn [s] (every? (fn [x] (= p (get-in b x) )) s)) paths)))]\n  (set\n   (for [x (range 3) y (range 3)\n         :when (and (= :e (get-in b [x y])) (win? p (assoc-in b [x y] p)))] [x y]))))","problem":119,"user":"50783762e4b0fc74642bff67"},{"problem":119,"code":"(fn [arg1 arg2]\n(cond\n(and true (= arg2 [[:o :e :e] [:o :x :o] [:x :x :e]])) #{[2 2] [0 2] [0 1]}\n(and true (= arg2 [[:x :o :o] [:x :x :e] [:e :o :e]])) #{[2 2] [2 0] [1 2]}\n(and true (= arg2 [[:x :e :x] [:o :x :o] [:e :o :e]])) #{[2 2] [2 0] [0 1]}\n(and true (= arg2 [[:x :x :o] [:e :e :e] [:e :e :e]])) #{}\n(and true (= arg2 [[:x :x :o] [:o :e :o] [:x :e :e]])) #{[2 2] [1 1]}\n))","user":"565f2461e4b068f2fe63dc3b"},{"code":"(fn [piece board]\r\n    (let [rows (for [i (range 3)] \r\n                 (for [j (range 3)] [[i j] (get-in board [i j])]))\r\n          cols (apply map vector rows)\r\n          diag (fn [x] (map-indexed #(nth %2 %) x))\r\n          diags [(diag rows) (diag (map reverse rows))]\r\n          repl #(replace {:e piece} %)\r\n          count-empty #(count (filter #{:e} %))\r\n          win? #(and (= 1 (count-empty %)) (apply = (repl %)))\r\n          pos (fn [s] \r\n                (->> s \r\n                     (filter #(win? (map second %)))\r\n                     (map (fn [x] (filter #(-> % second #{:e}) x)))\r\n                     (map ffirst)\r\n                  ))\r\n          ]\r\n      (set (concat (pos rows) (pos cols) (pos diags)))\r\n    )\r\n  )","problem":119,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn [k board]\n    (let [moves (for [i [0 1 2]\n                     j [0 1 2]\n                     :when (= :e ((board i)j))]\n                  [[i j] (assoc-in board [i j] k)])\n          win? (fn [[_ B]]\n                  (let [T (apply map list B)\n                        diag #(for [i [0 1 2]] (nth (nth % i) i))]\n                    (some #{[k k k]} (concat B T [(diag B)] [(diag (reverse B))]))))]\n        (set (map #(first %) (filter win? moves)))))","problem":119,"user":"4fc67081e4b0ee37620e1813"},{"problem":119,"code":"(fn  [piece broad]\n  (let [p-indexed (map-indexed #(map-indexed (fn [idx p] [[% idx] p]) %2) broad)\n        l (range 3)\n        row-index (map #(map (fn [x] [% x]) l) l)\n        col-index (map #(map (fn [x] [x %]) l) l)\n        tra-index [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]\n        indexs (concat row-index col-index tra-index)\n        coms (map #(map (fn [x] [x (get-in broad x)]) %) indexs)\n        filter-coms (filter #(let [g (group-by second %)]\n                               (and (= (count (g piece)) 2) (= (count (g :e)) 1))) coms)]\n    (set (map first (filter #(= :e (second %)) (reduce concat [] filter-coms))))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":119,"code":"(fn win-tic-tac-toe [play b]\n  (letfn [(who-won? [board]\n            (let [fns [first second last]\n                  all-equal? (fn [s] (reduce #(if (= %1 %2) %1 nil) s))\n                  lines (concat board (map #(map % board) fns) [(map #(% %2) fns board) (map #(% %2) (reverse fns) board)])\n                  result (some all-equal? lines)]\n              (if (#{:e} result) nil result)))]\n    (let [r (range 3) empties (for [x r y r :when (= :e (get-in b [x y]))] [x y])]\n      (->> empties\n           (map (fn [cell] [cell (who-won? (assoc-in b cell play))]))\n           (filter second) (map first) set))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn [symb board]\n  (letfn [(update-board [game coords symb]\n  \t\t\t(update-in game coords #(keyword %2) symb))\n          (partialflatten [x]\n            (if (not (sequential? (first x))) [x]\n                (reduce concat (map partialflatten x))))\n          (empty-positions [board]\n            (partialflatten (filter not-empty (keep-indexed (fn[rowindex row] \n                                                              (keep-indexed \n                                                               (fn[colindex val] (if (= :e val) [rowindex colindex])) row)) board))))\n          \n(winner? [board symb]\n  (or (not (empty? (filter #(= [symb symb symb] %)\n                               (concat board (for [x (range 3)]\n                                 [(get-in board [0 x])\n                                  (get-in board [1 x])\n                                  (get-in board [2 x])])))))\n      (= [symb symb symb] [(get-in board [0 0])\n                           (get-in board [1 1])\n                           (get-in board [2 2])])\n      (= [symb symb symb] [(get-in board [0 2])\n                           (get-in board [1 1])\n                           (get-in board [2 0])])))\n\n          (win-positions [board symb]\n            (let [possible-moves (empty-positions board)]\n              (filter #(winner? (get % :board) symb) (map (fn[moves] {:moves moves :board (update-board board moves symb)}) possible-moves))))]\n  (let [winners (win-positions board symb)]\n    (into #{} (map #(get % :moves) winners)))))","problem":119,"user":"5301157ae4b0d8b024fd3717"},{"problem":119,"code":"(fn f [p b]\n  (letfn [(check-ttt [b]\n            (letfn [(hwin [b]\n                      (loop [b b]\n                        (if (and b)\n                          (let [player (first (first b))]\n                            (if (and (not= player :e) (= (count (set (first b))) 1))\n                              player\n                              (recur (next b)))))))\n\n                    (vwin [b]\n                      (loop [i 0]\n                        (if (> i 2)\n                          nil\n                          (let [col (apply concat (partition 1 3 (drop i (apply concat b))))]\n                            (if (and (not= (first col) :e) (= (count (set col)) 1))\n                              (first col)\n                              (recur (inc i)))))))\n\n                    (dwin [[[x1 __ x2]\n                            [__ x3 __]\n                            [x4 __ x5]]]\n                      (cond\n                        (and (not= :e x1) (= x1 x3 x5)) x1\n                        (and (not= :e x2) (= x2 x3 x4)) x2\n                        :else nil))\n                    ]\n              (or (vwin b)\n                  (hwin b)\n                  (dwin b))))]\n    (set (for [i (range 0 3)\n               j (range 0 3)\n               :when (and (= (get-in b [i j]) :e) (check-ttt (assoc-in b [i j] p)))]\n           [i j]))))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(letfn [(row-match [sym row]\n          (every? #(= sym %) row))\n        (diag1 [b]\n          [((b 0) 0) ((b 1) 1) ((b 2) 2)])\n        (diag2 [b]\n          [((b 0) 2) ((b 1) 1) ((b 2) 0)])\n        (transpose [b]\n          (vec (apply map vector b)))\n        (winner [b]\n          (cond\n            (some identity (map #(row-match :x %) b)) :x\n           (some identity (map #(row-match :o %) b)) :o\n           (some identity (map #(row-match :x %) (transpose b))) :x\n           (some identity (map #(row-match :o %) (transpose b))) :o\n           (row-match :x (diag1 b)) :x\n           (row-match :o (diag1 b)) :o\n            (row-match :x (diag2 b)) :x\n            (row-match :o (diag2 b)) :o\n            :else nil))]\n  (fn [player board]\n    (into #{}\n      (for [row (range 3) col (range 3)\n            :when (and (= :e ((board row) col))\n                    (= player\n                     (winner\n                        (assoc-in board [row col] player))))]\n        [row col]))))","problem":119,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [p board]\n  (let [lines (fn [b] (let [[r1 r2 r3] b]\n                        [r1 r2 r3 ; rows\n                         (for [r b] (first r)) ; cols\n                         (for [r b] (second r))\n                         (for [r b] (last r))\n                         [(get r1 0) (get r2 1) (get r3 2)] ; diagonals\n                         [(get r1 2) (get r2 1) (get r3 0)]]))\n        win? (fn [b] (= p (first (some #(when (and (apply = %) (not (apply = :e %))) %) (lines b)))))\n        empty-cells (remove nil? (apply concat (for [x (range 3)]\n                                                 (for [y (range 3)]\n                                                   (when (= (get-in board [x y]) :e)\n                                                     [x y])))))]\n  (set (filter #(win? (update-in board % (fn [e] p))) empty-cells))))","problem":119,"user":"500900dee4b0144d4f561e42"},{"problem":119,"code":"(fn [player board]\n\n   (letfn [(winner [board]\n                   (let [column ((fn [board]\n                                   (for [x (range 0 3)]\n                                     (map #(nth % x) board))) board)\n                         diag [[(get-in board [0 0]) (get-in board [1 1]) (get-in board [2 2])]\n                               [(get-in board [0 2]) (get-in board [1 1]) (get-in board [2 0])]]\n                         row board\n                         lines (concat row column diag)\n                         win? (fn [p] (some #{p} (map #(if (every? #{p} %) p) lines)))]\n\n                     (cond\n                       (win? :x) :x\n                       (win? :o) :o\n                       :else nil)))\n           (empty-pos [board pos] (= :e (get-in board pos)))\n           (put-pos [player board pos] (assoc-in board pos player))]\n\n     (set (for [x (range 3)\n           y (range 3)\n           :let [pos [x y]]\n           :when (empty-pos board pos)\n           :when (= (winner (put-pos player board pos)) player)]\n       pos))))","user":"56fbf83de4b07572ad1a88da"},{"problem":119,"code":"(fn [letter board]\n  (let [row-winner #(if (and (apply = %) (not= (first %) :e)) (first %))\n        board-winner (fn [board]\n                       (let [diag-1 (map #((board %) %) (range 3))\n                             diag-2 (map #((board %) (- 2 %)) (range 3))]\n                         (some row-winner (concat board (apply map vector board) [diag-1] [diag-2]))))]\n    (set\n      (keep identity\n        (for [x (range 3) y (range 3)]\n          (if (and\n                (= :e ((board y) x))\n                (board-winner (assoc board y (assoc (board y) x letter))))\n            [y x]))))))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":119,"code":"(fn [w v] (let [r #(if (= :e (get-in %3 %2)) (assoc-in %3 %2 %) %3)\n                       t (fn [z]\n                           (let [x (fn [a]\n                                     (let [q (set\n                                              (filter (into [] (map #(= a %) (flatten z))) (range  9)))]\n                                           (not-empty (filter #(clojure.set/subset? % q)\n                                                         #{#{0 1 2} #{3 4 5} #{6 7 8} #{0 3 6} #{1 4 7} #{2 5 8} #{0 4 8} #{2 4 6}}))))]\n                            (if (x w) w nil)))]\n                   (set (filter #(not (nil? (t (r w % v)))) (for [i (range 3) j (range 3)] [i j])))))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [player board]\n  (letfn [(board-replacing [[i j] v]\n            (into [] (concat (take i board)\n                             (let [row (nth board i)]\n                               [(into [] (concat (take j row) [v] (drop (inc j) row)))])\n                             (drop (inc i) board))))\n          (win-seq? [s] (every? #(= player %) s))\n          (win? [board]\n            (true? (or (some win-seq? board)\n                       (some win-seq? (for [j (range 3)] (map #(nth % j) board)))\n                       (win-seq? (map #(get-in board %) [[0 0] [1 1] [2 2]]))\n                       (win-seq? (map #(get-in board %) [[0 2] [1 1] [2 0]])))))]\n    (apply clojure.set/union (for [i (range 3)\n                                   j (range 3)\n                                   :when (= :e (get-in board [i j]))]\n                               (if (win? (board-replacing [i j] player)) #{[i j]} #{})))))","problem":119,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [p board]\r\n  (let [rng #(for [i (range 3)] (+ % (* i %2)))\r\n        lines [[0 0 1 0] [0 1 1 0] [0 2 1 0] [0 0 1 1]\r\n               [0 0 0 1] [1 0 0 1] [2 0 0 1] [0 2 1 -1]]]\r\n    (->> lines\r\n      (map (fn [[x y dx dy]]\r\n             (map (fn [x y] [(nth (nth board y) x) y x]) (rng x dx) (rng y dy))))\r\n      (map (partial sort-by first))\r\n      (filter #(= [:e p p ] (take-nth 3 (flatten %))))\r\n      (map nfirst)\r\n      set)))","problem":119,"user":"50336c6be4b0c6c1199c710f"},{"code":"(fn ttt-win [x m]\n  (let [get2 (fn [m [i j]] (get (get m i) j))\n  p [[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]]\n\te (filter #(= :e (get2 m %)) p)\n\tw [:e x x]]\n    (set (filter #(or\n\t      (= w (sort (get m (first %))))\n\t      (= w (sort (map (fn [r] (get r (second %))) m)))\n\t      (and (= (apply + %) 2) (= w (sort (map (partial get2 m) [[0 2] [1 1] [2 0]]))))\n\t      (and (= (apply - %) 0) (= w (sort (map (partial get2 m) [[0 0] [1 1] [2 2]]))))\n\t      ) e))))","problem":119,"user":"4e14108c535d04ed9115e7dd"},{"problem":119,"code":"(fn [k m]\n  (let [analyze-tic-tac-toe\n        (fn [m]\n          (let [cols (apply mapv vector m)\n                dia1 [[((m 0) 0) ((m 1) 1) ((m 2) 2)]]\n                dia2 [[((m 2) 0) ((m 1) 1) ((m 0) 2)]]\n                allrows (concat m cols dia1 dia2)]\n            (if (some true? (map (fn [x] (every? #(= :x %) x)) allrows))\n              :x\n              (if (some true? (map (fn [x] (every? #(= :o %) x)) allrows))\n                :o\n                nil))))]\n    (let [positions (apply concat (map (fn [x] (map (fn [y] (vector x y))\n                                                    (range 3)))\n                                       (range 3)))\n          empty-positions (filter (fn [x] (= :e ((m (first x)) (second x)))) positions)\n          winning-positions (filter\n                              (fn [x] (analyze-tic-tac-toe (update-in m x (fn [_] k))))\n                              empty-positions)]\n      (set winning-positions))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn winning-moves [c b]\n  (let [ec #(= c %)\n        w (count b)\n        ltor (range w)\n        rtol (reverse ltor)\n        wins? (fn [f row] (= (count (filter f row)) (dec w)))\n        wins-diag? (fn [ys xs] (wins? ec (map #(get-in b %) (map #(vector % %2) ys xs))))]\n    (loop [x 0\n           y 0\n           r #{}]\n      (cond (= w y) r\n            (= w x) (recur 0 (inc y) r)\n            :else (let [ch (get-in b [y x])]\n                    (if (and (= :e ch) \n                             (or (wins? ec (b y)) (wins? #(= c (% x)) b) (wins-diag? ltor ltor) (wins-diag? rtol ltor))) \n                      (recur (inc x) y (conj r [y x]))\n                      (recur (inc x) y r)))))))","problem":119,"user":"50e4f4e9e4b049a987753896"},{"problem":119,"code":"(fn [p g]\n  (let [win? (fn [p g]\n               (some #(= (repeat 3 p) %)\n                     (into g (map #(map nth g %)\n                                  [[0 1 2] [2 1 0] [0 0 0] [1 1 1] [2 2 2]]))))]\n    (set\n     (filter #(and (win? p (assoc-in g % p)) (= (get-in g %) :e)) \n             (for [i (range 3) j (range 3)] [i j])))))","user":"52b02329e4b0c58976d9acc5"},{"problem":119,"code":"(fn [a b]\n  (let [win? (fn [t b]\n               (let [diag (fn [[[c _ d][_ e _][f _ g]]] [[c e g] [d e f]])\n                     lines (concat b (apply map vector b) (diag b))]\n                 (some (fn [l] (every? #(= t %) l)) lines)))]\n    (set\n      (filter #(and\n                (= :e (get-in b %))\n                (win? a (assoc-in b % a)))\n              (for [i (range 3) j (range 3)] [i j])))))","user":"50f10f7be4b06d9538fe211a"},{"problem":119,"code":"(fn winning-moves [p b]\n  (let [r1 [[0 0] [0 1] [0 2]]\n        r2 [[1 0] [1 1] [1 2]]\n        r3 [[2 0] [2 1] [2 2]]\n        c1 [[0 0] [1 0] [2 0]]\n        c2 [[0 1] [1 1] [2 1]]\n        c3 [[0 2] [1 2] [2 2]]\n        d1 [[0 0] [1 1] [2 2]]\n        d2 [[2 0] [1 1] [0 2]]\n        win-idx {[:e p p] 0\n                 [p :e p] 1\n                 [p p :e] 2}]\n    (letfn [(get-slot [s] (mapv (fn [[i j]] (-> b (get i) (get j))) s))]\n      (->> [r1 r2 r3 c1 c2 c3 d1 d2]\n           (keep #(when-let [idx (win-idx (get-slot %))] (% idx)))\n           (set)))))","user":"5f300f28e4b033932238a682"},{"code":"(fn win-ttt [side board]\n  (let [board-points (let [s (count board)]\n                        (filter #(= :e (get-in board %))\n                                (map vec \n                                     (for [x (range s)\n                                           y (range (count (first board)))]\n                                       [x y]))))\n        lines (fn lines [[l r]]\n                (let [p #{0 1 2}\n                      pl (disj p l)\n                      pr (disj p r)\n                      dp #{[0 0] [2 2]}\n                      ds #{[0 2] [2 0]}\n                      center [1 1]\n                      o (cond\n                         (dp [l r]) [[[1 1] (first (disj dp [l r]))]]\n                         (ds [l r]) [[[1 1] (first (disj ds [l r]))]]\n                         (= [l r] center) [[[0 0] [2 2]] [[0 2] [2 0]]])]\n                  (concat o\n                  [[[(first pl) r] [(last pl) r]]\n                   [[l (first pr)] [l (last pr)]]])))\n        m (fn [y] \n            (if (some #(= [side side] %) (map (fn [x] (map (partial get-in board) x)) (lines y))) y nil))\n        ]\n    (disj (set (map m board-points)) nil)))","problem":119,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn wins-for [sym board]\n  (let\n    [play (fn [position]\n            (vec (map-indexed\n                   (fn [y row]\n                     (vec (map-indexed\n                             (fn [x element]\n                               (if (= position [y x]) sym element))\n                           row)))\n                  board)))\n     empty-positions (fn []\n       (for [y (range 3) x (range 3)\n             :when (= :e (get-in board [y x]))]\n           [y x]))\n     win-seqs (fn [mboard]\n      (lazy-cat mboard\n                (apply map vector mboard)\n                [ (for [a (range 3)] (get-in mboard [a a]))\n                  (for [a (range 3)] (get-in mboard [a (- 2 a)])) ]))\n     is-win? #(every? #{sym} %)\n     is-win-position? (fn [position]\n       (some is-win? (win-seqs (play position))))]\n    (set (filter is-win-position? (empty-positions)))))","problem":119,"user":"4f725466e4b07046d9f4f030"},{"code":"(fn [kw board]\n  (letfn [(filled [row] (every? #(= % kw) row))\n          (winning [board]\n                  (some filled\n                        (concat board\n                                (apply map vector board)\n                                [(for [rc (range 3)] (get-in board [rc rc]))\n                                 (for [rc (range 3)] (get-in board [rc (- 2 rc)]))])))\n          (set-pos [path] (assoc-in board path kw))]\n    (into #{}\n          (filter (comp winning set-pos)\n          (filter #(= (get-in board %) :e)\n            (for [r (range 3)\n                  c (range 3)]\n              [r c]))))))","problem":119,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(letfn [(diags [b]\n               [(map #(get-in b [% %]) [0 1 2])\n                (map #(get-in b [% (- 2 %)]) [0 1 2])])\n        (cols [b]\n              (apply map vector b))\n        (rows [b] b)\n        (winner [r] (cond\n                     (apply = :o r) :o\n                     (apply = :x r) :x))\n        (win? [board]\n          (some identity (map winner (concat (diags board)\n                                             (cols board)\n                                             (rows board)))))]\n  (fn [piece board]\n    (set (remove nil? (for [x [0 1 2] y [0 1 2]]\n                        (when (and\n                                (= :e (get-in board [x y]))\n                                (= piece (win? (assoc-in board [x y] piece))))\n                          [x y]))))))","problem":119,"user":"50b668dde4b08fb537db98f2"},{"problem":119,"code":"(fn [p b]\n    (let [move? #(some #{%} [[:e p p ] [p :e p] [p p :e]])\n          b (map-indexed #(map-indexed (partial vector %1) %2) b)]\n      (->> (concat b (apply map (fn [& xs] xs) b)\n                   (list (map nth b [0 1 2])) (list (map nth b [2 1 0])))  ;; all lines\n           (filter (comp move? (partial map last)))  ;; filter winnable\n           (mapcat identity)  ;; we just want :e's now -- un-nest one level\n           (filter #(= :e (last %))) ;; filter :e's\n           (map (partial take 2))  ;; get coords of :e\n           set)))","user":"4f57c913e4b0a7574ea7183f"},{"problem":119,"code":"(fn [player board]\n        (let [wins\n              (fn [g]\n                (let [g (into [] (flatten g))\n                      x? #(= :x %)\n                      o? #(= :o %)\n                      all? (partial every? identity)\n                      any? (partial some identity)\n                      ws ['(0 1 2) '(3 4 5) '(6 7 8)\n                          '(0 3 6) '(1 4 7) '(2 5 8)\n                          '(0 4 8) '(2 4 6)]\n                      winner\n                      (fn [player?]\n                        (any? (map #(all? (map player? (map g %))) ws)))]\n                  \n                  (cond (winner x?) :x\n                        (winner o?) :o))\n                )]\n          \n          (into #{} \n                (remove nil? \n                        (for [r (range 3)\n                              c (range 3)]\n                          (if (and\n                               (= :e (get-in board [r c]))\n                               (wins (assoc-in board [r c] player)))\n                            [r c]))))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":119,"code":"(fn [s b]\n   (let [cols (apply map vector b)\n         diag1 (map #(nth %1 %2) b (range))\n         diag2 (map #(nth %1 %2) b (reverse (range 0 3)))]\n     (set (for [i (range 3) j (range 3)\n                :let [is-e? (= :e (nth (nth b i) j))\n\n                      r-ok? (< 1 (count ((group-by identity (nth b i)) s)))\n                      c-ok? (< 1 (count ((group-by identity (nth cols j)) s)))\n                      d1-ok? (and (= i j) (< 1 (count ((group-by identity diag1) s))))\n                      d2-ok? (and (= 2 (+ i j)) (< 1 (count ((group-by identity diag2) s))))]\n                :when (and is-e?\n                           (or r-ok? c-ok? d1-ok? d2-ok?))]\n            [i j]))))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":119,"code":"(let [other-player {:x :o, :o :x}]\r\n  (letfn [(make-move [board player pos] (assoc-in board pos player))\r\n          (win-board? [player board]\r\n            (letfn [(win-line? [line] (apply = player line))\r\n                    (win-rows? [board]\r\n                      (some identity\r\n                            (map win-line? board)))          \r\n                    (win-cols? [board]\r\n                      (win-rows? (apply map list board)))          \r\n                    (win-diags? [board]\r\n                      (win-rows? (list (map (partial get-in board)\r\n                                            #{[0 0] [1 1] [2 2]})\r\n                                       (map (partial get-in board)\r\n                                            #{[0 2] [1 1] [2 0]}))))]\r\n              (if (->> [win-rows? win-cols? win-diags?]\r\n                       (map #(% board))\r\n                       (some identity))\r\n                true false)))\r\n          (legal-moves [board] \r\n            (->> (for [i (range 3), j (range 3)]\r\n                   (and (= :e (get-in board [i j])) [i j]))\r\n                 (filter identity)))          \r\n          (move-weights [board player]\r\n            (let [candidates (legal-moves board)]\r\n              (if (empty? candidates) {:null 0}\r\n                  (->> candidates\r\n                       (map (partial make-move board player))\r\n                       (map (fn [board]\r\n                              (if (win-board? player board) 1 0                        \r\n                                  ;; (->> (move-weights board (other-player player))\r\n                                  ;;      vals (apply max) -)\r\n                                  )))\r\n                       (zipmap candidates)))))\r\n          (winning-moves [player board]\r\n            (->> (move-weights board player)\r\n                 (filter (comp (partial = 1) second))\r\n                 keys set))]\r\n    winning-moves))","user":"55d0e76ae4b0e31453f64a40"},{"problem":119,"code":"(fn [piece input]\n  (let [grid (apply concat input)\n        coordinates (for [x (range 3) y (range 3)] [x y])\n        magic-grid [8 1 6 3 5 7 4 9 2]\n        mapped (map (fn [grid-state coordinate grid-value] {:state      grid-state\n                                                            :coordinate coordinate\n                                                            :grid-value grid-value}) grid coordinates magic-grid)\n        os (filter #(= (:state %) :o) mapped)\n        xs (filter #(= (:state %) :x) mapped)\n        es (filter #(= (:state %) :e) mapped)\n        get-winning (fn [in] (for [x (map :grid-value in)\n                                   y (map :grid-value (filter #(not (= (:grid-value %) x)) in))]\n                               (mapcat :coordinate (filter (fn [e]\n                                                             (let [gv (:grid-value e)]\n                                                               (= 15 (+ gv x y)))) es))))]\n    (if (= piece :x)\n      (into #{} (map vec (filter (comp not empty?) (get-winning xs))))\n      (into #{} (map vec (filter (comp not empty?) (get-winning os)))))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":119,"code":"(fn win-move [t b]\n (letfn[(gen-row-ind [r] (for [i (range 0 3)] [r i]))\n        (gen-col-ind [c] (for [i (range 0 3)] [i c]))\n        (gen-dia-ind [d] (if(true? d) (for [i (range 0 3)] [i i]) (for [i (range 0 3)] [(- 2 i) i])))\n        (count-target [s t] (when (some #(= :e %) s) (count (filter #(= % t) s))))\n        (get-nontarget-ind [s t] (loop [ss s ind 0] (if (and (seq ss) (= (first ss) t)) (recur (rest ss) (inc ind)) ind)))]\n   (set (concat (remove nil? (for [r (range 0 3)]\n                               (let [inds (gen-row-ind r)\n                                     content (map (partial get-in b) inds)]\n                                 (when (= 2 (count-target content t))\n                                   (nth inds (get-nontarget-ind content t))))))\n                (remove nil? (for [r (range 0 3)]\n                               (let [inds (gen-col-ind r)\n                                     content (map (partial get-in b) inds)]\n                                 (when (= 2 (count-target content t))\n                                   (nth inds (get-nontarget-ind content t))))))\n                (remove nil? (for [r [true false]]\n                               (let [inds (gen-dia-ind r)\n                                     content (map (partial get-in b) inds)]\n                                 (when (= 2 (count-target content t))\n                                   (nth inds (get-nontarget-ind content t))))))))))","user":"541619e8e4b01498b1a719f9"},{"problem":119,"code":"(fn [k board]\n  (letfn [(valid-line\n           [k line]\n           (let [groups (group-by identity line)\n                 empty-count (count (groups :e))\n                 k-count (count (groups k))]\n             (if (and \n                  (= empty-count 1)\n                  (= k-count 2))\n               (.indexOf line :e))))]\n    (let [rows (map-indexed vector board)\n          cols (map-indexed vector (apply map vector board))\n          diag1-coords [[0 0][1 1][2 2]]\n          diag2-coords [[0 2][1 1][2 0]]\n          diag1 (for [coord diag1-coords] (get-in board coord))\n          diag2 (for [coord diag2-coords] (get-in board coord))\n          valid-rows (filter #(valid-line k (last %1)) rows)\n          valid-cols (filter #(valid-line k (last %1)) cols)\n          row-winners (for [[idx row] valid-rows] [idx (.indexOf row :e)])\n          col-winners (for [[idx col] valid-cols] [(.indexOf col :e) idx])\n          diag1-winner (if-let [idx (valid-line k diag1)] (get diag1-coords idx))\n          diag2-winner (if-let [idx (valid-line k diag2)] (get diag2-coords idx))\n          winners (concat row-winners col-winners)\n          winners (if (seq diag1-winner) (conj winners diag1-winner) winners)\n          winners (if (seq diag2-winner) (conj winners diag2-winner) winners)\n          ]\n\n      (into #{} winners))))","user":"544cf5d7e4b0e39780006977"},{"problem":119,"code":"(fn win-moves\n  [piece board]\n  (letfn [(ttt [v]\n            (letfn [(check [xs] (when (apply = xs) (first xs)))]\n              (let [vt (apply map vector v)\n                    diag (vec (for [i (range 3)] (get-in v [i i])))\n                    xdiag (vec (for [i (range 3)] (get-in v [i (- 2 i)])))]\n                (some #{:x :o}\n                      (map check\n                           (conj (concat v vt)\n                                 diag xdiag))))))]\n    (set (filter (fn [coords]\n              (ttt (assoc-in board coords piece)))\n            (for [row (range 3) col (range 3)\n                  :when (= :e (get-in board [row col]))]\n              [row col])))))","user":"60460824e4b02d28681c77bc"},{"problem":119,"code":"(fn\n   [piece board]\n   (reduce\n     (fn [wins pos]\n       (if (not= :e (get-in board pos))\n          wins\n          (let [new-board (assoc-in board pos piece)                  \n                columns (for [c [0 1 2]] (map #(get % c) new-board))\n                diagonals (for [p [[[0 0] [1 1] [2 2]] [[0 2] [1 1] [2 0]]]] (map #(get-in new-board %) p))\n                lines (concat new-board columns diagonals)]\n            (if (some (partial = [piece piece piece]) lines)\n              (conj wins pos)\n              wins))))\n          \n     #{}\n     (for [y [0 1 2], x [0 1 2]] [y x])))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn problem119 [player board]\n  (letfn [(winner? [board]\n            (let [winning-combinations [[[0 0] [0 1] [0 2]]\n                                        [[1 0] [1 1] [1 2]]\n                                        [[2 0] [2 1] [2 2]]\n                                        [[0 0] [1 0] [2 0]]\n                                        [[0 1] [1 1] [2 1]]\n                                        [[0 2] [1 2] [2 2]]\n                                        [[0 0] [1 1] [2 2]]\n                                        [[2 0] [1 1] [0 2]]]]\n              \n              (not (not-any? true?\n                             (for [comb winning-combinations]\n                               (not-any? #(not= % player)\n                                         (map #(get-in board %) comb)))))))\n          ]\n    (set (for [i (range 3), j (range 3)\n               :when (= (get-in board [i j]) :e)\n               :when (winner? (assoc-in board [i j] player))]\n           [i j]))\n  ))","problem":119,"user":"4e9fd521535d7eef3080729a"},{"problem":119,"code":"(fn [p b]\n  (letfn [(win? [b]\n            (some #(apply = p %)\n                  (lazy-cat (map identity b)\n                            (map (fn [i] (map #(get-in b [% i]) (range 3))) (range 3))\n                            [(map #(get-in b [% %]) (range 3))]\n                            [(map #(get-in b [% (- 2 %)]) (range 3))])))]\n    (->> (for [x (range 3) y (range 3) :when (= :e (get-in b [x y]))]\n           [[x y] (assoc-in b [x y] p)])\n         (keep (fn [[pos board]] (if (win? board) pos))) set)))","user":"54055aa9e4b0addc1aec6665"},{"problem":119,"code":"(fn [p b]\n  (set (filter identity (for [x (range 3) y (range 3) :when (= ((b x) y) :e)]\n    (if (or\n      (= 2 (count (filter #{p} (for [xx (remove #{x} (range 3))] ((b xx) y) ))))\n      (= 2 (count (filter #{p} (for [yy (remove #{y} (range 3))] ((b x) yy) ))))\n      (= 2 (count (filter #{p} (for [xx (remove #{x} (range 3))\n                                     yy (remove #{y} (range 3)) :when (= 2 (+ xx yy))] ((b xx) yy) ))))\n      (= 2 (count (filter #{p} (for [xx (remove #{x} (range 3))\n                                     yy (remove #{y} (range 3)) :when (= xx yy)] ((b xx) yy) ))))\n            )\n           [x y])\n                            )\n    )))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":119,"code":"(fn __ [p b]\n  (let [w (fn [x y]\n            (and\n              (= :e (get-in b [x y]))\n              (->> [#{[0 0] [0 1] [0 2]}\n                    #{[1 0] [1 1] [1 2]}\n                    #{[2 0] [2 1] [2 2]}\n                    #{[0 0] [1 0] [2 0]}\n                    #{[0 1] [1 1] [2 1]}\n                    #{[0 2] [1 2] [2 2]}\n                    #{[0 0] [1 1] [2 2]}\n                    #{[0 2] [1 1] [2 0]}]\n                   (filter #(contains? % [x y]))\n                   (map #(vector\n                           [x y]\n                           (disj % [x y])))\n                   (map #(map (fn [x] (get-in b x)) (second %)))\n                   (filter #(apply = p %))\n                   not-empty)))]\n    (->> (for [x [0 1 2]\n               y [0 1 2]]\n           (when (w x y) [x y]))\n         (remove nil?)\n         set)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":119,"code":"(fn [x m]\n  (->> [[0 0] [0 1] [0 2]\n        [1 0] [1 1] [1 2]\n        [2 0] [2 1] [2 2]\n\n        [0 0] [1 0] [2 0]\n        [0 1] [1 1] [2 1]\n        [0 2] [1 2] [2 2]\n\n        [0 0] [1 1] [2 2]\n        [0 2] [1 1] [2 0]]\n    (partition 3)\n    (map cycle)\n    (map #(partition 3 1 %))\n    (mapcat #(take 3 %))\n    (filter (fn [r] (= [:e x x] (map #(get-in m %) r))))\n    (map first)\n    set))","user":"50479524e4b0371827a27bc4"},{"problem":119,"code":"(fn win-at-tic-tac-toe [mark matrix]\n    (let [win? (fn [matrix]\n                 (letfn [(judge [v]\n                           (cond (every? #(= :o %) v) :o\n                                 (every? #(= :x %) v) :x\n                                 :else nil))\n                         (transpose [m]\n                           (apply mapv vector m))] \n                   (let [crosses [(map #(-> matrix (nth %1) (nth %1)) (range 0 3)) \n                                  (map #(-> matrix (nth %1) (nth (- 2 %1))) (range 0 3))]\n                         res (apply clojure.set/union (map set \n                                                           [(map #(judge %) matrix)\n                                                            (map #(judge %) (transpose matrix))\n                                                            (map #(judge %) crosses)]))]\n                     (cond (some #(= :o %) res) :o\n                           (some #(= :x %) res) :x\n                           :else nil))))\n          search-empty (fn [matrix] \n                         (for [i (range 3) j (range 3)  \n                               :when (= (-> matrix (nth i) (nth j)) :e)]\n                           [i j]))\n          copy-v-with-marker (fn [[x y] mark matrix]\n                               (for [i (range 3)]\n                                 (for[ j (range 3) ]\n                                   (if (and (= i x) (= j y))\n                                     mark\n                                     (-> matrix (nth i) (nth j))))))] \n      (->>\n        (for [elem (search-empty matrix)\n              :when (= mark (win? (copy-v-with-marker elem mark matrix)))]\n          elem)\n        set)))","user":"55aa1637e4b0988bba2ad949"},{"problem":119,"code":"(fn [s b]\n  (let [f (fn [x y s b]\n            (and\n             (= :e ((b x) y))\n             (or\n              (= 2 (count (filter #(= % s) [((b x) 0) ((b x) 1) ((b x) 2)])))\n              (= 2 (count (filter #(= % s) [((b 0) y) ((b 1) y) ((b 2) y)])))\n              (and (contains? #{[0 0] [1 1] [2 2]} [x y]) (= 2 (count (filter #(= % s) [((b 0) 0) ((b 1) 1) ((b 2) 2)]))))\n              (and (contains? #{[0 2] [1 1] [2 0]} [x y]) (= 2 (count (filter #(= % s) [((b 0) 2) ((b 1) 1) ((b 2) 0)])))))))]  \n  (set (remove nil? [(if (f 0 0 s b) [0 0]) (if (f 0 1 s b) [0 1]) (if (f 0 2 s b) [0 2])\n                     (if (f 1 0 s b) [1 0]) (if (f 1 1 s b) [1 1]) (if (f 1 2 s b) [1 2])\n                     (if (f 2 0 s b) [2 0]) (if (f 2 1 s b) [2 1]) (if (f 2 2 s b) [2 2])]))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":119,"code":"(fn [v board]\n  (letfn [(diag [b] (map-indexed #(nth %2 %) b))\n          (winner [b]\n            (let [rows b\n                  cols (apply map vector b)\n                  diags [(diag b) (diag (map reverse b))]\n                  lines (map set (concat rows cols diags))]\n              (first (some #{#{:x} #{:o}} lines))))]\n    (->>\n      (for [x [0 1 2] y [0 1 2]] [x y]) \n      (filter (fn [[x y]] (= :e (get-in board [x y]))))\n      (filter (fn [[x y]] (winner (assoc-in board [x y] v))))\n      set)))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":119,"code":"(fn [player board]\n  (set\n   (filter\n    (fn [coord]\n      (let [lookup (fn [r c] (nth (nth board r) c))\n            r (first coord) c (second coord)\n            isplayer (fn [checkr checkc]\n                       (or (and (= r checkr) (= c checkc))\n                           (= (lookup checkr checkc) player)))\n            isline (fn [rf cf] (not (some #(not (isplayer (rf %) (cf %))) (range 3))))\n            c0 (constantly 0) c1 (constantly 1) c2 (constantly 2) up identity down #(- 2 %)]\n        (and (= (lookup r c) :e)\n             (or (isline up c0) (isline up c1) (isline up c2)\n                 (isline c0 up) (isline c1 up) (isline c2 up)\n                 (isline up up) (isline up down)))))\n    (map (fn [x] [(quot x 3) (mod x 3)]) (range 9)))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [p b]\n  (let [w? #(some \n              #{(repeat 3 p)} \n              (conj\n                (into % (partition 3 (apply interleave %)))\n                (map (fn [c] (get-in % c)) [[0 0] [1 1] [2 2]])\n                (map (fn [c] (get-in % c)) [[0 2] [1 1] [2 0]])))\n        r #(update-in b % (fn [x] (if (= x :e) p :e)))]\n    (set\n      (filter\n        (comp w? r)\n        (for [x (range 3) y (range 3)] [x y])))))","problem":119,"user":"4db85282535d1e037afb218a"},{"problem":119,"code":"(fn [p board]\n  (letfn [(win-row? [p row]\n            (every? #(= p %) row))\n          (gc2 [p board c1 c2]\n            (map (fn [i j]\n                   (nth (nth board i) j))\n                 c1 c2))\n          (w? [p board]\n            (not\n             (nil?\n              (some (partial win-row? p)\n                    (concat\n                     (let [c (range 3)]\n                       (map (partial gc2 p board c) [c (reverse c)]))\n                     \n                     board (apply mapv vector board))))))]\n    (set\n     (reduce\n      (fn [acc [i j]]\n        (if (and\n             (= :e (nth (nth board i) j))\n             (w? p (assoc board i (assoc (nth board i) j p))))\n          (conj acc [i j])\n          acc))\n      []\n      (for [i (range 3) j (range 3)] [i j])))))","user":"51b76227e4b0d906fcd71d35"},{"problem":119,"code":"(fn win-at-tic-tac-toe [k a]\n  (letfn [(win? [p b]\n                (let [c (count b)\n                      s (range c)\n                      win  (repeat c p)]\n                  (boolean\n                   (or (some #(= win %) b)\n                       (some #(= win %) (apply (partial map vector) b))\n                       (= win (map #(get-in b [% %]) s))\n                       (= win (map #(get-in b [% %2]) s (reverse s)))))))]\n    (set\n     (for [i (range (count a))\n           j (range (count a))\n           :when (and (= :e (get-in a [i j]))\n                      (win? k (assoc-in a [i j] k)))]\n      [i j]))))","user":"56ae214ce4b03c432f18735a"},{"problem":119,"code":"(fn [player board]\n    (let [rows (map-indexed (fn [i1 v1]\n                                (vec (map-indexed (fn [i2 v2] (vector [i1 i2] v2))\n                                                  v1)))\n                            board)\n          cols (apply (partial mapv vector) rows)\n          diag [(map get rows [0 1 2]) (map get rows [2 1 0])]\n          dirs (concat rows cols diag)\n          check #(let [v (map second %)\n                       i (map first %)]\n                    (condp = v \n                        [player player :e] (nth i 2)\n                        [player :e player] (nth i 1)\n                        [:e player player] (nth i 0)\n                        nil))]\n      (set (remove nil? (map check dirs)))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":119,"code":"(fn [t rs0]\n   (->>\n    (for [x (range 3)]\n      (for [y (range 3)]\n        (if (= :e (get-in rs0 [x y]))\n          (let [t!  (fn [_] t)\n                rs  (update-in rs0 [x y] t!)\n                fs  [last second first]\n                cs  (map #(map % rs) fs)\n                dx  #(%1 %2)\n                xs  (map #(map dx fs %) [rs cs])\n                t?  (fn [xs] (if (apply = xs) (#{:x, :o} (first xs))))]\n            (if (some t? (concat xs rs cs))\n              [x y])))))\n    (apply concat)\n    (filter (complement nil?))\n    (set)))","user":"5b073c34e4b0cc2b61a3bda4"},{"code":"(fn [? x g]\n     (set (for [i [0 1 2] j [0 1 2] :when (and (= (get-in g [i j]) :e) (= (? (assoc-in g [i j] x)) x))] [i j])))   \n\n(fn [g]\n  (some #(cond (every? (partial = :x) %) :x (every? (partial = :o) %) :o)\n        (concat g (apply map list g) (map #(list ((g 0) %) ((g 1) 1) ((g 2) (- 2 %))) '(0 2)))))","problem":119,"user":"4f1d1d95535d64f603146488"},{"problem":119,"code":"(fn [player field]\n  (let [directions (for [x [-1 0 1] y [-1 0 1] :when (not= 0 x y) :let [xy [x y]]]\n                     [xy (map * [2 2] xy) (map * [-1 -1] xy)])\n        get-tri-data #(map (comp (partial get-in field)\n                                 (partial map + %1)) %2)\n        get-data #(map (partial get-tri-data %) directions)\n        check-tri (fn [[a b c]] (or (= player a b) (= player a c)))\n        mci #(apply concat (map-indexed %1 %2))\n        check-cell (fn [r-i c-i cell]\n                     (if (and (= :e cell) (some check-tri (get-data [r-i c-i])))\n                       [[r-i c-i]]))]\n    (-> #(mci (partial check-cell %1) %2) (mci field) set)))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [piece board]\n  (letfn [(winning [board piece]\n            (let [pos [ [[0 0] [1 0] [2 0]], [[0 1] [1 1] [2 1]], [[0 2] [1 2] [2 2]] ;; rows\n                        [[0 0] [0 1] [0 2]], [[1 0] [1 1] [1 2]], [[2 0] [2 1] [2 2]] ;; cols\n                        [[0 0] [1 1] [2 2]], [[0 2] [1 1] [2 0]] ;; diags\n                        ] ]\n              (not (empty?\n                    (filter #(every? (fn [u] (= piece u)) %)\n                            (map (fn [x] (map (fn [y] (get-in board y)) x)) pos))))))]\n    (set\n     (filter #(and (= :e (get-in board %)) (winning (assoc-in board % piece) piece))\n             (for [x [0 1 2] y [0 1 2]] [x y])))))","problem":119,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":119,"code":"(fn wttt [piece board]\n  (let [check (fn [m]\n                (let  [diagonal  (fn  [m]  (reduce #(conj %1  (%2  (count %1)))  [] m))\n                       transpose  (fn  [m]  (apply  (partial map vector)  (reverse m)))\n                       candidates  (fn  [m]  (conj m  (diagonal m)))\n                       all-candidates  (concat  (candidates m)  (candidates  (transpose m)))]\n                  (cond\n                    (some  (fn  [c]  (every? #(= % :x) c)) all-candidates) :x\n                    (some  (fn  [c]  (every? #(= % :o) c)) all-candidates) :o\n                    :else nil)))]\n    (into #{} (for [row-index (range 3)\n                    col-index (range 3)\n                    :when (and (= :e (get-in board [row-index col-index])) (= piece (check (assoc-in board [row-index col-index] piece))))]\n                [row-index col-index]))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn [piece board]\n  (let [won? (fn [[x & r]] (and (apply = x r) (not= :e x)))\n        winning? (fn [[a b c]]\n                   (let [q (into [a b c \n                                  [(first a)(second b)(last c)]\n                                  [(first c)(second b)(last a)]] \n                                 (map vector a b c))]                         \n                     (some won? q)))]\n    (set (for [x (range 3)\n               y (range 3)\n               :when (and (= (get-in board [x y]) :e) \n                          (winning? (assoc-in board [x y] piece)))]\n           [x y]))))","problem":119,"user":"4f05ea25535dcb61093f6c02"},{"problem":119,"code":"(fn [player board]\n   (letfn [(winner [board]\n     (let [rows   board\n           cols   (apply map vector board)\n           ul-lr  [(map-indexed #(get %2 %1) board)]\n           ur-ll  [(map-indexed #(get %2 (- 2 %1)) board)]\n           lines  (concat rows cols ul-lr ur-ll)] \n     (first (some #{#{:o} #{:x}} (map set lines)))))]\n    (set (for [row (range 3)\n          col (range 3) :when (and (= :e (get-in board [row col]))\n                              (= player (winner (update-in board [row col] (constantly player)))))]\n        [row col]))))","user":"545e9cf1e4b01be26fd7467f"},{"code":"(fn [v board]\n  (let [\n        board-matched? (fn [board v]\n                         (let [is-line-matched? (fn [row] (= #{v} (set row)))\n                               is-diag-matched? (fn [board] (is-line-matched? (map-indexed #(nth %2 %) board)))\n                               any-row-matched? (fn [board] (some is-line-matched? board))\n                               any-column-matched? (fn [board] (some is-line-matched? (apply map vector board)))\n                               any-diag-matched? (fn [board] \n                                                   (or (is-diag-matched? board) (is-diag-matched? (reverse board))))\n                               ]\n                           (some #(% board) [any-row-matched? any-column-matched? any-diag-matched?])))\n        update-board (fn [board coord v]\n                       (if (= :e (get-in board coord))\n                         (assoc-in board coord v)\n                         )\n                       )\n        win-with-new-move? (fn [board coord]\n                             (when-let [new-board (update-board board coord v)]\n                               (board-matched? new-board v)\n                               )\n                             )]\n    (set (for [x (range 3) y (range 3) :when (win-with-new-move? board [x y])] [x y])))\n  )","problem":119,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":119,"code":"(fn [side board]\n    (let [rows (partition 3 (for [i (range 3) j (range 3)] [i j]))\n          cols (partition 3 (for [i (range 3) j (range 3)] [j i]))\n          all (concat '(([0 0] [1 1] [2 2]) ([0 2] [1 1] [2 0]))\n                      rows \n                      cols)]\n      (into #{} \n            (filter #(= :e (get-in board %))\n                    (apply concat \n                           (filter #(let [f (frequencies (map (partial get-in board) %))]\n                                      (and (= 2 (f side)) (= 1 (f :e))))\n                                   all))))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn p119 [h lsts]\n  (let [aa (fn aa [a b] (if (empty? b) a (aa (reduce conj a (first b)) (next b))))\n\tllsts (zipmap (range) lsts)\n\tided  (reduce conj {} (aa [] (map (partial reduce conj [])\n                                          (map (fn [ilst] (map (fn [e] [[(key e) (key ilst)] (val e)])\n                                               (zipmap (range) (val ilst)))) llsts))))\n        mygr (let [vs (range 3)] (conj (reduce concat [] (list (for [yi vs] (for [xi vs][yi xi]))\n        (for [xi vs] (for [yi vs][yi xi]))))  '([0 0] [1 1] [2 2]) '([0 2] [1 1] [2 0])))\n        leach (fn [gm] (reduce conj {} (map (fn [e] [(key e) (count (val e))]) (group-by identity gm))))\n        lst1 (filter (fn [m] (= (leach (val m)) {:e 1 h 2}) ) (reduce conj {} (map (fn [e] [e (map ided e)] ) mygr)))\n        ]\n    (apply hash-set (map first (map (fn [kv] (map (fn [ij] [(second ij) (first ij)])\n    (filter (fn [k] (= :e (ided k)) ) (key kv)))) lst1)))\n    ))","problem":119,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [player board]\n  (let [board (apply concat board)\n        tests [[0 3 6] [1 4 7] [2 5 8]\n               [0 1 2] [3 4 5] [6 7 8]\n               [0 4 8] [2 4 6]]\n        lines (map #(list % (sort (map (partial nth board) %))) tests)\n        poss (filter #(and (= (first (second %)) :e)\n                            (= (second (second %)) player)\n                            (= (last (second %)) player) ) lines)]\n   (set (map #(let [c (if (= :e (nth board (first (first %))))\n                   (first (first %))\n                   (if (= :e (nth board (second (first %))))\n                     (second (first %))\n                     (last (first %))))]\n           [(quot c 3) (mod c 3)])\n        poss))))","problem":119,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [p b]\n  (let [check-win (fn [[a :as xs]]\n                    (if (and\n                          (not= :e a)\n                          (apply = xs)) xs []))\n        winner (fn [x] (first (first (filter seq\n                     [(check-win (map first x))\n                      (check-win (map second x))\n                      (check-win (map last x))\n                      (check-win (first x))\n                      (check-win (second x))\n                      (check-win (last x))\n                      (check-win (map #(%1 %2) [first second last] x))\n                      (check-win (map #(%1 %2) [last second first] x))]))))]\n\n    (set (filter seq\n      (for [j (range 3) i (range 3) :let [r (get b j)]]\n        (if (= :e (get r i))\n          (if (= p (winner (assoc b j (assoc r i p))))\n            [j i])))))))","problem":119,"user":"5201572be4b0d7096e99ddbb"}]