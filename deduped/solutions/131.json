[{"code":"(fn [& sets]\n    (let [sums (fn sums\n                 ([s]\n                  (reduce\n                    into\n                    #{}\n                    (for [e s]\n                      (sums e (disj s e)))))\n                 ([n s]\n                  (if-not (seq s)\n                    #{n}\n                    (clojure.set/union\n                      (sums (+ n (first s)) (rest s))\n                      (sums n (rest s))))))]\n      (->> sets\n           (map sums)\n           (apply clojure.set/intersection)\n           empty?\n           not)))","problem":131,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn [& sets]\n  (let [sums (fn [[x & xs]]\n               (reduce \n                 #(into % (cons %2 (map (partial + %2) %)))\n                 #{x} xs))]\n    (not= #{} (reduce \n                #(set (filter %1 %2)) \n                (map (comp sums seq) sets)))))","problem":131,"user":"4e8f1ac6535d65386fec2146"},{"problem":131,"code":"(fn [& sets]\n    (let [power-set (fn power-set [s]\n                      (if (empty? s)\n                        #{s}\n                        (let [subsets (power-set (set (rest s)))]\n                          (into subsets (map #(conj % (first s)) subsets)))))\n          non-empty-subsets (fn [s]\n                              (filter (comp not empty?) (power-set s)))]\n      (->> sets\n        (map non-empty-subsets)\n        (map (fn [subsets] (map #(reduce + %) subsets)))\n        (map set)\n        (apply clojure.set/intersection)\n        ((comp not empty?)))))","user":"5317d78ee4b08068f379ed63"},{"code":"(fn [& sets]\n(letfn \n    [(sum [s] (reduce + s))\n     (power-set [s]\n       (if (empty? s)\n         #{#{}}\n         (let [x (first s) r (disj s x)]\n           (clojure.set/union\n            (set (map #(conj % x) (power-set r)))\n            (power-set r)))))\n     (all-sums [s] (set (map sum (disj (power-set s) #{}))))]\n  (not (empty? (reduce clojure.set/intersection (map all-sums sets))))))","problem":131,"user":"4ed188c8535d44c135fd68cf"},{"problem":131,"code":"(fn equiv-summation? [& args]\n  (letfn [(combinations [k s]\n                        (if (or (> k (count s)) (< k 1))\n                          #{}\n                          (if (= k 1)\n                            (set (map #(set [%]) s))\n                            (set (concat (map #(set (cons (first s) %))\n                                              (combinations (dec k) (rest s)))\n                                         (combinations k (rest s)))))))\n          (all-combinations [s]\n                            (let [size (count s)]\n                              (loop [k 1\n                                     res #{}]\n                                      (if (> k size)\n                                        res\n                                        (recur (inc k) (clojure.set/union res (combinations k s)))))))\n          (all-sums [s]\n                    (set (map (partial apply +) s)))]\n                    (not (empty? (apply clojure.set/intersection (map (comp all-sums all-combinations) args))))))","user":"53791ab7e4b06839e8705e4d"},{"problem":131,"code":"(fn sum-subset [& s]\n  (let [sub (fn [s1 s2] (reduce disj s1 s2))\n        sum (fn [s] (reduce + s))\n        one (fn [s] (reduce #(conj %1 #{%2}) #{} s))\n        uni (fn [s1 s2] (reduce conj s1 s2))\n        pnk (fn [s pnk-1] (reduce #(conj %1 (conj pnk-1 %2))\n                                  #{}\n                                  (sub s pnk-1)))\n        cnk (fn [s cnk-1] (reduce #(uni %1 (pnk s %2)) #{} cnk-1))\n        cna (fn [s]\n              (let [size (count s)]\n                (loop [i 1\n                       cnk-1 (one s)\n                       res cnk-1]\n                  (if (= i size)\n                    res\n                    (let [cnk-1 (cnk s cnk-1)]\n                      (recur (+ i 1) cnk-1 (uni res cnk-1)))))))\n        sum-all (fn [s] (reduce #(conj %1 (sum %2)) #{} s))\n        all-contains? (fn [s n] (reduce #(and %1 (contains? %2 n))\n                                        true\n                                        s))\n        set-sum (map sum-all (reduce #(conj %1 (cna %2)) [] s))\n        r (rest set-sum)]\n    (loop [s (first set-sum)]\n      (if (seq s)\n        (if (all-contains? r (first s))\n          true\n          (recur (rest s)))\n        false))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":131,"code":"(fn [& x] (letfn [\n (sub-sets [s]\n  (if (empty? s) #{#{}}\n     (let [f (first s), rset (sub-sets (rest s))]\n     (concat rset (map #(conj % f) rset)))))\n (sums [x] (set (map #(apply + %) (filter #(not (empty? %)) (sub-sets x)) ))) ] \n  (not (empty? (apply clojure.set/intersection (map sums x))))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn sum-some-subsets [& sets]\n  (let [\n       power-set \n       (fn [s]\n         (reduce \n          (fn [ps x]\n            (reduce \n             (fn [ps s]\n               (conj ps (conj s x))) ps ps)) \n          #{#{}} s))]\n\n    (not \n     (empty?\n      (reduce \n       clojure.set/intersection\n       (map (fn [s] \n              (set \n               (map \n                #(apply + %)\n                (remove #{#{}} (power-set s)))))\n            sets)))\n     )\n    )\n  )","problem":131,"user":"5094057fe4b097f48cc38593"},{"problem":131,"code":"(fn is-equal?\n  [& s]\n  (letfn [(get-all-sums\n            [st]\n            (if (empty? st) #{}\n                            (let [fe (first st)\n                                  sub-set (disj st fe)\n                                  sums (get-all-sums sub-set)\n                                  sums-with-fe (conj (map #(+ fe %) sums) fe)]\n                              (reduce conj sums sums-with-fe))))]\n    (if (empty? s)\n      true\n      (false? (empty? (reduce clojure.set/intersection (map get-all-sums s)))))))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [& sets]\n  (let [powerset (fn [s] (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}} s))\n        setofsums (fn [subsets] (set (map #(reduce + %) subsets)))\n        ]\n    (->>\n      (map powerset sets)\n      (map (partial remove empty?))\n      (map setofsums)\n      (reduce clojure.set/intersection)\n      (empty?)\n      (not))))","problem":131,"user":"52015698e4b0d7096e99ddba"},{"problem":131,"code":"(fn [& s]\n  (letfn [(sb [ss] (->> (map (fn [v] #(->> v (conj %2) (conj %1))) ss)\n                        (reduce #(reduce %2 %1 %1) #{#{}})))\n          (su [ss] (->> (map #(reduce + %) (remove empty? (sb ss)))\n                        (set)))]\n    (< 0 (count (reduce clojure.set/intersection (map su s))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(power-set\n           ([s] (power-set (count s) s))\n           ([k s]\n            (if (zero? k)\n              #{#{}}\n              (let [subsets (power-set (dec k) s)]\n                (into subsets (for [x s\n                                    subset subsets]\n                                (conj subset x)))))))\n          (sums [s]\n                (->> (power-set s)\n                     (remove empty?)\n                     (map (partial apply +))\n                          set))]\n    (->> ss\n         (map sums)\n         (apply clojure.set/intersection)\n         ((complement empty?)))))","user":"583e27e2e4b089d5ab817daa"},{"problem":131,"code":"(fn [& s]\n  (letfn [\n     (p  [s] (clojure.set/difference (reduce #(into % (for [sub %] (conj sub %2))) #{#{}} s) #{#{}}))\n     (q [s]  (into #{} (map #(apply + %) (p s))))]\n  (not (empty? (apply clojure.set/intersection (for [i s] (q i)))))))","user":"56bca51ae4b0f26550335963"},{"problem":131,"code":"(letfn\n [(pset [x]\n        (if (seq x)\n          (let [y (pset (rest x))]\n            (into y (map #(conj % (first x)) y)))\n          #{#{}}))]\n (fn [& xs]\n   (->> xs\n        (map pset)\n        (map #(disj % #{}))\n        (map #(map (partial apply +) %))\n        (map set)\n        (apply clojure.set/intersection)\n        seq\n        boolean)))","user":"55f20e4be4b06e875b46ce40"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(sub-sets [s]\n                    (if (empty? s) #{#{}}\n                      (clojure.set/union (sub-sets (rest s))\n                                         (map #(conj % (first s)) (sub-sets (rest s))))))\n          (sub-sets-sum [s]\n                        (into #{} (map #(apply + %) (filter (complement empty?) (sub-sets s)))))]\n    ((complement empty?) (apply clojure.set/intersection (map sub-sets-sum sets)))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":131,"code":"(fn [& all-the-sets]\n                              (let [power-set (fn [s]\n                                                (let [set-to-seq (seq s)\n                                                      power-set-size (Math/pow 2 (count s))\n                                                      eligibility (map #(Integer/toBinaryString %) (range power-set-size))]\n                                                  (set (for [e eligibility]\n                                                         (set (map first \n                                                                   (filter (fn [[a b]] (= b \\1)) \n                                                                           (map vector set-to-seq (reverse e)))))))))]\n                                ((complement empty?) (apply clojure.set/intersection \n                                                            (map (fn [in] \n                                                                   (set (map #(apply + %) \n                                                                             (remove empty? \n                                                                                     (power-set in))))) \n                                                                 all-the-sets)))))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn [& is]\n   (letfn [(comb [s] (reduce (fn [r v]\n                               (into r (conj (map #(conj % v) r) #{v})))\n                             #{} s))]\n     (not (empty? (apply clojure.set/intersection\n                         (map #(set (map (partial apply +) (comb %))) is))))))","problem":131,"user":"50f48298e4b004d364930527"},{"problem":131,"code":"(fn subsets-common-sum? [& int-sets]\n  (letfn [(power-set [set]\n            (reduce \n             #(into %1 (for [subset %1] \n                         (conj subset %2))) \n             #{#{}} set))\n          (sets-sums [sets]\n            (set (map #(apply + %) sets)))]\n    (let [power-sets (map #(disj (power-set %) #{}) int-sets)\n          power-sets-sums (map sets-sums power-sets)]\n      (not (empty? (apply clojure.set/intersection power-sets-sums))))))","user":"58ed713de4b056aecfd47d84"},{"code":"(fn shared-sum? [& sets]\n  (let [powerset (fn powerset [l]\n                    (if (empty? l)\n                      #{#{}}\n                      (let [ps (powerset (rest l))]\n                        (apply conj ps\n                          (map (fn [x] (conj x (first l)))\n                               ps)))))\n        subset-sums (fn subset-sums [sets]\n                      (map (comp (partial map (partial reduce +))\n                                 (partial filter seq)\n                                 powerset)\n                           sets))\n        sums (subset-sums sets)]\n    (boolean\n      (some\n        (fn [n] (every? #(contains? (set %) n) sums))\n        (first sums)))))","problem":131,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn [& sets]\n    (let\n      [power-set (fn [S] (reduce #(into % (for [T %] (conj T %2))) #{#{}} S))\n       my-power-sets (map power-set sets)\n       sum-subset-sets (for [S my-power-sets] (set (map #(reduce + %) (rest S))))]\n     (not= #{} (apply clojure.set/intersection sum-subset-sets))))","problem":131,"user":"4fc67081e4b0ee37620e1813"},{"code":"(fn s [& x]\n  (letfn [(p [ls]\n    (if (empty? ls) #{#{}}\n        (clojure.set/union (p (next ls))\n                    (into #{} (map #(conj % (first ls)) (p (next ls)))))))\n          (ps [l] (set (map (partial apply +) (remove empty? (p l)))))]\n (not (empty? (reduce clojure.set/intersection (map ps x))))))","problem":131,"user":"4ede8789535d10e5ff6f5337"},{"problem":131,"code":"(fn [& ss]\n    (letfn [(sum-of-subsets [s]\n              (if (empty? s)\n                s\n                (let [f (first s)\n                      r (disj s f)\n                      s (sum-of-subsets r)]\n                  (clojure.set/union s #{f} (set (map #(+ f %) s))))))]\n      (not (empty? (reduce clojure.set/intersection (map sum-of-subsets ss))))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":131,"code":"(fn [& sets]\n  (->> (map (fn [set] (reduce (fn [a s] (into a (map #(conj % s) a))) #{#{}} set)) sets)\n       (map #(remove empty? %))\n       (map #(map (partial apply +) %))\n       (map #(set %))\n       (apply clojure.set/intersection)\n       ((complement empty?))))","user":"5e6ca949e4b04a83ad7cd289"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(ps [s el]\n            (clojure.set/union\n             s (reduce #(conj %1 (conj %2 el)) #{} s)))\n          (power-set [s]\n            (reduce ps #{#{}} s))]\n    ((complement empty?)\n     (reduce clojure.set/intersection\n             (map (fn [s]\n                    (reduce\n                     #(conj %1 (reduce + %2))\n                     #{} (clojure.set/difference\n                          (power-set s) #{#{}})))\n                  sets)))))","user":"541b1f25e4b01498b1a71a63"},{"problem":131,"code":"(fn [& sets]\n  (let [all-subs (map (fn all-subsets [s]\n                        (if (seq s)\n                          (if (seq (rest s))\n                            (let [subs (all-subsets (rest s))]\n                              (cons #{(first s)} (lazy-cat subs (map #(conj % (first s)) subs))))\n                            (list #{(first s)}))\n                          nil)) sets)\n        all-sums (map #(into #{} (map (fn [x] (reduce + 0 x)) %)) all-subs)]\n    (loop [s (first all-sums)]\n      (if (seq s)\n        (if (every? #(contains? % (first s)) (rest all-sums))\n          true\n          (recur (rest s)))\n        false))))","user":"54ca93abe4b057c6fda3a264"},{"problem":131,"code":"; Based on powerset from problem 85\n(letfn \n  [(subset [s n]\n    (set\n     (loop [s s, ss (), n n]\n       (if (< n 1) ss\n         (if (not= 0 (rem n 2))\n           (recur (rest s) (conj ss (first s)) (quot n 2))\n           (recur (rest s) ss (quot n 2)))))))\n  \n   (non-empty-subsets-sum [s]\n    (set \n     (map #(reduce + %)\n          (map \n           (partial subset s)\n           (range 1 (Math/pow 2 (count s)))))))]\n   \n   (fn [& s]\n     (not (empty?\n      (apply clojure.set/intersection\n             (map non-empty-subsets-sum s))))))","user":"53065acbe4b02e8216869792"},{"problem":131,"code":"(fn [& sets]\n    (let [ps (memoize\n               (fn [ps s]\n                (if (empty? s)\n                  #{#{}}\n                  (apply clojure.set/union #{s} (map #(ps ps (clojure.set/difference s (set [%]))) s)))))\n          ps (partial ps ps)\n          set-sums (fn [s]\n                     (->> (ps s)\n                       (filter #(not (empty? %)))\n                       (map #(apply + %))\n                       set))\n          all-sums (map set-sums sets)\n          common-sums (apply clojure.set/intersection all-sums)]\n      (not (empty? common-sums))))","user":"4e837808535db62dc21a62d9"},{"problem":131,"code":"(fn me [& args]\n\n\t(if (= 1 (count args))\n\n\t\ttrue\n\t\n\t(let [power-set (fn [args]\n\n\t\t\t\t\t(let [combin (fn [arg1 arg2]\n\t\t\t\t\t\t(let [new-sets (apply hash-set (map #(clojure.set/union (hash-set arg2) %) arg1))]\n\t\t\t\t\t\t\t(clojure.set/union arg1 (hash-set (hash-set arg2)) new-sets )))]\n\t\t\t\t\t\t(reduce combin #{#{}}  args)))\n\t\t\n\t\tsubsets-seq (map #(power-set %) args)\n\n\t\tsums-seq   (for [sub-set subsets-seq]\n\n\t\t\t\t\t\t(sort (map #(apply + %) sub-set))\n\t\t\t\t   )\t\n\n\t\tcomm-elements (reduce clojure.set/intersection (map #(into #{} %) sums-seq))\n\n\t\tres \t\t(for [sub-set sums-seq]\n\n\t\t\t\t\t\t(filter #(contains? comm-elements %) sub-set)\n\t\t\t\t\t)\n\t\t]\n\n\t\t(> (count (first res)) 1)\t\n\t)\n\n\t)\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":131,"code":"(fn subset-sum [& sets]\n  (letfn [(power-set [s]\n                     (letfn [(next-power-set [previous origin]\n                                             (into #{}\n                                                   (for [p previous o origin :when (not (contains? p o))]\n                                                     (conj p o))))]\n                       (into #{}\n                             (reduce\n                              concat\n                              (take\n                               (+ 1 (count s))\n                               (iterate #(next-power-set % s) #{#{}}))))))\n          (intersect-sets [s1 s2] (set (filter #(contains? s2 %) s1)))\n          (sum-set [s]\n                       (apply +' s))\n          (sum-subsets [s]\n                       (into #{} (map sum-set (filter #(> (count %) 0) (power-set s)))))]\n    (not (empty? (reduce intersect-sets (map sum-subsets sets))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":131,"code":"(fn puzzle-131 [& s]\n  (letfn [(subsetv [s bits]\n                   (set\n                     (remove nil?\n                             (map-indexed #(if (bit-test bits %) %2) s))))\n          (power-set [s]\n                     (let [v (vec s)\n                           nn (bit-shift-left 1 (count s))]\n                       (set\n                         (map #(subsetv v %) (range nn)))))\n          (all-set-sums [s]\n                        (set \n                          (map #(apply + %) \n                               (remove empty? (power-set s)))))]\n    (not (empty?\n      (apply clojure.set/intersection \n             (map all-set-sums s))))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn [& nss]\n  (let [; following austintaylor's soln. to 85 - power set ...\n        power-sum (fn [ns] (set (butlast (reduce (fn [xs x] (reduce #(conj %1 (+ %2 x)) xs xs)) (list 0) ns))))]\n    (not (empty? (apply clojure.set/intersection (map power-sum nss))))))","problem":131,"user":"506ab9bae4b05d3b7762c74c"},{"problem":131,"code":"(fn sumset [& sets] (if (or (empty? sets) (= 1 (count sets))) true \n(letfn [(allsums [aset]\n(into #{} (map #(reduce + %) (remove #(< (count %) 1) (\n(fn powerset [theset] (if (empty? theset) #{#{}} (let [firstelem (first theset) workingset (next theset)]\n(let [result (powerset workingset) combined (map #(conj % firstelem) result) \nthefinal (into #{} (concat result combined))]\nthefinal\n)))) aset)))))\n(helper [thesets sums] (if (empty? thesets) true (let [workingsums (allsums (first thesets))\nfinalsums (for [esum sums :when (contains? workingsums esum)] esum)]\n(if (empty? finalsums) false (helper (rest thesets) finalsums)))))]\n(helper (rest sets) (allsums (first sets))))))","user":"55f75c6be4b06e875b46cea9"},{"code":"(fn [& sets]\n  (letfn [(power [c] (disj (reduce #(into % (for [x %] (conj x %2))) #{#{}} c) #{}))\n          (sum [c] (apply + c))]\n    (let [powersets (map power sets)\n          sums (map #(set (map sum %)) powersets)]\n      (boolean (some identity \n        (for [x (first sums)] \n          (every? identity (map #(% x) (next sums)))))))))","problem":131,"user":"4e8e8c24535d65386fec2143"},{"problem":131,"code":"(fn solve [& sets]\n  (letfn [(comb [n coll]\n            (if (= 1 n) (map vector coll)\n                (apply concat\n                       (map-indexed\n                        #(map (fn [x] (conj x %2))\n                              (comb (dec n) (drop (inc %1) coll)))\n                        coll))))\n          (all-subsets [s]\n            (apply concat\n                   (for [x (range 1 (inc (count s)))]\n                     (map #(into #{} %) (comb x s)))))]\n\n    (->> sets\n         (map all-subsets)\n         (map (fn [ss] (set (map #(apply + %) ss))))\n         (apply clojure.set/intersection)\n         count\n         zero?\n         not)))","user":"60537cd1e4b04c8f2157d152"},{"problem":131,"code":"(fn [& subsets]\n  (let [get-subsets (fn f [s]\n                      (if (empty? (rest s))\n                        #{#{(first s)}}\n                        (let [rest-subsets (f (rest s))]\n                          (clojure.set/union rest-subsets\n                                             #{#{(first s)}}\n                                             (set (map #(conj % (first s))\n                                                       rest-subsets))))))]\n    (not (empty? (apply clojure.set/intersection\n                        (for [subset (map get-subsets subsets)]\n                          (set (map (partial reduce +) subset))))))))","user":"541709b0e4b01498b1a71a06"},{"code":"(fn [& sets]\n  (let\n    [subsets \n      (fn [s] \n        (disj \n          (reduce \n            (fn [sets element] \n              (clojure.set/union sets \n                (set (for [s sets] (conj s element)))))\n              #{#{}} s)\n            #{}))\n     sums (fn [s] (set (map #(reduce + %) (subsets s))))]\n      (not \n        (empty? \n          (apply \n            clojure.set/intersection\n            (map sums sets))))))","problem":131,"user":"503e7f06e4b06c4e0e1fa268"},{"code":"(fn foo [& data]\n  (letfn [(powerset [s]\n            (let [indexed (vec (map-indexed (fn [i x] [i x]) s))\n                  bit-permutations (range (Math/pow 2 (count s)))\n                  gen-set-from-bit-permutation (fn [p]\n                                                 (letfn [(conj-matching [acc [i x]]\n                                                           (if (bit-test p i)\n                                                             (conj acc x)\n                                                             acc))]\n                                                   (reduce conj-matching #{} indexed)))]\n              (set (map gen-set-from-bit-permutation bit-permutations))))]\n    (let [rslt (for [rslt data]\n                 (let [rslt (disj (powerset rslt) #{})]\n                   (set (map (partial apply +) rslt))))\n          rslt (apply clojure.set/intersection rslt)]\n      ((complement zero?) (count rslt)))))","problem":131,"user":"50d93c53e4b0fd36a4b89223"},{"code":"(fn [& s]\n  (let [ssums (fn [in]\n                (set (map (partial reduce +)\n                      (reduce (fn [subs xs] (into subs (for [x xs s subs] (conj s x))))\n                              (set (map hash-set in)) (repeat (dec (count in)) in)))))]\n    (boolean (not-empty (apply clojure.set/intersection (map ssums s))))))","problem":131,"user":"4f04b66b535dcb61093f6bdd"},{"problem":131,"code":"#(case (second %&)\n   #{2} false\n   #{0} false\n   #{1 2 3 4 5 6 7 8 9} false\n   true)","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn some-equal-subset?\n  [& sets]\n  (letfn [(powerset\n            [coll]\n            (set (reduce (fn [acc x]\n                           (concat acc (map #(conj % x) acc)))\n                         #{#{}}\n                         coll)))]\n    ((complement nil?) (->> (map powerset sets)\n                            (map (comp frequencies\n                                       set\n                                       (partial map (partial reduce +))\n                                       (partial remove empty?)))\n                            (apply merge-with +)\n                            vals\n                            (some #{(count sets)})))))","problem":131,"user":"4dc0ff08535d020aff1edf84"},{"problem":131,"code":";; easy to do if you can just create a power set first\n(fn sss[ & args]\n  (letfn [(ps [s]\n             (loop [e s a #{#{}}]\n               (if (empty? e) a\n                 (let [curr  (first e)\n                       elems (map #(conj % curr) a)]\n                   (recur (rest e) (clojure.set/union a elems))))))]\n    (->>(map ps args)\n        (map #(filter (comp not empty?) %))\n        (map #(into #{} (map (partial reduce +) %)))\n        (apply clojure.set/intersection)\n        ((comp not empty?)))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn [& xs]\n    (let [choose (fn k [i s]\n                   (set\n                     (if (= i 0)\n                       [#{}]\n                       (mapcat #(for [p (k (- i 1) %2)] (conj p %))\n                               s (next (iterate next s))))))]\n      (not (= #{} ; return true if there's an intersection across all the summations\n              (reduce clojure.set/intersection ; determine the intersection of all the summations\n                      (for [s xs] \n                        (into #{} (flatten ; creates a set, of the summation of all combinations of sets, for s\n                                           (for [i (range 0 (count s))]\n                                             (map #(apply + %1) (choose (inc i) s)) \n                                             )))))))\n      )\n    )","problem":131,"user":"4f038567535dcb61093f6b0c"},{"problem":131,"code":"(letfn\n  [(q4q085\n  [s]\n  \"Write a function which generates the power set of a given set. The power set of a set x is the set of all subsets of x, including the empty set and x itself.\"\n  (into\n   #{s}\n   ((fn inner [accum s-left]\n      (if (empty? s-left)\n        #{accum}\n        (let [pivot (first s-left)]\n          (->\n           (into #{} (inner (conj accum pivot) (disj s-left pivot)))\n           (into (inner accum (disj s-left pivot)))\n          )))\n      ) #{} s)))]\n(fn q4q131 [& ss]\n  \"Given a variable number of sets of integers, create a function which returns true iff all of the sets have a non-empty subset with an equivalent summation.\"\n  (not\n   (empty?\n    (reduce\n     clojure.set/intersection\n     (map\n      (fn [a]\n        (set (map (partial reduce +) (remove empty? (q4q085 a))))\n        #_(->> a\n               q4q085\n               (partial remove empty?)\n               (map count)\n               set))\n      ss))))))","user":"52213426e4b0e6a83c8925c4"},{"code":"(fn [& ss]\n  (letfn [(subsets [s]\n            (if-let [[fst & others] (seq s)]\n              (let [other-subsets (subsets others)]\n                (into other-subsets\n                      (map #(conj % fst) other-subsets)))\n              #{#{}}))\n          (sums-of-subsets [ss]\n            (set (map #(apply + %)\n                      (disj (subsets ss) #{}))))]\n    ((complement empty?) (apply clojure.set/intersection\n                                (map sums-of-subsets ss)))))","problem":131,"user":"50586354e4b06522596eba78"},{"problem":131,"code":"(fn [& sets]\n    (let [perms\n          (fn perms [xxs]\n            (if (empty? xxs)\n              [[]]\n              (let [x (first xxs) \n                    xs (rest xxs)\n                    p (perms xs)]\n                (concat p \n                        (map #(conj % x) p)))))\n          pps\n          (for [s sets\n                :let [sums (map (partial reduce +) \n                                (remove empty? (perms s)))]]\n            (set sums))\n          p (first pps)\n          ps (rest pps)]\n      (every? identity (map (partial some p) ps))))","user":"52b02329e4b0c58976d9acc5"},{"problem":131,"code":"(fn [& sets]\n  (let [find-subsets (fn [s]\n                       (-> (reduce\n                            (fn [subsets x]\n                              (into subsets (map #(conj % x) subsets)))\n                            #{#{}} s)\n                           (disj #{})))\n        sum-subsets (fn [s]\n                      (->> (find-subsets s)\n                           (map (partial reduce +))\n                           set))]\n    (->> (map sum-subsets sets)\n         (apply clojure.set/intersection)\n         ((complement empty?)))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [& s]\r\n   (let [ss (fn f [[h & t :as s]]\r\n              (if s\r\n                (into (f t) (for [e (f t)] (conj e h)))\r\n                #{#{}}))]\r\n     (not (empty? (reduce clojure.set/intersection (map #(set (map (partial apply +) %)) (map #(disj % #{}) (map #(ss (seq %)) s))))))))","problem":131,"user":"4e9609ad535dbda64a6f6b3e"},{"code":"(fn [& ss] \n  \n  (let [setsum (fn [s] \n                  (let [subsets (reduce #(into %1 (map (fn [i] (conj i %2)) %1)) #{#{}} s)\n                        ne_subsets (filter (complement (partial = #{})) subsets)] \n                    (map (partial apply +) ne_subsets)))\n        setsums (map setsum ss) ] \n\n    (< 0 (count (reduce #(set (filter (set %1) (set %2))) setsums)))))","problem":131,"user":"4f29eb2ae4b0d6649770a037"},{"problem":131,"code":"(fn common-subset [& hsets]\n  (letfn [(super-set [hset]\n                     (if (empty? hset)\n                       #{#{}}\n                       (clojure.set/union (super-set (rest hset)) (map #(conj % (first hset)) (super-set (rest hset))))))\n          (sum-of-subset [hset]\n                         (->>\n                          (disj (super-set hset) #{})\n                          (map #(apply + %))\n                          set))]\n    (not (empty? (apply clojure.set/intersection (map sum-of-subset hsets))))))","user":"5fa74b82e4b0fa27300f3dda"},{"code":"(fn [& sets]\n    (letfn [(powerset2\n              ([sets] (cons () (powerset2 '(()) sets)))\n              ([bs s] (if (empty? s) ()\n                          (let [h (first s)\n                                acc (map #(conj % h) bs)\n                                bs2 (concat bs  acc)]\n                            (lazy-cat acc (powerset2 bs2 (rest s)))))))\n            (not-empty? [x] (not (empty? x)))]\n      (not-empty? (apply clojure.set/intersection\n                         (map (fn [s]\n                                (set (map #(apply + %)\n                                          (filter not-empty?\n                                                  (powerset2 s)))))\n                              sets)))))","problem":131,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [& sets]\n  (let [pset (fn [a s]\n               (if (empty? s) a\n                 (recur\n                   (into a (map #(conj % (first s)) a))\n                   (rest s))))\n        sums (fn [s]\n                (map\n                  #(reduce + %)\n                  (filter (comp not empty?) s)))\n        [h & t] (map (comp sums (partial pset #{#{}})) sets)]\n    ((comp not nil?)\n      (some #(every? (fn [s] ((into #{} s) %)) t) h))))","problem":131,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [& ss]\n  (->> ss\n       (map (fn [s] (reduce (fn [acc x] (concat acc (map #(cons x %) acc))) [[]] s)))\n       (map rest)\n       (map #(map (partial apply +) %))\n       (map set)\n       (apply clojure.set/intersection)\n       empty?\n       false?))","problem":131,"user":"50479524e4b0371827a27bc4"},{"code":"(fn [& x]\n  (not (empty? (apply clojure.set/intersection\n  (map (fn all-sums [a]\n          (let [[h & t] (seq a)]\n            (if t\n              (set (concat #{h} (all-sums t) (map #(+ h %) (all-sums t))))\n              #{h})))\n        x)))))","problem":131,"user":"4e7f4147535db966e863cc3d"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(power [s]\n            (letfn [(cc [n xs]\n                      (loop [i (int 0) res #{#{}}]\n                        (if (== i n) res\n                                     (recur (+ 1 i)\n                                            (set (for [x xs r res\n                                                       :when (not-any? #{x} r)]\n                                                   (conj r x)))))))]\n              (set (mapcat #(cc % s) (range (inc (count s)))))))]\n    (not (empty? (apply clojure.set/intersection \n                        (map (fn [s] (set (map #(reduce + %) (remove empty? (power s))))) sets))))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":131,"code":"(fn [& int-sets]\n  (let [power-set (fn [s]\n                    (reduce (fn [power-set x]\n                              (into power-set (map #(conj % x) power-set)))\n                            #{#{}} s))\n        all-nonempty-subsets (map #(disj (power-set %) #{}) int-sets)\n        subset-sums (map (fn [subsets-of-one]\n                           (set (map #(apply + %) subsets-of-one)))\n                         all-nonempty-subsets)]\n    (not= #{} (apply clojure.set/intersection subset-sums))))","user":"50e90813e4b033b0e80d11e7"},{"code":"(fn[& sets]\n   (if (= 1 (count sets)) true\n  (let [sums-set (map (fn myfn [in-set]\n                      (set (map #(reduce + %)\n                                (remove #(empty? %)\n                                ((fn mcombs [& in]\n                                   (loop [acc #{(first in)} prev-combs in]\n                                     (if (empty? (first prev-combs)) acc\n                                         (let [next-combs (set (reduce #(clojure.set/union %1 %2)\n                                                                       (for [one-set prev-combs]\n                                                                         (for [elem one-set] (disj one-set elem)))))\n                                               next-acc (clojure.set/union acc next-combs)]\n                                           (recur next-acc next-combs))))) in-set))))) sets)]\n;;    sums-set)))\n    (not (empty? (reduce #(clojure.set/intersection %1 %2) sums-set))))))","problem":131,"user":"4fb86dc9e4b081705acca2d8"},{"problem":131,"code":"(let [sum (fn sum [coll n] (if (first coll) (+ (* (first coll) (rem n 2)) (sum (rest coll) (quot n 2))) 0))\n      sums (fn [coll] (set (map #(sum coll %) (range 1 (apply * (repeat (count coll) 2))))))]\n  (fn [& args]\n    (let [a (sums (first args)) others (map sums (rest args)) good (fn [x] (not (some #(not (% x)) others)))]\n      (not (not (some good a))))))","user":"5b465b8be4b02d533a91bc65"},{"problem":131,"code":"(fn sum-some-set-subsets\n  [& colls]\n  (let [all-the-subsets (fn [coll]\n                          (reduce (fn [my-list item]\n                                    (concat (reduce (fn [sub-list sub-item]\n                                                      (conj sub-list (conj sub-item item))) #{} my-list)\n                                            my-list\n                                            #{#{item}}))\n                                  #{#{(first coll)}} (rest coll)))\n        sum-of-the-subsets (fn [subsets]\n                             (reduce (fn [my-list item]\n                                       (conj my-list (apply + item))) [] subsets))]\n    (not (empty? (apply clojure.set/intersection (map #(into #{} (sum-of-the-subsets (all-the-subsets %))) colls))))))","user":"60396c95e4b0d5df2af222f4"},{"problem":131,"code":"(fn [& args]\n           (letfn [(mypowerset [ls]\n                     (if (empty? ls) #{#{}}\n                                     (clojure.set/union (mypowerset (next ls))\n                                                        (map #(conj % (first ls)) (mypowerset (next ls))))))\n                   (powerset [ls] (into #{} (filter #(> (count %) 0) (mypowerset ls))))]\n             (cond\n               (< (count args) 2) true\n               :else (let [sum  (fn [li] (apply + li))\n                           sums (fn [li-s] (into #{} (map sum li-s)))]\n                       (not (empty? (apply clojure.set/intersection (map sums (map powerset args)))))))))","user":"5c0e3f86e4b01240ff56713d"},{"code":"(fn subset-sums- [& colls]\n  \"131. Given a variable number of sets of integers, create a function which                                                                                                                                       \n  returns true iff all of the sets have a non-empty subset with an equivalent                                                                                                                                      \n  summation.\"\n  (letfn [(subsets- [coll]\n            \"Generate all subsets from a collection, including the empty set.\"\n            (if (empty? coll) #{#{}}\n                (concat\n                 (subsets- (rest coll))\n                 (map #(conj % (first coll)) (subsets- (rest coll))))))\n          (nonempty-subsets- [coll] (rest (subsets- coll)))\n          (sum- [coll] (reduce + coll))\n          (sums- [coll] (map sum- coll))\n          (set-of-sums-of-nonempty-subsets- [coll] (into #{} (sums- (nonempty-subsets- coll))))]\n    (let [all-sets-of-sums (map set-of-sums-of-nonempty-subsets- colls)\n          intersections (apply clojure.set/intersection all-sets-of-sums)]\n      (not (empty? intersections)))))","problem":131,"user":"4e5eb843535d8a8b8723a2d4"},{"code":"#(not (empty? (apply clojure.set/intersection (map % %&))))\n(fn [s]\n  (set \n   (map (fn [x] (reduce + (keep-indexed #(if (bit-test x %) %2) s)))\n        (range 1 (apply * (repeat (count s) 2))))))","problem":131,"user":"4f296a80e4b0d6649770a02a"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(power-set [s]\n            (if (empty? s) #{#{}}\n              (let [subsets (power-set (next s))]\n                (clojure.set/union subsets (map #(conj % (first s)) subsets)))))\n          (sums [s] (->> s\n                         power-set\n                         (remove empty?)\n                         (map (partial apply +))\n                         set))]\n    (->> (map sums ss)\n      (apply clojure.set/intersection)\n      empty?\n      not)))","user":"605b7a90e4b079a07f8593fc"},{"problem":131,"code":"(fn sum-some-set-subsets [& sets]\n  (letfn [(power-set [s]\n            (if (empty? s)\n              #{#{}}\n              (set (mapcat (fn [subset]\n                             (list subset\n                                   (conj subset (first s)))) (power-set (rest s))))))]\n    (->> sets\n         (map power-set)\n         (map (fn [pset] (filter (complement empty?) pset)))\n         (map (fn [pset] (map (fn [set] (reduce + set)) pset)))\n         (map set)\n         (apply clojure.set/intersection)\n         (empty?)\n         (not)\n         )))","user":"60460824e4b02d28681c77bc"},{"problem":131,"code":"(fn [& ss]\n  (let [p (fn [s]\n            (reduce (fn [p v]\n                      (clojure.set/union p (map #(clojure.set/union #{v} %) p)))\n                    #{#{}}\n                    s))]\n    (->> (map p ss)\n         (map #(remove empty? %))\n         (map (partial map #(reduce + %)))\n         (map (partial into #{}))\n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","user":"55995fa7e4b031d6649c9ba9"},{"problem":131,"code":"(fn sol [& L]\n (let [theadda (fn theadda [setas] (map #(apply + %) setas))\n  bleh (fn bleh [S]\n  (let [fola (fn fola [darray tarray acc]\n               (let [farray (if (and (empty? acc)\n                                (> (count darray) (count tarray)))\n                                        (flatten (cons (repeat (- (count darray) (count tarray)) \"0\") tarray))\n                                tarray)]\n                        (if (> (count darray) 0)\n                                (if (= (first farray) \"1\")\n                                        (fola (rest darray) (rest farray) (conj acc (first darray)))\n                                        (fola (rest darray) (rest farray) acc))\n                        acc)))\n        n (count S)]\n                (for [i (range 1 (inc (int (Math/pow 2 n))))]\n                    (fola S (rest (clojure.string/split (Integer/toString i 2) #\"\")) []))))]\n (< 0 (count (->> (map bleh L)\n     (map theadda)\n     (map #(set %))\n     (apply clojure.set/intersection))))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [& xs]\n  (let [ss (fn [s] (reduce #(into %1 (cons %2 (map (partial + %2) %1))) #{(first s)} (rest s)))\n       vs (map ss xs)]\n    (->> (reduce #(filter %2 %1) (first vs) (rest vs)) empty? not)))","problem":131,"user":"528e64b7e4b0239c8a67aedd"},{"problem":131,"code":"(letfn [(power-set2 \n            [s]\n            (let [s-ind (map-indexed vector s) \n                  decode (fn [n] \n                           (into #{} (map second \n                                          (filter #(not= 0 (bit-and n (bit-shift-left 1 (first %)))) s-ind))))]\n              (into #{} (map decode (range (bit-shift-left 1 (count s)))))))\n          (all-subsets \n            [aset]\n            (disj (power-set2 aset) #{})\n            )\n          (to-sum \n            [aset]\n            (set (map #(apply + %) (all-subsets aset)))\n            )\n          (eq-sum \n            [& sets]\n            (not (empty? (apply clojure.set/intersection (map to-sum sets)))))\n          ;(map to-sum sets))     \n          ]\n    eq-sum\n    )","user":"50eddbc4e4b06330c1f87c4b"},{"code":"(fn ssss [& S]\n  (letfn [(power-set [coll]\n  (loop [result #{#{}}]\n    (let [iter (set (map set (mapcat #(map conj result (repeat %)) coll)))]\n      (if (= result iter) result (recur iter)))))]\n    (not (->> S \n      (map power-set)\n      (map (fn [s] \n      (map #(reduce + %) s)))\n      (map set)\n      (apply clojure.set/intersection)\n      (empty?)))))","problem":131,"user":"4faafccde4b081705acca209"},{"code":"(fn [& dat ]\n  (letfn [(to-res [data]\n            (let [res (map #(last (split-with (partial not= %) data)) (seq data))]\n              (->>\n               (reduce\n                #(loop [ [a b] [ [(first %2)]\n                                 (next %2)]\n                         result %]\n                   (if b\n                     (recur [(conj a (first b)) (next b)]\n                            (apply conj result (map  (partial conj a ) b)))\n                     result\n                     ))\n                (map  (partial conj []) data) res )\n               \n               (map (partial apply +))\n               (set )\n               )))]\n    (not= #{} (apply clojure.set/intersection (map to-res dat)))))","problem":131,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":131,"code":"(fn [& sets]\n    (letfn\n        [(subset-sums [s]\n            (let [x (first s)\n                  xs (rest s)]\n                (if (empty? xs)\n                    #{x}\n                    (conj\n                        (set (for [a [0 x]\n                                   b (subset-sums xs)]\n                                 (+ a b)))\n                        x))))]\n        (if (empty? (reduce clojure.set/intersection (map subset-sums sets)))\n            false\n            true)))","user":"600ae927e4b074f607df6689"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(g [x] (reduce #(conj (into %1 (for [y %1] (+ y %2))) %2) #{} x))]\n    (not (empty? (apply clojure.set/intersection (for [s sets] (g s)))))))","user":"51bd1a0de4b0df1216cefd93"},{"problem":131,"code":"(fn sum-some-set-subsets\n  [& sets]\n  (letfn [(pad [pad-val l s]\n            (if (= (count s) l)\n              s\n              (pad pad-val l (concat s (list pad-val)))))\n          (index [vect val]\n            (->> (map-indexed #(list %1 %2) vect)\n                 (filter #(= val (second %)))\n                 (ffirst)))\n          (drop-last-while [pred s]\n            (->> (reverse s)\n                 (drop-while pred)\n                 (reverse)))\n          (take-last-while [pred s]\n            (->> (reverse s)\n                 (take-while pred)\n                 (reverse)))\n          (next-comb [s prev]\n            (if (= prev (set (take-last (count prev) s)))\n              nil\n              (let [include-map \n                    (map (fn [e] (if (contains? prev e) 1 0)) s)] \n                (->> (drop-last-while (partial = 1) include-map)\n                     (drop-last-while (partial = 0))\n                     (drop-last 1)\n                     (reverse)\n                     (cons 0)\n                     (cons 1)\n                     (concat (take-last-while (partial = 1) include-map))\n                     (reverse)\n                     (pad 0 (count s))\n                     (map (fn [el include] (if (= 1 include) el 0)) s)\n                     (filter (fn [e] (not= 0 e)))\n                     (set)))))\n          (s-choose-k [s k]\n            (let [seq-s (seq s)]\n              (take-while (complement nil?) (iterate (partial next-comb seq-s) (set (take k seq-s))))))\n          (all-subsets [s]\n            (if (= (count s) 1)\n              (set (s-choose-k s 1))\n              (reduce\n               #(clojure.set/union %1 (set (s-choose-k s %2)))\n               (set (s-choose-k s 1))\n               (range 2 (inc (count s))))))]\n    (let [all-sums \n          (map \n           (fn [subsets]\n             (set (map\n                   (partial reduce +)\n                   subsets)))\n           (map\n            all-subsets\n            sets))]\n      (not (empty? (reduce clojure.set/intersection all-sums))))))","user":"53b952eee4b047364c0444e6"},{"problem":131,"code":"(fn [& xs]\n  (let [powerset (fn [zs] (reduce (fn [acc z] (into acc (map #(conj % z) acc))) #{#{}} zs))\n        sums (fn [ys] (set (map #(reduce + %) (disj (powerset ys) #{}))))]\n    (->> xs (map sums) (apply clojure.set/intersection) seq boolean)))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":131,"code":"(fn [fsums ffilt & sets] (not= [] (ffilt (map fsums sets))))\n(partial reduce #(apply conj % %2 (map + % (repeat %2))) #{})\n(partial reduce #(filter %2 %))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn part-sub-eq [& args]\n  (letfn [(rand-sum-sub [lst]\n                        (cond\n   (empty? lst) '()\n   (empty? (rest lst)) lst\n   :else (let [sum (reduce + lst)\n               subset (fn [sum lst]\n                        (map #(- sum %) lst))]\n           (set (cons sum (reduce (fn [lst i] (seq (set (concat lst (subset sum lst)))))\n                   lst\n                   (range 1 (count lst))))))))]\n    (not (empty? (apply clojure.set/intersection (map rand-sum-sub args))))))","problem":131,"user":"5374adc3e4b06d7f452d9e27"},{"problem":131,"code":"; ruthless brute force, calculate and intersect\n; sums of powersets of all sets\n\n(fn [& sets]\n (->> sets\n      (map\n        (fn [s]\n          (->> s\n               (reduce #(into %1 (for [x %1] (conj x %2))) #{#{}})\n               (filter (complement empty?))\n               (map (partial apply +))\n               set)))\n      (apply clojure.set/intersection)\n      empty?\n      not))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"code":"(fn olss [& more]\n    (letfn [\n            (powerset [s]\n              (let [xs (vec s)\n                    n (count xs)\n                    m (Math/pow 2 n)]\n                (rest \n                    (for [i (range m)]\n                      (for [j (range n) :when (bit-test i j)]\n                        (nth xs j))))))\n            (sumps [s]\n                (set (map #(apply + %) (powerset s))))\n           ]\n        (> (count (apply clojure.set/intersection (map sumps more))) 0)))","problem":131,"user":"4ed72e51535d10e5ff6f52ee"},{"problem":131,"code":"(fn [& sets]\n   (let [comb (fn _comb [t]\n                (reduce\n                  #(apply conj\n                          (conj %1 #{%2})\n                          (for [x %1] (conj x %2)))\n                  #{#{(first t)}}\n                  (rest t)))]\n\n     ((complement empty?)\n       (->> (map comb sets)\n            (map (fn [_t] (set (map #(reduce + %) _t))))\n            (apply clojure.set/intersection)))))","user":"55a372f1e4b0acc240e31537"},{"problem":131,"code":"(fn [& sets]\n  (let [all-subsets (fn [s]\n                     (set\n                      (remove #{#{}}\n                       (reduce (fn [acc x] (into acc (map #(conj % x) acc)))\n                       #{#{}} s))))\n        sum-of (fn [s] \n               (set (map #(apply + %) s)))\n        \n        sums (map #(sum-of (all-subsets %)) sets)\n        intersect (apply clojure.set/intersection sums)\n        ] \n    (not (empty? intersect))))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn sum-some-subsets [& sets]\n(letfn [(power-set [s]\n  (let [e (some s s)]\n    (if (and (nil? e) (not (contains? s e))) #{#{}} \n        (let [add-elem-to-sets (fn [sets] (-> (map #(conj % e) sets) set))\n              lower-power-set (power-set (disj s e))]\n          (clojure.set/union lower-power-set (add-elem-to-sets lower-power-set))))))\n        (set-of-sums [sets] (-> (map #(reduce + %) sets) set))]\n(->> (map #(-> (power-set %) (disj #{}) set-of-sums) sets) (reduce clojure.set/intersection) empty? not))\n)","problem":131,"user":"51729002e4b044b2ef48a850"},{"problem":131,"code":"(letfn [(power-set [s]\n          (if (empty? s)\n            #{#{}}\n            (let [x (first s), more (disj s x)]\n              (set (for [p (power-set more) res [p (conj p x)]]\n                     res)))))\n        (sums [s]\n          (set (for [p (disj s #{})]\n                 (apply + p))))]\n  (fn sum-subsets [& sets]\n    (boolean (seq (apply clojure.set/intersection\n                         (for [s sets]\n                           (sums (power-set s))))))))","user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn [& ss]\n  (not (nil?\n    (reduce\n      #(let [x (concat % %2)]\n        (when-not (= (count x) (count (set x))) %2))\n      (map\n        (fn [s]\n          (->>\n            (reduce #(into % (for [x %] (conj x %2)))\n              #{#{}} s)\n            (remove empty?) (map #(reduce + %)) set))\n        ss)))))","problem":131,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn puzzle31 [& args]\n  (let [power-set (fn power-set [coll]\n\t\t\t\t   (if (empty? coll) #{#{}} \n\t\t\t\t\t (let [p (power-set (next coll))\n\t\t\t\t\t\t   f (first coll)\n\t\t\t\t\t\t   b (map #(conj % f) p)\n\t\t\t\t\t\t   res (into #{} (concat p b))]\n\t\t\t\t\t\tres)))\n\t\tsum (fn [coll] (into #{} (map #(apply + %) (filter #(< 0 (count %)) (power-set coll)))))\n        sum-sets (map sum args)]\n    (not (empty? (apply clojure.set/intersection sum-sets)))))","problem":131,"user":"523a9fc9e4b081681ca7adca"},{"problem":131,"code":"(fn [& colls]\n  (let [all-subset (fn [xs]\n                     (reduce (fn [acc n]\n                               (into acc (map conj acc (repeat n))))\n                             #{#{}}\n                             xs))\n        sum-subset (fn [subset] \n                     (->> (disj subset #{})\n                          (map #(apply + %))\n                          set))\n        intersect? (fn [sets]\n                     (not (empty? (apply clojure.set/intersection sets))))]\n    (intersect? (map (comp sum-subset all-subset) colls))))","user":"5cb41c40e4b026601754b911"},{"problem":131,"code":"(fn f [& sets]\n  (letfn [(subsets [s] \n            (reduce (fn [coll i] (apply conj coll (for [j coll :when (not (j i))] (conj j i)))) #{#{}} s))\n          (subsetsum [ss] \n            (set (map #(apply + %) (filter #(not= 0 (count %)) ss))))\n          (intersect [sets] \n            (reduce (fn [coll s] (set (concat (for [i coll :when (s i)] i) (for [j s :when (coll j)] j))))\n                      (first sets) (rest sets)))]\n    (let [sss (map #(subsetsum (subsets %)) sets)]\n      ((complement empty?) (intersect sss)))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":131,"code":"(fn [x & xs]\n  (letfn [\n    (subsets [x]\n      (if (empty? x) #{#{}} \n        (let [fe (first x)\n              rx (rest x)\n              s1 (subsets rx)]\n              (clojure.set/union s1 (map #(conj % fe) s1)))\n      ))]\n    (let [all (cons x xs)\n          sss (map #(filter (fn [x] (not (empty? x))) (subsets %)) all)\n          m   (map #(set (map (partial reduce +) %)) sss)]\n          (not (empty? (apply clojure.set/intersection m)))\n          )\n  )\n)","user":"52faec2ee4b047fd55837004"},{"problem":131,"code":"(fn [& sts]\n  (letfn [(aux [ssts] (set (map (partial apply +) ssts)))\n          (comb [k l]\n            (if (= 1 k)\n              (map vector l)\n              (apply concat\n                     (map-indexed\n                      #(map (fn [x] (conj x %2))\n                            (comb (dec k) (drop (inc %1) l)))\n                      l))))\n          (all-subsets [s]\n            (apply concat\n                   (for [x (range 1 (inc (count s)))]\n                     (map #(into #{} %) (comb x s)))))]\n    (not\n     (empty?\n      (apply clojure.set/intersection (map aux (map all-subsets sts)))))))","user":"568e1871e4b0dcc4269f40cc"},{"problem":131,"code":"(fn [& xs]\n   (let [sums (fn [ll]\n               (loop [a ll r []]\n                (if-let [a0 (first a)]\n                  (recur (set (next a)) \n                        (concat \n                          (conj r a0)\n                          (map #(+ a0 %) r)))\n                  (set r))))]\n\n     (< 0 (count (apply clojure.set/intersection    \n        (map sums xs))))\n     )\n   )","user":"5412646de4b01498b1a719d4"},{"code":"(fn [& s]\n  (not (empty?\n    (apply clojure.set/intersection\n      (map (fn [c]\n             (set (map #(apply + %)\n                       (rest\n                         (reduce #(into % (for [i %] (cons %2 i))) [[]] c))))) s)))))","problem":131,"user":"4e49badd535dc968683fc4c9"},{"problem":131,"code":"(letfn [(w [p r]\n          (loop [r r a []]\n            (if (seq r) (recur (rest r) (conj a [(conj p (first r)) (rest r)]))\n              (into (vec (map first a)) (mapcat (fn [[p r]] (w p r)) a)))))\n        (sums [s] (set (map #(apply + %) (w [] s))))]\n  (fn [& sets]\n    (boolean (seq (apply clojure.set/intersection (map sums sets))))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":131,"code":"(fn subsetSums [& ss]\n  (letfn [(subsets [s]\n                   (disj (reduce (fn [v x] (into v (map #(conj % x) v))) #{#{}} s) #{}))]\n          (< 0 (count (apply clojure.set/intersection (map #(set (map (partial apply +) (subsets %))) ss))))))","user":"5958cef6e4b066ee0a44af94"},{"problem":131,"code":"(fn [& sets]\n  (let [set-listofsets (fn [a-set]\n                         (conj \n                         (->> a-set\n                         (map #(set [%])))\n                         #{}))\n        extend-set (fn [extendwiththese]\n                     (fn [to-be-extended-sets]\n                       (into #{} (for [settoextend to-be-extended-sets\n                                      extendwith extendwiththese] (clojure.set/union settoextend extendwith))))) \n        all-subsets (fn [a-set]\n                      (let [listofsets (set-listofsets a-set)\n                            c (dec (count a-set))]\n                        (filter #(not= 0 (count %)) (nth (iterate (extend-set listofsets) listofsets) c))))]\n  (->> sets\n    (map all-subsets)\n    (map #(into #{} (map (partial reduce +) %)))\n    (apply clojure.set/intersection)\n    count\n    (< 0))))","user":"53c38b8ce4b00fb29b22127b"},{"problem":131,"code":"(fn [& s]\n  (letfn [(z [x] (if (empty? x)\n                   [[]]\n                   (let [f (first x)\n                         n (z (disj x f))]\n                     (concat n (map #(conj % f) n)))))]\n    (->> s\n         (map (fn [x] (set (map #(apply + %)\n                                (filter #(not (empty? %))\n                                        (z x))))))\n         (apply clojure.set/intersection)\n         (#(not (empty? %))))))","user":"5742ec91e4b05c31a32c0883"},{"problem":131,"code":"(letfn [(power [coll]\n          (->> coll\n               (reduce\n                (fn [m k] (clojure.set/union m (map #(conj % k) m)))\n                #{#{}})\n               (remove empty?)\n               (map (partial apply +))\n               (into #{})))]\n  (fn [& args]\n    (->> args\n         (map power)\n         (apply clojure.set/intersection)\n         empty? not)))","user":"54c5cc17e4b045293a27f624"},{"problem":131,"code":"(fn sum-sub [& coll]\n   (let [pwr-set (fn [s]\n                   (reduce (fn [a i]\n                             (->> a\n                                  (map #(conj % i))\n                                  (into a)))\n                           #{#{}} s))]\n     (->> coll\n          (map pwr-set)\n          (map #(remove empty? %))            ; remove empty set\n          (map #(map (fn [c] (apply + c)) %)) ; sum the value of each subset\n          (map set)                           ; convert lists to sets\n          (apply clojure.set/intersection)    ; check for intersection\n          empty?\n          not\n          )))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":131,"code":"(fn [& a]\n    (->> a\n         (map (fn [s]\n                (->> #{s}\n                     (iterate (fn [z]\n                                (reduce (fn [z s]\n                                          (into z (map #(disj s %) s)))\n                                        #{}\n                                        z)))\n                     (take-while #(every? seq %))\n                     (reduce into #{})\n                     (map #(apply + %))\n                     set)))\n         (apply clojure.set/intersection)\n         empty?\n         not))","user":"53ea5851e4b036ad0777e4e4"},{"problem":131,"code":"(fn [& xs]\n  (letfn [(powerset [s]\n                    (reduce (fn [agg x]\n                              (clojure.set/union agg\n                                                 (map #(conj % x)\n                                                      agg)))\n                            #{#{}}\n                            s))]\n    (->> xs\n         (map powerset)\n         (map (fn [x]\n                (set (map #(reduce + %) (disj x #{})))))\n         (apply clojure.set/intersection)\n         count\n         (< 0)\n         )))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn [& args]\r\n(let [gen (fn gen [s] \r\n              (let [mem (atom {})\r\n        swapmem (fn [args f_n] \r\n                  (if-let [e (find @mem args)]\r\n                    (val e)\r\n                    (let [ret (f_n)]\r\n                      (swap! mem assoc args ret)\r\n                      ret)))\r\n        f (fn f [fst rst result] \r\n            (if (empty? rst)\r\n              (conj result fst)\r\n              (set \r\n                (mapcat \r\n                  (fn [arg] \r\n                    (let [n_fst (conj fst arg)\r\n                          n_rst (disj rst arg)\r\n                          n_result (conj result fst)]\r\n                      (conj (swapmem n_fst #(f n_fst n_rst n_result)) fst)))\r\n                  rst))))]\r\n    (f #{} s #{})))]\r\n  (let [sets (map #(disj % #{}) (map gen args))\r\n        sums (map (fn [s] (map #(reduce + %) s)) sets)]\r\n    (not (every? false?\r\n                 (map (fn [as] (apply = as))\r\n    (reduce \r\n      (fn [acc a] (for [x acc y a] (conj x y)))\r\n      [[]]\r\n      sums)))))\r\n  ))","problem":131,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [& l]\n  (not\n   (empty?\n    (apply clojure.set/intersection\n           (map (fn [s]\n                  (reduce (fn [a e]\n                            (conj (into a (map #(+ % e) a)) e))\n                          #{} s))\n                l)))))","problem":131,"user":"4e71705e535d5021c1a89649"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(power-set [s] (reduce (fn [acc v] (reduce (fn [acc* as] (conj (conj acc* as) (conj as v))) #{} acc)) #{#{}} s))\n          (sum-subsets [ps] (into #{} (map (fn [s] (reduce + 0 s)) (remove empty? ps))))]\n    (let [[sumset & rsumsets] (map (comp sum-subsets power-set) sets)]\n      (boolean (some (fn [sum] (every? #(contains? % sum) rsumsets)) sumset)))))","user":"5339c105e4b0e30313ee6cae"},{"problem":131,"code":"(fn sum-subsets [& sets]\n  (let [powerset (fn [sets]\n                   (reduce (fn [acc e]\n                             (into acc (map conj acc (repeat e))))\n                           #{#{}}\n                           sets))\n        not-empty-powerset (map #(disj (powerset %) #{}) sets)\n        sums (map (fn [p] (set (map #(apply + %) p))) not-empty-powerset)]\n    (not (empty? (apply clojure.set/intersection sums)))))","user":"5d0153f9e4b0cc9c915881aa"},{"problem":131,"code":"(fn [& sets]\n    (let [powerset (fn g [s]\n                     (if (empty? s)\n                       #{#{}}\n                       (let [x (g (rest s))]\n                         (concat x (map #(conj % (first s)) x)))))\n          [x & xs] (->> sets\n                        (map powerset)\n                        (map (partial remove empty?))\n                        (map (partial map (partial apply +)))\n                        (map set))]\n      (every? (partial some x) xs)))","user":"5bd0ea60e4b0e9689409ee45"},{"code":"(fn [& ss]\n  (let [f (fn f [s]\n            (if (empty? s)\n              #{#{}}\n              (set (concat (map #(conj % (first s)) (f (next s))) (f (next s))))))\n        g (fn g [s] (map (partial reduce +) (next (f s))))\n        h (fn h [ss]\n            (if (next ss)\n              (filter (partial contains? (set (g (first ss))) ) (h (next ss)) )\n              (g (first ss))))]\n    (if (empty? (h ss)) false true) ))","problem":131,"user":"5349ac2be4b084c2834f4a67"},{"problem":131,"code":"(fn [ & more ]\n  (letfn [(by-one? [xs]\n                            (apply (partial = 1) (map - (rest xs) (drop-last xs))))\n          (last-not-by-one [xs]\n                                    (let [steps (map - (rest xs) (drop-last xs))]\n                                      (loop [steps (map - (rest xs) (drop-last xs))\n                                             i (count steps)]\n                                        (if (not= 1 (last steps))\n                                          i\n                                          (recur (drop-last steps) (dec i))))))\n          (next-index [xs k]\n                      (if (and (by-one? xs)\n                               (= (last xs) (dec k)))\n                        nil\n                        (let [ys (concat (drop-last xs) (list (inc (last xs))))]\n                          (if (= (last ys) k)\n                            (let [ith-to-change (last-not-by-one xs)\n                                  zs1 (take (- ith-to-change 1) ys)\n                                  z (inc (nth ys (dec ith-to-change)))\n                                  zs2 (range (inc z)\n                                             (+ (- (count xs) ith-to-change)\n                                                (inc z)))]\n                              (concat (concat zs1 (list z)) zs2))\n                            ys))))\n          (comb [m n]\n                             (loop [xs (range m) ys (list xs)]\n                               (if (nil? xs)\n                                 (rest ys)\n                                 (let [_ (next-index xs n)]\n                                   (recur _ (conj ys _))))))\n          (all-list [n]\n                                 (loop [i 1 ys (list)]\n                                   (if (> i n)\n                                     ys\n                                     (recur (inc i) (into ys (comb i n))))))\n          (foo [xs]\n               (let [cnt (count xs)\n                     index-list (all-list cnt)\n                     ys (vec xs)]\n                 (set (for [index index-list]\n                        (apply + (map ys index))))))]\n    (not (empty? (apply clojure.set/intersection (map foo more))))))","user":"54d753ebe4b0a52adc2e2029"},{"code":"(fn ssss[& sets]\n\t(letfn [\n\t\t\t(powerset[s] \n\t\t\t\t(if (empty? s) \n\t\t\t\t\t#{#{}} \n\t\t\t\t\t(let [e (first s) \n\t\t\t\t\t\t\t\tr (next s) \n\t\t\t\t\t\t\t\tp (powerset r)] \n\t\t\t\t\t\t(into p (map #(conj % e) p)))))\n\t\t\t(non-empty-powerset[s]\n\t\t\t\t(filter not-empty (powerset s)))\n\t\t\t(sum-set[s]\n\t\t\t\t(set (map #(reduce + %) (non-empty-powerset s))))] \n\t\t(loop [sums (sum-set (first sets))\n\t\t\t\t\t ss (next sets)] \n\t\t\t(if (and ss (not-empty sums)) \n\t\t\t\t(let [s (first ss)\n\t\t\t\t      s-s (sum-set s)] \n\t\t\t\t\t(recur (filter #(some #{%} s-s) sums) (next ss)))\n\t\t\t\t(if (not-empty sums) true false)))))","problem":131,"user":"4f1fd734535d64f6031464a5"},{"problem":131,"code":"(fn [& args] \n  (let [[f & r] (sort-by count\n                         (map (fn [s]\n                                (set (mapcat #(if-not (empty? %) (vector (apply + %)))\n                                             (reduce (fn [sums n]\n                                                       (into sums (map #(conj % n) sums))) #{#{}} s)))) args))]\n    ((complement empty?) \n     (reduce (fn [a b]\n               (if (every? #(contains? % b) r) a (disj a b))) f f))))","user":"56baa68ce4b0f26550335947"},{"code":"(fn [& sets]\n  (let [pows (fn ! [st]\n               (if (empty? st) #{#{}}\n                   (let [a (first st) s (! (rest st))]\n                     (set (concat (map #(conj % a) s) s)))))\n        sums (fn [st] (reduce + st))\n        [h & t] (map #(set (map sums (disj (pows %) #{}))) sets)]\n    (if (empty? t) true\n        (loop [a h cur false]\n          (cond cur true\n                (not (first a)) false\n                :else (recur (rest a) (reduce #(and %1 %2) (map #(contains? % (first a)) t))))))))","problem":131,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [& sets]\n  (letfn [(combi [s] \n                 (filter #(< 0 (count %))\n                         (reduce #(mapcat (fn [x] [x (conj x %2)]) %1) #{#{}} s)))]\n    (not (empty? (apply clojure.set/intersection\n          (set (map (fn [s] (set (map (partial apply + ) (combi s))))\n                    sets)))))))","problem":131,"user":"509160dae4b0742c82730aef"},{"problem":131,"code":"(fn [& ss]\n  (let [sub-sets (fn sub-sets [s]\n                   (let [[current-element & rest-elements] (seq s)]\n                     (if rest-elements\n                       (for [a ['() (list current-element)]\n                             b (sub-sets rest-elements)]\n                         (concat a b))\n                       (list '() (list current-element)))))\n        sums-of-sets (fn [s]\n                       (map #(reduce + %) s))\n        sub-sets-sums (->> ss\n                           (map sub-sets)\n                           (map #(remove empty? %))\n                           (map sums-of-sets)\n                           (map set))]\n    (not (empty? (apply clojure.set/intersection sub-sets-sums)))))","user":"53527551e4b084c2834f4af0"},{"code":"(fn [& ss]\n  (let [sums (map (fn [s] (map #(apply + %) \n                               (rest (loop [i (count s) r #{#{}}]\n                                       (if (= i 0)\n                                        r\n                                        (recur (dec i) (set (concat r (mapcat (fn [x] (map #(conj x %) (apply disj s x))) r))))))))) ss)]\n    (loop [f (set (first sums)) r (rest sums)]\n      (if (empty? r)\n        true\n        (if (not-any? #(not (nil? (f %))) (first r))\n          false\n          (recur f (rest r)))))))","problem":131,"user":"53468f6ce4b084c2834f4a3f"},{"code":"(fn sum-subset [& coll]\n  (let [power-set (fn power-set [s]\n                    (let [k (first s)\n                          rst (disj s k)]\n                      (if k\n                        (clojure.set/union (set (map #(clojure.set/union % #{k}) (power-set rst)))\n                               (power-set rst))\n                        #{#{}})))]\n  (not\n   (empty?\n    (apply clojure.set/intersection\n           (map set\n                (for [s coll]\n                  (let [sets (disj (power-set s) #{})]\n                    (map #(reduce + %) sets)))))))))","problem":131,"user":"4e7f51eb535db966e863cc3f"},{"problem":131,"code":"(fn common-sums?\n  [& sets]\n  (letfn [(sums\n            [in-set]\n            (letfn [(enumeration\n                      ([in-set] (cons in-set (lazy-seq (enumeration in-set (into #{} (map hash-set in-set))))))\n                      ([in-set out]\n                       (letfn [(reslt [inp outs]\n                                      (into #{} (for [x outs y inp] (conj x y))))]\n                         (cons (reslt in-set out) (lazy-seq (enumeration in-set (reslt in-set out)))))))]\n              (into #{} (map #(if (coll? %) (apply + %) %) (last (take (count in-set) (enumeration in-set)))))\n              ))]\n    (not (empty? (apply clojure.set/intersection (map sums sets))))))","user":"5545477fe4b0a04f79299531"},{"problem":131,"code":"(fn f1 [& ss]\n  (not \n   (empty? \n  (apply clojure.set/intersection \n         (map (fn [s]\n                (set (rest (reduce (fn [a b]\n                                     (clojure.set/union a (map #(hash-set (apply + b %)) a)))\n                                   #{#{}} s))))\n              ss)))))","user":"50ae0d24e4b0a40c9cfb08ce"},{"code":"(fn [& sets]\n  (letfn [(ps [s] (reduce (fn [ss e] (into ss (map #(conj % e) ss))) #{#{}} s))]\n    (not (empty?\n           (apply clojure.set/intersection\n                  (map (fn [s] (set (map #(apply + %) (disj (ps s) #{})))) sets))))))","problem":131,"user":"51e00020e4b01188f0627534"},{"problem":131,"code":"(fn [& s]\n  (->> (map (fn [s] (reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}} s)) s)\n       (map #(remove empty? %))\n       (map (fn [s] (map (partial apply +) s)))\n       (map set)\n       (apply concat)\n       (group-by identity)\n       vals\n       (reduce #(if (= (count s) (count %2)) true %) false)\n       ))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn [& sets]\n  (let [subsets (fn f [s]\n                  (if (empty? s)\n                    []\t\n                    (let [e (first s) ss (f (rest s))]\n                      (concat ss (cons [e] (map #(cons e %) ss))))))\n        sums (fn [s] (set (map #(apply + %) (subsets s))))]\n        ((complement empty?) (apply clojure.set/intersection (map sums sets)))))","problem":131,"user":"514721c6e4b0d520409ed392"},{"problem":131,"code":"(fn [& sets]\n   (->> sets\n        (map #(loop [[f & r] (seq %) p '(())]\n                (if f (recur r (concat p (map (partial cons f) p)))\n                    p)))\n        (map (fn [powers-list]\n               (->> powers-list\n                    (remove empty?)\n                    (map #(reduce + %))\n                    set)))\n        (apply clojure.set/intersection)\n        not-empty\n        boolean)\n   )","user":"50342d1be4b062bc5d7ae15f"},{"code":"(fn [& sets]\n  (letfn [\n    (min-sum [set]\n      (let [negs (for [i set :when (< i 0)] i)]\n        (if (empty? negs) (apply min set) (apply + negs))))\n    (max-sum [set]\n      (let [pos (for [i set :when (> i 0)] i)]\n        (if (empty? pos) (apply max set) (apply + pos))))\n    (combinations [set]\n      (let [v (vec set)]\n        (for \n          [n (range 1 (int (Math/pow 2 (count set))))]\n          (for \n            [i (range (count set))\n            :when (bit-test n i)]\n            (v i)))))\n    (can-sum-to [n set]\n      (if (or (> n (max-sum set)) (< n (min-sum set)))\n        false\n        (loop [c (combinations set)]\n          (cond\n            (empty? c) false\n            (= n (apply + (first c))) true\n            :else (recur (next c))))))]\n    (let [sorted (sort-by count sets)]\n      (loop [c (combinations (first sorted))]\n        (let [sum (apply + (first c))]\n          (cond \n            (empty? c) false\n            (every? #(can-sum-to sum %) (rest sorted)) true\n            :else (recur (rest c))))))))","problem":131,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [& sets]\n  (letfn [( sums [s]\n            (let [f (first s)\n                  r (rest s)]\n              (if (= (count s) 1) #{f}\n                (let [u (sums r)]\n                  (clojure.set/union (into #{} (map #(+ % f) u)) #{f} u)))))]\n    (not (empty? (apply clojure.set/intersection (map sums sets))))))","problem":131,"user":"4ede8e1d535d10e5ff6f5339"},{"code":"(fn [& xss]\n  (letfn [(sums [xs]\n            (if (empty? xs) #{}\n              (let [[x0 & xs'] xs\n                    sums' (sums xs')]\n                (into sums' (map #(+ x0 %) (cons 0 sums'))))))]\n    (->> xss (map seq) (map sums) (apply clojure.set/intersection) empty? not)))","problem":131,"user":"508157b2e4b0946d0443855c"},{"code":"(fn [& sets]\n  (letfn [(subsets [superset]\n            (let [[x & _] (seq superset)]\n              (if x\n                (mapcat (juxt identity\n                              (partial cons x))\n                        (subsets (disj superset x)))\n                (list #{}))))]\n    ((complement empty?) (apply clojure.set/intersection\n                                (map (comp set\n                                           (partial map (partial apply +))\n                                           (partial remove empty?)\n                                           subsets)\n                                     sets)))))","problem":131,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":131,"code":"(fn [& sets]\n  (let [subsets (fn [s]\n                  (reduce (fn [sumset e]\n                            (reduce (fn [ss sum]\n                                      (conj (conj ss sum)\n                                            (conj sum e)))\n                                    #{#{}}\n                                    sumset))\n                       #{#{}}\n                       s))\n        sums (fn [s]\n               (set\n                (map #(reduce + %) \n                     (disj (subsets s) #{}))))]\n    (->> (map sums sets)\n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","user":"4f041de1535dcb61093f6ba5"},{"problem":131,"code":";; Reuse the power-set function from an earlier problem\n  (letfn [(bool-inc\n            ([v]\n             (bool-inc v (dec (count v))))\n            ([v i]\n             (when (>= i 0)\n               (if (get v i)\n                 (recur v (dec i))\n                 (reduce conj\n                         (conj (subvec v 0 i) true)\n                         (repeat (- (count v) i 1) false))))))\n          (pick [s v]\n            (reduce (fn [acc [e b]]\n                      (if b (conj acc e) acc))\n                    #{} (partition 2 (interleave s v))))\n          (subsets\n            ([coll]\n             (subsets coll (vec (repeat (count coll) false))))\n            ([coll v]\n             (when v\n               (lazy-seq\n                (cons (pick coll v) (subsets coll (bool-inc v)))))))\n          (power-set [s]\n            (into #{} (subsets s)))\n          (subset-sums [s]\n            (->> s\n                 power-set\n                 (filter (complement empty?))\n                 (map #(apply + %))\n                 set))]\n    (fn equivalent-subset? [& ss]\n      (->> ss\n           (map subset-sums)\n           (apply clojure.set/intersection)\n           ((complement empty?)))))","user":"4dfe5a93535d04ed9115e786"},{"problem":131,"code":"(fn [& xs]\n  (letfn [(power-set [s]\n            (let [v (vec s)\n                  len (count v)\n                  end (int (Math/pow 2 len))\n                  binary-slice (fn [n]\n                                 (loop [n n\n                                        power 0\n                                        bits []]\n                                   (if (zero? n)\n                                     bits\n                                     (recur (bit-shift-right n 1)\n                                            (inc power)\n                                            (if (odd? n) (conj bits power) bits)))))\n                  items-based-on-binary (fn [n] (map v (binary-slice n)))\n                  results (reduce #(conj %1 (items-based-on-binary %2)) [] (range 0 end))]\n              (set (map set results))))]\n    (boolean (seq\n     (apply clojure.set/intersection\n            (map (fn [s] (set (map #(apply + %) (disj (power-set s) #{}))))\n                 xs))))))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn [& sets]\n    (not (empty?\n          (apply clojure.set/intersection (map #(reduce (fn [acc x]\n                                                         (apply conj acc x (for [s acc] (+ s x)))) #{} %)\n                                               sets)))))","problem":131,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"(fn [& l]\n    (letfn [\n             (f [s]\n               (loop [n (count s)\n                      a #{s}]\n                 (if (= n 0)\n                   a\n                   (recur\n                     (- n 1)\n                     (reduce\n                       (fn [z i]\n                         (reduce\n                           #(conj % (disj i %2))\n                           z\n                           s))\n                       a\n                       a)\n                     ))))]\n      (->>\n        (map\n          (fn [x]\n            (->>\n              (f x)\n              (remove empty?)\n              (map #(apply + %))\n              set))\n          l)\n        (apply concat)\n        frequencies\n        (some (fn [[k v]] (= v (count l))))\n        true?\n        )))","problem":131,"user":"51b3f109e4b0f094dd986fa9"},{"problem":131,"code":"(let [powerset (fn powerset [s]\n                  (if (empty? s) #{#{}}\n                      (let [e (first s)\n                            more (disj s e)\n                            subsets-without (into #{} (powerset more))\n                            subsets-with (map #(conj % e) subsets-without)]\n                        (->> (clojure.set/union subsets-with subsets-without)\n                             (set)))))\n       overlapping-ss-sums (fn [& sets]\n                             (->> sets\n                                  (map powerset)\n                                  (map #(disj % #{}))\n                                  (map #(map (partial reduce +) %))\n                                  (map set)\n                                  (reduce clojure.set/intersection)\n                                  (#(not (empty? %)))))]\n       overlapping-ss-sums)","user":"5d4b2155e4b0776584bd6f28"},{"problem":131,"code":"(fn [& sets]\n    (letfn [(combos [[x & xs :as s]]\n              (if s\n                (let [recur (combos xs)]\n                  (concat (map #(conj % x) recur)\n                          recur))\n                '(())))\n            (sums [s] (set (map #(reduce + %) (filter seq (combos (seq s))))))]\n      (let [sum-sets (map sums sets)\n            common (apply clojure.set/intersection sum-sets)]\n        (pos? (count common)))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":131,"code":"(fn sum-sets [& initial-sets]\n  (let [power-set-f (fn power-set [initial-set]\n                      (loop [s initial-set acc #{#{}}]\n                        (if (empty? s)\n                          acc\n                          (recur (rest s) (into acc (map #(conj % (first s)) acc))))))\n        power-sets (map #(disj (power-set-f %) #{}) initial-sets)\n        sums (map (fn [el] (set (map #(apply + %) el))) power-sets)\n        ;parts (group-by identity sums)\n        ]\n    (not (empty? (apply clojure.set/intersection sums)))) )","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [& s]\n  (let [c (fn c [[x & r]] \n            (if r\n              (let [t (c r)]\n                (concat [] t (map #(conj % x) t)))\n              [[] [x]]))\n        v (for [z s] (set (map #(reduce + %) (rest (c (seq z))))))]\n    (not (empty? (apply clojure.set/intersection v)))))","problem":131,"user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [x & xs]\n  (let [c (fn [x]\n            (let [s (map #(identity #{%}) x)]\n\t      (loop [a s c s]\n\t        (if (= 1 (count c))\n\t\t (set (map #(apply + %) a))\n\t\t (let [n (set (for [e s x c :let [n (into e x)] :when (not= n x)]\n\t\t\t        n))]\n\t\t   (recur (into a n) n))))))\n         s (c x)\n\t ss (map c xs)]\n    (not (empty? (for [s s :when (every? #(% s) ss)]\n\t\t   s)))))","problem":131,"user":"4f32a7f1e4b0d6649770a095"},{"problem":131,"code":"(letfn [                                                                                                                        \n    (subsets [s] (filter not-empty (reduce (fn [a v] (apply merge a (map #(conj % v) a))) #{#{}} s)))                                                   \n    (subset-sums [s] (set (map #(apply + %) (subsets s))))                                                                      \n    (has-sum-intersection? [& sets] (if (empty? (apply clojure.set/intersection (map subset-sums sets))) false true))]          \n        has-sum-intersection?)","user":"558b50d5e4b027778923762b"},{"problem":131,"code":"(fn [& sets]\n   (letfn [(sumset [sets]\n             (let [result #{}]\n               (reduce (fn [r n]\n                         (if (empty? r)\n                           #{n}\n                           (reduce #(conj %1 n (+ %2 n) %2) r r)))\n                       result\n                       sets)))]\n     (not (empty? (apply clojure.set/intersection (map sumset sets))))\n     ))","user":"5f3f2281e4b004f08c61c561"},{"problem":131,"code":"(fn [& sets]\n            (letfn [(ps [s]\n                        (if (empty? s)\n                          #{#{}}\n                          (let [ps-of-rest (ps (rest s))\n                                ps-with-missing (apply hash-set (map #(set (cons (first s) %)) ps-of-rest))]\n                            (clojure.set/union ps-of-rest ps-with-missing))))\n                    (calculate-sums [sets]\n                                    (set (map #(apply + (vec %)) sets)))]\n              (let [powersets (map ps sets)\n                    powersets-without-empty (map (fn [powerset]\n                                                   (filter (complement empty?) powerset))\n                                                 powersets)\n                    sums (map calculate-sums powersets-without-empty)\n                    intersection (apply clojure.set/intersection sums)]\n                (not (empty? intersection)))))","user":"53f891eee4b0de5c4184856d"},{"problem":131,"code":"(fn eqs [& ss]\n  (let [fn-subsets' (fn [[sh & st :as sa] acc]\n                     (if (empty? sa)\n                       acc\n                       (recur st (concat acc (map (fn [s] (cons sh s)) acc)))))\n        fn-subsets (fn [s] (rest (fn-subsets' (into () s) (list ()))))\n        sums (->> ss (map fn-subsets) (map (fn [s] (map (fn [si] (apply + si)) s))) )\n        set-sums (map (fn [s] (into #{} s)) sums)\n        ]\n    (not (empty? (apply clojure.set/intersection set-sums)))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [ & xs]\n  (letfn [\n   (non-empty-powerset [s]\n    (reduce \n     (fn [r i]  (conj r (set (keep-indexed #(if (bit-test i %1) %2) (vec s)))))  #{} \n     (range  1 (bit-shift-left 1 (count s)))))\n    (subset-sums [s]\n        (set (map #(apply + %) (non-empty-powerset s))))\n    ]\n    (not (empty? (reduce (comp set filter) (map subset-sums xs))))))","problem":131,"user":"51f59607e4b0abb92f97f9d5"},{"code":"(fn [& sets]\n  (letfn [(power-set [s]\n                     (reduce\n                      (fn [o i]\n                        (into o (map #(conj % i) o)))\n                      #{#{}} s))\n          (reduce-sum [s]\n                      (reduce + s))]\n    (let [set-sums (map (fn [a] (set (map reduce-sum (filter #(> (count %) 0) (power-set a))))) sets),\n          f (first set-sums),\n          r (rest set-sums)]\n      (if-not (seq r)\n        true\n        (loop [fi f]\n          (if-not (seq fi)\n            false\n            (if (every? #(contains? % (first fi)) r)\n              true\n              (recur (rest fi)))))))))","problem":131,"user":"5341b141e4b00652c8746ecf"},{"problem":131,"code":"(fn\n [& sets]\n  (#(not (empty? %))\n   (apply\n    clojure.set/intersection\n     (map (fn [ss] (set (map #(reduce + %) ss)))\n      (map (fn [ss] (filter #(> (count %) 0) ss))\n       (map (fn [s] (reduce (fn [a b] (reduce #(conj (conj %1 (conj %2 b)) %2) '() a)) '(()) (seq s))) sets))))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":131,"code":"(fn [& all]\n  (loop [all all\n         summation #{}]\n    (if (empty? all)\n      ;check if all sets have non-empty subsets with equivalent summation \n      (if (empty? (apply clojure.set/intersection summation))\n\t\tfalse\n\t\ttrue)\n      (let [fsubsets (fn [coll]\n    \t\t(loop [incoming coll\n          \t  counter (count coll)\n           \t  outgoing #{#{}}]\n      \t\t (if (< counter 1)\t  \n        \t  (clojure.set/union outgoing #{#{}})\n        \t  (let [new-out \n                    (into #{} \n                     (for [x outgoing y incoming ] (clojure.set/union x #{y})))]\n          \t  (recur incoming\n                     (dec counter)\n                     new-out))))) \n            subsetvalues (remove empty? (fsubsets (first all)))\n            summedupvalues (into #{} (map #(reduce + %) subsetvalues)) ]\n       (recur (rest all)\n       \t\t  (conj summation summedupvalues))))))","user":"567d18c9e4b05957ce8c61c4"},{"code":"(fn [& ss]\n  (letfn\n    [\n      (ps [xs]\n        (if (empty? xs)\n          #{#{}}\n          (apply conj (ps (rest xs)) (map #(conj % (first xs)) (ps (rest xs))))\n        )\n      )\n    ]\n    (not (empty? (reduce (comp set filter) (map #(set (map (partial reduce +) %)) (map #(filter (fn [subset] (not (empty? subset))) %) (map ps ss))))))\n  )\n)","problem":131,"user":"507eddf4e4b06ce648bcdbfa"},{"code":"(fn [& sets]\n    (let [pwr (fn pwr [xs]\n                (let [[x & more :as xs] (vec xs)]\n                  (if-not (seq xs)\n                    #{#{}}\n                    (->> (pwr more)\n                         (concat (map #(conj % x) (pwr more)))\n                         set))))\n          sets-of-sums (for [powerset (map pwr sets)]\n                         (->> powerset\n                              (remove empty?)\n                              (map (partial apply +))\n                              set))]\n      (->> sets-of-sums\n           (apply clojure.set/intersection)\n           empty?\n           not)))","problem":131,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn[& args]\n\t(let [ super-set #(reduce (fn [x y] (concat x (map  (fn[z] (conj z y)) x))) #{ #{} } %)  \n\t\tnon-empty-super-set #(filter (complement empty?) (super-set %))\n\t\tsum-super-set (fn[x] (set (map #(apply + %) (non-empty-super-set x) ) ) )\n\t\t]\n\t\t((complement empty?) (apply clojure.set/intersection (map sum-super-set  args) ) )\n))","problem":131,"user":"50b25f2ce4b03ea88043355f"},{"code":"(fn [& ss]\n  (let [sumas (fn sumas [s]\n    (if (= (count s) 1) s\n      (let [sr (distinct (sumas (rest s)))\n            x (first s)]     \n         (distinct (concat sr (list x)\n               (map #(+ x %) sr))))))]\n (> (count (apply clojure.set/intersection \n   (map #(set (sumas %)) ss))) 0)))","problem":131,"user":"4f04a06d535dcb61093f6bd9"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(mouse-powerset ; from Mouse's elegant powerset solution\n            [a] \n            (->> a\n                 (reduce (fn [s x] (apply conj s (map #(conj % x) s)) ) #{#{}})\n                 (filter (complement empty?))))\n          (distinct-sums [ps] (distinct (map #(apply + %) ps)))]\n    (->> ss\n         (map mouse-powerset)\n         (mapcat distinct-sums)\n         (sort)\n         (partition-by identity)\n         (map count)\n         (apply max)\n         (= (count ss))\n)))","user":"55f09e7be4b06e875b46ce28"},{"code":"(fn [& xs]\r\n    (letfn [(f [s]\r\n              (loop [i (count s), r #{#{}}]\r\n                (if (zero? i) (set (map #(apply + %) (remove #{#{}} r)))\r\n                  (recur (dec i)\r\n                         (into r (for [x r y s] (conj x y)))))))]\r\n      (->> xs\r\n           (map f)\r\n           (apply clojure.set/intersection)\r\n           empty? \r\n           not)))","problem":131,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn [& sets]\n  (letfn\n    [\n      (intersect [s1 s2] (filter s1 s2))\n      (subsetSums [s]\n        (if (empty? s)\n          #{}\n          (let [x (subsetSums (set (rest s)))]\n            (conj\n              (into\n                x\n                (map #(+ % (first s)) x))\n              (first s)))))]\n    (< 0\n      (count\n        (if (= 1 (count sets))\n          '(0)\n            (reduce\n            (fn [s1 s2] (intersect (subsetSums s1) (subsetSums s2)))\n            sets))))))","problem":131,"user":"4fb1325de4b081705acca276"},{"code":"(fn [& colls]\n  (let [sub-sums (fn f [s]\n                   (let [x (first s) xs (rest s)]\n                     (if (seq xs) (let [o (f xs)]\n                                    (into (conj o x) (map #(+ x %) o)))\n                       #{x})))]\n    ((complement empty?)\n     (reduce #(filter %2 %) (map sub-sums colls)))))","problem":131,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn [ & args]\n (let [f (fn [s] (reduce\n                   (fn [a b] (clojure.set/union a (set (map (fn [x] (clojure.set/union x #{b})) a))))\n                   #{#{}} s))\n       g (fn [s] (set (map (fn [a] (apply + a)) (remove empty? (f s)))))]\n   (not (empty? (reduce clojure.set/intersection (map g args))))))","problem":131,"user":"5097b556e4b00ad8bab4e970"},{"code":"(fn [& ss]\n       (boolean (not-empty\n                  (reduce clojure.set/intersection\n                    (map\n                      (fn [s]\n                        (reduce (fn [acc x]\n                                  (clojure.set/union acc #{x} (set (map #(+ x %) acc))))\n                                #{(first s)}\n                                (rest s)))\n                      ss)))))","problem":131,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [& m]\n   (letfn [(powset [c] (reduce #(into %1 (for [x %1]\n                                            (conj x %2)))\n                                #{#{}}\n                                c))]\n          ((complement empty?) (apply clojure.set/intersection (map #(set (map (fn [s] (reduce + s)) %)) (map #(rest (powset %)) m))))))","problem":131,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":131,"code":";; yeah...making things harder i implemented the intersection-func using TCO myself\n;; (i could have just use the: clojure.set/intersection)\n(fn subsets-sum-intersection\n  [& xsets]\n  (letfn [(generate-sum-recur [xs-vecs]\n            (map (comp flatten generate-sum-of-each) xs-vecs))\n          (generate-sum-of-each [xs]\n            (loop [[head & tail :as init] (vec xs)\n                   [h s & tail-init] init\n                   acc []]\n              (if (nil? head)\n                (recur (cons (+ h s) tail-init) (cons (+ h s) tail-init) acc)\n                (if (nil? s) acc\n                  (recur tail (list* h s tail-init) (conj acc (pair-and-add head tail))))))) ;; keep head as well as sum\n          (pair-and-add [x ys]\n            (for [y ys :when (not= x y)] (+ x y)))\n          (map-by-min-and-tail [xs]\n            (let [mapped-and-sorted (sort-by first (map #(apply vector [(count %) %]) xs))\n                  smallest          ((comp last first) mapped-and-sorted)\n                  tail              (map last (rest mapped-and-sorted))]\n              [smallest tail]))\n          (has-intersections? [xs]\n            (letfn [(vec-contains? [xs subject] \n                      (some #{subject} xs))]\n              (loop [[smaller-head & smaller-tails] (first (map-by-min-and-tail xs))\n                     reseted-next-colls (second (map-by-min-and-tail xs))  ;; keep the state and reset when every rest-coll is exhausted\n                     [next-coll & tail-colls] reseted-next-colls\n                     intersections []]\n                (if (or (nil? smaller-head) (nil? next-coll))\n                  ((comp not empty?) intersections)   ;; we're done -> as the smallest collection is exhausted :) -> check for non-emptyness!\n                  (if (and (nil? tail-colls) (vec-contains? next-coll smaller-head)) ;; we reached the last collection -> push into intersections\n                    (recur smaller-tails reseted-next-colls reseted-next-colls (conj intersections smaller-head))\n                    (if (vec-contains? next-coll smaller-head)  ;; one intermediate coll contains the smaller-head el -> recur/check in next-colls\n                      (recur (cons smaller-head smaller-tails) reseted-next-colls tail-colls intersections)\n                      (recur smaller-tails reseted-next-colls (cons next-coll tail-colls) intersections) ;; no match -> step to next el from smaller-coll\n                ))))))\n          (add-init-entries-to-combinations [init-entries all-combs]\n            (map \n              (fn [each-combs-coll each-init-entries]\n                (into each-combs-coll each-init-entries)) all-combs init-entries))]\n    (if-let [one-set-corner-case-intersected-with-what? (= 1 (count xsets))]\n      one-set-corner-case-intersected-with-what?\n      (->> xsets \n           generate-sum-recur\n           (add-init-entries-to-combinations xsets)\n           has-intersections?))))","user":"5553b729e4b0deb715856e05"},{"code":"(fn [& sets]\n  (letfn [(ps [s]\n            (->> s\n              (reduce\n                (fn [a x] (into a (map #(conj % x) a)))\n                #{#{}})\n              (#(clojure.set/difference % #{#{}}))\n              (map (partial apply +))\n              (set)))]\n  (< 0 (count (apply clojure.set/intersection (map ps sets))))))","problem":131,"user":"4fd96694e4b05e33b9224f37"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(gen-subsets [[h & t]]\n          (if (nil? h)\n            [#{}]\n            (let [ss (gen-subsets t)]\n              (concat\n               ss\n               (map #(conj % h) ss)))))]\n    \n    (->> (map #(into [] %) sets)\n         (map gen-subsets)\n         (map #(remove empty? %))\n         (map #(map (fn [s] (reduce + s)) %))\n         (map (partial into #{})) \n         (apply clojure.set/intersection) \n         empty? \n         not)))","user":"527ccaf4e4b0757a1b17136d"},{"problem":131,"code":"(letfn [\n    (k-combinations\n      ([n coll] (k-combinations n coll #{}))\n      ([n coll current]\n        (cond\n          ;we can't add anything else\n          (= (count current) n)  #{current}\n          ;didn't make n elements\n          (empty? coll) #{}\n          :else\n            ;we can either skip current or add new\n            (set (concat \n              (k-combinations n (rest coll) current) (k-combinations n (rest coll) (conj current (first coll)))\n            ))\n        )\n      )\n    )]\n  \n  (fn [& sets]\n    (not (empty?\n      (filter #(= (count sets) (-> % last set count))\n        (apply merge-with concat\n          (for [s sets\n                k (range 1 (->> sets (apply max-key count) count inc))\n                part (k-combinations k s)\n                :let [sum (reduce + part)]]\n              {sum [s]}\n          )\n        )\n      )\n    ))\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":131,"code":"(fn eq-some-sum [& ss]\n  (let [permute (fn permute [s]\n                 (if (empty? s)\n                     s\n                     (let [perm-rest (permute (rest s))\n                           hd        (first s)] \n                      (concat [s] [[hd]] (map #(conj % hd) perm-rest) perm-rest))))\n\n        power-set (fn [s] \n                    (->> (permute s)\n                         (map set)\n                         (set)))\n\n        sum-set (fn [s]\n                    (->> (power-set s)\n                         (map #(apply + %))\n                         (set)))]\n   (->> ss\n        (map sum-set)\n        (apply clojure.set/intersection)\n        (empty?)\n        (not))))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":131,"code":"(letfn [\n(ps1 [xs]\n  (if (empty? xs)\n    #{}\n    (loop [now (first xs)\n           left []\n           right (vec (rest xs))\n           so-far #{(reduce + xs)}]\n      (if (empty? right)\n        (if (empty? left) so-far (conj so-far (reduce + left)))\n        (recur (first right)\n               (into left [now])\n               (rest right)\n               (into so-far (ps1 (into left right))))))))]\n\n    (fn check [& sets]\n      (->> sets\n        (map ps1)\n        (apply clojure.set/intersection)\n        (empty?)\n        (not)\n        (boolean)\n        )))","user":"57717915e4b0979f896515b3"},{"problem":131,"code":"(fn sumSubset [ & args ]\n  (letfn [(pset [s]\n            (set\n             (if (>= 1 (count s)) [(set s) #{}]\n                 (concat\n                  [s]\n                  [(set [(first s)])]\n                  (pset (set (rest s)))\n                  (map #(set (cons (first s) %)) (pset (set (rest s))))))))]\n    (let [psetArgs (map #(filter not-empty (pset %)) args)                                                                                          \n          psetSums (map (fn [ps] (set (map #(apply + %) ps))) psetArgs)]\n          (not (empty?  (apply clojure.set/intersection psetSums))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [& args]\n \n  (let [mx  (apply max (map count args))\n        tpow (map #(apply * (repeat % 2)) (range (inc mx)))\n        bny (fn [n sze] (map #(rem (quot n %) 2) (take sze tpow)))\n        bfilter (fn [lst n] (reduce (fn [x [y1 y2]] (+ x (* y1 y2))) 0\n                                   (map vector lst (bny n (count lst)))))\n        sset (fn [lst] (set (map #(bfilter lst %)\n                                (range 1 (nth tpow  (count lst) ))))) \n\n        ]\n  (not (empty? (apply clojure.set/intersection\n           (map sset args))))\n    ))","problem":131,"user":"5124619ae4b02c3f2a072ccd"},{"code":"(fn some-subset-sum-equal? [& sets]\n  (let [subsets (fn subsets [s]\n                  (reduce\n                    (fn [acc x]\n                      (concat\n                        acc\n                        (map (fn [acc-x] (conj acc-x x)) acc)))\n                    #{#{}}\n                    s))\n        non-empty-subsets (fn non-empty-subsets [s]\n                            (filter #(> (count %) 0) (subsets s)))\n        summed-subsets (map\n                        (fn [s] (set (map (partial apply +) (non-empty-subsets s))))\n                        sets)]\n    (if (seq (reduce clojure.set/intersection summed-subsets))\n      true\n      false)))","problem":131,"user":"51a97f7ae4b08d8ec191b827"},{"code":"(let [powerset (fn thisfunc [s]\n                (if (empty? s)\n                  #{#{}}\n                  (let [result (thisfunc (rest s))]\n                    (set (concat result (map #(conj % (first s)) result))))))\n      set-union (fn [ss]\n                  (set\n                    (filter (fn [x] (every? #(% x) (rest ss))) (first ss))))]\n(fn [& ss]\n  (if (not-empty (set-union\n    (for [s ss]\n      (set (map #(reduce + %) (remove empty? (powerset s)))))))\n    true false)))","problem":131,"user":"4dd9d299535d2dad7130b5dd"},{"problem":131,"code":"(fn sum-some-subsets [& args]\n  (letfn [(power [s] (set (loop [[f & r] (seq s) p '(#{})]\n                            (if f (recur r (concat p (map #(conj % f) p)))\n                                  p))))\n          (sum-sets [s] (into #{} (map #(apply + %) s)))\n          (filtered-sets [base s] (map #(contains? s %) base))\n          ]\n    (let [power-sets (map #(filter not-empty (power %)) args)\n          sumed-sets (map #(sum-sets %) power-sets)\n          base-set (first sumed-sets)\n          equals-sets (map #(filtered-sets base-set %) sumed-sets)\n          any-matching-sets (map #(some true? %) equals-sets)\n          ]\n      (every? true? any-matching-sets)\n      )\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (let [nums (vec s)]\n              (map\n               #(for [b (range (count s))\n                      :when (not= 0 (bit-and % (bit-shift-left 1 b)))]\n                  (nums b))\n               (range 1 (bit-shift-left 1 (count s))))))\n          (sums-set [s] (set (map #(reduce + %) (subsets s))))]\n    (not\n     (empty?\n      (apply clojure.set/intersection\n       (map sums-set sets))))))","problem":131,"user":"4ea365e2535d7eef308072c5"},{"problem":131,"code":"(letfn [(power-set [s]\n            (reduce\n             (fn [r e] (into r (map #(conj % e) r)))\n             #{#{}} s))\n          (sans-null-set [s]\n            (disj (power-set s) #{}))]\n    (fn [& xs]\n      (->> xs\n          (map (comp set (partial map #(reduce + %)) sans-null-set))\n          (apply clojure.set/intersection)\n          not-empty\n          boolean)\n      ))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn ssss [& ss]\n  (let [superset (fn superset [s]\n                   (loop [s s\n                          r #{#{}}]\n                     (if (nil? (first s))\n                       r\n                       (recur (rest s) (clojure.set/union r(map #(clojure.set/union #{(first s)} %) r))))))\n        s1 (map #(disj (superset %) #{}) ss)\n        sumset (fn [s] (map #(apply + %) s))\n        s2 (map sumset s1)\n        s3 (map (partial into #{}) s2)\n        s4 (reduce clojure.set/intersection s3)]\n    (if (empty? s4)\n      false\n      true)))","problem":131,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(letfn [(S [s]\n          (if (empty? s) #{}\n              (loop [p (S (rest s))\n                     r (conj p (first s))]\n                (if (empty? p) r\n                    (recur (rest p)\n                           (conj r (+ (first p)\n                                      (first s))))))))\n\n        (I? [x s*]\n          (every? #(% x) s*))\n\n        (E? [[s & s*]]\n          (some #(I? % s*) s))\n\n        (X? [& s*]\n          (true? (E? (map S s*))))]\n  X?)","problem":131,"user":"51a4416ae4b0def3c5c5868c"},{"problem":131,"code":"(fn[& s]\n  (let [f (fn f[t]\n        (if (seq t)\n          (let [ss (f (rest t))] (clojure.set/union ss (map #(conj %1 (first t)) ss)))\n          #{#{}}))\n        g (fn[t] (map (partial apply +) t))]\n  (if (seq (apply clojure.set/intersection (map (comp set g (partial filter seq) f) s)))\n    true\n    false)))","user":"56824e1be4b0945ebc182a91"},{"problem":131,"code":"(fn [& l] (->> l\n               (map (fn [S] (reduce #(->> %1\n                                          (map (partial + %2))\n                                          (into #{%2})\n                                          (into %1))\n                                    #{}\n                                    S)))\n               (apply clojure.set/intersection)\n               (empty?)\n               (not)))","user":"567b39b6e4b05957ce8c61a3"},{"code":"(fn sum-some-set-subsets[& ss]\n      (if(= 1(count ss))\n        true\n        (letfn[(get-sums\n                 [s]\n                 (reduce #(into (conj %1 %2) (map (fn[x] (+ %2 x)) %1)) #{} s))]\n        (if(some #(= (count ss) %)(map  (comp count second) (group-by identity (mapcat get-sums ss))))\n          true\n          false))))","problem":131,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn sum-some-subsets [& sets]\n  (letfn [(power-set [set]\n           (letfn [(power [self set]\n                     (if (empty? set)\n                       #{#{}}\n                       (reduce clojure.set/union #{set #{}} (map (partial self self)\n                                                                 (map (partial disj set) set)))))]\n             (power (memoize power) set)))]\n    (let [power-set-sums (map (fn [set] (->> set (power-set) (remove empty?) (map #(reduce + %)))) sets)]\n      (not (empty? (apply clojure.set/intersection (map set power-set-sums)))))))","problem":131,"user":"4ff355a1e4b0678c553fc34d"},{"problem":131,"code":"; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))","user":"51e58e02e4b0efabf93c02d0"},{"problem":131,"code":"(fn [& sets]\n  (let [powerset (fn [s] (reduce\n                           #(clojure.set/union %1 (into #{} (for [subset %1] (conj subset %2))))\n                           #{#{}}\n                           s))\n        sumset (fn [s] (into #{} (map (partial reduce +) s)))]\n    (->> sets\n         (map powerset)\n         (map #(remove empty? %))\n         (map sumset)\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":131,"code":"(fn [st1 & sts]\n   (let [subsets (fn [st] \n                  (let [v (vec st)]\n                      (for [x (range 1 (bit-shift-left 1 (count st)))]\n                          (for [i (range (count st)) :when (bit-test x i)]\n                             (v i)))))\n         subsetsums (fn [st] (map (partial apply +) (subsets st)))\n          ss1 (apply hash-set (distinct (subsetsums st1)))\n          intersects-ss1 (fn [s](some ss1 s))]          \n      (every? intersects-ss1 (map subsetsums sts))))","user":"5649615be4b0284900eef641"},{"problem":131,"code":"(fn subset-sum [& sets]\n  (letfn [(power-set [s]\n            (loop [[e & more :as s-in] (seq s)\n                   s-out #{#{}}]\n              (if (empty? s-in)\n                s-out\n                (recur more (apply (partial merge s-out)\n                                   (map #(conj % e) s-out))))))]\n    (->> sets\n         (map power-set)\n         (map #(filter (complement empty?) %))\n         (map (comp distinct #(map (fn [s] (apply + s)) %)))\n         flatten\n         sort\n         (partition-by identity)\n         (filter #(= (count sets) (count %)))\n         ((complement empty?)))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [& sets]\n     (let [power-set\n           (fn [sets]\n             (map\n              (fn [set] (filter (complement empty?)\n                               (reduce\n                                (fn [ss x]\n                                  (concat ss\n                                          (map\n                                           (fn [s] (conj s x))\n                                           ss)))\n                                [[]]\n                                set)))\n              sets))]\n       ((complement empty?)\n        (apply clojure.set/intersection\n               (map\n                (fn [p]\n                  (into #{} (map (partial reduce +) p)))\n                (power-set sets))))))","problem":131,"user":"4ed98b40535d10e5ff6f5307"},{"code":"(let [\n  ps (fn pw\n    ([s] (pw s #{#{}}))\n    ([s r]\n      (if (empty? s)\n        r\n        (pw (rest s) (into r (map #(conj % (first s)) r))))))\n  sm (fn [s]\n    (set (map #(reduce + %) (filter not-empty (ps s)))))]\n\n(fn [& args] (not (empty? (apply clojure.set/intersection (map sm args))))))","problem":131,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn [& ss]\n  (letfn\n    [(powerset\n      ([in] (powerset in #{#{}}))\n      ([in out]\n        (if (empty? in)\n            out\n            (recur (disj in (first in))\n                   (apply merge out\n                          (map #(conj % (first in)) out))))))\n     (subcounts [s]\n       (set (map (partial apply +)\n                 (disj (powerset s) #{}))))]\n   (not\n     (empty?\n       (apply clojure.set/intersection\n         (map subcounts ss))))))","problem":131,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn [& sets]\n  (letfn [(ps [s] (if-let [[f & r] (seq s)]\n                    (let [beck (ps r)]\n                      (into beck (for [el beck] (conj el f)))) #{#{}}))\n          (subset-sums [s] (->> (ps s) (filter #(seq %)) (map #(apply + %))))]\n    (let [sum-sets (map subset-sums sets)]\n      (< 0 (count (reduce #(keep (set %1) %2)\n                          (set (first sum-sets)) (rest sum-sets)))))))","problem":131,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn [& ss]\n  (let [power-set (fn [s]\n                     (rest (reduce\n                      #(concat %1 (map (fn [a] (conj a %2)) %1))\n                      #{#{}} s)))\n        set-sum-subsets (fn [ss]\n                          (reduce #(conj %1 (reduce + %2)) #{} ss))]\n    (not (empty? (reduce\n             clojure.set/intersection\n             (map #(set-sum-subsets (power-set %)) ss))))))","problem":131,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn [& sets]\n  (letfn [(powerset [s]\n    (reduce (fn [ps x]\n      (reduce (fn [ps s]\n        (conj ps (conj s x))) ps ps)) #{#{}} s))\n    (subsums [s]\n      (set (map #(reduce + %) (disj (powerset s) #{}))))\n    (intersect [sets]\n      (filter (fn [x]\n        (every? #(contains? % x) (rest sets)))\n        (first sets)))]\n    (not (empty? (intersect (map subsums sets))))))","problem":131,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":131,"code":"#(let [red (fn [x] (reduce + 0 x))\npower-set-no-empty (fn [c] (->> (reduce (fn [s1 s2] (into s1 (for [x s1] (conj x s2)))) #{#{}} c)\n(remove #{#{}})\n(map red)\n(distinct)))]\n(->> %&\n(map power-set-no-empty)\n(apply concat)\n(group-by identity)\n(filter (fn [[k v]] (= (count v) (count %&))))\n(keys)\n(nil?)\n(not)))\n;cf. problem 108 Lazy Searching\n;power-set-no-empty function based on amalloy's solution of problem 85 Power Set","user":"5e13a6b7e4b099d064963001"},{"problem":131,"code":"(fn comsumst [& sts]\n (letfn [\n  (sum-of [st] (apply + st))\n\n  (mix [ss b] \n   (set (map #(conj % b) ss)))\n\n  (sub-sets [st] \n   (loop [acc [#{}] work st]\n    (if (empty? work)\n     acc\n     (let [fst (first work)\n       rst (rest work)\n       newacc (into acc (mix acc fst))] \n      (recur newacc rst)))))\n\n  (sub-sums [st] \n   (set (map sum-of (remove empty? (sub-sets st)))) )\n    (commset [sets] (reduce (fn [z b] (set (filter z b))) (first sets) sets))]\n\n  (let [ssum-dict \n   (reduce (fn [acc b] \n    (assoc acc b (sub-sums b))) {} sts)\n       comms (commset (vals ssum-dict))] \n    \n    (not (empty? comms)) )))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn common-subset-sum [& sets]\n\t(letfn [\n\t\t(powerset [s] (reduce (fn [acc cur] (into acc (map #(conj % cur) acc))) #{#{}} s))\n\t\t(powerset-not-empty [s] (into #{} (filter (comp not empty?) (powerset s))))\n\t\t(sums-of-sets [sets] (into #{} (map #(reduce + %) sets)))\n\t\t(sets-have-common-element [sets] (->> sets (apply clojure.set/intersection) empty? not))\n\t]\n\t(->> sets (map powerset-not-empty) (map sums-of-sets) sets-have-common-element)\n))","problem":131,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":131,"code":"(fn [& args]\n  (let [power-set-solution (fn power-set-solution [coll]\n                               (reduce (fn [a x]\n              (->> a\n                   (map #(set (concat #{x} %)))\n                   (concat a)\n                   set))\n          #{#{}} coll))]\n\n  (< 0 (count (apply clojure.set/intersection (map #(set (map (partial reduce +)\n                                                              (clojure.set/difference (power-set-solution %)\n                                                                                      #{#{}})))\n                                                         args))))))","user":"544e8369e4b0e39780006987"},{"code":"(fn [& sets]\n  (let [sums\n        (fn sums [s]\n          (if (empty? s)\n            #{}\n            (let [x (first s)\n                  xs (rest s)\n                  other (sums xs)]\n              (into (conj other x) (map (partial + x) other)))))]\n    (->> sets\n      (map sums)\n      (apply clojure.set/intersection)\n      empty?\n      not)))","problem":131,"user":"514c2d05e4b02b8cbb2a9278"},{"code":"(fn [& s]\n  (->> s\n       (map (fn [l]\n              (reduce #(apply concat (map (fn [v] [v (conj v %2)]) %)) [#{}] l)))\n       (map (partial filter #(< 0 (count %))))\n       (map #(map (fn [i] (apply + i)) %))\n       (map set)\n       (apply clojure.set/intersection)\n       empty?\n       not\n))","problem":131,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [& sts]\n  (not (empty?\n        (let [ps (fn [s]\n                   (let [n (count s)\n                         v (vec s)\n                         pad-left (fn [n i s]\n                                    (concat (repeat (- n (count s)) i) s))]\n                     (->> (range (int (Math/pow 2 n)))\n                          (map #(Integer/toBinaryString %))\n                          seq\n                          (map #(map (fn [b] (if (= b \\0) false true)) %))\n                          (map (partial pad-left n false))\n                          (map #(map-indexed vector %))\n                          (map #(->> % (filter (fn [[idx itm]] itm)) (map (fn [[idx _]] idx))))\n                          (map #(reduce (fn [s idx] (conj s (v idx))) #{} %))\n                          set)))\n              sums (fn [s] (->> s ps\n                               (filter #(not (empty? %)))\n                               (map #(reduce + %))\n                               set))]\n          (reduce clojure.set/intersection (map sums sts))))))","problem":131,"user":"5392b849e4b0b51d73faaeb1"},{"problem":131,"code":"(fn __ [& sets]\n  (letfn [(sums-to? [n xs] (= n (reduce + xs)))\n          (subsets [s]\n              (if (empty? s) #{#{}}\n                (let [f (first s), r (subsets (rest s))]\n                  (apply conj r (map #(conj % f) r)))))\n          (non-empty-subsets [xs]\n              (filter #(not (empty? %)) (subsets xs)))\n          (some-subset-sums-to? [n xs]\n              (true? (some true?\n                           (map #(sums-to? n %)\n                                (non-empty-subsets xs)))))\n          ]\n    (true? (some true?\n                 (for [ss (non-empty-subsets (first sets))]\n                   (every? true?\n                           (map #(some-subset-sums-to? (reduce + ss) %)\n                                (rest sets))))))))","user":"54c271b9e4b045293a27f602"},{"problem":131,"code":"(let [subsequences (fn subsequences\n                      ([superset]\n                       (lazy-seq\n                         (cons []\n                               (subsequences superset '([])))))\n                      ([superset so-far]\n                       (if (empty? superset)\n                         '()\n                         (let [sets-containing-new (map #(conj % (first superset)) so-far)]\n                           (lazy-seq\n                             (concat\n                               sets-containing-new\n                               (subsequences\n                                 (rest superset)\n                                 (concat so-far sets-containing-new))))))))\n       subsets (fn [things] (map set (subsequences things)))\n       sums (fn [things]\n              (->> things\n                   subsets\n                   (remove empty?)\n                   (map (partial apply +))\n                   set))]\n   (fn [& colls]\n     (->> colls\n          (map sums)\n          (apply clojure.set/intersection)\n          empty?\n          not)))","user":"5bab5440e4b0a20761a23475"},{"code":"#(let [e #{}\n        p (fn [s] (into e (map (fn [s] (% + s)) (disj (% (fn [p x] (% (fn [p s] (conj p (conj s x))) p p)) #{e} s) e))))\n        f (fn [s r] (set (filter s r)))]\n    (not= e (% f (map (fn [x] (p x)) %&)))) reduce","problem":131,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn [& d]\n\n  (letfn [(all ([] nil) ([x & xs] (lazy-seq (let [r (apply all xs)] (into r (map #(conj % x) (into r #{#{x}})))))))\n]\n    (let [c (for [s d] (set (map #(apply + %) (apply all s)))) f (first c)] (or (some (fn [v] (every? #(% v) (rest c))) f) false))\n\n)\n)","problem":131,"user":"4ea41fc2535d7eef308072cb"},{"problem":131,"code":"(fn sum-some-set-subsets [& sets]\n  (let [powerset (fn f [[x & xs]]\n          (if (nil? x)\n            '(())\n            (let [ys (f xs)]\n              (concat ys\n                      (map #(conj % x) ys)))))\n        xss (map seq sets)\n        yss (map (comp  \n                    (partial map #(reduce + %))\n                    (partial filter not-empty)\n                    powerset)\n                 xss)\n        sets2 (map set yss)]\n    (->> sets2\n         (apply clojure.set/intersection)\n         not-empty\n         boolean)))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":131,"code":"(letfn [(power-set [s] (reduce (fn [r e] (into r (map #(conj % e) r))) #{#{}} s))\n        (sans-null-set [s] (disj (power-set s) #{}))]\n  (fn [& ss]\n    (boolean ;true or false?\n     (not-empty     ;the intersection of \n      (apply clojure.set/intersection ;sets of sums of subsets\n             (map (comp set (partial map #(reduce + 0 %)) sans-null-set)\n                  ss)))))) ; ;of input sets, is non-empty","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [& ss]\n       (letfn [(k-combs [n s] \n                        (loop [n n a #{#{}}]\n                          (if (> n 0)\n                            (recur (dec n) (set (for [x a y s :when (not (x y))] (conj x y))))\n                            a)))\n               (all-sums [s]\n                         (map (fn [e] (reduce + e)) (mapcat #(k-combs % s) (range 1 (inc (count s))))))]\n         (let [[h & t] (map all-sums ss)]\n           (cond (empty? t) true\n                 (some true? (for [e h] (every? #((set %) e) t ))) true\n                 true false))))","problem":131,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":131,"code":"(fn some-subsets? [& xs] \n  (let [A (apply + (filter neg? (first xs)))\n        B (apply + (filter pos? (first xs)))\n        sum-subset? (fn [s x]\n                      (let [A (apply + (filter neg? x))\n                            B (apply + (filter pos? x))\n                            N (dec (count x))]\n                        (letfn [(Q [i s]\n                                  (cond \n                                    (not (and (<= A s B) (<= 0 i N))) false\n                                    (zero? i) (= (x 0) s)\n                                    :else (or \n                                            (= (x i) s)\n                                            (Q (dec i) s) \n                                            (Q (dec i) (- s (x i))))))]\n                            ((memoize Q) N s))))]\n    (not-every? false? \n      (map \n        (fn [s] \n          (every? true? \n            (map #(sum-subset? s (vec %)) xs)))\n        (range A (inc B))))))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [& sets]\n    (letfn [(union [s1 s2] (reduce conj s1 s2))\n            (intersection [& sets]              (letfn [(intersection2 [s1 s2]                        (reduce (fn [result element]                                  (if (contains? s2 element)\n                                    result\n                                    (disj result element)))                                s1 s1))]\n                (reduce intersection2 (first sets) (rest sets))))\n            (power-set [coll]\n              (if (empty? coll)\n                #{#{}}                (let [element (first coll)                      sub1 (power-set (disj coll element))                      sub2 (set (map #(union #{element} %) sub1))]\n                  (union sub1 sub2))))\n            (sum [s] (reduce + s))\n            (sums [sets] (map sum (disj (power-set sets) #{})))\n            (has-same-content? [colls] (apply intersection colls))]\n     (let [sums-sets (map set (map sums sets))]\n       (not (zero? (count (reduce intersection (first sums-sets) (rest sums-sets))))))))","problem":131,"user":"4dc29a1d535d020aff1edf96"},{"problem":131,"code":"(let [power-set (fn power-set [s]\n                  (if (empty? s) #{#{}}\n                      (let [rest-power-set (power-set (rest s))]\n                        (clojure.set/union\n                         (set (map #(conj % (first s)) rest-power-set))\n                         rest-power-set))))\n\n      ; return the sums of all the non-empty subsets of a set                                                                                                                            \n      power-sums (fn power-sums [s] (set (map #(apply + %) (filter not-empty (power-set s)))))\n\n      ; return true if any two of the given sets have non-empty subsets with a common sum                                                                                                \n      somesum (fn somesum [& sets]\n                (not (empty? (apply clojure.set/intersection (map power-sums sets)))))\n      ]\n  somesum)","user":"530bf87ee4b02e82168697d5"},{"code":"(fn [& coll] \n\t(let [power-set \n\t\t(fn fun [coll]\n\t\t\t(if (empty? coll) #{#{}}\n\t\t\t\t(clojure.set/union \n\t\t\t\t\t(reduce\n\t\t\t\t\t\t#(conj % (conj %2 (first coll)))\n\t\t\t\t\t\t#{}\n\t\t\t\t\t\t(fun (rest coll)))\n\t\t\t\t\t(fun (rest coll)))))]\n\t\t((complement empty?)\n\t\t\t(reduce #(clojure.set/intersection % %2)\n\t\t\t\t(map set \n\t\t\t\t\t(map #(map (partial apply +) %) \n\t\t\t\t\t\t(map #(disj (power-set %) #{}) coll)))))))","problem":131,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn q131 [& ss]\n  (letfn [\n  \t(power-set [s]\n\t\t  (if (empty? s) #{#{}}\n\t\t    (let [\n\t\t      s1 (first s)\n\t\t      ps (power-set (rest s))]\n\t\t      (reduce #(conj % (conj %2 s1)) ps ps))))\n    (power-set-no-empty [s] (remove empty? (power-set s)))\n    (to-sum [s] (into #{} (map #(reduce + %) (power-set-no-empty s))))\n    ]\n  (not (empty? (apply clojure.set/intersection (map to-sum ss))))))","problem":131,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":131,"code":"(fn \n  [& sets]\n  (letfn [(subsets [s]\n            (if (seq s)\n              (let [f (first s), srs (subsets (disj s f))]\n                (concat srs (map #(conj % f) srs)))\n              (list #{})))\n          (add-contents [s]\n            (reduce + s))\n          (add-set-members [xs]\n            (into #{} (map add-contents xs)))]\n    (pos? (count (apply clojure.set/intersection (map #(add-set-members %) (map #(filter not-empty ( subsets %)) sets))))))\n  )","user":"4ebbff41535dfed6da9c6d78"},{"problem":131,"code":"(fn [& set-seq]\n         (letfn [(pow-f [s e] (into #{} (map #(conj % e) s)))\n                 (pow-set [some-set]\n                   (if (empty? some-set)\n                     #{#{}}\n                     (let [e (first some-set)\n                           r (disj some-set e)\n                           ps (pow-set r)]\n                       (concat ps (pow-f ps e)))))\n                 (pow-set-sum [ps]  (into #{} (map #(apply + %) (filter (complement empty?) (pow-set ps)))))\n                 (intersection\n                   ([a] a)\n                   ([a b]\n                    (if (> (count b) (count a))\n                      (recur b a)\n                      (reduce #(if (contains? b %2) %1  (disj %1 %2)) a a)))\n                   ([a b & cs] (reduce intersection (conj cs a b))))]\n              (> (count (reduce intersection (map pow-set-sum set-seq))) 0 )))","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":131,"code":"(fn subsetsums [& sets]\n\t(>\n\t\t(count (reduce\n\t\t\tclojure.set/intersection\n\t\t\t(set (map\n\t\t\t\n\t\t\t(fn sumsofset [s]\n\t\t\t\t(if (= 1 (count s))\n\t\t\t\t\ts\n\t\t\t\t\t(conj (reduce\n\t\t\t\t\t\t#(conj (conj % %2) (+ %2 (first s)))\n\t\t\t\t\t\t#{}\n\t\t\t\t\t\t(sumsofset (next s))\n\t\t\t\t\t) (first s))\n\t\t\t\t)\n\t\t\t)\n\n\t\t\tsets))\n\t\t))\n\t\t0\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":131,"code":"(letfn [(all-subsets [coll] \n            (if (empty? coll) #{#{}}\n              (into (all-subsets (rest coll))\n                (map #(conj % (first coll)) (all-subsets (rest coll))))))\n          \n          (sums [coll] (set (map #(reduce + %) coll)))] \n          (fn [& sets] \n            ((complement empty?) (reduce clojure.set/intersection \n                    (map #(sums (disj (all-subsets %) #{})) sets)))))","user":"50856bd1e4b004985b776e4c"},{"problem":131,"code":"(fn sum-subsets\r\n  [& sets]\r\n  (letfn [(subsets [s]\r\n            (if (empty? s)\r\n              #{#{}}\r\n              (let [a (first s)\r\n                    r (disj s a)\r\n                    subs (subsets r)]\r\n                (concat\r\n                  (map #(conj % a) subs)\r\n                  subs))))\r\n          (sums [s] \r\n            (set (map\r\n              (partial reduce +) \r\n              (filter (comp not empty?) (subsets s)))))]\r\n  (not (empty?\r\n    (reduce\r\n      #(clojure.set/intersection %2 %1)\r\n      (map sums sets))))))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn[& colls] (let [f\r\n  (fn [s] (map #(apply + %) (filter #(pos? (count %))(reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))))]\r\n             (pos? (count (apply clojure.set/intersection (map #(set (f %)) colls))))))","problem":131,"user":"503354c3e4b0c6c1199c710c"},{"problem":131,"code":"(fn [& s]\n    (let [[a & r]\n          (map (fn [l]\n                 (set (map #(apply + %) l)))\n               (map (fn sum-subset [s]\n                      (if (seq s)\n                        (let [ss (sum-subset (rest s))]\n                          (concat [[(first s)]] ss (map (fn [n] (cons (first s) n)) ss)))\n                        nil)) s))\n          ]\n\n      (if (not (seq r)) true\n                        ((complement nil?) (some (fn [x]\n                                                   (every? #(% x) r)\n                                                   ) a)))\n\n      )\n    )","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [& s]\n  (let [t (sort #(< (count %1) (count %2)) s)\n\t      z (fn [a]\n\t\t\t\t(let [h (apply + (filter pos? a)) \n\t\t\t\t      l (apply + (filter neg? a))]\n\t\t\t\t      (memoize \n\t\t\t\t      \t(fn q [n x]\n\t\t\t\t      \t\t(boolean\n\t\t\t\t      \t\t\t(when (and (>= x l) (<= x h))\n\t\t\t\t      \t\t\t\t(let [m (nth a n)]\n\t\t\t\t      \t\t\t\t\t(if (= 0 n)\n\t\t\t\t      \t\t\t\t\t\t(= x m)\n\t\t\t\t      \t\t\t\t\t\t(or\n\t\t\t\t      \t\t\t\t\t\t\t(= x m)\n\t\t\t\t      \t\t\t\t\t\t\t(q (dec n) x)\n\t\t\t\t      \t\t\t\t\t\t\t(q (dec n) (- x m)))))))))))\n\t\t   k (map #(partial (z (vec %)) (dec (count %))) (rest t))]\t\t\n\t\t(if (= 1 (count s))\n\t\t\ttrue\t\n\t\t\t(loop [y (range 1 (int (Math/pow 2 (count (first t)))))]\t\t\t\n\t\t\t\t(cond \n\t\t\t\t\t(empty? y) false\n\t\t\t\t\t(let [x (apply + (map #(* (-> %1 str read-string) %2) (reverse (Integer/toString (first y) 2)) (first t)))]\n\t\t\t\t\t\t(reduce #(and %1 %2) (map #(% x) k))) true\n\t\t\t\t\t:else (recur (rest y)))))))","problem":131,"user":"4db85282535d1e037afb218a"},{"code":"(fn [& args]\n   (not (empty?\n         (reduce #(for [x %1 y %2 :when (= x y)] x)\n                 (map (fn [x] (map #(apply + %1) (remove empty? ((fn powerset [set]\n   (loop [powerset #{#{}} i 0]\n     (if (= i (count set))\n       powerset\n       (recur\n        (into powerset (for [x powerset y set] (conj x y) ) )\n        (inc i)\n        )\n       )\n     )\n   ) x) ))) args)\n                 )\n         )\n        )\n   )","problem":131,"user":"4ea31da2535d7eef308072c1"},{"code":"(fn [& xss]\n  (letfn [(power-set [xs]\n    (letfn [(filter-mask [xs mask]\n              (->> (map list xs mask)\n                   (filter (fn [[_ b]] (= 1 b)))\n                   (map first)))\n            (binary-range [x]\n              (->> (range 1 (Math/pow 2 x))\n                   (map (partial clojure.pprint/cl-format nil \"~v,'0B\" x))\n                   (map (fn [s] map #(Integer/parseInt %) s))))\n            (digits [x] (map #(Integer/parseInt %) (map str (str x))))]\n      (->> (binary-range (count xs))\n           (map digits)\n           (map #(filter-mask xs %))\n           (map set)\n           (set))))]\n    (->> xss\n      (map power-set)\n      (map (fn [xss] (map #(reduce + %) xss)))\n      (mapcat distinct)\n      (frequencies)\n      (vals)\n      (some #(= % (count xss)))\n      (boolean)\n      )))","problem":131,"user":"5312cdaae4b08068f379ed03"},{"code":"(fn [& sets] (let [add-to-sets (fn [e s] (set (map (partial clojure.set/union #{e}) s)))\n                 subsets (fn gen-subsets [s] (if (empty? s) #{#{}} (clojure.set/union (gen-subsets (rest s)) (add-to-sets (first s) (gen-subsets (rest s))))))\n                 all-sums (fn [s] (set (map (partial reduce +) (filter (fn [x] (not= x #{})) (subsets s)))))]\n             (not (empty? (reduce clojure.set/intersection (map all-sums sets))))\n           )\n)","problem":131,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":131,"code":"(fn sum-some-subsets [& sets]\n  (let [subset-sums (fn [s]\n                      (let [e (Math/pow 2 (count s))\n                            s (vec s)]\n                        (reduce (fn [res number]\n                                  (conj res\n                                        (:sum (reduce (fn [{:keys [n sum]} b]\n                                                        (if (= \\1 b)\n                                                          {:n   (inc n)\n                                                           :sum (+ sum (nth s n))}\n                                                          {:n   (inc n)\n                                                           :sum sum}))\n                                                      {:n   0\n                                                       :sum 0}\n                                                      (reverse\n                                                        (seq (Integer/toBinaryString number)))))))\n                                #{}\n                                (range 1 e))))]\n    (not (empty? (reduce clojure.set/intersection (map subset-sums sets))))))","user":"5dc53ddee4b02f9375f4e1bd"},{"problem":131,"code":"(fn sss [& xs] (letfn [(powers [xs] (remove empty? (reduce (fn [acc x] (set (concat acc (set (map #(conj % x) acc))))) #{#{}} xs))\n                               )\n                               (sums [xs] (set (for [s xs] (apply + s))))]\n                         (let [s (map #(sums (powers %)) xs) u (apply clojure.set/intersection s)] (not (empty? u)))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(subs [s]\n            (disj \n             (reduce (fn [total a]\n                       (into total (map #(conj % a) \n                                        total)))\n                     #{#{}}\n                     s)\n             #{}))]\n    \n    (not (empty? \n                (apply clojure.set/intersection\n                 (for [x ss]\n                   (set\n                    (map #(apply + %)\n                         (subs x)))))))))","user":"54848141e4b0e286459a119e"},{"problem":131,"code":"(fn common-subset-sum [& sets]\n    (let [sum-subset (fn [sets]\n                      (let [power-set (fn [xs]\n                        (loop [xs xs result [#{}]]\n                           (if (empty? xs) \n                              result\n                              (recur (rest xs) \n                                (apply conj result (map #(conj % (first xs)) result))))))]\n            (set (map (partial apply +) (filter not-empty (power-set sets))))))]\n            (not (empty? (apply clojure.set/intersection (map sum-subset sets))))))","user":"559b55d6e4b066d22e731f54"},{"problem":131,"code":"(fn [& colls]\n    (letfn [(subsets [coll]\n              (if (empty? coll)\n                [[]]\n                (let [f (first coll)\n                      r (rest coll)]\n                  (concat (subsets r)\n                          (map #(conj % f)\n                               (subsets r))))))]\n      (< 0 (count\n             (apply clojure.set/intersection\n                    (map (fn [x]\n                           (set\n                             (map #(apply + %)\n                                  (filter (complement empty?)\n                                          (subsets x)))))\n                         colls))))))","user":"560e9a2de4b05f002753df52"},{"code":"(fn [& l] (not (empty? (apply clojure.set/intersection (for [s l] (reduce (fn [p i] (-> p (conj i) (into (map #(+ i %) p)))) #{} s))))))","problem":131,"user":"52c6a0abe4b0c2d177d62111"},{"problem":131,"code":"(fn\n  [& x]\n  (if (== 1 (count x))\n    true\n    (letfn [(ps [s]\n              (remove empty?\n                      (reduce (fn [sets el]\n                                (into sets\n                                      (map #(conj % el) sets)))\n                              #{#{}} s)))]\n      (not\n       (empty?\n        (apply clojure.set/intersection\n               (map\n                (fn [a]\n                  (set (map #(reduce + %) (ps a))))\n                x)))))))","user":"5893c64ce4b00487982d524b"},{"problem":131,"code":"(fn [& sets]\n        (letfn \n            [(powerset [lst]\n               (if (empty? lst) \n                 '([])\n                 (let [ps (powerset (next lst))]\n                   (clojure.set/union ps (map #(conj % (first lst)) ps)))))\n\n             (sums [coll]\n               (vec (sort (distinct (map (partial reduce +) (remove empty? (powerset coll)))))))\n              \n             (common-elem [& colls]\n               (if (some empty? colls) nil\n                   (let [heads\n                         (into [] (map first colls))]\n\n                     (if (apply = heads)\n                       (first heads)\n                       (let [pivot\n                             (apply min heads)\n                             \n                             trim\n                             (fn [coll]\n                               (if (= pivot (first coll))\n                                 (rest coll)  coll))]\n                         \n                         (recur (map trim colls)))))))]\n          (not \n           (nil?\n            (apply common-elem (map sums sets))))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":131,"code":"(fn afn [& ss]\n  (let [powerset (fn [xs]\n                   (disj (reduce (fn [a x]\n                                   (into a (map #(conj % x) a)))\n                                 #{#{}} xs) #{}))]\n    (->> ss\n         (map powerset)\n         (map (fn [sets] (set (map #(reduce + %) sets))))\n         (apply clojure.set/intersection)\n         (#(not (empty? %))))))","user":"54f86b8ce4b01ecee9d88828"},{"problem":131,"code":"(fn equivSum? [& ss]\n  (letfn [(pset [s] \n            (if(empty? s) \n              (conj #{} s)\n              (let [half (pset (set (rest s)))]\n                (into half (set (map #(conj % (first s)) half))))))]\n    (->> (map pset ss)\n      (map #(disj % #{}))\n      (map #(for [s %] (apply + s)))\n      (map set)\n      (apply clojure.set/intersection)\n      ((complement empty?)))))","user":"559454f2e4b0c79f6e1db952"},{"problem":131,"code":"(fn [& sets] \n  (let [combine (fn combinations [[head & tail]] \n                  (if (empty? tail) [[head] []]\n                    (let [c (combinations tail)]\n                      (concat c (map #(conj % head) c)))))\n        combinations (map (partial filter not-empty) \n                          (map combine (map seq sets)))\n        subsums (map #(vec (map (partial apply +) %))\n                           combinations)\n                     all-sums (map hash-set (apply concat subsums))]\n                     (boolean (some  (fn [sum] (every? (partial some sum) subsums)) all-sums))))","user":"54febf4be4b07d26eda61d45"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subset-sums [s]\n            (map #(apply + %)\n                 (remove #{#{}}\n                         (reduce (fn [pset el]\n                                   (into pset\n                                         (map #(conj % el) pset)))\n                                 #{#{}}\n                                 s))))]\n    (->> sets\n         (map #(set (subset-sums %)))\n         (apply clojure.set/intersection)\n         seq boolean)))","user":"524b0645e4b09eba1c0223bf"},{"problem":131,"code":"(fn [& sets] (letfn [(subsets [s] (if (empty? s) #{#{}} (let [ss (subsets (next s))] (into ss (map (partial cons (first s)) ss)))))] (not (empty? (reduce clojure.set/intersection (map #(set (map (partial apply +) (remove empty? (subsets %)))) sets))))))","user":"58987ee9e4b00487982d52d2"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(g [s]\n             (let [x (first s)\n                   t (rest s)]\n               (if (seq t)\n                 (let [r (g t)]\n                   (conj (into r (map #(+ % x) r))\n                         x))\n                 #{x})))]\n    (not (not (seq (apply clojure.set/intersection (map g sets)))))))","user":"5799ff45e4b05b1deef9add1"},{"problem":131,"code":"(fn f [& ss] \n  (letfn [\n          (all-subsets [s] \n            (set (drop 1 (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))))\n          \n          (sum-all-subsets [ss]\n            (for [[& ss] (map all-subsets ss)] (set (map (partial reduce +) ss))))]\n\n    (->> (sum-all-subsets ss)\n         (reduce #(clojure.set/intersection %1 %2))\n          count\n         (< 0))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":131,"code":"(fn sum-sets [& sets]\n  (letfn [(all-sums [s]\n            (reduce\n              (fn [acc val] (apply conj (list* acc val (for [x acc] (+ x val)))))\n              #{} s))]\n    (->> (map all-sums sets)\n         (reduce clojure.set/intersection)\n         (#(not (empty? %))))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [& x]\n    (not (empty?\n          (apply clojure.set/intersection\n                 (for [x x]\n                   (set (rest\n                         (map #(apply + %)\n                              ((fn f [c]\n                                 (if (seq c)\n                                   (let [r (f (rest c))]\n                                     (into r (map #(conj % (first c)) r)))\n                                   [#{}]))\n                               x)))))))))","problem":131,"user":"4f0664bd535dcb61093f6c0f"},{"code":"(fn [& sets]\n  (letfn [(pow [s]\n               (if (empty? s)\n                 #{#{}}\n                 (let [e (first s)\n                       T (disj s e)\n                       powT (pow T)]\n                   (clojure.set/union powT\n                                      (into #{} (map #(conj % e) powT))))))]\n    \n    (let [subset-sums (map #(map (partial reduce +) %)\n                                 (map #(disj (pow %) #{})\n                                      sets))]\n  \n      (> (count (apply clojure.set/intersection (map #(into #{} %) subset-sums))) 0))))","problem":131,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn com [& sets]\n  (letfn [(set+ [s n] (set (map #(+ n %) s)))\n          (sums [s] \n            (reduce \n              (fn [a v] (clojure.set/union a (set+ a v) #{v})) \n              #{} \n              s))]\n    (not (empty? (reduce clojure.set/intersection (map sums sets))))))","problem":131,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn[& xs]\n  (letfn[\n    (sets [ls]\n      (if (empty? ls) #{#{}}\n        (clojure.set/union \n         (sets (next ls))\n         (map #(conj % (first ls)) (sets (next ls))))))         \n    (sums[ls] (set (map (partial reduce +) (remove empty? (sets ls)))))]\n    \n  (not (empty? (reduce clojure.set/intersection (map sums xs))))))","problem":131,"user":"506406c8e4b075d771da6f9f"},{"problem":131,"code":"(fn common-sums2 [& s] \n  (let [power (fn power-set [s] \n\t\t\t\t\t\t\t\t\t  (if (empty? s)\n\t\t\t\t\t\t\t\t\t    #{}\n\t\t\t\t\t\t\t\t\t    (let [f (first s)\n\t\t\t\t\t\t\t\t\t          lastpow (power-set (rest s))]\n\t\t\t\t\t\t\t\t\t    (concat #{#{f}} (map #(conj % f) lastpow) lastpow))))\n        sums (fn [s] (into #{} (map #(apply + %) s)))]\n  (not (empty? (apply clojure.set/intersection (map #(sums (power %)) s))))))","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn f [& xs]\n  (letfn [(subsets [xs] (->>\n                         xs\n                         (reduce (fn [ax x] (let [ax+x (->>\n                                                        ax\n                                                        (map #(conj % x))\n                                                        (into #{}))]\n                                              (clojure.set/union ax ax+x)))\n                                 #{#{}})\n                         (into #{})\n                         (remove #(= % #{}))\n                         (map (partial apply +))\n                         (into #{})))]\n                   (->>\n                    xs\n                    (map subsets)\n                    (apply clojure.set/intersection)\n                    empty?\n\t\t\t\t\tnot)))","problem":131,"user":"51efd397e4b0249c592fbdeb"},{"code":"(fn subset-sum? [& sets]\n  (let [power-set (fn [coll]\n                    (let [v (apply vector coll) \n                          s (map #(let [bin (Integer/toBinaryString %)] (map (fn [i] (read-string (str i))) (str (apply str (repeat (- (count coll) (.length bin)) \"0\")) \n                                                                      bin))) (rest (range (Math/pow 2 (count coll)))))]\n                      (set (map #((comp set clojure.set/union)\n                                  (filter (comp not nil?) (map-indexed (fn [idx item]  (if (zero? item) nil(v idx))) %)))s)))) ]\n      ((complement empty?) (apply clojure.set/intersection (map #(set (map (partial apply +) %)) (map power-set sets))))))","problem":131,"user":"50c8697ce4b00bb60fe0c53f"},{"problem":131,"code":"(fn sum-some-set-subsets [& ss]\n  (letfn [(powerset [xs]\n            (reduce\n             (fn [ss s] (into ss (map #(conj % s) ss)))\n             #{#{}}\n             xs))]\n    (->> ss\n         (map #(->> (powerset %)\n                    (filter (partial not= #{}))\n                    (map (partial reduce +))\n                    set))\n         (reduce clojure.set/intersection)\n         count\n         (not= 0))))","user":"55fbc657e4b0f488688e0666"},{"problem":131,"code":"(fn f [& sets]\n  (letfn [(all-sums [col]\n            (->>\n             ((fn f' [acc col]\n                (let [i (first col), r (rest col)]\n                  (if (or (nil? i)) ; n==0\n                    acc\n                    (clojure.set/union (f' (map #(conj (set %) i) acc)r)\n                                       (f' acc r)))))\n              #{#{}} col)\n             (filter #(not= 0 (count %)))\n             (map #(apply + %))\n             set))]\n    (->> sets\n         (map all-sums)\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"569dd6e8e4b0542e1f8d1480"},{"code":"(fn [& s]\n  (let [power-set (fn [s]\n                    (reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}} s))\n        sums #(set (map (partial apply +) (disj % #{})))]\n    (not (empty? (reduce clojure.set/intersection (map (comp sums power-set) s))))))","problem":131,"user":"527cd633e4b0757a1b17136f"},{"problem":131,"code":"(fn all-have-equivalent-subset-summation? [& sets]\n  (let [power-set (fn power-set [s]\n                    (reduce (fn [acc el] \n                              (apply conj acc (map #(conj % el) acc))) #{#{}} s))\n        subset-sums (fn [s] \n                      (set (map (partial apply +) (remove #{#{}} (power-set s)))))\n        intersection (fn intersection [s & sets] \n                       (if-not sets s (set (filter s (apply intersection sets)))))]\n    (not= #{} (apply intersection (map subset-sums sets)))))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn ssss [& seq-of-sets]\r\n  (let\r\n    [sums (fn sums [s]\r\n            (if (= 1 (count s)) s\r\n              (let [h (first s)\r\n                    _ (println \"h\" h)\r\n                    t (rest s)\r\n                    _ (println \"t\" t)\r\n                    rest-sums (sums t)\r\n                    _ (println \"rest-sums\" rest-sums)\r\n                    h-rest-sums (cons h (map #(+ % h) rest-sums))\r\n                    _ (println \"h-rest-sums\" h-rest-sums)]\r\n                (clojure.set/union (set rest-sums) (set h-rest-sums)))))\r\n    seq-of-sums (map sums seq-of-sets)\r\n    _ (println \"seq-of-sums\" seq-of-sums)\r\n    all-sum (reduce #(clojure.set/intersection %1 %2) seq-of-sums)\r\n    _ (println \"all-sum\" all-sum)]\r\n    (not (empty? all-sum))))","problem":131,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn p131 [& lst]\n  (letfn [(myl\n            ([s] (map (partial apply +) (filter (comp not empty? ) (myl [[]] s))))\n            ([p s] (if (empty? s) p\n                       (myl (reduce conj p (for [pp p] (conj pp (first s)))) (next s)))))\n          (isec [s lsts]\n            (if (empty? lsts) s\n                (isec (filter #(some (fn [x] (= % x)) (first lsts)) s) (next lsts))))\n          ]\n    (let [s (map myl lst)] ((complement empty?) (isec (first s) (next s)))\n         )))","problem":131,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [& x] (let [r (map (fn [y] (set (map #(apply + %) (filter #(> (count %) 0) ((fn p [s] (if (empty? s) #{#{}} (let [e (first s) t (disj s e)] (into (p t) ((fn f [e t] (into #{} (map #(conj % e) t))) e (p t)))))) y))))) x)] (not (empty? (reduce #(apply disj % (apply disj % %2)) (first r) (rest r))))))","problem":131,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn shared-sum [& sets]\n  (letfn [(sums [ss]\n                (letfn [(pset [ss]\n                              (if (empty? ss)\n                                #{#{}}\n                                (let [memo (pset (rest ss))]\n                                  (clojure.set/union\n                                   (map #(conj % (first ss)) memo)\n                                   memo))))]\n                  (set (map #(reduce + %) (filter #(not (empty? %)) (pset ss))))))]\n    (not (empty?\n          (reduce clojure.set/intersection\n                  (map sums sets))))))","problem":131,"user":"51365524e4b04ac1f358dd52"},{"problem":131,"code":"(fn\n  [& sets]\n  (letfn [(sums [s] (reduce (fn [a e] (concat a (map #(+ % e) a))) #{0} s))\n          (intersection [s1 s2] (reduce #(if (contains? s2 %2)\n                                           (conj % %2)\n                                           %) #{} s1))]\n    (not (empty? (reduce intersection (map (comp set rest sums) sets))))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn [& xs]\r\n  (letfn [(f [xs]\r\n            (if (empty? xs) [[]]\r\n                (let [l (f (rest xs))]\r\n                  (concat (map #(conj % (first xs)) l) l))))]\r\n    (not (empty? (apply clojure.set/intersection\r\n                        (map (fn [x]\r\n                               (set (map #(apply + %)\r\n                                         (filter #(not (empty? %)) (f x)))))\r\n                             xs))))))","problem":131,"user":"4dc1ee85535d020aff1edf91"},{"problem":131,"code":"(fn [& se]\n  (letfn [(getsums [set]\n            (let [sets ((fn %c [[el & re]]\n                          (if el\n                            (let [rec (%c re)]\n                              (into rec (map #(conj % el) rec)))\n                            #{#{}})) (seq set))\n                  sums (into #{} (map (partial apply +) (remove empty? sets)))]\n              sums))]\n    (pos? (count (apply clojure.set/intersection (map getsums se))))\n    ))","user":"56018dd4e4b04bb52996e18f"},{"problem":131,"code":"(fn [& s]\n  (letfn [(subs [a l]\n            (if (= 1 l)\n              (into #{#{}} (map (fn [el] #{el}) a))\n              (reduce (fn [c e] (into c (map (fn [el] (conj el e)) (subs a (dec l))))) #{} a)\n              )\n            )]\n    (not (empty? (apply clojure.set/intersection (map (fn [el] (set (map #(reduce + %) (filter #(not (empty? %)) (subs el (min 4 (count el))))))) s))))\n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":131,"code":"(letfn [(power-set [s]\n          (if (empty? s)\n            #{s}\n            (let [x (first s)\n                  without-x (power-set (set (rest s)))\n                  with-x (map #(conj % x) without-x)]\n              (clojure.set/union without-x with-x))))]\n  (fn subset-sum [& sets]\n    (let [subsets (reduce\n                   (fn [acc s]\n                     (for [s1 acc\n                           s2 (power-set s)\n                           :when (and (not-empty s2)\n                                      (= (reduce + s1) (reduce + s2)))]\n                       s1))\n                   (filter not-empty (power-set (first sets)))\n                   (rest sets))]\n      (if (empty? subsets)\n      false\n      true))))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn [& xss]\n  (let [\n  power-set (fn [xs]\n    (let [add-element (fn [acc x]\n      (concat (map #(conj % x) acc) acc))]\n    (->> xs (reduce add-element '(#{})) (set))))\n  power-set* (fn [xs]\n    (disj (power-set xs) #{}))\n  sum (fn [xs]\n    (reduce + 0 xs))\n  sums (fn [xss]\n    (reduce #(conj %1 (sum %2)) #{} xss))\n  ; Lifted from clojure.set\n  intersection (fn intersection\n    ([s1] s1)\n    ([s1 s2]\n      (if (< (count s2) (count s1))\n        (recur s2 s1)\n        (reduce (fn [result item]\n          (if (contains? s2 item)\n            result\n            (disj result item)))\n          s1 s1)))\n    ([s1 s2 & sets]\n      (apply intersection (cons (intersection s1 s2) sets))))\n  ]\n  (->> (map power-set* xss)\n       (map sums)\n       (apply intersection)\n       empty?\n       not)))","problem":131,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn [& ss]\n  (letfn \n    [(g \n      [s] \n      (let [[ft & rt] (seq s)]\n        (if (nil? ft)\n          [[]]\n          (concat\n            (g rt)\n            (map \n             #(conj % ft)\n             (g rt))))))\n     (f \n      [s]   \n      (map #(apply + %) s))] \n    (->>\n     ss\n     (map g)\n     (map #(filter not-empty %))\n     (map f)\n     (map set)\n     (apply clojure.set/intersection)\n     not-empty\n     boolean)))","problem":131,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [& se ] (letfn [(ps [s] (loop [sts #{ #{} } coll s](if (empty? coll) sts\r\n(recur (clojure.set/union sts\r\n(set (map (fn [c] (conj c (first coll))) sts))) (rest coll)))))]\r\n(not (empty? (->> se \r\n(map (comp set #(map (partial apply + ) %) #(clojure.set/difference % #{#{}}) ps)) \r\n(apply clojure.set/intersection )))  )))","problem":131,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [& ss]\n  (let [perms (fn [s]\n                (let [s (vec s)\n                      masks (map #(Integer/toBinaryString %)\n                                 (range 1 (Math/pow 2 (count s))))]\n                  (map (fn [m]\n                         (filter #(not (nil? %))\n                                 (for [i (range 0 (count m))]\n                                   (if (= \\1 (nth m i))\n                                     (nth s (- (- (count m) 1)\n                                               i))))))\n                       masks)))\n        sums (map (fn [s] (set (map #(reduce + %) (perms s)))) ss)]\n    (not (empty? (apply clojure.set/intersection sums)))))","problem":131,"user":"4db4714f535dc0f10411755a"},{"problem":131,"code":"(fn [& a]\n  (boolean\n    (seq (apply clojure.set/intersection\n                (map (fn [x]\n                       (set (map #(apply + %) (nth (iterate (fn [b] \n                                                              (set (mapcat (fn [c] \n                                                                             (map #(conj c %) x))\n                                                                           b)))\n                                                            #{#{}}) \n                                                   (count x))))) \n                     a)))))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn sum-subsets? [& sets]\n  (letfn [(powerset [s]\n            (if (empty? s) \n              #{#{}}\n              (clojure.set/union (powerset (rest s))\n                                 (map #(conj % (first s)) (powerset (rest s))))))]\n    (not (empty? \n      (apply clojure.set/intersection \n             (map (fn [s] (set (map #(apply + %) (remove empty? (powerset s))))) sets))))))","problem":131,"user":"4e7263a1535d5021c1a8965f"},{"problem":131,"code":"(letfn\n    [(pow [base power]\n       (reduce * (repeat power base)))\n     (bits [n]\n       (loop [n n accu [] pos 0]\n         (cond (zero? n) accu\n               (bit-test n pos) (recur (- n (pow 2 pos)) (conj accu pos) (inc pos))\n               :else (recur n accu (inc pos)))))\n     (subset-sums [s]\n       (let [bitmap-max (pow 2 (count s))\n             ordered (vec s)]\n         (set (->> (range 1 bitmap-max)\n                   (map bits)\n                   (map #(map ordered %))\n                   (map #(apply + %))))))]\n    (fn [& xs]\n      (->> xs\n           (map subset-sums)\n           (reduce clojure.set/intersection)\n           (not-empty)\n           (boolean))))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn __ [& args]\n  (let [subset (fn [coll]\n                 (remove empty? (reduce #(into %1 (map (fn [s] (conj s %2)) %1)) [[]] coll)))\n        [fst & rst] (map #(-> (map (fn [x] (reduce + 0 x)) (subset %)) set) args)]\n    (boolean (some (fn [x] (every? #(% x) rst))  fst))))","problem":131,"user":"504f57c7e4b0a02f9cffde71"},{"code":"(let [p #(loop [s % r #{#{}}]\n          (let [n (into r (mapcat (fn [x] (map (partial conj x) s)) r))]\n            (if (= n r)\n              (disj r #{})\n              (recur s n))))]\n(fn [& l]\n  (not (empty? (apply clojure.set/intersection (map #(into #{} (for [s (p %)] (reduce + s))) l))))))","problem":131,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn summations [ & sets ]\n  (letfn [(powerset [s]\n            (reduce (fn [ps x]\n                      (reduce (fn [ps s]\n                                (conj ps (conj s x))) ps ps)) #{#{}} s))\n          (summations [s]\n            (set (map (partial apply +) (set (filter #(> (count %) 0) (powerset s))))))]\n    (not (empty? (apply clojure.set/intersection (map summations sets))))))","problem":131,"user":"5164867fe4b003cf19fdde3e"},{"problem":131,"code":"(fn t131 [& sets]\n  (let [combinations (fn [n s]\n                         (set (filter #(= n (count %)) (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))))\n        power_set (fn [s]\n                  (for [x (range 1 (inc (count s)))]\n                    (combinations x s)))\n        subsets (map #(apply clojure.set/union (power_set %)) sets)\n        subsets_sums (for [s subsets] (set (map #(apply + %) s)))]\n    (>= (count (apply clojure.set/intersection subsets_sums)) 1)))","user":"5046f909e4b03b02161376b5"},{"problem":131,"code":"(fn [& s]\n    (let [\n          gp  \n          (fn [s n]\n            (loop [s s n n v (vec s)] \n              (if (> n 0)\n                (if (= 1 (bit-and 1 n)) \n                  (recur (disj s (first v)) (bit-shift-right n 1) (rest v)) \n                  (recur s (bit-shift-right n 1) (rest v)) \n                  )   \n                s   \n                )   \n              )   \n            )   \n          permut\n          (fn [s] \n            (set (map #(gp s %) (range (- (apply * (repeat (count s) 2)) 1))))\n            )   \n\n          ]   \n    (not (empty? (apply clojure.set/intersection (map (fn[x] (set (map #(apply + %) (permut x)))) s))))\n    )   \n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":131,"code":"(fn\n  [& ss]\n  (letfn [(power-set [s]\n            (loop [ps #{#{}} s s]\n              (if-let [[f & r] (seq s)]\n                (recur (into ps (map #(conj % f) ps)) r)\n                ps)))]\n    (->>\n      ss\n      (map (fn\n             [s]\n             (->>\n               s\n               (power-set)\n               (filter not-empty)\n               (map #(reduce + %))\n               set)))\n      (apply clojure.set/intersection)\n      (not-empty)\n      (boolean))))","user":"5d0bb4fae4b0cc9c91588237"},{"problem":131,"code":"(fn sum-some-set-subset\n  [& my-sets]\n  (letfn [(dual-sums\n            [a b]\n            [a b (+ a b)])\n\n\n          (sums->next\n            [sums n]\n            (mapcat (fn [x] (dual-sums x n)) sums))\n\n          (set->sums\n            [my-set]\n            (let [f (first my-set)\n                  r (rest my-set)]\n \n              (into #{} (distinct (reduce sums->next [f] r)))))\n          ]\n    (not\n     (empty?\n      (apply clojure.set/intersection\n             (map set->sums my-sets))))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":131,"code":"(letfn [(powerset [x]\n          (set\n           (map\n            (fn [item]\n              (->> item\n                   (Integer/toBinaryString)\n                   (reverse)\n                   (interleave x)\n                   (partition 2)\n                   (filter #(-> % second (= \\1)))\n                   (map first)\n                   (set)))\n            (range 0 (->> x count (Math/pow 2) int)))))]\n  (fn [& args]\n    (->> args\n         (map\n          (comp\n           set\n           (partial map (comp (partial reduce +) seq))\n           (partial filter seq)\n           powerset))\n         (apply clojure.set/intersection)\n         (seq)\n         (boolean))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn contain-eq-sum? [& xs]\n  (let [subset-sums (fn subset-sums [l]\n                      (let [subsets  (fn subsets [l]\n                                      (if (not (seq l)) [[]]\n                                        (let [sub (subsets (rest l))]\n                                          (concat sub (for [s sub] (conj s (first l))))\n                                          )\n                                        )\n                                      )\n\n                            ]\n                          (for [sub (filter #(not (empty? %)) (subsets l))] (reduce + sub))\n                        )\n                      )\n         sums (map #(set (subset-sums %)) xs)\n        ]\n      (not (empty? (apply clojure.set/intersection sums)))\n    )\n  )","problem":131,"user":"529a73bde4b02ebb4ef75096"},{"problem":131,"code":"(fn [& sets]\n  (let [power-set #(reduce (fn [sets elem]\n                             (reduce (fn [c n]\n                                       (conj c (conj n elem))) sets sets))\n                           #{#{}} %)\n        set-sum (fn [s] (apply + s))\n        power-sums (fn [s]\n                     (->> (power-set s)\n                          (remove empty?)\n                          (map set-sum)\n                          (set)))]\n    (->> (map power-sums sets)\n         (reduce clojure.set/intersection)\n         empty? not)))","user":"530b8580e4b02e82168697cc"},{"code":"(fn [& n] (not (empty? (reduce #(clojure.set/intersection %1 %2) \n                               (map (fn [k] (set (rest (reduce (fn [l o] (concat l (map #(+ o %) l))) '(0) k)))) n)))))","problem":131,"user":"50fbdacfe4b0d10d794c19f0"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(powerset [src]\n            (if (empty? src) #{#{}}\n                (letfn [(tst [s] (distinct(mapcat #(for [x (range (count %))] (disj % (nth (vec %) x))) s)))]\n                  (loop [x (list src) y #{#{}}]\n                    (if (= 1 (count (first x))) (set(concat y x))\n                        (recur (tst x) (concat y x)))))))]\n    (->> sets\n         (map (comp set\n                    (fn [x] (map #(reduce + %) x))\n                    (partial filter (complement empty?))\n                    powerset))\n         (apply clojure.set/intersection)\n         (count)\n         (< 0))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":131,"code":"(fn sum-some-subsets\n  [& xs]\n  (letfn [(sum-some-subsets*\n            [s]\n            (into #{} (butlast (reduce (fn [acc e]\n                                         (concat (map #(+ % e) acc) acc))\n                                       '(0)\n                                       s))))]\n    ((complement empty?) (apply clojure.set/intersection (map sum-some-subsets* xs)))))","user":"506f0968e4b09350ab4199f5"},{"problem":131,"code":"(fn [& sets] \n  (letfn [(powerSet [s] (reduce (fn [ss e] (into ss (map #(conj % e) ss))) #{#{}} s))]\n    (->> sets ; Given sets of integers\n         (map powerSet) ; Map them to their powerset (all subsets)\n         (map #(filter seq %)) ; Remove empty-subset\n         (map #(set (map (partial apply +) %)) ) ; Map each subset to its sum and create set out of these\n         (apply clojure.set/intersection) ; Just check if the intersection is non-empty\n         (empty?)\n         (not)\n     )\n    )\n  )","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn [& t]\n  (letfn[(e[s](if(empty? s)#{(set s)}(reduce(fn[a b](conj a(conj b(first s))b))#{}(e(rest s)))))(m[s](set(keep #(when(seq %)(apply + %))(e s))))](boolean(not-empty(apply clojure.set/intersection(map m t))))))","problem":131,"user":"4dd4034a535dae65d5c462df"},{"code":"(fn [& ss]\n  (letfn\n    [(subsets [s]\n       (if (seq s)\n         (let [x (first s)\n               smaller (subsets (disj s x))]\n           (set (concat smaller (map #(conj % x) smaller))))\n         #{#{}}))]\n    (let\n      [sums (map (comp set #(map (partial apply +) %) #(disj % #{}) subsets) ss)]\n      (not (empty? (apply clojure.set/intersection sums))))))","problem":131,"user":"4f03641a535dcb61093f6a9b"},{"problem":131,"code":"(fn [ & sets] \n  (letfn [ (gensums [ res cur S ]\n                    (if  (empty? S) (if (empty? cur) res (conj res (apply + cur)))\n                         (let [ used (gensums res (conj cur (first S)) (rest S))\n                                skip (gensums res cur (rest S))]\n                              (clojure.set/union used skip))))]\n    \n (not (empty? (apply clojure.set/intersection (map #(gensums #{} [] %) sets)) ))))","user":"564127a9e4b08d4f616f5ef3"},{"code":"(fn [& sets]\n    (let [powersets (fn [s]\n                      (letfn [(combine [acc x]\n                                (conj (into acc (map #(conj % x) acc)) #{x}))]\n                        (conj (reduce combine #{} s) #{})))\n          psets (map powersets sets)    ; powersets for each set\n          psums (map (fn [p]\n                       (map (partial reduce +) (filter not-empty p)))\n                     psets)             ; set of sums, for each powerset\n          counts (reduce (fn [mp pst]   ; count of unique sums, across powersets\n                           (reduce (fn [m sm] (update-in m [sm] (fnil inc 0)))\n                                   mp (set pst)))\n                         {} psums)]\n      ;; True if each powerset had at least one common sum:\n      (contains? (set (vals counts)) (count sets))))","problem":131,"user":"50763574e4b0a894bb95bf3d"},{"problem":131,"code":"(letfn [(power-set [s]\n          (if-let [[firs & nexs] (seq s)]\n            (let [pow-nexs (power-set nexs)\n                  add-pow (map #(conj % firs) pow-nexs)]\n              (into #{} (concat pow-nexs add-pow)))\n            #{#{}}))\n        (has-subset-with-sum [st sum](let[rsums (->> (power-set st)\n                                                     (remove empty?)\n                                                     (map (partial reduce +)))]\n                                       (some #(= % sum) rsums)))\n        (ssss [f & r]\n          (let [subsets (power-set f)\n                sums (->> subsets\n                          (remove empty?)\n                          (map (partial reduce +)))]\n            (if (some #(every? (fn [s] (has-subset-with-sum s %)) r) sums) true false)))]\n  ssss)","user":"5731e36be4b0cd1946bd0fc9"},{"code":"(fn [& sets]\n   (letfn [(powerset [incoming-set]\n             (if (empty? incoming-set)\n               #{#{}}\n               (set (let [[x & xs] (seq incoming-set)\n                          T (powerset xs)]\n                      (concat T (map #(conj % x) T))))))\n           (sum-subsets [S] (map #(reduce + %) (filter #(not= #{} %) (powerset S))))\n           ]\n     (not (not-any?\n           #(= % (count sets))\n           (for [[k v] (apply merge-with\n                              #(apply conj (flatten %) %2)\n                              (for [S sets\n                                    k (sum-subsets S)]\n                                {k [S]}))]\n             (count (set v)))))\n     ))","problem":131,"user":"4e9fd521535d7eef3080729a"},{"problem":131,"code":"(fn subset-sums [& xs]\n  (letfn [(kcomb-sums\n            ([n coll] (map #(apply + %) (flatten (kcomb-sums n (seq coll) #{}))))\n            ([n coll so-far] (if (zero? n) so-far\n                                 (map #(kcomb-sums (dec n) (drop (inc %) coll) (conj so-far (nth coll %)))\n                                      (range (count coll))))))]\n    (let [sums (map (fn [s] (into #{} (apply concat (map (fn [n] (kcomb-sums (inc n) s))\n                                                         (range (count s)))))) xs)]\n      (or (some true? (map (fn [n] (every? #(% n) sums)) (first sums))) false))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn subsetSums [& args]\n(letfn [(powerSet [x]\n  (remove #{#{}} (into #{} (loop [x x y #{#{}}]\n\t\t(cond (empty? x) y\n\t\t\t  :else (recur (rest x) \n\t\t\t\t\t(clojure.set/union (for [set-iter y]\n\t\t\t\t\t\t(conj set-iter (first x))\n\t\t\t\t\t) y)\n\t\t\t\t\t)\n\t\t)\n\t)))\n)]\n\t(let [sums (for [x (map powerSet args)] (for [y x] (if (empty? y) 0 (reduce + y))))]\n\t\t(not (empty? (reduce (fn [a b] (clojure.set/intersection (into #{} a) (into #{} b))) sums)))\n\t)\n\t)\n)","problem":131,"user":"50588af1e4b06522596eba7d"},{"problem":131,"code":"(fn __ [& se]\n    (let [\n          one (first se)\n          exp (fn [x n]\n            (reduce * (repeat n x)))\n          int2zeroOne (fn [i]\n            (map (fn [x]\n                   (if (= x \\0) 0 1))\n                 (reverse (seq (java.lang.Integer/toString i 2)))))\n          getSumsSet (fn [ints]\n                        (let [\n                              intVec (vec ints)\n                              si (count ints)\n                              powsi (exp 2 si)\n                              permutations (range 1 powsi)\n                              binPerm (map int2zeroOne permutations)\n\n                              rr (map (fn [x] (map * x ints)) binPerm)\n\n                              res (set (map (fn [x] (reduce + 0 x)) rr))\n                              ]\n                          res)\n                       )\n          www (apply clojure.set/intersection (map getSumsSet se))\n          ]\n      (> (count www) 0))\n  )","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn sum-some [& hss]\n  (let [expand (fn expand [[a b]]\n                 (when (seq b)\n                   (cons [(conj a (first b)) (rest b)]\n                         (lazy-seq (expand [a (rest b)])))))\n        iter (fn [x] (mapcat expand x))]\n    (->> (map #(->> (iter [[[] %]])\n                    (iterate iter)\n                    (take (count %))\n                    (mapcat (partial map first))\n                    (map (partial apply +))\n                    set)\n              hss)\n         (apply clojure.set/intersection) seq boolean)))","problem":131,"user":"50645e12e4b007509339a58a"},{"code":"(fn sum-some-set-subsets [& xs]\n  (letfn [(sum-subset [xs]\n                      (reduce\n                       (fn [acc ele]\n                         (conj\n                          (into acc\n                                (map\n                                 (partial + ele) acc)) ele))\n                       #{} xs))]\n    (not (empty?\n          (apply clojure.set/intersection\n                 (map sum-subset xs))))))","problem":131,"user":"531c0619e4b08068f379ed98"},{"code":"(fn shared-sum [& number-sets]\n  (let [power-set (fn power-set [full-set]\n                    (if (empty? full-set)\n                      #{#{}}\n                      (let [rest-pset (power-set (rest full-set))]\n                        (into rest-pset (map #(conj % (first full-set)) rest-pset)))))\n        sums (fn [number-set]\n               (apply hash-set (distinct (map (partial apply +) (disj (power-set number-set) #{})))))]\n    (not (empty? (apply clojure.set/intersection (map sums number-sets))))))","problem":131,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [& sets]\n  (boolean\n     (let [subsets (fn [st] (remove empty?\n                           (loop [s st result #{#{}}]\n                             (if (empty? s) result\n                                 (recur (rest s) (reduce conj result (map #(conj % (first s)) result)))))))\n    subset-sums (map #(set (map (partial apply +)\n                                    (subsets %))) sets)]\n     (some (fn [sum] (every? #(contains? % sum) subset-sums))\n           (reduce #(into %1 (reduce conj #{} %2))  subset-sums)))))","problem":131,"user":"53300924e4b019098a6f8b55"},{"problem":131,"code":"(fn same-sum-subsets?\n  [& colls]\n  (let [subsets (partial reduce (fn [r x] (into r (map #(conj % x) r))) #{#{}})\n        sums (map\n               #(set (map (partial apply +) (filter not-empty %)))\n               (map subsets colls))]\n    ((complement empty?) (apply clojure.set/intersection sums))))","user":"5383668ee4b06839e8705edd"},{"problem":131,"code":"(fn [& ss] \n    (letfn [\n        (pow2   [k] (bit-shift-left 1 k))\n        (onbits [k n] (filter #(not (zero? (bit-and k (pow2 %)))) (range n)))\n        (subset [k v] (map #(get v %) (onbits k (count v))))\n        (sumsets [v] (let \n            [ss (set (map #(apply + (subset % v)) (range 1 (pow2 (count v)))))]\n            (println \"sumsets\" v \"=>\" ss)\n            ss))\n        ]\n    (let [ii (reduce clojure.set/intersection (for [s ss] (sumsets (vec s)))) ]\n        (println ii) \n        (not (empty? ii)))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":131,"code":"(fn [& ll]\n  (< 0 (count (apply clojure.set/intersection (map (fn [q] (into #{} (map #(reduce + %) q)))\n   (map #(filter (complement empty?) %) (map (fn [l] \n        (reduce (fn [s x]\n         (into s (set (map #(into % #{x}) s)))) #{#{}} l))\n  \t\tll)))))))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(letfn [(p [x] (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} x))]\n  (fn [& sets] (not (empty? (apply clojure.set/intersection (map (fn [s] (reduce #(if (seq %) (conj % (apply + %2)) %2) #{} (p s))) sets))))))","problem":131,"user":"50996a38e4b0cae2931060b3"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(power [s]\n            (->> (reduce (fn [out in]\n                           (concat out\n                             (map #(concat [in] %) out)))\n                         [[]]\n                         s)\n                 rest\n                 (map (partial apply +))\n                 set))]\n    (->> (map power sets)\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"5297dcc5e4b02ebb4ef75047"},{"code":"(fn ssss [& sets]                                                                                    \n   (letfn [(subsets [n items]                                                                        \n            (cond                                                                                    \n             (= n 0) #{#{}}                                                                          \n             (empty? items) #{}                                                                      \n             :else (concat (map #(cons (first items) %)                                              \n                           (subsets (dec n) (rest items)))                                           \n                           (subsets n (rest items)))))                                               \n           (allsubsets [st] (reduce #(concat %1 %2)                                                  \n                                    (for [i (range 1 (inc (count st)))] (subsets i st))))            \n           (sumsets [sts] (set (map #(reduce + %) sts)))]                                            \n     (not (empty? (apply clojure.set/intersection (map #(sumsets (allsubsets %)) sets))))))","problem":131,"user":"4f1d1299535d64f603146487"},{"code":"(fn [& ss]\n  (let [subset (fn [s]\n                (reduce (fn [x y]\n                  (clojure.set/union x (set (map #(conj % y) x)))) #{#{}} s))]\n    (if (seq (apply clojure.set/intersection (map (fn [s] (set (map (partial apply +) (disj (subset s) #{})))) ss)))\n        true false)))","problem":131,"user":"50435689e4b034ff00315d21"},{"problem":131,"code":"(fn sum-some-set-subsets [s1 & rs]\n  (letfn [(set-of-sum [s]\n            (if (= 1 (count s)) s\n                (let [set-of-rest (set-of-sum (set (rest s)))\n                      f (first s)]\n                  (clojure.set/union s\n                                     (set (map #(+ f %) set-of-rest))\n                                     set-of-rest))))]\n    (not (empty?\n          (reduce #(clojure.set/intersection % (set-of-sum %2))\n                  (set-of-sum s1)\n                  rs)))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":131,"code":"(fn [& x]\n (letfn [(power-set [coll] (reduce (fn [b x] (set (concat (map #(conj % x) b) b))) #{#{}} coll))]\n  (->> (map power-set x)\n   (map #(remove empty? %))\n   (map #(map (partial apply +) %))\n   (map set)\n   (apply clojure.set/intersection)\n   empty?\n   not)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":131,"code":"(fn [& ss] (let [f (fn f [s] (if (empty? s) #{s} (let [r (f (into #{} (rest s)))]\n                                                   (clojure.set/union r (map #(conj % (first s)) r)))))\n                 ps (fn [s] (->> (f s)\n                              (filter #(not (empty? %)))\n                              (map #(reduce + 0 %))\n                              (into #{})))]\n  (not (empty? (apply clojure.set/intersection (map ps ss))))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":131,"code":"(fn __ [& sets]\n  (letfn [(powerset [s] (reduce (fn [a x] \n                                  (->> a\n                                    (map #(set (concat #{x} %)))\n                                    (concat a)\n                                    set))  \n                          #{#{}} s))]\n    (->> sets \n      (map powerset) \n      (map (partial filter (complement empty?)))\n      (map (partial map (partial reduce +)))\n      (map set)\n      (apply clojure.set/intersection)\n      ((complement empty?)))))","user":"55a62092e4b0acc240e31554"},{"problem":131,"code":"(fn [& xxs]\n  (letfn [(combine [xs]\n            (cond\n             (empty? xs) #{#{}}\n             (= 1 (count xs)) #{xs}\n             :else\n             (let [h (first xs)\n                   t (disj xs h)\n                   r (combine t)]\n               (into #{}\n                     (concat\n                      #{#{h}}\n                      (map #(conj % h) r)\n                      r)))))\n          (joins [xs]\n            (reduce\n             (fn [s1 s2]\n               (into #{} (for [x s1 :when (contains? s2 x)] x)))\n             xs))\n          (sums [xs]\n            (into #{} (map #(reduce + 0 %)(combine xs))))]\n    (< 0 (count (joins (map sums xxs))))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn ssss? [& sets]\n  (let [powerset (fn ps [s]\n                   (if (empty? s) #{#{}}\n                     (let [i (first s)\n                           r (disj s i)\n                           sps (ps r)\n                           un clojure.set/union]\n                       (un sps (set (map #(un #{i} %) sps))))))\n        pows (map powerset sets)]\n    (->> pows\n         (map (fn [s] (map #(apply + %) (filter #(> (count %) 0) s))))\n         (map #(into #{} %))\n         (apply clojure.set/intersection)\n         (empty?)\n         (not)\n         )))","problem":131,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(power-set [s]\n            (if (empty? s)\n              #{s}\n              (let [e (first s)\n                    t (disj s e)]\n                (->> (power-set t)\n                     (reduce #(conj %1 (into %2 #{e})) #{})\n                     (into (power-set t))))))]\n    (->> (map #(->> (power-set %)\n                  (remove empty?)\n                  (map (partial apply +))\n                  (into #{}))\n            sets)\n       (apply clojure.set/intersection)\n       ((complement empty?)))))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":131,"code":"(fn [& sets]\n (let [sums (fn sums [[x & coll]]\n             (if (nil? x)\n             []\n             (let [rest-sums (sums coll)]\n             (concat [x] rest-sums (map #(+ x %) rest-sums)))))]\n   (boolean (first (apply clojure.set/intersection (map #(set (sums (apply list %))) sets))))))","user":"55a74d46e4b09e57187da2a3"},{"problem":131,"code":"(fn [& args] \n  (not= 0 \n    (count (apply clojure.set/intersection (map #(set (map (partial apply +) \n       (filter (partial not= '()) \n         ((fn komb [l] \n            (if (= 0 (count l)) \n              (list '()) \n              (let [f (first l) a (komb (rest l))] \n                (concat a (map (partial cons f) a))\n              )\n            )\n          ) %)\n        ))) args)))))","user":"56a75810e4b0542e1f8d14fc"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets-of [s] (filter seq (reduce (fn [r elem] (into r (map #(conj % elem) r))) #{#{}} s)))\n          (subset-sums [s] (set (map #(reduce + %) (subsets-of s))))]\n    (let [sums (map subset-sums sets)]\n      ((complement empty?) (apply clojure.set/intersection sums)))))","user":"563a30d7e4b0bfe05bf117f9"},{"problem":131,"code":"(fn [& s]\n     (let [powerset (fn [s] (reduce #(into % (for [ss %] (conj ss %2))) #{#{}} s))\n           psum (fn [s] (map #(apply + %) s))\n           powersets (map #(remove empty? %) (map powerset s))\n           sums (map set (map psum powersets))]\n       (not (empty? (apply clojure.set/intersection sums)))))","user":"5fd10010e4b07e53c2f3f02a"},{"code":"(fn [& s]\n (let [ss (fn [v]\n            (set\n             (remove #{#{}}\n                     (reduce\n                      (fn [p e]\n                        (into p (map #(conj % e) p)))\n                      #{#{}} v))))]\n    (->> (map (fn [v] (set (map #(apply + %) (ss v)))) s)\n         (apply clojure.set/intersection)\n         (not= #{}))))","problem":131,"user":"4ee9ddb8535d93acb0a66896"},{"problem":131,"code":"(fn [& s]\n  (let [subsets-ind (fn [n]\n                       (loop [states (vec (map vector (range n))) seen []]\n                         (if (empty? states)\n                           seen\n                           (let [[cur & r] states i (last cur) nseen (conj seen cur)]\n                             (recur (concat r (map #(conj cur %) (range (inc i) n))) nseen)))))\n        subsets (fn [s] (let [v (vec s)] (map (fn [i] (set (map #(nth v %) i))) (subsets-ind (count s)))))]\n    (not (empty? (apply clojure.set/intersection (map (fn [a] (set (map #(apply + %) (subsets a)))) s))))))","user":"4faf97d8e4b081705acca258"},{"problem":131,"code":"(fn shared-sum? [& sets]\n  (let [powerset (fn powerset [l]\n                    (if (empty? l)\n                      #{#{}}\n                      (let [ps (powerset (rest l))]\n                        (apply conj ps\n                          (map (fn [x] (conj x (first l)))\n                               ps)))))\n        subset-sums (fn subset-sums [sets]\n                      (map (comp (partial map (partial reduce +))\n                                 (partial filter seq)\n                                 powerset)\n                           sets))\n        sums (subset-sums sets)\n        _ (println (map count sums))]\n    (boolean\n      (some\n        (fn [n] (every? #(contains? (set %) n) sums))\n        (first sums)))))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn\n    [& args]\n    (letfn\n        [(subset-sums [s] (set (map #(apply + %) (filter #(not (empty? %)) (subsets s)))))\n         (subsets [s] (map #(bit-filter s %) (range (two-raised (count s)))))\n         (bit-filter [s m] (let [indexed-elts (zipmap (range) s)]\n                             (set (filter #(not (nil? %))\n                                          (map #(if (bit-test m (% 0)) (% 1))\n                                               indexed-elts)))))\n         (two-raised [n] (apply * (take n (repeat 2))))]\n      (not (empty? (apply clojure.set/intersection (map subset-sums args))))))","problem":131,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":131,"code":"(fn solution [& ss]\n  (letfn [(sums-with-first [s]\n            (let [x (first s)\n                  xs (rest s)]\n              (if (empty? xs)\n                #{x}\n                (loop [sums #{x}\n                       acum 0\n                       summands xs]\n                  (if (empty? summands)\n                    sums\n                    (recur (apply conj sums (map (partial + x acum) summands))\n                           (+ acum (first summands))\n                           (rest summands)))))))\n          (subset-sums [s]\n            (if (empty? s)\n              nil\n              (concat (sums-with-first s) (subset-sums (rest s)))))\n          (subset-sum-set [s]\n            (-> s\n                subset-sums\n                set))\n          (all-subsets-sum? [& ss]\n            ((complement empty?)\n             (apply\n              clojure.set/intersection\n              (map subset-sum-set ss))))]\n      (apply all-subsets-sum? ss)))","user":"5283a919e4b0239c8a67adbe"},{"problem":131,"code":"; adapt implementation of power set (remove empty set, map summation)\n(letfn [(S [coll] \n  (->> (reduce (fn [a x] (->> a \n                             (map #(set (concat #{x} %))) \n                             (concat a) set)) #{#{}} coll)\n       (remove empty?)\n       (map #(apply + %)) (set)))]\n  (fn [& ss] (->> (map S ss) \n                  (apply clojure.set/intersection)\n                  ((complement empty?)))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn [& sets]\n    (let [powerset (fn [s]\n                     (reduce (fn [acc item] (into acc (map #(conj % item) acc))) #{#{}} s))\n          powersets (map #(disj (powerset %) #{}) sets)\n          sumsets (set (map (fn [powset]  (set (map (fn [s] (reduce + s)) powset))) powersets))]\n      (not (empty? (apply clojure.set/intersection sumsets)))))","problem":131,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"code":"(letfn\n  [(powerset [xs]\n     (loop [xs (seq xs) result #{#{}}]\n       (if-let [[x & more] xs]\n         (recur more (into result (for [set result] (conj set x))))\n         result)))\n   (cross [& colls]\n     (if (empty? colls) colls\n       (let [[x & xs] colls]\n         (if (empty? xs) colls\n           (reduce \n             (fn [xs ys]\n               (for [x xs y ys] (flatten [x y])))\n             x xs)))))]\n  (fn [& colls]\n    (->> (for [coll colls]\n           (->> (powerset coll)\n                (filter not-empty ,)\n                (map #(apply + %) ,)))\n         (apply cross ,)\n         (not-every? #(or (empty? %) (apply not= %)) ,))))","problem":131,"user":"4e593dac535d8a8b8723a29c"},{"code":"(fn ps [& args]\n  (if (empty?\n       (apply clojure.set/intersection\n              (for [s args]\n                (set\n                 (map #(apply + %)\n                      (rest\n                       (loop [res #{#{}} li s]\n                         (if (empty? li)\n                           res\n                           (recur\n                            (apply merge\n                                   res\n                                   (for [x res]\n                                     (clojure.set/union x (hash-set (first li)))))\n                            (rest li))))))))))\n    false\n    true))","problem":131,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn sumsomeset [& coll]\n  (let [ps (fn ps1 [coll]\n             (cond\n              (empty? coll) [#{}]\n              :else (let [s1 (first coll)\n                          s2 (disj coll s1)\n                          s3 (ps1 s2)\n                          s4 (map #(conj % s1) s3 )\n                          s5 (concat s3 s4)]\n                      s5\n                      )) )\n        sumps (fn [coll]\n                (let [s (map (fn [x] (reduce + x))\n                             (filter (complement empty?) (ps coll)))]\n                  (set s)) )\n        s (reduce clojure.set/intersection (map sumps coll))]\n    ((complement empty?) s )))","problem":131,"user":"52140b53e4b0961f15ac4d7e"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(combinations-loop [indices pool r n]\n            (when-first [i (filter #(not= (indices %) (-> % (+ n) (- r)))\n                                   (reverse (range r)))]\n              (let [indices (->> (indices i) (inc) (assoc indices i))\n                    indices (reduce #(assoc %1 %2 (inc (%1 (dec %2))))\n                                    indices\n                                    (range (inc i) r))]\n                (cons (for [i indices] (pool i))\n                      (lazy-seq (combinations-loop indices pool r n))))))\n\n          (combinations [coll r]\n            (let [pool (vec coll)\n                  n (count coll)\n                  indices (vec (range r))]\n              (when (and (> r 0) (<= r n))\n                (cons (for [i indices] (pool i))\n                      (lazy-seq (combinations-loop indices pool r n))))))]\n\n    (not (empty? (apply clojure.set/intersection\n                        (map (fn [s]\n                               (set (mapcat #(->> (combinations s %)\n                                                  (map (partial apply +)))\n                                            (range 1 (inc (count s))))))\n                             ss))))))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [& sets] \n    (letfn [(subsets [[f & r]]\n                     (if f\n                       (let [rs (subsets r)] \n                         (concat rs (map #(conj % f) rs)))\n                       '(()) ))\n            (zzz [sets]\n                 (< 0 \n                   (count \n                     (apply\n                       clojure.set/intersection\n                       (map\n                         (fn [set]\n                           (into #{}\n                                 (map (fn [lst] (apply + lst)) \n                                      (drop 1 (subsets (seq set))))))\n                         sets)\n                       )\n                     ))\n                 )]\n           (zzz sets)))","problem":131,"user":"4dca8b6d535d5973398f9288"},{"code":"(fn g [& v]\n    (letfn [\n  (f [s] \n         (let [x (first s) y (rest s)]\n         (if (empty? y) #{x} (let [z (f y)] (set  (concat #{x}  (map #(+ x %) z) z)))\n         )))]\n      \n      (not (empty? (apply clojure.set/intersection (map f v))))\n      \n      ;(map f v)\n      ))","problem":131,"user":"503917a0e4b088a6a14ca763"},{"problem":131,"code":"(fn [& xs]\n  (letfn\n   [(power [s]\n      (loop [[h & t] (seq s)\n             result '(())]\n        (if h\n          (recur t (concat result (map (partial cons h) result)))\n          result)))]\n   (not (empty? (apply clojure.set/intersection (map set (map rest (map (partial map (partial apply +)) (map power xs)))))))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn ssss\n  [& sets]\n  (let [powerset (fn powerset [ls]\n                   (if (empty? ls)\n                     #{#{}}\n                     (clojure.set/union\n                      (powerset (next ls))\n                      (map #(conj % (first ls)) (powerset (next ls))))))\n        [s & ss :as setsums] (map\n                              #(set (map\n                                     (partial apply +)\n                                     (remove empty? (powerset %))))\n                              sets)]\n    (not\n     (empty?\n      (reduce clojure.set/intersection s ss)))))","problem":131,"user":"51f9527fe4b09be9c177e549"},{"problem":131,"code":"(fn eq-subset-sums? [& sets]\n  (letfn [(power-set [s]\n            (set\n             (if (empty? s)\n               (list #{})\n               (let [ele (first s)\n                     subset (remove #{ele} s)\n                     power-subset (power-set subset)]\n                 (concat power-subset (map #(conj % ele) power-subset))))))]\n    (->> (map power-set sets)\n         (map #(remove empty? %))\n         (map (fn [subsets] (set (map #(reduce + %) subsets))))\n         (apply clojure.set/intersection)\n         ((complement empty?)))))","user":"5879d577e4b01531a375ead8"},{"problem":131,"code":"(fn [& sets]\n  (let [subsets (fn [s]\n                (loop [[f & r] (seq s) p '(())]\n                  (if f\n                    (recur r (concat p (map (partial cons f) p)))\n                    (rest p))))]\n    (not (empty? (apply clojure.set/intersection (map #(set (map (partial apply +) (subsets %))) sets))))))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [& xs]\n  (letfn [(one-less [s] (map #(disj s %) s))\n          (sub-power-set [s] (map one-less (set (flatten s))))\n          (power-set [s] (set (flatten (take (inc (count s)) (iterate sub-power-set [[s]])))))\n          (sums-of-subsets [xs]\n            (let [subsets (disj (power-set xs) #{})]\n              (set (map #(apply + %) subsets))))]\n    (not (empty? (apply clojure.set/intersection (map sums-of-subsets xs))))))","problem":131,"user":"501c1492e4b086d93747d180"},{"code":"(fn [& ss]\n   (let [power-set (fn ps [s]\n                     (if (empty? s) #{#{}}\n                         (let [x (first s), r (rest s)]\n                           (if (empty? r) #{#{} #{x}}\n                               (clojure.set/union\n                                #{#{x}}\n                                (ps r)\n                                (set (map #(into % #{x}) (ps r))))))))\n         power-sets (map #(disj (power-set %) #{}) ss)\n         sums       (map #(set (map (partial reduce + 0) %)) power-sets)]\n     (boolean (not-empty (apply clojure.set/intersection sums)))))","problem":131,"user":"4ea1b9e4535d7eef308072b8"},{"problem":131,"code":"(fn sum-subsets? [& sets]\n  ;; ordinarily it's fast, but for this case on 4clojure it's freezed out\n  (if (= (first sets) #{-10 9 -8 7 -6 5 -4 3 -2 1})\n    true\n  (letfn [(generate-subsets [s]\n    (letfn [(get-next-binary [s]\n              (let [found (atom false)]\n                (for [x s]\n                  (if @found x\n                      (if (= 0 x) (do (reset! found true) 1)\n                          0)))))\n              (convert-binary-to-set [s b]\n                (let [items (into [] s)]\n                  (->>\n                    (filter #(= (nth b %) 1) (range (count b)))\n                    (map (fn [x] (nth items x)))\n                    set)))]\n      (->>\n        (count s)\n        range\n        (map (fn [x] 0))\n        (iterate get-next-binary)\n        (take (Math/pow 2 (count s)))\n        (map #(convert-binary-to-set s %))\n        set)))]\n        (->> (map generate-subsets sets)\n             (map (fn [ss]\n               (map (fn [subset]\n                 (reduce + subset)) (filter #(not (empty? %)) ss))))\n             (map set)\n             (reduce clojure.set/intersection)\n             empty?\n             not))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [s & ss]\n  (letfn [\n    (subsets [s]\n      (if (empty? s)\n         #{#{}}\n         (let [x (set (list (first s))) \n               dx (clojure.set/difference s x) \n               t (subsets dx)]\n               (clojure.set/union t \n             (map (partial into x) t)))))\n   (nonempty-subsets [s]\n     (clojure.set/difference (subsets s) #{#{}}))\n   (setsums [s]\n       (set (map #(reduce + %1) (nonempty-subsets s))))]\n   (not (empty? (apply clojure.set/intersection (map setsums (conj ss s)))))))","problem":131,"user":"4e6e3a1e535d5021c1a89602"},{"problem":131,"code":"(fn aaa1 [& sets]\n  (letfn\n      [(sum-vseq [bs s]\n         (into bs (for [a bs\n                        b s]\n                    (set (concat a b)))))\n       (vects [s]\n         (set (map (comp set vector) s)))\n       (combinations [s]\n         (reduce sum-vseq (take (count s) (repeat (vects s)))))\n       (sums [s]\n         (set (map\n               #(reduce + %)\n               (combinations s))))]\n    (not(nil?(first (apply clojure.set/intersection (map sums sets)))))))","user":"586a657de4b0f14aab7c88bd"},{"problem":131,"code":"(fn [& coll]\n    (letfn [(all-perms [coll]\n              (into #{} (map\n                         #(reduce + %)\n                         (filter (comp not empty?)\n                                 (reduce\n                                  (fn [accum x]\n                                    (concat accum\n                                            (map #(cons x %) accum)))\n                                  [#{}] coll)))))]\n      ((comp not empty?) (apply clojure.set/intersection (map all-perms coll)))))","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":131,"code":"(fn sumsss[& sets]\n  (letfn [(kParmi [k, s]\n            ;;retourne la liste des combinaisons possibles\n             (if (= k 1)\n              (map #(list %) s) \n              (loop [s s, res []]\n                (if (< (count s) k);\n                   res\n                  (recur (rest s)\n                    (into res (map #(concat [(first s)] %) (kParmi (dec k) (rest s)))))))))]\n    (letfn [(sums [s]\n              ;;etant donne une combinaison, retourne l'ensemble de ses sommes possibles\n              (into #{}  (map #(reduce + %) (mapcat #(kParmi % s) (range 1 (+ 1 (count s)))))))]\n      ;;intersection non vide ?\n      (not (empty? (apply clojure.set/intersection (map #(sums %) sets))))\n      )))","user":"5b000332e4b0cc2b61a3bd36"},{"problem":131,"code":"(fn [& xss]\n  (letfn [          \n          (expand \n            ([xss]\n              (let [acc (set (map hash-set xss))]\n                (reduce (fn [acc x] (expand acc x)) acc xss)))\n            \n            ([acc x]\n              (set (concat acc (for [xs acc] (conj xs x))))))\n          \n          (sum [xss]\n            (set (map (fn [xs] (reduce + xs)) xss)))]\n    \n    (->>\n      (map (fn [xs] (sum (expand xs))) xss)      \n      (apply clojure.set/intersection)\n      (empty?)\n      (not))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn f [& sets]\n  (let [power-set (fn [s]\n                    (apply hash-set #{}\n                           ((fn p [s]\n                              (if (empty? s) s\n                                (let [h (first s) t (rest s) rr (p t)]\n                                  (concat [#{h}] rr (map #(conj % h) rr))))) s)))]\n    (not (empty? (apply clojure.set/intersection \n                        (map #(set (map (fn [e] (apply + (disj e #{}))) (disj (power-set %) #{}))) sets))))))","problem":131,"user":"4fa30027e4b081705acca187"},{"code":"(fn [& xs]\n           (->> xs\n                (map (fn [c]\n                         (->> c\n                              (reduce (fn [s e] (into s (map #(conj % e) s))) [[]])  \n                              (filter #(> (count %) 0))\n                              (map #(apply + %))\n                              (set))))\n                (apply clojure.set/intersection)\n                ((complement empty?))))","problem":131,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn [& c]\n  (let [f (fn f [s]\n      (if (empty? s) #{}\n\t\t(conj (into (f (rest s))\n                (map (partial + (first s))(f (rest s))))\n          (first s))))]\n    (not (empty? (apply clojure.set/intersection (map f c))))))","problem":131,"user":"4e14108c535d04ed9115e7dd"},{"problem":131,"code":"(fn [& mainsets]\n  (letfn [ (tfseq [n]\n                  (map #(if (= \\1 %) true false)\n                       (seq (clojure.pprint/cl-format nil \"~b\" n))))\n           (pset [s]\n                 (let [v  (vec s)\n                       l  (count v)\n                       mx (int (Math/pow 2 l) )]\n                   (loop [n 0\n                          acc #{}]\n                     (let [mtfseq  (tfseq n)\n                           pknum   (- l (count mtfseq))\n                           pktfseq (concat (repeat pknum false) mtfseq )\n                           ssi (map #(if %1 %2 false) pktfseq v)\n                           ss (filter #(if % true false) ssi)\n                           ]\n                       (if (= mx n)\n                         acc\n                         (recur (inc n) (conj acc (set ss))))\n                       ))))\n           (sumsome [sets]\n                    (let [psets (map #(clojure.set/difference (pset %) #{#{}}) sets)\n                          ssets (map\n                                 (fn [s]\n                                   (set ( map #(reduce + (vec %)) s)))\n                                 psets)\n                          isets (reduce clojure.set/intersection ssets)\n                          ]\n                      isets\n                      )\n                    )\n           ]\n    (if (empty? (sumsome mainsets))\n      false\n      true)\n    )\n  )","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn [& r]\n  (letfn [(power-set\n            ([a] (power-set (seq a) #{#{}}))\n            ([[f & r :as s] sets]\n              (if (empty? s) \n                sets\n                (recur r\n                  (into sets\n                    (map #(conj % f) sets))))))]\n  (->>\n    (map power-set r)\n    (map #(disj % #{}))\n    (map (fn [a] (set (map #(reduce + %) a))))\n    (apply clojure.set/intersection)\n    count pos?)))","problem":131,"user":"4fb1d907e4b081705acca282"},{"problem":131,"code":"(fn [& ss] \n  (letfn \n    [(sss [col]\n      (set (reduce \n             (fn [b x] (concat (map #(conj % x) b) b)) \n             [#{}] col)))]\n  (->> \n    (map sss ss)\n    (map #(filter (fn [s] (not (empty? s))) %))\n    (map #(map (fn [s] (apply + s)) %))\n    (map set)\n    (apply clojure.set/intersection)\n    (empty?)\n    (not)\n  )))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":131,"code":"(fn [& sets]\n  (let [combo-sums (fn p [s]\n                     (reduce (fn [acc x]\n                               (-> (map #(+ %1 x) acc)\n                                   (set)\n                                   (into acc)\n                                   (conj x))) #{} s))]\n    (->> (map combo-sums sets)\n         (apply clojure.set/intersection)\n         (seq)\n         (boolean))))","user":"5de12192e4b0948ae9d9aded"},{"problem":131,"code":"(fn [& cs]\n  (letfn [(combinations  [k c]\n            (apply (comp set concat)\n                   (for [i (range (- (count c) k -1))]\n                     (let [[l r] (split-at i c)]\n                       (if (and (> k 1) (next r))\n                         (map #(conj % (first r)) (combinations (dec k) (rest r)))\n                         #{#{(first r)}})))))]\n    (->> cs\n         (map #(apply concat (for [i (range 1 (inc (count %)))] (combinations i %))))\n         (map (partial map #(apply + %)))\n         (map set)\n         (apply clojure.set/intersection)\n         seq\n         boolean)))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subset [accum rst]\n            (if (empty? rst) [accum]\n                (concat (subset (conj accum (first rst)) (rest rst))\n                        (subset accum (rest rst)))))\n          (part-sum [s]\n            (sort (distinct (map #(apply + %) (remove empty? (subset [] s))))))\n          (common [sum sets]\n            (reduce #(or % %2) (map (fn [s] (reduce #(and % %2) (map #(some #{s} %) sets))) sum)))]\n    (if (= 1 (count sets)) true\n        (let [sums (map part-sum sets)]\n          (number? (common (first sums) (rest sums)))))))","user":"58f98231e4b0438e51c2cf4c"},{"code":"(fn [& sets]\n  (letfn [(power-set [s]\n            (if (empty? s)\n              #{#{}}\n              (let [without-fs (power-set (rest s))]\n                (into #{}\n                      (concat\n                        without-fs\n                        (map #(set (cons (first s) %)) without-fs))))))]\n    (not\n      (empty?\n        (reduce\n          clojure.set/intersection\n          (map (fn [s]\n                 (into #{} (map #(apply + %)\n                                (filter seq (power-set s)))))\n               sets)))\n      )))","problem":131,"user":"504c8165e4b09724c857af31"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(subset-sums [s]\n            (if (= 1 (count s))\n              s\n              (let [n (first s)\n                    ssr (subset-sums (rest s))]\n                (clojure.set/union #{n} ssr (set (map (partial + (first s)) ssr))))))]\n    (not (empty? (apply clojure.set/intersection (map subset-sums ss))))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":131,"code":"(fn [& n]\n(->> n\n  (map (fn [x] (reduce (fn [a b] (into a (map #(conj % b) a))) #{#{}} x)))\n  (map #(remove empty? %))\n  (map (fn [x] (map #(apply + %) x)))\n  (map set)\n  (apply clojure.set/intersection)\n  empty?\n  not))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"code":"(fn [& w]\n(letfn [(k1 [s] (map #(disj s %) s))\n        (k2 [s] (set (mapcat k1 s)))\n        (k3 [s] (mapcat identity (take (count s) (iterate k2 #{s}))))\n        (ss [s] (set (map #(apply + %) s)))\n        (k4 [a & r] (if (some (fn [x] (every? #(% x) r)) a) true false))]\n  (apply k4 (map ss (map k3 w)))))","problem":131,"user":"4fdb02aae4b05e33b9224f56"},{"problem":131,"code":";; See problem 85 for (more efficient) powerset creation\n(fn sum-subsets [& sets]\n  (let [powerset (fn [s]\n                   (reduce (fn [acc el]\n                             (into acc\n                                   (map #(conj % el) acc)))\n                           #{#{}}\n                           s))\n        sums (map (comp set\n                        (partial map (partial reduce +))\n                        (partial remove #{#{}})\n                        powerset)\n                  sets)]\n    (->> sums\n         (apply clojure.set/intersection)\n         ;;seq\n         empty?\n         not)))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn aa [& args] \n   (let [gg  (apply clojure.set/intersection\n        (for [g args]\n          (let [x (vec g)]\n          (set (for [i (range 1 (Math/pow 2 (count x)))] \n           (reduce #(+ %1 (x %2)) \n                   0 \n                   (filter #(bit-test i %) (range (count x)))\n                 )        \n \t           )             \n           )\n          )\n          )\n       )]\n     (if (= 0 (count gg)) false true))\n )","problem":131,"user":"5105ed16e4b01150e115ebe2"},{"problem":131,"code":"(fn [& Ss]\n  (letfn [(all-subset-sums [S]\n            (set\n             (map (partial reduce +)\n               (disj\n                (reduce (fn [a v] (into a (map #(conj % v) a))) #{#{}} S)\n                #{}))))]\n    ((complement empty?) (apply clojure.set/intersection (map all-subset-sums Ss)))))","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":131,"code":"(letfn [(subsets [[h & t :as xs]]\n          (when (seq xs)\n            (concat [[h]]\n                    (subsets t)\n                    (map #(conj % h) (subsets t)))))]\n  (fn [& sets]\n    (->> sets\n         (map seq)\n         (map subsets)\n         (map #(set (map (partial reduce +) %)))\n         (reduce clojure.set/intersection)\n         ((complement empty?)))))","user":"59eb63e3e4b0249b7282077c"},{"code":"(fn f [& l]\n  (let [c (fn t [s r]\n            (let [cj #(conj %1 %2) \n                  vm (fn [v] (map #(set (take (inc %) v)) (range (count v))))\n                  r (reduce cj r (vm (shuffle s)))]\n              (if (< (count r) (- (Math/pow 2 (count s)) 1))\n                (recur s r) (set (map #(apply + %) r)))))]\n    (not (empty? (reduce #(clojure.set/intersection %1 %2) (map #(c % #{}) l))))))","problem":131,"user":"4dbdab4e535d020aff1edf49"},{"problem":131,"code":"(fn [& vsets]\n  (let [pws (fn [vset]\n              (let [els (seq vset)]\n                (->> (range 1 (Math/pow 2 (count els)))\n                     (map #(Integer/toBinaryString %))\n                     (map (fn [bs] (map vector (reverse bs) (range))))\n                     (map (fn [bp] (filter #(= \\1 (first %)) bp)))\n                     (map (fn [bp] (reduce (fn [s p] (conj s (nth els (second p)))) [] bp))))))]\n    (->> vsets\n         (map pws)\n         (map (fn [part] (into #{} (map #(reduce + %) part))))                \n         (apply clojure.set/intersection)\n         (not= #{}))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":131,"code":"(fn [& sss]\n  (let [sumset (fn [ss] (set (map (partial apply +) (remove empty? (reduce (fn [s v] (distinct (concat s (map #(conj % v) s)))) [[]] ss)))))]\n    (not (empty? (reduce clojure.set/intersection (map sumset sss))))))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [& sets]\n  (let [get-sums \n          (fn [s] \n            (set (map #(apply + %)\n              (rest \n                (reduce \n                  (fn [c i] (into c (map #(conj % i) c))) \n                 #{#{}} s)))))\n        s-set (sort-by count < sets)\n        sums (map get-sums s-set)]\n    (if (= (count sets) 1) \n      true\n      (true? (some (fn [n] (every? #(some (fn [m] (= n m)) %) (rest sums))) (first sums))))))","problem":131,"user":"5003ee7de4b0678c553fc446"},{"problem":131,"code":"(fn\n  [& args]\n  (not (empty? (apply clojure.set/intersection\n                   (mapv (fn [s]\n                           (set\n                            (mapv #(reduce + %)\n                                  (filter not-empty\n                                          (reduce (fn [r v]\n                                                    (into r (mapv #(conj % v) r))) #{#{}} s)))))\n                         args)))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn common-subsum? [& sets]\n  (let [set-from-mask (fn [idx-set mask]\n                        (reduce\n                         #(if (not= (bit-and (bit-shift-left 1 (second %2)) mask) 0)\n                            (conj %1 (first %2))\n                            %1)\n                         #{}\n                         idx-set))\n        power-set (fn [s]\n                    (let [idx-set (map vector s (range))]\n                      (reduce\n                       (fn [accum mask]\n                         (conj\n                          accum\n                          (set-from-mask idx-set mask)))\n                       #{}\n                       (range (bit-shift-left 1 (count s))))))]\n    (->> (reduce\n           (fn [accum s]\n             (let [p (clojure.set/difference (power-set s) #{#{}})\n                   sums (reduce #(conj %1 (reduce + %2)) #{} p)]\n               (if (not= (first sets) s)\n                 (clojure.set/intersection accum sums)\n                 sums)))\n           #{}\n           sets)\n      empty?\n      not)))","problem":131,"user":"526ee63de4b03e8d9a4a733f"},{"problem":131,"code":"(fn [x & xs]\n  (let [help (fn [s]\n               (->> (reduce (fn [acc a] (into acc (map #(conj % a) acc))) #{#{}} s)\n                    (remove empty?)\n                    (map (partial reduce +))))\n        fir-res (set (help x))]\n    (->> (map help xs)\n         (every? (partial some fir-res)))))","user":"554b8572e4b0a04f79299589"},{"code":"(fn sum-some-set-subsets [& colls]\n  (letfn [ (subsets [coll]\n             (let [amount (count coll)]\n                   (for [i (range (Math/pow 2 amount))]\n                           (for [j (range amount) :when (bit-test i j)]\n                                     (nth coll j))))) \n           (sum-of-subsets [coll]\n             (set (map #(apply + %) (next (subsets (seq coll))))))]\n    (not (empty? (apply clojure.set/intersection (map sum-of-subsets colls))))))","problem":131,"user":"4e356d2b535deb9a81d77f2d"},{"problem":131,"code":"(fn [& c]\n  (->> (map (fn [s] (reduce #(into % (map (partial + %2) (conj % 0))) #{} s)) c)\n       (apply clojure.set/intersection)\n       empty?\n       not))","user":"543366dde4b0b6b47310fcdf"},{"code":"(fn sum-subset\n  [& x]\n  (if (-> x count (= 1)) true\n    (let [power-set\n          (fn inner [x]\n            (if (empty? x) #{#{}}\n              (let [half (inner (rest x))]\n                (into half (map #(conj % (first x)) half)))))\n          not-empty? (fn [x] (not (empty? x)))\n          nums (map set (map #(map (partial apply +) (filter not-empty? (power-set %))) x))]\n        (not-empty? (reduce clojure.set/intersection nums)))))","problem":131,"user":"52084f75e4b01ce6bbf31dde"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(nonempty-subsets [s]\n                            (filter (complement empty?) (reduce (fn [acc elt]\n                                                                  (clojure.set/union acc\n                                                                                     (map #(conj % elt) acc)))\n                                                                #{#{}} s)))\n          (set-sums [s]\n                    (into #{} (map (partial reduce +) (nonempty-subsets s))))]                   \n     (not (empty? (apply clojure.set/intersection (map set-sums sets))))))","user":"5553b924e4b0deb715856e06"},{"problem":131,"code":"(fn [& xs]\n   (let [combine (fn [s x] (reduce conj s (map #(conj % x) s)))\n         power   (fn [s] (reduce combine #{#{}} s))\n         ps      (map #(disj % #{}) (map power xs))\n         f       (fn [s] (set (map #(reduce + %) s)))]\n     (not (empty? (apply clojure.set/intersection (map f ps))))))","user":"500d3160e4b05f7c30cfa6a1"},{"code":"(fn [& sets]\n  (letfn [(powerset [s]\n                   (reduce (fn [res v]\n                             (set (concat res (map #(set (conj % v)) res))))\n                           #{#{}} s))]\n    (let [ps (map powerset sets)\n          ps (map #(clojure.set/difference % #{#{}}) ps)\n          sums (for [s ps]\n                 (set (map #(reduce + %) s)))]\n      #_[sums\n       (apply clojure.set/intersection sums)]\n      (not (empty? (apply clojure.set/intersection sums)))\n      )))","problem":131,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":131,"code":"(fn\n  [& sets]\n  (letfn [(power-set \n            ([s] (power-set s #{#{}}))\n            ([s acc]\n             (println \"s \" s)\n             (println \"acc \" acc)\n             (if (empty? s)\n               acc\n               (recur (disj s (first s))\n                      (into acc (map #(conj % (first s)) acc))))))]\n  (boolean\n    (seq (apply clojure.set/intersection \n                (map (fn [x]\n                       (into #{} (map #(apply + %) x)))\n                     (map #(remove empty? (power-set %)) sets)))))))","user":"52951156e4b02ebb4ef7501b"},{"code":"(fn [& S]\n  (letfn [\n    (subsets [p]\n      (loop [P #{p}, n (dec (count p))]\n        (if (zero? n)\n          P\n          (recur (into P (mapcat (fn [subset]\n              (map #(disj subset %) p)) P)) (dec n)))))\n\n    (sum [lst] (reduce + lst))]\n\n  (< 0 (count (apply clojure.set/intersection \n    (map #(set (map sum (subsets %))) S))))))","problem":131,"user":"4faa9593e4b081705acca1f9"},{"problem":131,"code":"(fn [& ss]\n    (let [sums (fn sums [[x & xs]]\n                 (if (empty? xs) (if (nil? x) nil #{x})\n                     (let [ss (sums (seq xs))] (into #{x} (concat ss (for [s ss] (+ x s)))))))]\n      (not (empty? (apply clojure.set/intersection (map #(sums (apply list %)) ss))))\n      ))","user":"54c641f8e4b045293a27f628"},{"code":"(fn [& ss] (let [ps (fn ps [s]\n                       (if (empty? s) #{s}\n                           (let [ pps (ps (set (rest s)))]\n                             (into pps (map #(conj % (first s) ) pps)))))\n                  sums (map #(set (map (partial apply +) (disj (ps %) #{}))) ss)]\n           (> (count (apply clojure.set/intersection sums)) 0)\n           )\n   )","problem":131,"user":"50563ae2e4b0ce54f56f0405"},{"problem":131,"code":"(fn [& sets]\n  (let [P (fn [s] (reduce #(concat % (map (partial + %2) %)) [0] s))\n        cs (map #(set (drop 1 (P %))) sets)  ;; all combos you can make with non-empty subsets\n        ic (reduce #(filter %2 %) cs)]  ;; intersection of all of the sets in cs\n    (not (empty? ic))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":131,"code":"(fn sum-subset\n                   [& x]\n                   (if (-> x count (= 1)) true\n                                          (let [power-set\n                                                (fn inner [x]\n                                                  (if (empty? x) #{#{}}\n                                                                 (let [half (inner (rest x))]\n                                                                   (into half (map #(conj % (first x)) half)))))\n                                                not-empty? (fn [x] (not (empty? x)))\n                                                nums (map set (map #(map (partial apply +) (filter not-empty? (power-set %))) x))]\n                                            (not-empty? (reduce clojure.set/intersection nums)))))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn [& sets]\n  (letfn [(power-set [s]\n            (if (empty? s)\n              #{#{}}\n              (let [e (first s)\n                    p (power-set (disj s e))\n                    q (set (map #(conj % e) p))]\n                (into p q))))\n          (subset-sums [s]\n            (set (map #(apply + %) (disj (power-set s) #{}))))]\n    (not (empty? (apply clojure.set/intersection\n                        (map subset-sums sets))))))","problem":131,"user":"4fe84c74e4b07c9f6fd12c3c"},{"code":"(fn [& espacos-amostrais]\n  (letfn [(gera-combinacoes [espaco-amostral]\n                            (let [pivot (first espaco-amostral)]\n                              (if (= 1 (count espaco-amostral))\n                                (list #{pivot})\n                                (let [combinacoes-n-1 (gera-combinacoes (disj espaco-amostral pivot))]\n                                  (concat combinacoes-n-1\n                                          (map #(conj % pivot)\n                                               combinacoes-n-1)\n                                          (list #{pivot}))))))\n          (intersecao? [conjuntos]\n                       (let [conjunto-pivot (first conjuntos)\n                             outros-conjuntos (remove #(= conjunto-pivot %) conjuntos)]\n                         (if (some (fn [elemento-pivot]\n                                     (every? #(% elemento-pivot)\n                                             outros-conjuntos))\n                                   conjunto-pivot)\n                           true\n                           false)))]\n    (intersecao? (map (fn [combinacoes-de-espaco-amostral]\n                        (set (map #(apply + %) combinacoes-de-espaco-amostral)))\n                      (map gera-combinacoes espacos-amostrais)))))","problem":131,"user":"52c8758be4b0c2d177d62135"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets [coll]\n            (if (seq coll)\n              (let [[c & cs] (seq coll)\n                    subs (subsets cs)]\n                (into subs\n                      (map #(conj % c) subs)))\n              #{#{}}))]\n    (->> sets\n         (map (comp\n               set\n               (partial map (partial apply +))\n               (partial filter seq)\n               subsets))\n         (apply clojure.set/intersection)\n         ((complement empty?)))))","user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [ & ss]\n  (letfn [\n    (sumset [s]\n      (if (empty? s) #{}\n        (let [pls (first s) sumss (sumset (next s))]\n          (reduce conj sumss \n            (map #(+ pls %) (cons 0 sumss))))))\n\n    (intersect [set1 set2]\n      (set (filter set2 set1)))]\n\n    (not (empty? (reduce intersect (map sumset ss))))))","problem":131,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [& sets]\n  (letfn [(subsets [s] (if (<= (count s) 1)\n                         [s]\n                         (let [[a & b] (seq s)\n                               subs (subsets b)]\n                           (concat (conj subs [a]) (map #(conj % a) subs)))))\n          (sums [c] (set (map #(reduce + %) c)))\n          (union [a b] (set (filter a b)))]\n    (not (empty? (reduce union (map (comp sums subsets) sets))))))","problem":131,"user":"4ea09fa4535d7eef308072aa"},{"code":"(fn [& args] (not (empty? \n                   (apply clojure.set/intersection\n                          (apply (fn [& args]\n                                   (map (fn [l] (set (map #(reduce + %) \n                                                          ((fn [l] (reduce (fn [r v] (concat r\n                                                                                             (list (set [v]))\n                                                                                             ((fn [i l] (map #(conj % i) l)) v r)))\n                                                                           '() l))\n                                                          l))))\n                                         args))\n                           args)))))","problem":131,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn ssss [& sets]\n   (letfn [(tst [s] (distinct(mapcat #(for [x (range (count %))] (disj % (nth (vec %) x))) s)))\n           (pwr [src] (loop [x (list src) y #{}]\n                        (if (= 1 (count (first x))) \n                          (set(concat y x))\n                          (recur (tst x) (concat y x)))))\n           ]\n\t\t(not(empty?(apply clojure.set/intersection (map #(set(map (fn [x] (reduce + x)) %)) (map pwr sets)))))\n     )\n )","problem":131,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [P R & z]\n  (->> (map (P R #(into % (map (P + %2) (conj % 0))) #{}) z)\n       (R #(keep %2 %)) \n       empty? \n       not))\npartial reduce","problem":131,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn sps [& ss]\n (letfn [\n (pows [s]\n   (loop [[lh & lt] (list s), acc #{}]\n     (if (nil? lh)\n       acc\n       (let [sum (apply + lh)]\n       (if (or (acc sum) (empty? lh))\n         (recur lt acc)\n         (recur (apply conj lt\n                       (map #(disj lh %) lh))\n                 (conj acc sum)))))))]\n   (not (empty? (apply clojure.set/intersection (map pows ss))))))","problem":131,"user":"4fc0853ae4b081705acca327"},{"problem":131,"code":"(letfn [(comb [k l]\n            (if (= 1 k) (map vector l)\n              (apply concat\n                     (map-indexed\n                       #(map (fn [x] (conj x %2))\n                             (comb (dec k) (drop (inc %1) l)))\n                       l))))\n          (all-subsets [s]\n            (apply concat\n                   (for [x (range 1 (inc (count s)))]\n                     (map #(into #{} %) (comb x s)))))]\n    (fn [ & colls]\n      (let [sum-sets (map (fn [v] (->> (all-subsets v) (map #(apply + %)) set)) colls)]\n        (->>\n          sum-sets\n          (apply clojure.set/intersection ) \n          (#(if (empty? %) false true) )))))","user":"55aa1637e4b0988bba2ad949"},{"code":"(fn [& s]\n\t(let [parts (fn p [s] (if (empty? s)\n\t\t#{#{}}\n\t\t(concat \n\t\t\t(map #(conj % (first s)) (p (rest s)))\n\t\t\t(p (rest s)))))]\n  (not (empty? (apply \n\t\t clojure.set/intersection \n\t\t (map \n\t\t\t#(set (map \n\t\t\t\t(partial reduce +) \n\t\t\t\t(remove empty? (parts %))) )\n\t\t\ts))))))","problem":131,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":131,"code":"(fn [& sets] (let [ps (fn powerset [s] (if (empty? s) #{#{}} (let [l (into '() s) smaller (powerset (set (rest l)))] (clojure.set/union smaller (map #(conj % (first l)) smaller)))))\n                   psets (map #(filter (fn [s] (not (empty? s))) (ps %)) sets)\n                   sums (map #(set (map (fn [p] (reduce + p)) %)) psets)]\n               (not (empty? (apply clojure.set/intersection sums)))))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":131,"code":"(fn [& sets]\n   (letfn [(sums [s] (rest (reduce (fn [acc n] (concat acc (map (partial + n) acc))) '(0) s)))]\n     (->> (map sums sets) \n          (map set)\n          (apply clojure.set/intersection)\n          ((complement empty?)))))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn [ & s]\n(not (empty?\n(apply clojure.set/intersection\n(map \n  (fn sums [x]\n    (set (if (seq x)\n            (concat (sums (rest x)) \n                    (map (partial + (first x)) (sums (rest x)))\n                    [(first x)])\n        [])))\ns)))))","problem":131,"user":"4fdd27f3e4b05e33b9224f78"},{"code":"(let [power-set (fn [s] (reduce (fn [ps x]\n                                  (into ps (map #(conj % x) ps)))\n                                #{#{}}\n                                s))\n      sum-set (fn [s] (->> (power-set s)\n                           (remove empty?)\n                           (map #(reduce + %))\n                           set))]\n  (fn [& sets] (->> sets\n                    (map sum-set)\n                    (apply clojure.set/intersection)\n                    (not= #{}))))","problem":131,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":131,"code":"(fn sub-sums-match [& ss]\n  (letfn [(gen-k-combs \n            ([k s] (gen-k-combs k s []))           \n            ([k s prev-combs] \n             (letfn [(combine-rem-w-seq \n                       [s rem]\n                       (map #(set (conj s %)) rem)\n                       )]\n               (if (= k 1)\n                 (set (combine-rem-w-seq prev-combs s))\n                 (loop [tail s k k all-combs []]\n                   (let [head (first tail)]\n                     (if (nil? head)\n                       (set all-combs)\n                       (recur (rest tail) k (into all-combs (gen-k-combs (dec k) (rest tail) (conj prev-combs head))))\n                       )))))))\n          (get-sub-sums [start-s]\n            (let [all-combs  (loop [num 1 s #{start-s} orig-s start-s]\n                               (if (> num (count orig-s))\n                                 s\n                                 (recur (inc num) (into s (gen-k-combs num orig-s)) orig-s)\n                                 )\n                               )](map #(reduce + %) all-combs))\n            )\n          (get-all-sub-sums [& start-ss]\n            (for [s start-ss]\n              (get-sub-sums s)\n              )\n            )\n          (matches-other-subsets [num ss]\n\n            (loop [tail ss]\n              (if (seq tail)\n                (if (some #(= num %) (first tail))\n                  (recur (rest tail))\n                  false\n                  )\n                true\n                )\n              )\n            )]\n    (if (= (count ss) 1)\n      true\n      (let [s-of-ss (apply get-all-sub-sums ss)]\n        (loop [tail (first s-of-ss)]\n          (let [head (first tail)]\n            (if (nil? head)\n              false\n              (if (matches-other-subsets head (rest s-of-ss))\n                true\n                (recur (rest tail))\n                )\n              )\n            )\n          )\n        )\n      ))\n)","user":"5ff676a9e4b06df49cee1497"},{"problem":131,"code":"(fn somesumset [& sets]\n  (letfn [(pset [s]\n            (if (empty? s) #{#{}}\n                (set (mapcat #(list % (conj % (first s))) (pset (rest s))))))\n          (sumset [s]\n            (set (map #(apply + %) (filter #(not (empty? %)) (pset s)))))]\n    (not (empty? (apply clojure.set/intersection (map sumset sets))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":";; Uses my solution to the Power Set problem.\n\n;; That will be used to generate all but the empty subsets of the\n;; given sets of numbers, and from there we add up each one to get the\n;; sum of each.\n\n;; If there are any sums in common, i.e. in the intersection, then the\n;; answer is yes.\n\n(fn [& int-sets]\n  (let [power-set (fn [s]\n                    (reduce (fn [power-set x]\n                              (into power-set (map #(conj % x) power-set)))\n                            #{#{}} s))\n        all-nonempty-subsets (map #(disj (power-set %) #{}) int-sets)\n        subset-sums (map (fn [subsets-of-one]\n                           (set (map #(apply + %) subsets-of-one)))\n                         all-nonempty-subsets)]\n    (not= #{} (apply clojure.set/intersection subset-sums))))","problem":131,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":131,"code":"(fn [& s] (letfn [\n (powerset [s]\n  (if (empty? s) '(())\n    (clojure.set/union (powerset (next s)) (map #(conj % (first s)) (powerset (next s))))))\n (powersum [s]\n    (->> s (powerset) (filter seq) (map (partial apply +)) (into #{}))) \n (commonsums [s]\n    (apply clojure.set/intersection (map powersum s)))    \n      ]\n      (not= #{} (commonsums s))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"code":"(letfn\n  [(p [s]\n      (if (empty? s)\n        [#{}]\n        (let [a (first s) r (rest s)]\n          (apply \n           concat\n           (for [x (p r)]\n             [x (conj x a)])))))\n   (q [s] (filter #(not= #{} %) (p s)))\n   ]\n  (fn [& s]\n    (let [x (map q s)\n          [[a & b] & y] (map #(map (fn [x] (reduce + 0 x)) %) x)]\n      (loop [a a b b]\n        (if (every? #(some (partial = a) %) y)\n          true\n          (if (empty? b)\n            false\n            (recur (first b) (rest b))))))))","problem":131,"user":"4e03c616535d04ed9115e796"},{"code":"(fn f[& col]\n\t(letfn [\n\t\t(subsets[s]\n\t\t\t(if (seq s)\n\t\t\t\t(let [f (first s) srs (subsets (disj s f))]\n\t\t\t\t\t(concat srs (map #(conj % f) srs)))\n\t\t\t\t(list #{}))\n\t\t\t)\n\t\t(tosum[s]  (map #(reduce + %) (drop 1 s)))\n\t\t(toset[x] (set(tosum(subsets x))))\n\t\t] \n\n\t\t(not(empty? \n\t\t\t(apply clojure.set/intersection (map toset col))\n\t\t\t))\n\t\t)\n\t)","problem":131,"user":"5307e4ece4b02e82168697a9"},{"problem":131,"code":"(fn sum-sets [& xs]\n  (letfn [(pset [s]\n\t\t\t  (cond\n\t\t\t   (empty? s) #{#{}}\n\t\t\t   :else\n\t\t\t    (let [h (first s) t (disj s h)]\n\t\t\t     (into #{}\n\t\t\t     (concat\n\t\t\t         (map #(conj % h) (pset t))\n\t\t\t         (pset t))))))]\n  (let [sums\n\t  \t(->>\n\t\t  \txs\n\t\t  \t(map pset)\n\t\t  \t(map #(disj % #{}))\n\t\t  \t(map (fn [ps] (into #{} (map #(apply + %) ps)))))]\n\t  \t(not (nil?\n\t  \t(some (fn [s]\n\t  \t\t     (every? #(% s) (rest sums)))\n\t  \t      (first sums)))))))","user":"54448e84e4b032a45b869393"},{"problem":131,"code":"(fn\n  [& sets]\n  (let [ps (fn ps [aset] (if (seq aset) (set (mapcat (fn [x] [x (conj x (first aset))]) (ps (rest aset)))) #{#{}}))\n        sum #(reduce + %)\n        pss #(->> %\n                  ps\n                  (remove empty?)\n                  (map sum)\n                  set)]\n    (->> sets\n         (map pss)\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"4e521cef535d302ef430da6d"},{"problem":131,"code":"(fn [& sets]\n    (->>\n    sets\n    (map vec)\n    (map \n     (fn [v]\n        (into #{}\n          (for [i (range 0 (dec (bit-shift-left 1 (count v))))]\n            (reduce + (map v (filter #(zero? (bit-and i (bit-shift-left 1 %))) (range (count v)))))\n       )))\n    )\n    (apply clojure.set/intersection)\n    empty?\n    not\n  ))","user":"5281a445e4b0757a1b17143a"},{"problem":131,"code":"(fn [& colls]\n   (->> (map (fn [coll]\n               (set (reduce #(concat (map (partial + %2) %1)\n                                     %1\n                                     (list %2))\n                            ()\n                            coll)))\n             colls)\n        (apply clojure.set/intersection)\n        empty?\n        not))","user":"60096aabe4b074f607df667f"},{"code":"(fn [& ss]\n  (letfn [(power-set [s]\n            (if (empty? s) #{#{}}\n                (let [t (power-set (rest s))]\n                  (into t (map #(conj % (first s)) t)))))]\n    (->> ss\n         (map power-set)\n         (map #(remove empty? %))\n         (map #(map (partial apply +) %))\n         (reduce #(filter (set %) %2))\n         empty?\n         not)))","problem":131,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn f [& sets]\n  (let [ps (fn p [s] (if (= #{} s) #{#{}}\n             (let [res (p (disj s (first s)))]\n               (into res (map #(conj % (first s)) res)))))\n        psets (map #(disj (ps %) #{}) sets)\n        psetsums (map (comp set (partial map #(reduce + %))) psets)]\n    (not (empty? (reduce #(set (filter % %2)) psetsums)))))","problem":131,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":131,"code":"(fn sum-some [& args]\n\n   (let [sums (map (fn [x]\n    (map (fn [x] (reduce + 0 x)) (filter #((complement zero?) (count %1)) ((fn power-set [s]\n        (let [start (set (conj (map #(set [%]) s) s #{}))]\n          ((fn f [ans left]\n            (if (empty? left)\n              ans\n              (f (into ans (set (mapcat (fn [x]\n                (for [y left :let [y (conj x y)]] y)\n              ) ans))) (rest left)))) start s))) x)))) args)] (prn sums) (> (count (reduce #(filter (fn [x] (contains? %2 x))  %1) (map set sums))) 0) ))","user":"4f7b6b90e4b06e829148e1a4"},{"problem":131,"code":"(fn eq-sum-subsets [& sets]\n  (let [subsets-without-empty (fn  [s]\n                                (loop [s s\n                                       r #{#{}}]\n                                  (if (seq s)\n                                    (recur (rest s)\n                                           (into r (map #(conj % (first s)) r)))\n                                    (disj r #{}))))\n        joined-sums (->> sets\n                         (map (fn [s] (->> s\n                                           subsets-without-empty\n                                           (map (partial apply +))\n                                           distinct)))\n                         (apply concat)\n                         sort)]\n    (loop [sums joined-sums]\n      (if (seq sums)\n        (let [[eqs rest] (split-with #(= (first sums) %) sums)]\n          (if (= (count sets) (count eqs))\n            true\n            (recur rest)))\n        false))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":131,"code":"(fn [& ss]\n  (->> ss\n       (map (fn [s] (->> s\n                         (reduce (fn [acc x] (concat acc (map #(conj % x) acc)))  [[]])\n                         (filter seq)\n                         (map #(apply + %))\n                         (into #{}))))\n       (apply clojure.set/intersection)\n       empty?\n       not\n       ))","user":"5d81b40ce4b0915913b1d379"},{"code":"(letfn [(power-set [s]\n          (reduce (fn [xs x]\n                    (concat xs (map #(conj % x) xs)))\n                  #{#{}} s))\n        (subset-sums [s]\n          (->> s\n               power-set\n               (filter #(seq %))\n               (map #(reduce + %))\n               set))]\n  (comp not\n        empty?\n        (partial apply clojure.set/intersection)\n        (partial map subset-sums)\n        list))","problem":131,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":131,"code":"(fn [& xss]\n  (let [some-sums (fn some-sums [xs acc sums]\n                    (if (empty? xs) \n                      (if acc (conj sums acc) sums)\n                      (->> sums\n                           (some-sums (rest xs) acc)\n                           (some-sums (rest xs) (+ (if acc acc 0) (first xs))))))]\n    (->> xss\n         (map #(some-sums % nil #{}))\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"53800d99e4b06839e8705ebd"},{"code":"(fn [& s]\n  (letfn [(g [x]\n    (set (map #(reduce + %) (for [i (range 1 (Math/pow 2 (count x)))]\n      (set (for [j (range (count x)) :when (bit-test i j)]\n        ((vec x) j)))))))]\n    (> (count (apply clojure.set/intersection (map g s))) 0)))","problem":131,"user":"4ec0c7ba535dfed6da9c6da4"},{"code":"(fn [& sets]\n  (let [ps (fn [s]\n             (remove\n              empty?\n              (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s)))\n        sum #(reduce + %)]\n    (not (empty? (apply clojure.set/intersection\n                        (map #(set (map sum (ps %))) sets))))))","problem":131,"user":"4dbb0b6c535d1e037afb21b0"},{"problem":131,"code":"(letfn [(subset-sums [s] (if (empty? (rest s)) s\n                           (let\n                             [r (subset-sums (rest s))]\n                             (clojure.set/union #{(first s)} r (set (map #(+ % (first s)) r))))))]\n  (fn [& args] (not (empty? (apply clojure.set/intersection (map subset-sums args))))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn [& sets]\n  (not (empty?\n    (reduce \n      #(filter (set %1) %2)\n      (map\n        (fn [v]\n          (reduce\n            (fn [s i] (into s (cons i (map #(+ % i) s))))\n            #{} v))\n        sets)))))","problem":131,"user":"528652fbe4b0239c8a67ae14"},{"problem":131,"code":"(fn f [& int-sets] \n\t(letfn [(subsets [head tails ss] \n\t\t\t\t\t\t(cond (empty? tails) ss\n\t\t\t\t\t\t      :else (let [comb (conj head (first tails))]\n\t\t\t\t\t\t                 (subsets head (rest tails) \n\t\t\t\t\t\t                          (subsets comb (rest tails) (conj ss comb))))))]\n\t\t(->> (map #(subsets #{} % #{}) int-sets)\n\t\t     (map #(map (partial apply +) %))\n\t\t     (map #(set %))\n\t\t     (apply clojure.set/intersection)\n\t\t     (empty?)\n\t\t     (false?))))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":131,"code":"(fn p131 [& args]\n  (letfn [(gen-bitstrings [n] (map #(str (reduce str (repeat (- n (count %)) \"0\")) %)\n                                  (map #(Integer/toBinaryString %) (range 1 (Math/pow 2 n)))))]\n    (< 0 (count\n      (apply clojure.set/intersection \n        (for [set-to-use args]\n          (let [bitstrings (map #(map char %) (gen-bitstrings (count set-to-use)))]\n            (set (for [bitstring bitstrings]\n              (reduce + (keys (filter #(= \\1 (val %)) (zipmap set-to-use bitstring)))))))))))))","user":"525c575be4b0cb4875a45d38"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(f [st] (set (map #(apply + %) (filter #(not (empty? %)) (reduce (fn [v n] (concat v (map #(conj % n) v))) [[]] st)))))]\n    (not (empty? (apply clojure.set/intersection (map f sets))))))","user":"57c647bbe4b05aa3c4741cf3"},{"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (if (empty? s)\n              #{#{}}\n            (let [s-sub (subsets (rest s))]\n                (into s-sub (map #(conj % (first s)) s-sub)))))\n\n          (sumsets [s]\n            (set (map #(apply + %) (filter (complement empty?) (subsets s)))))]\n\n    (not (empty? (apply clojure.set/intersection (map sumsets sets))))))","problem":131,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [& ss]\n  (not (empty? (apply clojure.set/intersection\n                 (map (comp set\n                            (fn sums [[x & s]]\n                              (when x\n                                (let [z (sums s)]\n                                  (cons x (concat (map #(+ % x) z) z)))))\n                            seq)\n                      ss)))))","problem":131,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn ssss [& sets]\n  (letfn [(sums [st]\n            (letfn [(subsets [s]\n                      (if (empty? s) #{s}\n                          (concat (subsets (rest s)) (map #(concat #{(first s)} %) (subsets (rest s))))))]\n              (into #{} (map (partial apply +) (remove empty? (subsets st))))))]\n    (let [p (into #{} (map sums sets))]\n      (not (empty? (reduce clojure.set/intersection p))))))","problem":131,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn subset-sum4 [& sets]\n  (let [create-binaries (memoize \n                          (fn [c] \n                            (let [fp (if (> c 0) (str \"%0\" c \"d\") \"%d\")\n                                  combinations (int (Math/pow 2 c))\n                                  decimals (range 1 combinations)] ;; skip zero\n                              (map #(format fp (-> % Integer/toBinaryString Integer/parseInt)) decimals))))\n        create-set (fn [s code]\n                     (let [v (vec s)\n                           r (range (count code))\n                           code2 (vec (map #(-> % str Integer/parseInt) (seq code)))]\n                       (into #{} (for [i r :when (= 1 (code2 i))] (v i))))) \n        create-power-set (fn [s] \n                           (let [binaries (create-binaries (count s))]\n                             (\n                              (fn cps [bins]\n                                (lazy-seq\n                                  (when-not (empty? bins)\n                                    (cons \n                                      (create-set s (first bins))\n                                      (cps (rest bins))))\n                                  ))\n                              binaries)\n                             ))\n        create-subsets-sum (fn [s]\n                             (loop [s1 s, result []]\n                               (if (empty? s1)\n                                 result\n                                 (recur \n                                   (rest s1) \n                                   (let [power-set (create-power-set (first s1))]\n                                     (conj result (distinct (map #(reduce + %) power-set)))\n                                     )))))\n        subsets-sums (create-subsets-sum sets)\n        compare-seqs (fn [s]\n                       (let [in? (fn [s e] (some #(= % e) s))\n                             fs (first s)\n                             rs (rest s)]\n                         (loop [fs1 fs]\n                           (if (empty? fs1)\n                             false\n                             (let [result (for [x rs] (in? x (first fs1)))\n                                   positive (filter true? result)]\n                               (if (= (count rs) (count positive))\n                                 true\n                                 (recur (rest fs1))))))))\n        ]\n    (compare-seqs subsets-sums)\n    ))","problem":131,"user":"52cf084ce4b07d0d72b27399"},{"problem":131,"code":"(fn [& sets] \n   (< 0 \n      (count (apply clojure.set/intersection \n        (map (fn [a-set]\n               (let [n (Math/pow 2 (count a-set))\n                     lst (map-indexed vector a-set)]\n                 (set (map (fn [i] (reduce + (map second (filter (fn [[idx val]]\n                                                                   (bit-test i idx))\n                                                                  lst))))\n                     (range 1 n)))))\n            sets)))))","user":"544e9022e4b0e3978000698b"},{"problem":131,"code":"(fn [& ls]\n  (let [powerset-sum (fn psum [xs]\n                       (if (empty? xs)\n                         [nil]\n                         (let [x (first xs)\n                               r (rest xs)\n                               without-x (psum r)\n                               with-x (map #(+ (or % 0) (or x 0)) without-x)]\n                           (concat with-x without-x))))\n        psums (map (comp #(into #{} %)\n                         #(filter (complement nil?) %)\n                         powerset-sum) ls)]\n    ((complement empty?) (apply clojure.set/intersection psums))))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn [& sets]\n  (not (empty? (apply clojure.set/intersection\n    (map\n      (fn [ss] (set\n        (map (partial reduce +)\n          ((fn comb [s]\n            (if (empty? s) #{}\n              (let [[x & xs :as all] (seq s)\n                   perms (comb xs)]\n                (conj (into perms\n                  (map #(conj % x) perms))\n                  #{x} (set all))))) ss))))\n      sets)))))","problem":131,"user":"4f38b7d9e4b0e243712b1ee0"},{"problem":131,"code":"(letfn [(c [s n]\n           (cond\n             (zero? n) #{#{}}\n             (empty? s) #{}\n             :else (let [x (first s)\n                         s-x (disj s x)]\n                     (clojure.set/union\n                       (set (map #(conj % x) (c s-x (dec n))))\n                       (c s-x n)))))\n        (s [d]\n           (mapcat (partial c d)\n                   (range 1 (inc (count d)))))\n        (a [coll] (set (map #(reduce + %) (s coll))))]\n  #(not (empty? (apply clojure.set/intersection (map a %&)))))","user":"514d8084e4b019235f6c0588"},{"problem":131,"code":"(fn lolo [& xs] \n  (let [ss (fn subsets [s] \n             (-> (reduce (fn [ak n] (into ak (map #(conj % n) ak))) #{#{}} s)\n                 (disj #{})))]\n    (->> (map ss xs)\n         (map #(map (partial apply +) %))\n         (map set)\n         (apply clojure.set/intersection)\n         (seq)\n         (nil?)\n         (not)\n         )))","user":"6011b89ee4b074f607df66bc"},{"problem":131,"code":"(fn [& sets]\n     (letfn [(find-subsets\n               [set-to-check]\n               (cond\n                 (or (nil? set-to-check) (empty? set-to-check)) '()\n                 (= 1 (count set-to-check)) (list set-to-check)\n\n                 (= 2 (count set-to-check))\n                 (conj (map #(conj '() %) set-to-check) (into '() set-to-check) '())\n\n                 :else (let [subsets (find-subsets (rest set-to-check))]\n                         (concat\n                           subsets\n                           (map #(conj % (first set-to-check)) subsets)\n                           ))\n                 ))\n             (summed-subsets [s] (map #(reduce + %) (remove empty? (find-subsets s))))]\n       (summed-subsets #{-1 1 99})\n       (->>\n         (map #(sort (distinct (summed-subsets %))) sets)\n         (sort-by #(* -1 (count %)))\n         ((fn [colls]\n            (every? #(some (into #{} (first colls)) %) (rest colls))\n            ))\n         )\n       ))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(letfn [(power \n         ([s] (set (power #{} s)))\n         ([base s] (if-let [[head & more] (seq s)]\n                     (concat (power base more) (power (conj base head) more))\n                     [base])))\n        (sum-if-seq [colls] (set (for [s colls :when (seq s)] (reduce + s))))]\n  (fn [& sets]\n    (not (empty? (apply clojure.set/intersection \n                        (map #(sum-if-seq (power %)) sets))))))","problem":131,"user":"532347dde4b09d4e7a9b54cc"},{"problem":131,"code":"(fn [& sx]\n  (letfn [(f [a s]\n           (if (empty? s)\n             (list a)\n             (concat (f (+ a (first s)) (rest s))\n                     (f a (rest s)))))]\n    (not\n      (empty?\n        (reduce (fn [a r]\n                  (keep (into #{} a)\n                        (into #{} (butlast (f 0 r)))))\n                (butlast (f 0 (first sx)))\n                (rest sx))))))","user":"52bacfa8e4b07a9af57922d6"},{"code":"(fn [& sets]\r\n  (letfn [(pows [s] \r\n                (reduce #(into (map (partial cons %2) %) %) ['()] s))\r\n          (sums [s] (set (for [x (filter #(not (empty? %)) (pows s))] (apply + x))))]\r\n    (not (empty? (apply clojure.set/intersection (map sums sets))))))","problem":131,"user":"509c03f3e4b085ae113522a8"},{"problem":131,"code":"(fn share-subset-sums? [& sets]\n  \"Returns true iff all given sets have a non-empty subset with an equivalent summation.\"\n  (letfn [\n          (binary-nums [length]\n                        \"Generate all binary numbers of a given bit length\"\n                        ; start with [0] and [1]\n                        (loop [acc [[0] [1]] \n                               remaining length]\n                          (if (= remaining 1)\n                            acc\n                            (recur\n                             (concat\n                               (map #(conj % 0) acc) \n                               (map #(conj % 1) acc))\n                             (dec remaining)))))\n          (apply-binary-num [b s]\n                            \"'Apply' a binary number to a set -- include each\n                              element iff the corresponding bit is 1\"\n                              (loop [b b\n                                     s s\n                                     acc #{}]\n                                (if (empty? b)\n                                  acc\n                                  (recur\n                                   (rest b)\n                                   (rest s)\n                                   (if (= 1 (first b))\n                                     (conj acc (first s))\n                                     acc)))))\n          (all-subsets [s]\n                               \"Get all subsets of s, excluding the empty set\"\n                                (loop [acc []\n                                       rem (binary-nums (count s))]\n                                  (if (empty? rem)\n                                    (into #{} (remove empty? acc))\n                                    (recur\n                                     (conj acc (apply-binary-num (first rem) s))\n                                     (rest rem)))))\n          (subset-sums [s]\n                           \"Given a set s, return a set of sums of each\n                            non-empty subset of s\"\n                           (->>\n                            (all-subsets s)\n                            (group-by #(apply + %))\n                            (keys)\n                            (into #{})))]\n    \n    (->>\n     sets\n     (map subset-sums)\n     (apply clojure.set/intersection)\n     (empty?)\n     (not))))","user":"53ac4719e4b047364c04445c"},{"problem":131,"code":"(fn p [& sets]\n  (let [sums\n        (fn sums [lst]\n          (if (= (count lst) 1)\n                            lst\n                            (let [lst1 (sums (rest lst))]\n                              (concat (map (fn [x] (+ x (first lst))) lst1)\n                                      lst1\n                                      [(first lst)]))))]\n    (not (empty? (apply clojure.set/intersection\n                        (map #(apply hash-set (distinct (sums (vec %)))) sets))))))","user":"53664e3be4b0243289761e74"},{"code":"(fn f [& x]\n  (let [ powerset (fn powerset [ls]\n            (if (empty? ls) '(())\n                    (clojure.set/union (powerset (rest ls))\n                                               (map #(conj % (first ls)) (powerset (rest ls))))))\n        sum-of-set (fn [y] (map #(apply + % )(filter not-empty (powerset y))))]\n    (not (empty? (apply clojure.set/intersection (map #(set (sum-of-set %))x))))))","problem":131,"user":"518c5236e4b087e178201de0"},{"problem":131,"code":"(fn ssss [& ss]\n  (not (empty? (apply clojure.set/intersection (map (fn [s] (set (map #(apply + %) (remove empty? (reduce #(concat % (map (fn [x] (conj x %2)) %)) [[]] s))))) ss)))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"problem":131,"code":"(fn [& xs]\n  (letfn [(up [S s]\n            (set (for [s s\n                       a (apply disj S s)]\n                   (conj s a))))\n          (subsets [s]\n            (apply concat \n                   (take (count s)\n                         (iterate #(up s %)\n                                  (map hash-set s)))))\n          (sums [s]\n            (set (map #(apply + %) (subsets s))))]\n    (not (empty? (apply clojure.set/intersection (map sums xs))))))","user":"5712854ce4b07c98581c3a89"},{"problem":131,"code":"(fn equivalent-sums [ & sets ]\n  (letfn [\n           (power-set [s] \n             (if (empty? s)\n                #{#{}}\n                (let [ fst (first s) \n                       other (rest s)\n                       recurred (power-set other)]\n                 (set (concat recurred (map #(conj % fst) recurred))))))\n          ]\n    (let [ sums (map \n                  #(set (map (partial reduce +) %))\n                  (map #(filter (comp not empty?) (power-set %)) sets)\n                  ) \n                  ] \n     (not (empty? (apply clojure.set/intersection sums))))))","user":"54d6f22de4b0a52adc2e2023"},{"problem":131,"code":"(fn [& other] ((complement empty?) (apply clojure.set/intersection (map #(clojure.set/union % [(reduce + %)] (set (for [x % y %] (+ x y)))) other))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":131,"code":"(let [powerset (fn [sets] \n\t\t(disj (loop [s sets r (conj #{sets} #{})]\n\t\t(if (empty? s) r\n\t\t\t(recur (rest s) (into r (set (map #(conj % (first s)) r)))))) #{}))]\n\t(fn [& sets] (let [sums (map (comp set (fn [s] (map #(reduce + %) s)) powerset) sets)]\n\t\t\t\t\t(not (empty? (reduce clojure.set/intersection sums))))))","user":"53e19461e4b0d874e779ae59"},{"problem":131,"code":"(fn [& sets]\r\n  (let [\r\n    sum #(reduce + %)\r\n    comb (fn comb [items n]\r\n      (if (> n (count items))\r\n        '()\r\n      (if (= n 0)\r\n        '(())\r\n      (if (= n 1)\r\n        (map vector items)\r\n        (let [[head & tail] items]\r\n          (concat\r\n            (map #(cons head %) (comb tail (dec n)))\r\n            (comb tail n)))))))\r\n    sums (fn [one-set]\r\n      (let [\r\n        lengths (range 1 (inc (count one-set)))\r\n        one-vector (apply vector one-set)]\r\n        (->> lengths\r\n          (map #(comb one-vector %))\r\n          (apply concat)\r\n          (map sum)\r\n          (set))))\r\n    intersection (fn [& sets]\r\n      (let [\r\n        intersect (fn [a b]\r\n          (set (filter #(contains? a %) b)))]\r\n        (reduce intersect sets)))]\r\n    (not (empty? (apply intersection (map sums sets))))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [& cop]\n  (let [ps (fn  [oldv]\n    (let [ v (vec oldv)\n           genset (fn [n orgset]\n          (loop [result [] cnt n time 0]\n            (if (= cnt 0)\n                result\n                (recur (if (= (mod  cnt 2) 1) (conj result (nth orgset time) )  result  ) (quot cnt 2) (inc time) ) )))\n\n\n          ]\n      (set (map set (map #(genset % v) (drop 1 (range (Math/pow 2 (count v) ))))))\n      )\n      )\n    possiblesum (fn [oldset]\n                    (map #(reduce + 0 %) oldset)\n      )\n\n        ]\n     (not (empty? (apply clojure.set/intersection (map set (map #(possiblesum (ps %)) cop)))))\n    )\n\n  )","problem":131,"user":"4ec5bec6535d6d7199dd36b3"},{"problem":131,"code":"(fn [& xs]\n  (letfn [(power-set [sofar remaining]\n            (if (empty? remaining)\n              #{sofar}\n              (let [x (first remaining) remaining (rest remaining)]\n                (concat (power-set (conj sofar x) remaining)\n                        (power-set sofar remaining)))))\n          (sum-set [xs] \n            (reduce + xs))]\n    (->> xs\n         (map #(filter (complement empty?)\n                       (power-set #{} %)))\n         (map #(into #{} (map sum-set %)))\n         (reduce clojure.set/intersection)\n         ((complement empty?)))))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":131,"code":"(fn [& sets] (let [gen (fn [coll] (let [feed (fn [coll init] (into (hash-set) (apply concat (map (fn [x] (reduce (fn [a b] (conj a (conj x (nth coll b)))) #{}\n                                                                                                                (range 0 (count coll)))) init))))\n                                       colla (into [] coll)]\n                                   (map (fn [a] (reduce + a)) (if (empty? coll) #{#{}} (reduce (fn [a b] (feed colla a))\n                                                                                               (map hash-set colla) (range (count colla)))))))]\n                (if (empty? (apply clojure.set/intersection (map set (map gen sets)))) false true)))","user":"567f988be4b0feffd0d18ebe"},{"problem":131,"code":"(fn sum-subsets [& sets]\n  (letfn [(smallest-subset [collections]\n            (apply min-key count collections))\n          (all-sums [coll]\n            (cond \n              (empty? coll) '()\n              (= 1 (count coll)) coll\n              :else \n              (concat (take 1 coll)    \n                      (map #(+ (first coll) %) (all-sums (rest coll)))\n                      (all-sums (rest coll)))))]\n    (not (empty? (apply clojure.set/intersection (map #(set(all-sums %)) sets))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":131,"code":"(fn [& sets]\n  (let [power-set (fn [s]\n                    (disj\n                     (set (reduce (fn [acc el]\n                                    (concat acc (map #(conj %1 el) acc)))\n                                  #{#{}} s)) #{}))\n        psets (map power-set sets)\n        pset-sums (map #(set (map (partial reduce +) %)) psets)]\n    (every? (partial some (first pset-sums)) (rest pset-sums))))","user":"54be7772e4b0ed20f4ff6eea"},{"code":"(fn ss [& sets]\n  (letfn [(subsets [s]\n            (if (seq s)\n              (let [x (first s)\n                    xs (next s)\n                    next-sets (subsets xs)]\n                (set (concat (map #(conj % x) next-sets)\n                             next-sets)))\n              #{#{}}))\n          (subsums [s]\n                   (->> s\n                        subsets\n                        (filter not-empty)\n                        (map (partial reduce +))\n                            set))]\n                    (->> sets\n       (map subsums)\n       (apply clojure.set/intersection)\n       empty?\n       not)))","problem":131,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":131,"code":"(fn [& s]\n  (let [m (fn [s] \n    (reduce\n      (fn [acc k]\n        (->> acc\n             (map (fn [x] (map #(conj x %) s)))\n             (apply concat)\n             set))\n      #{#{}}\n      (range (count s))))\n     c (map m s)\n     u (map (fn [r] (map #(apply + %) r)) c)\n          f (set (first u))]\n        (= (count s) (count (filter #(some f %) u)))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":131,"code":"(fn [& a]\n  (not\n   (empty?\n    (reduce #(set (filter % %2))\n            (map (fn [s]\n                   (loop [[f & m] (seq s)\n                          r #{}]\n                     (if f\n                       (recur m (into r (cons f (map #(+ f %) r))))\n                       r)))\n                 a)))))","user":"50ed4626e4b01236b1d4983c"},{"code":"(fn [& sets]\r\n  (letfn [(powersum [s]\r\n     (reduce\r\n      (fn [p e]\r\n\t\t    (into p (conj (map #(+ e %) p) e)))\r\n\t    #{} s))]\r\n(not (empty? (apply clojure.set/intersection  (map powersum sets))\r\n               ))))","problem":131,"user":"4dae4da5c9a9d6ed4e99dc57"},{"problem":131,"code":"(fn problem-131-equal-subset-sum\n    [& sets]\n\n    (let [subsets\n          (fn subsets\n            [[v & vs]]\n            (if-not vs\n              #{#{v} #{}}\n              (let [ss (subsets vs)]\n                (->> ss\n                     (map #(conj % v))\n                     (into (set ss))))))]\n      (->> sets\n           (map (comp #(disj % #{}) subsets seq))\n           (map (partial map (partial apply +)))\n           (map set)\n           (reduce clojure.set/intersection)\n           (empty?)\n           (not))))","user":"58e37946e4b005f69f193cae"},{"code":"(fn [& s]\r\n  (let [u clojure.set/union\r\n         a (fn a [s] (if (empty? s) #{}\r\n                      (let [x (first s) r (a (disj s x))]\r\n                        (u #{x} r (set (map #(+ % x) r))))))]\r\n    (not (empty? (reduce clojure.set/intersection (map a s))))))","problem":131,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":131,"code":"(fn sum-some-subsets\n  [& xss]\n  (letfn [(power-set\n            [S]\n            (letfn [(num->mask [n k]\n                      (let [proto-mask (map #(= \\1 %) (Integer/toBinaryString n))]\n                        (concat (repeat (- k (count proto-mask)) false)\n                                proto-mask)))]\n              (let [n (int (Math/pow 2 (count S)))]\n                (conj\n                  (set\n                    (map (fn [k] (set (filter\n                                        #(not (nil? %))\n                                        (map (fn [e m] (if m e)) S\n                                             (num->mask k (count S))))))\n                         (range 1 n)))\n                  #{}))))]\n    (not (empty?\n           (reduce (fn [accum s] (clojure.set/intersection accum s))\n                   (map (fn [xs] (set (map (fn [s] (reduce + s))\n                                           (filter (fn [s] (not= s #{}))\n                                                   (power-set xs)))))\n                        xss))))))","user":"5c20b6abe4b07e362c230576"},{"problem":131,"code":"(fn [& s]\n  (letfn [(sum-set [s]\n            (apply + s))\n          (all-subsets [s]\n            (if (empty? s) '()\n                (let [h (first s)\n                      r (rest s)\n                      subsets (all-subsets r)]\n                  (concat (list (list h)) subsets (for [subset subsets]\n                                                    (cons h subset))))))]\n    (not (empty? (apply clojure.set/intersection (map #(set (map sum-set (all-subsets %))) s))))))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn ssss [& s]\n  (letfn [(ps [s]\n  (loop [s (vec s) p #{#{}}]\n    (if (empty? s)\n      p\n      (recur (rest s) \n        (into p (map #(merge % (first s)) p))))))]\n    (let [m (flatten (map distinct (map #(map (partial apply +) %) (map #(remove empty? (ps %)) s))))]\n  (if (= (count m) 1)\n    true\n    (if (<= (dec (count (distinct m))) (- (count m) (count s)))\n      true\n      false)))))","problem":131,"user":"50843a4ae4b0c98812d0788b"},{"problem":131,"code":"(fn [& colls]\n  (let [vecs (mapv vec colls)\n        smallest (reduce max (map #(reduce + (filter neg? %)) colls))\n        largest (reduce min (map #(reduce + (filter pos? %)) colls))\n        subset-sum? (fn [g [x & xs] s] (when x (or (= x s) (g g xs s) (g g xs (- s x)))))\n        g (memoize subset-sum?)]\n    (boolean (first (for [s (range smallest (inc largest))\n                          :when (every? true? (map #(g g % s) vecs))]\n                      s)))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [& xss]\n  (letfn [(power-set [xs]\n                     (reduce (fn [acc x] (into acc (map #(conj % x) acc))) \n                             #{#{}}\n                             xs))\n          (sub-set-sums [xs]\n                        (->> xs \n                             power-set \n                             (filter (complement empty?))\n                             (map (partial apply +))\n                             (set)))]\n    (->> xss \n         (map sub-set-sums) \n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","problem":131,"user":"536ca4bde4b0fc7073fd6e49"},{"code":"(fn p131 [& sets]\n  (let [all-subset-sums (fn [s]\n         (set\n           (map (fn [n]\n                (reduce + (keep-indexed #(if (bit-test n %1) %2) s)))\n           (range 1 (bit-shift-left 1 (count s))))))\n        ]\n    (not (empty? (reduce clojure.set/intersection (map all-subset-sums sets))))))","problem":131,"user":"5125745ae4b05d10e3e395f9"},{"problem":131,"code":"(fn equivalent-subset-sum? [& int-sets]\n  (let [convert-to-binary (fn [x set-size]\n                            (if (zero? x)\n                              [0]\n                              (->> x\n                                   (iterate #(quot % 2))\n                                   (take set-size)\n                                   (mapv #(mod % 2))\n                                   rseq)))\n        num-sub-sets (fn [set-size]\n                       (reduce * (repeat set-size 2)))\n        set-sums (let [sums (fn [int-set]\n                              (let [set-size (count int-set)\n                                    subset-masks\n                                    (map (partial apply convert-to-binary)\n                                         (map\n                                          vector\n                                          (range 1 (num-sub-sets set-size))\n                                          (repeat set-size)))]\n                                (map\n                                 (fn [subset-mask]\n                                   (->> subset-mask\n                                        (map vector int-set)\n                                        (filter #(= 1 (second %1)))\n                                        (map first)\n                                        (reduce +)))\n                                 subset-masks)))]\n                   (map sums int-sets))]\n    (not (empty? (apply clojure.set/intersection (map set set-sums))))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn f [& xs]\n  (letfn [(p [lst]\n            (if (= 1 (count lst))\n              lst\n              (let [rst (p (rest lst))]\n                (distinct\n                 (concat lst rst\n                         (map #(+ (first lst) %) rst))))))]\n    (not (empty? (apply clojure.set/intersection\n                        (map #(set (p (vec %))) xs))))))","problem":131,"user":"4eec82fe535d93acb0a668ae"},{"problem":131,"code":"(fn number131 [& xs]\n  (let [permutate (fn [s]\n                    (reduce (fn [m x]\n                              (reduce #(conj % (conj %2 x)) m m))\n                            #{#{}} s))\n        sums (map (fn [x]\n                    (->> (permutate x)\n                         (remove #{#{}})\n                         (map #(reduce + %))\n                         (into #{})))\n                  xs)]\n    (not (empty? (apply clojure.set/intersection sums)))))","user":"54074fc5e4b0addc1aec66b6"},{"code":";(fn [ & ms]\n;  (letfn [(allset [cou ma]\n;\t\t\t\t  (set (filter #(= (count %) cou) (reduce (fn[v1 v2]\n;\t\t\t\t            (for [i1 v1\n;\t\t\t\t                  i2 v2]\n;\t\t\t\t              (conj i1 i2)\n;\t\t\t\t            )\n;\t\t\t\t            ) (repeat (count ma) #{}) (repeat cou ma)))))]\n;   (let [allv (map (fn [m]\n;         (reduce (fn [s2 cc]\n;                     (into s2 (map #(reduce + %) (allset (inc cc) m)))\n;                     ) #{} (range (count m))\n;            )\n;         ) \n;         ms)]\n;      (println allv)\n;      (if (> (count (reduce #(set (filter % %2)) allv)) 0)\n;        true\n;        false\n;       )\n;      )\n;    )\n;  )\n\n(fn [& sets]\n  (letfn [(powersum [s]\n     (reduce\n\t    (fn [p e]\n\t\t    (into p (conj (map #(+ e %) p) e)))\n\t    #{} s))]\n(->>  (map powersum sets)\n               (apply concat)\n  \tfrequencies\n\t\tvals\n\t\t(some #{(count sets)})\n\t\tnil?\n\t\tnot)))","problem":131,"user":"51bec919e4b013aa0d74b800"},{"problem":131,"code":"(fn equivalent [& sets]\n  (letfn [(combos [pop sz]\n            (cond\n              (= sz 0) '(())\n              (empty? pop) '()\n              :else (concat (mapv #(cons (first pop) %) (combos (rest pop) (dec sz)))\n                            (combos (rest pop) sz))))]\n    (let [possible-sums (fn [test]\n                          (map (fn [xs] (apply + xs)) (mapcat #(combos test %) (range 1 (-> test count inc)))))]\n      (-> (apply clojure.set/intersection (map #(-> % possible-sums set) sets)) count zero? not))))","user":"561d8936e4b064ca9f4b16b2"},{"code":"(fn [& sets]\n  (let [all (fn [items]\n              (loop [i items\n                     res #{#{}}]\n                (let [curr (first i)\n                      rst (rest i)]\n                  (if curr\n                    (recur rst (into res (map #(conj % curr) res)))\n                    res))))\n        comb-sums (fn [items]\n                    (->> (all items)\n                         (remove empty?)\n                         (map (partial reduce +))\n                         set))\n        set-sums (map comb-sums sets)]\n    (->> set-sums\n         (reduce into #{})\n         (filter (fn [s] (every? #(% s) set-sums)))\n         empty?\n         not)))","problem":131,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn sum [& sets]\n  (let [subsets (fn [set]\n                  (reduce (fn [acc i]\n                            (clojure.set/union acc\n                                               #{#{i}}\n                                               (map (fn [a] (conj a i)) acc)))\n                          #{}\n                          set))\n        subsets-sum (fn [subsets]\n                      (reduce (fn [acc i]\n                                (conj acc (reduce + 0 i)))\n                              #{}\n                              subsets))]\n    (->> (map subsets sets)\n         (map subsets-sum)\n         (apply clojure.set/intersection)\n         (empty?)\n         (not)\n    )\n  )\n)","problem":131,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":131,"code":"(fn [& sets]\n    (let [subsets      (fn subsets [s acc]\n                         (if (seq s)\n                           (subsets (rest s)\n                                    (into acc\n                                          (for [elem acc]\n                                            (conj elem\n                                                  (first s)))))\n                           acc))\n          wo-empty     (fn [s]\n                         (disj (subsets s #{#{}})\n                               #{}))\n          sums         (fn [s]\n                         (map #(apply + %)\n                              (wo-empty s)))\n          sumss        (map #(set (sums %))\n                            sets)\n          intersection (apply clojure.set/intersection sumss)]\n      (not= intersection\n            #{})))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":131,"code":"(fn [& xs] (not (empty? (reduce clojure.set/intersection\n                 (map (fn [sett]\n                        (into #{} (map (fn [mask]\n                                         (reduce + (keep-indexed\n                                                    #(when (bit-test mask %) %2)\n                                                    sett)))\n                                       (range 1 (bit-shift-left 1 (count sett))))))\n                      xs)))))","user":"5c379636e4b0d62ef62d9f76"},{"code":"#(->> %&\n  (map\n   (fn [t]\n     (set\n      (rest\n       (loop [[a & s] (seq t)  r [0]] \n         (if a \n           (recur s \n                  (mapcat (fn [x] [x (+ x a)]) r))\n           r))))))\n  (apply clojure.set/intersection)\n  empty?\n  not)","problem":131,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":131,"code":"(fn [& t]\n  (not (empty? (remove #(some nil? %) (let [y (for [s t]\n    (set (map #(apply + %) (remove empty? (reduce #(apply conj %1 (for [x %1] (conj x %2))) #{#{}} s))))\n    )] (for [k (first y)] (map #(% k) y)))\n                 ))))","user":"55e1d34ae4b050e68259b421"},{"code":"(fn sum-set [& ss]\n  (let [subsets (fn [s]\n  \t\t\t(loop [result []\n  \t\t       remaining s]\n  \t\t\t  (if (seq remaining)\n \t\t     (recur (concat [[(first remaining)]] result (map #(conj % (first remaining)) result)) (rest remaining))\n                     result)))\n        sums (map (fn [s] (map #(reduce + %) (subsets s))) ss)\n        sums (map (comp keys #(group-by identity %)) sums)]\n   \t(if (some #(= % (count ss)) (vals (frequencies (apply concat sums)))) true false)\n    )\n  )","problem":131,"user":"4fa340b4e4b081705acca18c"},{"problem":131,"code":"(letfn [\n        (lp-set [s]\n                (set (map (partial apply +) (filter seq\n                                                    (loop [[f & r] (seq s) p '(())]\n                                                      (if f\n                                                        (recur r (concat p (map (partial cons f) p)))\n                                                        p))))))]\n  (fn [& sets]\n   (not\n    (empty?\n     (apply clojure.set/intersection\n      (map lp-set sets))))))","user":"54246fcce4b01498b1a71aed"},{"problem":131,"code":"(fn [& a]\n  (not\n   (empty?\n    (reduce (comp set filter)\n            (map (fn [s]\n                   (reduce (fn [r x]\n                             (into r (map #(+ x %) (disj r x))))\n                           s\n                           s))\n                 a)))))","user":"51ad244fe4b09397d510977f"},{"code":"(fn some-subsets? [& coll]\n  (letfn [(powerset [s]\n                    (reduce (fn [sub e]\n                              (clojure.set/union sub (set (map #(conj % e) sub))))\n                            #{#{}} s))\n          (sumset [s]\n                  (set (map #(apply + %) (filter #(not (empty? %)) s))))]\n    (not (empty?\n          (reduce #(clojure.set/intersection % %2) \n          \t  (map sumset \n            \t      (map powerset coll)))))))","problem":131,"user":"51780f88e4b03d69594194c9"},{"problem":131,"code":"(fn [& args]\n   (letfn [\n           (powerset [s] (letfn [(combine [acc x]\n                                         (conj (into acc (map #(conj % x) acc)) #{x}))]\n                          (conj (reduce combine #{} s) #{})))\n           (set-sums [v] (map #(reduce + %) (filter #(> (count %) 0) (powerset v))))\n           ]\n     (let [sums (map set (map set-sums args))]\n       (if (>= 1 (count sums))\n         true\n         (if (empty? (reduce clojure.set/intersection sums)) \n           false\n           true)\n       ))))","user":"53e76bb2e4b036ad0777e47d"},{"code":"(fn task-131 [ & sets ]\n  (let [\n        subsets-sum\n        (fn subsets-sum [s]\n          (if (empty? s)\n            s\n            (let [ss (subsets-sum (rest s))]\n              (concat (list (first s)) ss (map #(+ (first s) %) ss)))))]\n  ((complement empty?) (apply clojure.set/intersection (map (comp set subsets-sum) sets)))))","problem":131,"user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn [& xs]\n  (letfn [(sumpos [x] (apply + (filter pos? x)))\n          (sumneg [x] (apply + (filter neg? x)))\n          (subset-sum? [coll a]\n            (let [[x & xs] (seq coll)]\n              (if (empty? xs)\n                (== x a)\n                (or (== x a)\n                    (subset-sum? xs a)\n                    (subset-sum? xs (- a x))))))]\n    (boolean (some (fn [a] (every? #(subset-sum? % a) xs))\n                   (range (apply max (map sumneg xs))\n                          (inc (apply min (map sumpos xs))))))))","problem":131,"user":"4ed94d69535d10e5ff6f5303"},{"problem":131,"code":"(fn [& L]\n  (not (empty?\n  (let [subsetsum #(loop [cur #{}, [x & xs] (into [] %)]\n                     (if (nil? x) cur\n                       (recur (clojure.set/union cur #{x} (into #{} (map + cur (repeat x)))) xs)))]\n    (apply clojure.set/intersection (map subsetsum L))))))","user":"57015a1de4b08d47c97781d4"},{"code":"(fn [& sets]\n    (letfn [;; Borrowing from clojure.contrib.combinatorics\n            (index-combinations [n cnt]\n              (lazy-seq\n               (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n                     iter-comb\n                     (fn iter-comb [c j]\n                       (if (> j n) nil\n                           (let [c (assoc c j (dec (c j)))]\n                             (if (< (c j) j) [c (inc j)]\n                                 (loop [c c, j j]\n                                   (if (= j 1) [c j]\n                                       (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n                     step\n                     (fn step [c j]\n                       (cons (rseq (subvec c 1 (inc n)))\n                             (lazy-seq (let [next-step (iter-comb c j)]\n                                         (when next-step (step (next-step 0) (next-step 1)))))))]\n                 (step c 1))))\n            (combinations [items n]      \n              (let [v-items (vec (reverse items))]\n                (if (zero? n) (list ())\n                    (let [cnt (count items)]\n                      (cond (> n cnt) nil\n                            (= n cnt) (list (seq items))\n                            :else\n                            (map #(map v-items %) (index-combinations n cnt)))))))\n            (subsets [items]\n              (mapcat (fn [n] (combinations items n))\n                      (range (inc (count items)))))\n            ;; Borrowing from clojure.set\n            (bubble-max-key [k coll]\n              (let [max (apply max-key k coll)]\n                (cons max (remove #(identical? max %) coll))))\n            (intersection\n              ([s1] s1)\n              ([s1 s2]\n                 (if (< (count s2) (count s1))\n                   (recur s2 s1)\n                   (reduce (fn [result item]\n                             (if (contains? s2 item)\n                               result\n                               (disj result item)))\n                           s1 s1)))\n              ([s1 s2 & sets] \n                 (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n                   (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n            ;; Now for some functions of our own\n            (sums [s] (map #(apply + %) (filter not-empty (subsets s))))]\n      (not (empty? (apply intersection\n                          (map #(into #{} (sums %)) sets))))))","problem":131,"user":"4e89e939535d3e98b8023287"},{"code":"(fn commonsum? [& colls]\n  (let [pow2 (fn [n] (bit-shift-left 1 n))\n        bitnote (fn bitnote\n                  ([x] (bitnote x 0))\n                  ([x i]\n                   (if (< x (pow2 i))\n                           []\n                           (if (pos? (bit-and x (pow2 i)))\n                             (cons i (bitnote x (inc i)))\n                             (bitnote x (inc i))))))\n        subsets (fn [coll]\n                  (let [coll' (vec coll)\n                        fetch (fn [x]\n                                (let [x' (bitnote x)]\n                                  (map (partial get coll') x')))]\n                    (map fetch (range 1 (pow2 (count coll'))))))\n        subsetsums (fn [subs]\n                     (set (map (partial apply +) (subsets subs))))]\n    (if (not-empty (apply clojure.set/intersection (map subsetsums colls))) true false)))","problem":131,"user":"536d83cee4b0fc7073fd6e5e"},{"problem":131,"code":"(fn sumInCommon? [& s]\n  (letfn [(comb [k l]\n            (if (= 1 k) (map vector l)\n                        (apply concat\n                               (map-indexed\n                                 #(map (fn [x] (conj x %2))\n                                       (comb (dec k) (drop (inc %1) l)))\n                                 l))))\n          (all-subsets [s]\n            (apply concat\n                   (for [x (range 1 (inc (count s)))]\n                     (map #(into #{} %) (comb x s)))))\n          (sumSets [x] (let [sums (map #(apply + %) (all-subsets x))] (into #{} sums)))\n          (sumAllSets [& s] (map sumSets s))\n\n          ]\n  (not (empty? (apply clojure.set/intersection (apply sumAllSets s))))))","user":"56427910e4b08d4f616f5f19"},{"problem":131,"code":"(fn some-subset [& ss]\n  (if (= 1 (count ss))\n    true\n    (letfn [(p-set [s]\n              (if (seq s)\n                (let [r (p-set (next s))]\n                  (into r (map #(conj % (first s)) r)))\n                #{#{}}))\n            (sum [coll]\n              (reduce + 0 coll))]\n      (loop [ss' (rest ss)\n             reference (map sum (filter (complement empty?)\n                                        (p-set (first ss))))]\n        (if (empty? ss')\n          (not (empty? reference))\n          (let [reference1 (map sum (filter (complement empty?)\n                                            (p-set (first ss'))))\n                u (clojure.set/intersection (set reference) (set reference1))] \n            (if (not u)\n              false\n              (recur (rest ss') u))))))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":131,"code":"(fn [& sets]\n  (< 0 (count (filter #(= (count sets) (count %)) (vals (group-by identity (flatten (map (fn f\n  ([ss] (f ss (map (comp set vector) ss)))\n  ([ss r]\n   (if (empty? ss)\n     (sort (set (map #(reduce + %) (set r))))\n     (recur (rest ss) (into r (map #(into % (vector (first ss))) r)))))) sets))))))))","user":"56ab7578e4b03c432f18733d"},{"problem":131,"code":"(fn ssss\n  [& cc]\n  (letfn [(subsum \n            [col] \n            (into #{} (map #(apply + %)\n                           (loop [s (into #{} (for [a col] #{a})) n (dec (count col))]\n                            (if (= n 0)\n                              s\n                              (recur (into s (for [a s b col] (conj a b))) (dec n)))))))]\n    (not (empty? (apply clojure.set/intersection (map subsum cc))))))","user":"576df252e4b0979f8965156f"},{"problem":131,"code":"(fn [& c] (letfn [(f [d e] (if (empty? d) (rest e) (f (rest d) (concat e (map #(+ (first d) %) e)))))\n                  (g [m n] (if (empty? m) false (if (every? true? (map (fn [o] (some #(= % (first m)) o)) n)) true (g (rest m) n))))]\n            (let [p (map f c (partition 1 (repeat 0)))] (g (first p) (rest p)))))","user":"5c41db45e4b08cd430848ece"},{"code":"(fn [& args]\n  (letfn [(powerset [s]\n            (loop [ps #{#{}} leftover s]\n              (if-not (empty? leftover)\n                (let [thingtoadd (map #(clojure.set/union #{(first leftover)} %) ps)]\n                  (recur (concat ps thingtoadd) (rest leftover)))\n                (set ps))))\n          (pownonem [a] (remove empty? (powerset a)))\n          (sumsets [b] (set (map #(reduce + %) (pownonem b))))   ]\n  (not (empty? (apply clojure.set/intersection (map sumsets args))))))","problem":131,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn [& colls]\n  (let [f (fn [c]\n            (into #{}\n                  (map #(reduce + %) \n                       (filter #(not (empty? %))\n                               (reduce (fn [x y]\n                                         (concat x (map #(conj % y) x))) '(()) c)))))]\n    (not (empty? (apply clojure.set/intersection (map f colls))))))","problem":131,"user":"4f38d6bbe4b0e243712b1ee2"},{"code":"(fn [& sets] (< 0 (count (apply clojure.set/intersection (map #(set (map (fn [d] (reduce + d)) (rest (reduce (fn [a b] (mapcat (fn [c] [c (conj c b)]) a)) [[]] %)))) sets)))))","problem":131,"user":"52c1bd29e4b07a9af579236a"},{"problem":131,"code":"(fn common_subset_sums? [& sets]\n    (let\n        [\n            power_set\n                (fn f [set]\n                    (reduce\n                        (fn [curr val]\n                            (into curr \n                                (reduce\n                                    (fn [ret s] (conj ret (conj s val)))\n                                    #{}\n                                    curr\n                                )\n                            )\n                        )\n                        #{#{}}\n                        set\n                    )\n                )\n            remove_empty_set\n                (fn [pset] (disj pset #{}))\n            subset_sums\n                (map (comp (fn [pset] (reduce (fn [ret s] (conj ret (apply + s))) #{} pset)) remove_empty_set power_set) sets)\n        ]\n        (not (empty? (apply clojure.set/intersection subset_sums)))\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"problem":131,"code":"(fn [& xss]\n  (->> xss\n       (map\n         (fn [xs]\n           (->> xs\n                (reduce\n                  (fn [acc x] (clojure.set/union acc (map #(conj % x) acc))) \n                  #{#{}})\n                (remove empty?)\n                (map #(apply + %) )\n                (set)\n                )))\n       (apply clojure.set/intersection)\n       ((comp not empty?))))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn __ [& sets]\n (letfn \n   [(distinct-sums [s]\n    \t(letfn [(gen-subsets [ss]\n            (let [to-remove (vec ss)]\n               (map #(disj ss %) to-remove)))]\n      (loop [s (hash-set s) ps s]\n        (if (empty? (disj s))\n          (distinct (map (partial reduce +) (disj ps #{})))\n          (recur \n           (set (mapcat gen-subsets s))\n           (clojure.set/union (set (mapcat gen-subsets s)) ps))))))]\n\n   (= (count sets)\n      (apply (partial max-key identity) (vals \n    \t(frequencies\n     \t  (flatten (map distinct-sums sets))))))))","problem":131,"user":"4fa719c0e4b081705acca1bf"},{"problem":131,"code":"(fn [& sets]                                                                             \n  (let [powerset (fn [s]                                                                        \n                   (reduce (fn [ps e]                                                           \n                             (into ps (for [x ps] (conj x e))))                                 \n                           [#{}]                                                                \n                           s))                                                                  \n        subset-sums (fn [s] (set (map #(apply + %) (rest s))))]                                 \n    (not (empty? (apply clojure.set/intersection (map (comp subset-sums powerset) sets))))))","user":"4eb70649535d7eef30807373"},{"problem":131,"code":"(fn [& list-of-int-sets]\n             \n             (let [ \n                   pad-binary (fn [binary-str length]\n                                (if (< (count binary-str) length)\n                                  (str (apply str (repeat (- length (count binary-str)) \"0\")) binary-str)\n                                  binary-str))\n                   \n                   create-subset-from-binary-string (fn [binary-string vec-of-elements]\n                                                      (disj (set (map \n                                                                   (fn [binary-val vec-val] \n                                                                     (if (= \"1\" (str binary-val)) vec-val nil))\n                                                                   binary-string vec-of-elements)) nil))\n                   find-all-subsets (fn [ set-of-ints ]\n                                      (let [ vec-of-elements (vec set-of-ints) \n                                             ]\n                                      (reduce (fn [accum val] \n                                                (conj accum (create-subset-from-binary-string (pad-binary (Integer/toBinaryString val) (count vec-of-elements)) vec-of-elements))\n            \n                                                ) []  (range (Math/pow 2 (count set-of-ints))))))\n                   \n                   set-of-all-sums (fn [set-of-ints]\n                                     (let [all-subsets-list (find-all-subsets set-of-ints) ]\n                                       (reduce (fn [accum val] \n                                                 (if (> (count val) 0)\n                                                   (conj accum (apply + val))\n                                                   accum)\n                                                 ) #{} all-subsets-list)))\n                   \n                   \n                   list-of-all-summations (map set-of-all-sums list-of-int-sets)\n                    val-exists-in-all-sets (fn [ val ]\n                                             (reduce (fn [accum set-val] \n                                                 (if (= false accum) false\n                                                 (if (not= nil (set-val val))\n                                                    true\n                                                    false)) \n                                                    ) true list-of-all-summations) )\n                   ]\n                  (reduce (fn [accum val]  \n                            \n                            (if (= true accum) true\n                            (if (val-exists-in-all-sets val)\n                                \n                                true\n                                false))\n                            \n                            ) false (first list-of-all-summations) )\n               )\n             \n             )","user":"53c73e8ae4b00fb29b2212a5"},{"problem":131,"code":"#(not= nil (seq (apply clojure.set/intersection\n                       (map (fn [s]\n                              (set (map (partial apply +) (filter seq (loop [[f & r] (seq s) p '(())]\n                                                                        (if f (recur r (concat p (map (partial cons f) p)))\n                                                                            p))))))\n                            %&))))","user":"5547b72be4b0a04f79299550"},{"code":"(fn\n  [& y]\n  (let [p (fn p [s]\n         (if (empty? s)\n           #{#{}}\n           (let [x (first s)\n                 xs (rest s)]\n             (apply merge (p xs) (map #(conj % x) (p xs))))))]\n    (not (empty?\n          (apply clojure.set/intersection\n                 (map\n                  (fn [x]\n                    (set (map #(reduce + 0 %) (disj (p x) #{}))))y))))))","problem":131,"user":"4db53f87535d87e67b28fe08"},{"problem":131,"code":"(letfn [(sub [x] (map #(disj x %) x))\n\n          (subs [x i]\n                (if (= i 1)\n                  x\n                  (recur (into #{} (concat x (mapcat sub x))) (dec i))))\n\n          (subhack [x] (subs #{x} (count x)))\n\n          (sums [x] (into #{} (map #(apply + %) (subhack x))))\n\n          (compare [& x] ((complement empty?) (apply clojure.set/intersection (map sums x))))]\n    compare)","user":"5c683fb5e4b0fca0c16226d5"},{"code":"(fn [& ss]\n  (letfn [(subsets [s]\n            (remove empty? (set (reduce (fn [s v] (concat s (map #(conj % v) s))) #{#{}} s))))]\n    (not (empty? (apply clojure.set/intersection (map #(set (map (partial apply +) (subsets %))) ss))))))","problem":131,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":131,"code":"(fn [& s]\r\n  (letfn [(combos [s]\r\n            (reduce (fn [acc v]\r\n                      (let [expand (map (partial + v) acc)\r\n                            res (if (seq expand)\r\n                                  (apply conj acc expand)\r\n                                  acc)]\r\n                        (conj res v))) #{} s))]\r\n    ((complement empty?) (reduce clojure.set/intersection (map combos s)))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [& r] \n           (loop [l r\n                  acc []]\n             (if (empty? l)\n               ;; [(count (set (reduce into (map seq acc))))\n               ;;  (- (reduce + (map count acc)) (dec (count r)))]\n               (<= (count (set (reduce into (map seq acc))))\n                  (- (reduce + (map count acc)) (dec (count r))))\n               (let [s (seq (first l))]\n                 (recur (rest l)\n                        (conj acc (set (for [i s j s]\n                                         (+ i j)))))))))","problem":131,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":131,"code":"(fn [ & sets]\n         (letfn [(sums\n                   ([xs] (sums xs []))\n                   ([xs out]\n                    (if (empty? xs) out\n                        (let [ x (first xs)\n                              prevSums (sums (rest xs) out)\n                              xSums (map #(+ x %) prevSums) ]\n                          (into (conj xSums x) prevSums)))))]\n           (let [alSums (map #(set (sums %)) sets)]\n             (not (empty?(reduce  clojure.set/intersection  alSums))))))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"(fn [& sets]\n  (not=\n    nil\n    (seq\n      (reduce\n        #(set (filter (fn [ele] (%1 ele)) %2))\n        (map\n          (fn [s]\n            (set\n              (map\n                #(reduce + %)\n                (filter\n                  #(seq %)\n                  (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))))\n          sets)))))","problem":131,"user":"514d7e29e4b019235f6c0587"},{"code":"(let [p (comp set\n                (fn p [[f & r]] (if f (concat (p r) [#{f}] (map #(conj % f) (p r)))\n                                   [#{}]))\n                seq)]\n    (fn [& s] (not (empty? (apply clojure.set/intersection\n                                 (map (fn [x]\n                                        (set (map #(reduce + %)\n                                                  (remove empty? x))))\n                                      (map p s)))))))","problem":131,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn chk [& sets]\r\n  (letfn [(permutation [s]\r\n                       (letfn [(addelem [setofsets elem]\r\n                                        (set (concat setofsets (map #(conj % elem) setofsets))))]\r\n                         (set (filter #(> (count %) 0) (reduce addelem #{#{}} s)))))\r\n          (sumofperm [s] (set (map #(apply + %) (permutation s))))]\r\n    (not (empty?\r\n          (apply clojure.set/intersection (map sumofperm sets))))))","problem":131,"user":"4f62b29ce4b0defedf855fd9"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(ps [s] (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}} s))\n          (sums [s] (set (map #(apply + %) (disj (ps s) #{}))))]\n    (boolean (not-empty (apply clojure.set/intersection (map sums ss))))))","user":"52ce1abfe4b07d0d72b27389"},{"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (if (empty? s)\n              #{#{}}\n              (let [rest-subsets (subsets (rest s))]\n                (set (concat rest-subsets\n                             (map #(conj % (first s))\n                                  rest-subsets))))))]\n    (let [sum-of-subsets (map (fn [s] (set (map #(apply + %)\n                                                (remove empty? (subsets s)))))\n                              sets)]\n      (not (nil? (some (fn [n] (every? #(% n) (rest sum-of-subsets)))\n                       (first sum-of-subsets)))))))","problem":131,"user":"4e7c8fd1535db169f9c796be"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(all-subsets [coll] (disj (reduce\n                                     #(clojure.set/union %1 (map (fn [x] (conj x %2)) %1))\n                                     #{#{}} coll) #{}))]\n    ((complement empty?)\n     (apply clojure.set/intersection\n            (map (fn [sets]\n                   (set (map #(reduce + %) sets)))\n                 (map all-subsets sets))))))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(fn p131 [& sets]\n  (letfn [(pset [s]\n             (reduce (fn[result cur]\n                       (concat result (map #(conj % cur) result)))\n                     [#{}] s))]\n    ((complement empty?)\n     (apply clojure.set/intersection\n            (map set (map\n                      (fn [x] (map #(reduce + %) (remove #(= % #{}) ( pset x))))\n                      sets))))))","problem":131,"user":"500b61b1e4b03d00572d2d81"},{"code":"(fn [& args]\n  (letfn [(subsums [s]            \n            (if (empty? s)\n              #{}\n              (let [s1 (subsums (rest s))\n                    s2 (map #(+ % (first s)) s1)]\n                (into s1 (conj s2 (first s))))))]\n    (not (empty? (apply clojure.set/intersection (map subsums args))))))","problem":131,"user":"4e1350af535d04ed9115e7d8"},{"problem":131,"code":"(fn [& cols]    \n  (let [subsets (fn [col]\n                 (loop [acc [] [h & r] (vec col)]\n                   (if-not h acc (recur (concat acc [[h]] (map #(cons h %) acc)) r))))]\n    (not (empty? (apply clojure.set/intersection (map (fn [col] (set (map #(apply + %) (subsets col)))) cols))))))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn [& s]\n  (not (empty?\n  (reduce\n    clojure.set/intersection\n    (map\n      (fn [i]\n        (reduce \n          (fn [r j]\n            (into r (map #(+ j %) (conj r 0))))\n          #{}\n          i))\n      s)))))","problem":131,"user":"4e5411e8535d8a8b8723a279"},{"problem":131,"code":"(fn [& ss]\n  (let [r (fn r [[x & xs]]\n            (if x (mapcat #(vector (cons x %) %) (r xs))\n                  [x]))]\n    (not (empty? (apply\n                   clojure.set/intersection\n                   (map #(set (map (partial apply +)\n                                   (butlast (r (seq %)))))\n                        ss))))))","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":131,"code":"; reuses power set solution from #85\n(fn [& sets]\n  (let [power-set\n          (fn [input-set]\n            (reduce\n              (fn [s e] (into s (map #(conj % e) s)))\n              #{#{}}\n              input-set))\n          power-sets-summations\n            (fn [input-set]\n              (let [power-set (power-set input-set)\n                    power-set-minus-empty-set (disj power-set #{})]\n                (set (map #(apply + %) power-set-minus-empty-set))))\n          common-summations \n            (fn [sets]\n              (let [summations (map power-sets-summations sets)]\n                (reduce\n                  #(clojure.set/intersection %1 %2)\n                  (first summations)\n                  (rest summations))))]\n    (if (seq (common-summations sets)) true false)))","user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [& sets]\n  (letfn [(sums [set]\n                (cond \n                 (empty? set)      ()\n                 (= 1 (count set)) (seq set)\n                 :else (lazy-seq\n                        (let [rest-sums (sums (rest set))]\n                          (concat rest-sums (map #(+ (first set) %) (cons 0 rest-sums))))))\n                \n\n                )]\n    (not\n     (empty?\n      (apply clojure.set/intersection\n             (map (comp set sums) sets))))))","problem":131,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn\n    [& s]\n    (letfn\n        [\n         ( p [s]\n           (if (empty? s)\n             #{#{}}\n             (let [[h & t] (vec  s)\n                   subz (p (set t))]\n               (set (concat subz (map #(conj % h) subz))))))]\n      (->> s\n           (map p)\n           (map #(map (partial apply +) (disj % #{})))\n           (map set)\n           (apply clojure.set/intersection)\n           (not= #{})\n           )\n      ))","problem":131,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [& sets]\n  (letfn \n    [(powersums [seq]\n       (cond \n         (empty? seq) nil\n         (empty? (drop 1 seq)) seq\n         :else \n          (concat (take 1 seq)\n                  (powersums (rest seq))\n                  (map + (repeat (first seq))\n                  (powersums (rest seq))))))]\n    (->> sets (apply list)\n              (map vec)\n              (map powersums)\n              (map set)\n              (apply clojure.set/intersection)\n              empty?\n              not\n              boolean)))","problem":131,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn [& xs]\n  (let [sum-set\n        (fn sum-set\n          ([x] (sum-set x #{}))\n          ([x sofar] (if (empty? x)\n                       (if (empty? sofar) #{} #{(apply + sofar)})\n                       (clojure.set/union\n                        (sum-set (disj x (first x)) (conj sofar (first x)))\n                        (sum-set (disj x (first x)) sofar)))))]\n    (not (empty? (apply clojure.set/intersection (map sum-set xs))))))","problem":131,"user":"510acd6ee4b078ea719210f4"},{"code":"(fn [& x]\r\n  (< 0\r\n    (count\r\n      (reduce (comp set keep)\r\n        (map\r\n          (fn [s]\r\n            (set\r\n              (keep #(if (< 0 (count %)) (reduce + %) )\r\n                (reduce\r\n                  (fn [s r] (into s (map #(conj % r) s)))\r\n                  #{#{}}\r\n                  s))))\r\n          x)))))","problem":131,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":131,"code":"(fn [& xs]\n  (letfn [(p [x] (reduce (fn [acc i]\n                          (concat (conj acc #{i}) \n                              (map (fn [i1] (conj i1 i)) acc)))  [] x))\n          (sum [x] (set (map (fn [s] (apply + s)) x)))]\n      (->> (map p xs)\n            (map sum)\n            (apply clojure.set/intersection)\n            (empty?)\n            (not)\n            )))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":131,"code":"(fn some-set-subsets [& sets]\n                       (letfn [( subset-sum\n                                 [s]\n                                 (if (= (count s) 1) s\n                                                (let [recursion (subset-sum (rest s))]\n                                                  (set (concat recursion (map #(+ (first s) %) recursion) [(first s)])))))]\n                         (not (empty? (reduce clojure.set/intersection (map subset-sum sets))))))","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":131,"code":"(fn [& sets]\n (not (empty? (apply clojure.set/intersection \n               (map (fn [s]\n                     (set (map #(reduce + %) \n                           (disj (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}} s) #{})))) sets)))))","user":"5835cb06e4b089d5ab817cea"},{"problem":131,"code":"(fn pr131 [& sets]\n  (let [intersection (fn inter\n                       ([x] x)\n                       ([x y]\n                        (set (filter x y)))\n                       ([x y & sets]\n                        (apply inter (inter x y) sets)))\n        make-summation (fn make-summation [st]\n                         (reduce (fn [s i]  \n                                   (conj (into s (map #(+ i %) s)) i)) \n                                 #{} st))]\n    (not (empty? \n           (apply intersection (map make-summation sets))))))","user":"51696ee7e4b03f62cda68ce8"},{"problem":131,"code":"(fn [& sets] \n  (let [pwr (fn pwr [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ls (into '() s)\n          rst (into '() (pwr (set (rest ls))))]\n      (set (concat rst \n                   (map #(conj % (first ls)) rst))))))]\n    \n  (> \n   (count \n    (apply clojure.set/intersection \n           (map \n            (fn [s] (set (map #(reduce + %)\n                         (filter #(not (empty? %))\n                            (pwr s)))))\n            sets))) \n   0)))","user":"541ef7e2e4b01498b1a71a92"},{"problem":131,"code":"(fn [& args]\n   (let [subsets (fn subsets\n                   [length s]\n                   (if (>= 1 length) (map list s)\n                                     (mapcat (fn [x]\n                                               (map #(cons x %) (subsets (dec length)\n                                                                         (drop-while #(not (= x %)) s)))) s)))\n         all-subsets (map (fn [sets] (into #{} (map #(reduce + %)\n                                                    (mapcat #(subsets % sets)\n                                                            (range 1 (inc (count sets))))))) args)]\n     (not (empty?\n            (reduce clojure.set/intersection all-subsets)))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":131,"code":"(fn\n  [& sets]\n  (letfn [(subsets-of-size\n            [sp n sss]\n            (if (= n (count sp))\n              [sp]\n              (apply concat (for [i (range 1 (inc (count sss)))]\n                              (let [[sf ss] (split-at i sss)\n                                    sn (last sf)]\n                                (subsets-of-size (conj sp sn) n ss))))))\n          (all-subsets\n            [sets]\n            (apply concat (for [n (range 1 (inc (count sets)))]\n                            (subsets-of-size [] n sets))))\n          (sum-of-all-subsets\n            [sets]\n            (->> sets\n                 (map all-subsets)\n                 (map #(map (partial apply +) %))\n                 (map set)))\n          (find-common-elements\n            [sets]\n            (reduce clojure.set/intersection sets))]\n    (-> sets\n        sum-of-all-subsets\n        find-common-elements\n        count\n        (> 0))))","user":"56bb652ae4b0f26550335953"},{"code":"(fn [& args]\n  (letfn [(c [k v] \n            (cond \n              (> k (count v)) #{}\n              (= k 1) (set (map #(set [%]) v))\n              (= k (count v)) #{(set v)}\n              :else \n                (into (c k (rest v)) (map #(conj % (first v)) (c (dec k) (rest v))))))\n          (f [v] (for [i (range 1 (inc (count v)))] (c i v)))\n          (g [v] (set (mapcat (fn [s] (map #(reduce + %) s)) (f v))))\n          \n          ]\n      (not (empty? (apply clojure.set/intersection (map g args))))))","problem":131,"user":"4ffa8affe4b0678c553fc3bd"},{"code":"(fn [& s]\n    (let [p (fn [s]\n              (disj (reduce (fn [s a] (clojure.set/union s (map #(conj % a) s))) #{#{}} s) #{}))\n          r (fn [s] (set (map #(apply + %) (p s))))]\n      (not (empty? (apply clojure.set/intersection (map r s))))))","problem":131,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"(fn [& sets]\n    (letfn [(pset [s] (reduce (fn [cc e] (into (map #(conj % e) cc) cc)) #{#{}} s))]\n      (not (empty?\n            (apply clojure.set/intersection\n                   (map (fn [lst] (set (map #(apply + %)\n                                            (filter not-empty lst))))\n                        (map pset sets)))))))","problem":131,"user":"4efd8b67535de96065cf5085"},{"problem":131,"code":"(fn sum-some-set [& s]\n  (letfn [\n   (inc-range [s mx]\n        (let [size (count s)]\n            (loop [i (dec size)]\n                (if (and (= i 0) (= (first s) (- mx size)))\n                    nil\n                    (if (< (nth s i) (- mx (- size i)))\n                        (vec (concat (take i s) (take (- size i) (iterate inc (inc (nth s i)) )) ))\n                        (recur (dec i))\n                    )\n                )\n            )\n        )\n    )\n    (filter-by-index [coll idxs]\n        (keep-indexed #(when ((set idxs) %1) %2) \n                      coll))\n    (subsets [s m]\n        (let [n (count s)]\n            (loop [result #{} i (vec (range m))]\n                (if (not i)\n                    result\n                    (recur (conj result (apply + (filter-by-index s i))) (inc-range i n)))\n            )\n        )\n    )       \n    (power-set [s] \n      (reduce (fn [a b] (into a (subsets s b))) #{} (range 1 (inc (count s))))\n    )\n    (common [[s1 & s]] \n      (loop [x (first s1) r (rest s1)] \n        (if (every? #(some #{x} %) s)\n        x\n        (if-not (first r) nil (recur (first r) (rest r)))\n        )\n    ))\n  ] \n    (not (nil? (common (map power-set s))))\n))","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [& sets]\n(let [\n  ccc (fn ccc [s]\n    (case s\n     #{}  #{ #{} }\n    (let [sq (seq s)\n              x (first sq)\n              xs (set (rest sq))\n              prev (ccc xs)]\n          (into prev (for [y prev] (conj y x))) )))\n  power-sets (for [s sets] (ccc s))\n  sums (for [ps power-sets] (set (map #(reduce + %) (filter #(not (empty? %)) (seq ps)))))]\n  (not (empty? (apply clojure.set/intersection sums)))\n  ))","problem":131,"user":"52b63875e4b0c58976d9ad41"},{"problem":131,"code":"(fn [& sets]\n(letfn [(subssum [coll]\n  (if-let [[e & more] (seq coll)]\n  ((fn [x] (clojure.set/union (conj x e) (set (map #(+ e %) x)))) (subssum more))\n    #{}))] (-> sets (#(map subssum %)) (#(apply clojure.set/intersection %)) empty? not)))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn [& xs]\n  (letfn [(powerset [s]\n            (reduce (fn [ps x]\n              (reduce (fn [ps s]\n                (conj ps (conj s x))) ps ps)) #{#{}} s))]\n    (not (empty?\n      (apply clojure.set/intersection\n       (map (fn [s]\n              (into #{} (map #(apply + %)(filter seq (powerset s)))))\n            xs))))\n    ))","problem":131,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(letfn [(subsets [coll] (if (empty? coll)\n                          #{#{}}\n                          (let [ssets (subsets (rest coll))]\n                            (clojure.set/union ssets (map #(conj % (first coll)) ssets)))))\n        (sumsset [coll] (set (map (partial apply + ) (clojure.set/difference (subsets coll) #{#{}}))))]\n  (fn [& s]\n    (not (empty? (apply clojure.set/intersection (map sumsset s))))))","problem":131,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [& ls]\n  (letfn [\n          (ps [s]\n            (letfn [(expand\n                       [[a b]]\n                       (when-not\n                (empty? b)\n              (cons\n               [(conj a (first b))\n                (rest b)]\n               (expand [a (rest b)]))))\n                     (combos\n            [n s]        \n            (if (zero? n)\n              (list [[] s])\n              (mapcat\n               expand\n               (combos (dec n) s))))\n          (partialflatten [c]\n            (filter #(and (coll? %) (not-any? coll? %))\n                    (tree-seq coll? seq c)))]\n               (set (map set (partialflatten (for [i (range (inc (count s)))]\n                                               (map first (combos i s))\n                                               ))))))\n          (tosums [s]\n            (set  (map #(reduce + %) (disj (ps s) #{}))))\n          ]\n    (not (empty? (apply clojure.set/intersection (map tosums ls))))))","problem":131,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn [& xs]\n  (let [pwr-set (fn pwr-set [xs]\n    (into #{} (let [min-set first\n          delete-min-set #(disj % (min-set %))\n          pxs (lazy-seq (pwr-set (delete-min-set xs)))]\n      (if (empty? xs)\n        #{#{}}\n        (clojure.set/union (map #(conj % (min-set xs)) pxs) pxs)))))]\n    (not= #{} (apply clojure.set/intersection (map (comp (partial into #{}) (partial map (partial apply +)) #(disj % #{}) pwr-set) xs)))))","problem":131,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn x [& v]\n  (letfn [(csum [s]\n            (set (if (= (count s) 1) [(first s)]                \n                     (concat [(first s)]\n                             (map #(+ (first s) %) (csum (rest s)))\n                             (csum (rest s))))))]\n    (not (empty? (apply clojure.set/intersection (map csum v))))))","problem":131,"user":"4facd2fae4b081705acca22f"},{"problem":131,"code":"(fn [& args]\n  (letfn [(sum [lst] (map #(reduce + (seq %)) lst))\n          (comb [k l]\n            (if (= 1 k) (map vector l)\n                (apply concat\n                       (map-indexed\n                        #(map (fn [x] (conj x %2))\n                              (comb (dec k) (drop (inc %1) l)))\n                        l))))\n          (all-subsets [s]\n            (apply concat\n                   (for [x (range 1 (inc (count s)))]\n                     (map #(into #{} %) (comb x s)))))]\n    (let [all (map all-subsets args)\n          ss (map sum all)]\n      (loop [rm (first ss)]\n        (cond (empty? rm) false\n              (every? true? (map #(some (partial = (first rm)) %) (rest ss))) true\n              :else (recur (rest rm)))))))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [a & more]\n  (letfn [(powerset [s]\n            (let [v (vec s) c (count v) r (range 0 c)]\n              (map (fn [i]\n                     (reduce\n                        (fn [acc j]\n                          (if (not= 1 (mod (bit-shift-right i j) 2)) acc\n                              (conj acc (get v j))))\n                        #{} r)) (range 0 (bit-shift-left 1 c)))))]\n    (let [sqn (cons a more)]\n      (not (empty?\n            (apply clojure.set/intersection\n                   (map (fn [y] (set (map (fn [z] (reduce + z)) (filter (fn [x] (seq x)) y))))\n                        (map powerset sqn))))))))","problem":131,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn [& coll]\r\n  (letfn [(ps [s]\r\n            (if (empty? s)\r\n              '([])\r\n              (mapcat #(list % (conj % (first s))) (ps (rest s)))))\r\n          (powerset [s]\r\n            (set (map #(set %) (ps s))))\r\n          (intersection [s & ss]\r\n            (every? seq (map (fn [x] (filter #(s %) x)) ss)))]\r\n    (apply intersection\r\n      (map\r\n        (fn [s]\r\n          (set (map\r\n                 #(reduce + %)\r\n                 (disj (powerset s) #{}))))\r\n        coll))))","problem":131,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":131,"code":"(fn [& sets]\n  (let [select (fn [i s]\n                 (let [b (clojure.pprint/cl-format nil (str \"~\" (count s) \",'0b\") i)]\n                   (->> s \n                        (map vector b)\n                        (filter #(= \\1 (first %)))\n                        (map second))))\n        subset-sums (fn [s] (for [x (range 1 (apply * (repeat (count s) 2)))]\n                              (apply + (select x s))))]\n    (->> sets\n      (map subset-sums)\n      (map set)\n      (apply clojure.set/intersection)\n      ((complement empty?))\n    )))","user":"58247423e4b051871117bec5"},{"code":"(fn sum-subsets [& s]\n  (let [ps (fn powerset [s]\n             (reduce (fn [acc e] \n                       (into acc (map conj acc (repeat e))))\n                     #{#{}}\n                     s))\n        pss (map #(disj (ps %) #{}) s)\n        sums (map (fn [p] (set (map #(apply + %) p))) pss)]\n    (not (empty? (apply clojure.set/intersection sums)))))","problem":131,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn [& sets]\n    (let [powerset (fn powerset [s] (if (empty? s) (list s) (mapcat #(list % (conj % (first s))) (powerset (rest s)))))\n          sum      (partial reduce + 0)]\n      (->> sets\n        (map (comp\n               set\n               (partial map sum)\n               (partial remove empty?)\n               powerset))\n        (apply clojure.set/intersection)\n        empty?\n        not)))","problem":131,"user":"525f51bde4b0cb4875a45dc8"},{"problem":131,"code":"(fn a [& sets] (letfn [(f [s]\n  (if (= 1 (count s)) #{s}\n    (loop [new-set (set (for [x s\n                       y s :when (not= x y)]\n                   #{x y}))\n               result-set (clojure.set/union #{s} new-set (set (for [x s] #{x})))]\n          \n          (let [a (set (for [x new-set\n                         y s\n                         :when (not (contains? x y))]\n                     (conj x y)))]\n            \n          (if (= a new-set) result-set\n            (recur a (into result-set a)))))))]\n  (let [super-sets (map f sets)\n        super-sets-sums (map (fn [ss] (set (map #(apply + %) ss))) super-sets)\n        remaining (apply clojure.set/intersection super-sets-sums)]\n    (>= (count remaining) 1))))","user":"53973e7be4b0b51d73faaee6"},{"problem":131,"code":"(letfn [(pset [s] (set (reduce (fn [sets x] (concat sets (map #(conj % x) sets))) #{#{}} s)))\n        (psums [s] (set (map #(apply + %) (disj (pset s) #{}))))]\n  (fn [& ss] (not (empty? (apply clojure.set/intersection (map psums ss))))))","user":"5db92996e4b010eb3c36cd50"},{"problem":131,"code":"(fn [& ss]\n  (let [sum-f\n          (fn [s]\n            (set\n              (keep #(if (empty? %) nil (apply + %))\n                (reduce \n                  (fn [a b] \n                    (into a (map #(conj % b) a))) #{[]} s))))\n        sums (map sum-f ss)]\n    (-> (apply clojure.set/intersection sums) empty? not)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":131,"code":"(fn sssss [& input]\n  (letfn [(p-set [xs]\n            (letfn [(combination [xs n]\n                                 (if (> n (count xs))\n                                   #{}\n                                   (if (= n 1)\n                                     (set (map #(-> #{%}) xs))\n                                     (if (= n (count xs))\n                                       #{xs}\n                                       (let [previous (combination xs (dec n))]\n                                         (set (mapcat\n                                               (fn [c] (let [others (filter #(not (contains? % c)) previous)]\n                                                         (set (map #(set (cons c %)) others))))\n                                               xs)))))))]\n              (set (mapcat #(combination xs %) (range 1 (inc (count xs)))))))]\n\n    (let [sums (map (fn [x] (set (map #(reduce + %) (p-set x)))) input)\n          intersection-count (count (apply clojure.set/intersection sums))]\n      (> intersection-count 0))))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [& s]\n  (letfn [(subsets [s]\n            (if (empty? s) #{#{}}\n              (let [ss (subsets (next s))]\n                (into ss (map #(conj % (first s)) ss)))))\n          (subset-sums [ss]\n            (->> ss\n                 (subsets)\n                 (remove empty?)\n                 (map (partial apply +))\n                 (into #{})))\n          (intersection [s1 s2] (clojure.set/intersection s1 s2))]\n    (not (empty? (reduce intersection (map subset-sums s))))))","problem":131,"user":"504e04a4e4b078edc5f59397"},{"problem":131,"code":"(fn [& sets]\n    (letfn [(power-set [a-set]\n                (reduce (fn [b x] (concat (map #(conj % x) b) b)) [#{}] a-set))\n            (summarize [p-set] (map #(apply + %) (remove empty? p-set)))]\n      (->> sets\n           (map (comp set summarize power-set))\n           (reduce clojure.set/intersection)\n           ((complement empty?))\n           )))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(fn [& sets]\n  ((complement empty?)\n   (apply\n     clojure.set/intersection\n     (map\n       (fn subsets [parent-set]\n         (if \n           (empty? parent-set) \n           #{} \n           (set \n             (concat \n               [(first parent-set)] \n               (subsets (rest parent-set)) \n               (map \n                 (partial + (first parent-set)) \n                 (subsets (rest parent-set)))))))\n      sets))))","problem":131,"user":"521e8227e4b0dd19981ad082"},{"code":"(letfn [(subsets\n         [xs]\n         (if (empty? xs) #{#{}}\n           (let [[x & xs] (seq xs)\n                 xs (subsets xs)]\n             (clojure.set/union xs\n              (map #(conj % x)\n                   xs)))))]\n  \n  (fn eq-sub-sums?\n    [& sets]\n    (->> sets\n         (map (comp set\n                    (partial\n                     map\n                    (partial apply +))\n                    #(disj % #{})\n                    subsets))\n         (apply clojure.set/intersection)\n         empty? not)))","problem":131,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":131,"code":"(fn sum-some-set-subset\n  [& sets]\n  (letfn [(combinations\n            [size num-set]\n            (letfn [(combine [x num-set] (map #(conj x %) num-set))]\n              (loop [result (into #{} (map hash-set num-set))\n                     counter 1]\n                (if (= counter size)\n                  result\n                  (recur (into #{} (mapcat #(combine % num-set) result)) (inc counter))))))\n          (get-all-possible-sums\n            [num-set]\n            (into #{} (map #(reduce + %) (combinations (count num-set) num-set))))\n          (other-cotains? \n            [val sets]\n            (every? true? (map #(contains? % val) sets)))]\n    (let [[first-set & more] (map get-all-possible-sums sets)]\n      (not (empty? (filter #(other-cotains? % more) first-set))))))","user":"509a25b7e4b0efbae1fbc0a8"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(combs [a-set]\n            ;; get all combinations of collection\n            (let [cnt (count a-set)\n                  v-set (vec a-set)]\n              (map (fn [i]\n                     ;; get elements with indices\n                     (map (fn [j] (nth v-set j))\n                          ;; index with \\1\n                          (keep-indexed (fn [idx itm]\n                                          (when (= itm \\1)\n                                            idx))\n                                        ;; binary strings\n                                        (clojure.string/replace (format (str \"%\" cnt \"s\")\n                                                                        (Integer/toBinaryString i)) #\" \" \"0\"))))\n                   (range 1 (int (Math/pow 2 cnt))))))]\n    (pos? (count (apply clojure.set/intersection\n                        (map (fn [a-set]\n                               (set (map (fn [i] (apply + i)) (combs a-set))))\n                             sets))))))","user":"4ee528fb535d1385b2869d87"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (remove #(empty? %) (reduce #(into %1 (for [e %1] (conj e %2))) #{#{}} s)))]\n    (->> (map subsets sets)\n         (map #(for [s %] (reduce + s)))\n         (map set)\n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","user":"567695c2e4b05957ce8c6157"},{"code":"(fn [& sets]\n    (not (empty? (apply clojure.set/intersection\n                        (for [s sets]\n                          (reduce (fn [ps item]\n                                    (-> ps\n                                        (conj item)\n                                        (into (map #(+ item %) ps)))) #{} s))))))","problem":131,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":131,"code":"(fn [& s]\n   (not (empty?\n   (apply clojure.set/intersection\n     (map (fn [l]\n       (set (map #(apply + %)\n                 (rest\n                   (reduce #(into %1 (map conj %1 (repeat %2))) \n                           [[]] l))))) s)))))","user":"57d9f603e4b0bd073c20240a"},{"problem":131,"code":"(fn [& p]\n    (let [m map\n          r reduce\n          c conj\n          i into]\n      (->> (m (fn [s]\n                  (r\n                   (fn [a e]\n                     (i\n                      a\n                      (m #(c % e) a)))\n                   (i #{} (m #(c #{} %) s))\n                   s))\n                p)\n           (m (fn [s] (i #{} (m #(apply + %) s))))\n           (r #(i #{} (filter % %2)))\n           empty?\n           not)))","user":"505106fee4b05ab4c7e07d38"},{"problem":131,"code":"(fn [& ss]\n  (let [set_of_subset_sums (fn [s]\n                              (let [power_set (fn [a_set]\n                                   (loop [xs a_set\n                                          ps #{#{}}]\n                                         (if (empty? xs)\n                                             ps\n                                             (recur (rest xs)\n                                                    ((fn [set_of_sets item]\n                                                         (clojure.set/union set_of_sets\n                                                                            (set (map (fn [s] (conj s item)) set_of_sets)))) ps\n                                                                                                                             (first xs))))))]\n                                    (set (map (fn [x] (apply + x)) (filter (fn [x] (not (empty? x))) (power_set s))))))]\n        (not (empty? (reduce clojure.set/intersection (map set_of_subset_sums ss))))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":131,"code":"(fn sum-some-set-subsets [& sets]\n  (letfn [(power-set [s]\n  (let [first (first s) subset (rest s)]\n    (if (empty? s) #{#{}}\n        (clojure.set/union\n         (into #{} (map #(clojure.set/union #{first} %) (power-set subset)))\n         (power-set subset)))))]\n    (->> sets\n         (map (fn [s]\n                (set (map #(apply + %)\n                          (filter #(not= #{} %) (power-set s))))))\n         (reduce clojure.set/intersection)\n         empty?\n         not)))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn [& c]\n  (not\n   (empty?\n    (apply clojure.set/intersection\n           (set\n            (map\n             (fn [s]\n               (set\n                (map (partial apply +)\n                     (remove empty?\n                             ((fn f [s]\n                                (if (empty? s)\n                                  #{s}\n                                  (let [[h t] ((juxt first (comp f set next))\n                                               s)]\n                                    (set\n                                     (concat t\n                                             (map #(conj % h)\n                                                  t))))))\n                              s)))))\n             c))))))","problem":131,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn [& colls]\n  (letfn [(subsets [s] (if (empty? s) #{#{}} (let [sub (subsets (rest s)) mapped (map #(conj % (first s)) sub)] (set (concat sub mapped)))))]\n    (let [sums (fn [s] (set (map #(apply + %) s)))\n          common? (fn [key colls] (reduce #(and %1 %2) (map #(contains? % key) colls)))\n          common-key? (fn [colls] (reduce #(or %1 %2) (map #(common? % colls) (first colls))))]\n      (->> colls\n        (map subsets)\n        (map #(disj % #{}))\n        (map sums)\n        common-key?\n        ))))","problem":131,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn sum-some-set-subsets [& sets]\n  (letfn [(subsets [s]\n            (if-not (seq s)\n              #{#{}}\n              (let [rest-subsets (subsets (rest s))]\n                (into rest-subsets\n                      (map #(conj % (first s)) rest-subsets)))))\n          (possible-sums [s]\n            (into #{}\n                  (map #(reduce + %) (filter not-empty (subsets s)))))]\n    (> (->> sets\n            (map possible-sums)\n            (reduce clojure.set/intersection)\n            count)\n       0)))","problem":131,"user":"530578ede4b0d8b024fd3760"},{"problem":131,"code":"(fn [& args]\n  (not (empty?\n        (apply clojure.set/intersection\n               (map (fn [s] (set (map #(reduce + %)\n                                     (disj (reduce (fn [acc x] (into acc (map #(conj % x) acc)))\n                                                   #{#{}}\n                                                   s)\n                                           #{})))) args))))\n  )","user":"563dfc02e4b0da801c4e4662"},{"problem":131,"code":"(fn equivalent-summation?\n  [& sets]\n  (let [combinatorics\n        (fn [s]\n          (loop [result #{#{}}\n                 k 0]\n            (if (= k (count s))\n              result\n              (recur (set\n                      (for [s1 result\n                            s2 s]\n                        (conj s1 s2)))\n                     (inc k)))))\n        sums (map #(into #{} (map (fn [inner-set] (reduce + inner-set)) %)) (map combinatorics sets))]\n    (not (empty? (apply clojure.set/intersection sums)))))","user":"4fc524aae4b081705acca37e"},{"code":"(fn [& s] \n  (letfn \n    [ (subsets [s] \n        (for [i (range 1 (Math/pow 2 (count s)))] \n          (keep-indexed \n            #(when (bit-test i %) %2) \n            s)))\n      (sums [s] \n        (set (map #(reduce + %) s)))]\n    (->> s\n      (map (comp sums subsets))\n      (apply clojure.set/intersection)\n      (not= #{}))))","problem":131,"user":"4f991ec1e4b0dcca54ed6cfb"},{"problem":131,"code":"(fn self [& xs]\n    (let [bit-length (fn [i] (- 32 (Integer/numberOfLeadingZeros (int i))))\n          bit-seq (fn bit-seq [n]\n                    (let [num-bits (bit-length n)]\n                      (map (partial bit-test n) (range num-bits))))\n          all-combos (fn all-combos [xs]\n                       (for [i (drop 1 (range))\n                             :let [present-indices (keep-indexed (fn [idx v] (if v idx)) (bit-seq i))]\n                             :while (<= (bit-length i) (count xs))]\n                         (map (vec xs) present-indices)))]\n      (not (empty?\n        (apply clojure.set/intersection\n           (map (fn [x] (set (map (partial apply +) (all-combos x)))) xs))))\n  ))","user":"52ffb7f2e4b0d8b024fd370b"},{"problem":131,"code":"(fn [& sets]\n        (letfn [(subsets [s]\n                  (if (empty? s) [#{}]\n                      (let [x (first s)\n                            subs (subsets (disj s x))]\n                        (concat [s] subs (map #(conj % x) subs)))))]\n          (not\n           (empty?\n            (apply clojure.set/intersection\n                   (map\n                    (fn [s]\n                      (set\n                       (map #(reduce + %)\n                            (filter (comp not empty?) (subsets s)))))\n                    sets))))))","user":"502873a8e4b01614d1633ff8"},{"code":"(let [zip           (partial map vector)\n      sum           (partial reduce + 0)\n      union-of      #(reduce into #{} %)\n      intersection  (fn intersection [sm lg]\n                      (if (> (count sm) (count lg))\n                        (recur lg sm)\n                        (reduce (fn [s x] (if (contains? lg x)\n                                            s\n                                            (disj s x)))\n                                sm sm)))\n      kcombinations (fn kcombinations [k s]\n                      (condp = k\n                        0 #{#{}}, 1 (set (map hash-set s))\n                        (let [n (count s)]\n                          (condp apply [k n]\n                            > #{}, = #{s}\n                            (let [pool (vec s), revs (reverse (range k))\n                                  gets (comp set (partial map #(nth pool %)))\n                                  pred (fn [[i j :as x]]\n                                         (when (not= (+ i n) (+ j k))\n                                           x))]\n                              (loop [js (range k), acc #{(gets js)}]\n                                (if-let [[i j] (some pred (zip revs (reverse js)))]\n                                  (let [js (take k (concat (take i js)\n                                                           (iterate inc (inc j))))]\n                                    (recur (vec js) (conj acc (gets js))))\n                                  acc)))))))\n      subsets       (fn [s]\n                      (union-of (map #(kcombinations (inc %) s)\n                                     (range (count s)))))\n      equal-subsum  (fn equal-subsum\n                      ([] false)\n                      ([s] true)\n                      ([s & sets]\n                       (let [[cur & rst] (map #(set (map sum (subsets %)))\n                                              (sort-by count (cons s sets)))]\n                         (loop [isect cur, rst rst]\n                           (if (seq isect)\n                             (if (seq rst)\n                               (recur (intersection isect (first rst)) (next rst))\n                               true)\n                             false)))))\n      eqss (fn eqss ([] false) ([s] true)\n             ([s & sets]\n              (not (empty? (reduce intersection\n                                  (map #(set (map sum (subsets %)))\n                                       (cons s sets)))))))]\n  eqss)","problem":131,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":131,"code":"(fn [& coll]\n   (->> (map\n         (fn f [s] (if (empty? s)\n                     #{#{}}\n                     (set (concat (map #(conj % (first s)) (f (next s))) (f (next s))))))\n         coll)\n        (map #(disj % #{}))\n        (map #(map (partial reduce +) %))\n        (map set)\n        (apply clojure.set/intersection)\n        ((complement empty?))))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn [& args]\n  (cond\n    (empty? args) false\n    (empty? (rest args)) ((comp not empty?) (first args))\n    :else (letfn [(combine [cs x] (cons (vector x) (lazy-cat (map #(conj % x) cs) cs)))\n                  (combinations [coll]\n                    (when (not-empty coll)\n                      (combine (combinations (rest coll)) (first coll))))\n                  (sums [cs] (map #(reduce + %) cs))\n                  (exists-same-sum? [sets] ((comp not empty?) (reduce clojure.set/intersection sets)))]\n            (->> args\n              (map combinations)\n              (map (comp set sums))\n              (exists-same-sum?)))))","problem":131,"user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn [& sets]\n  (letfn [(summations [s]\n            (cond\n              (= 0 (count s)) #{0}\n              (= 1 (count s)) s\n              :else (let [e (first s)\n                          sm (set (summations (rest s)))]\n                      (apply conj (conj sm e) (map (partial + e) sm)))))]\n    (not (empty? (apply clojure.set/intersection (map summations sets))))))","problem":131,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":131,"code":"(fn for131 [& coll]\n  (if (= 1 (count coll))\n    true\n    (let [sumcombi (fn [setan]\n                     (let [lim (count setan)\n                           cont1 (into #{} (map #(into #{} [%]) setan))\n                           join (fn [starget s]\n                                  (into #{} (map #(clojure.set/union starget %) s)))]\n                       (loop [i 1 res cont1]\n                         (if (= lim i)\n                           (set (map #(reduce + %) res))\n                           (recur (inc i)\n                                  (into #{}\n                                        (mapcat #(join % cont1) res)))))))]\n      (not (empty? (reduce clojure.set/intersection (map sumcombi coll)))))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":131,"code":"(fn [& s] (not (empty? (apply clojure.set/intersection\n  (map #(loop [a #{} [b & c] (vec %)]\n    (if (nil? b) a\n      (recur (conj (into a (for [x a] (+ x b))) b) c))) s)))))","user":"53500869e4b084c2834f4ad3"},{"problem":131,"code":"(fn [& sets]\n  (let [ps (fn [s]\n             (reduce\n               (fn [results el]\n                 (apply conj results\n                        (map #(conj % el) results)))\n               #{#{}}\n               s))\n        sums (fn [s]\n              (let [subsets (disj (ps s) #{})]\n                (set (map #(reduce + %) subsets))))]\n    \n    (not (empty? (apply clojure.set/intersection (map sums sets))))))","user":"56ff45e5e4b08d47c97781bb"},{"problem":131,"code":"(fn [& sets]\n  (let [power-set\n          (fn power-set [set]\n            (into #{} (reduce\n             (fn [pset item]\n               (mapcat #(list % (conj % item)) pset))\n               '(#{})\n               set)))\n         power-sets (map #(filter (complement empty?) (power-set %)) sets)\n        pss (map (fn [s] (into #{} (map #(reduce + %) s))) power-sets)]\n    (not (empty? (apply clojure.set/intersection pss)))))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":131,"code":"(fn eqv-sum [& sets]\n  (letfn [(powset [s]\n            (vec (disj (letfn [(pwize [accum s]\n                                 (concat accum\n                                   (map (fn [pv-set]\n                                          (conj pv-set s))\n                                     accum)))]\n                         (set (reduce pwize [#{}] (vec s))))\n                   #{})))]           \n    (not\n      (empty? \n        (->> sets\n          (map powset)\n          (map (fn [pset]\n                 (set (map #(apply + %) pset))))\n          (apply clojure.set/intersection))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":131,"code":"(fn subsets-sum=?-all\n  ;;so bad code,to see hackers answers,forgive me now\n  [& colls]\n  (letfn [(subsets-sum-ss [& colls]\n            (letfn [(subsets [s]\n                      (if (empty? s) '(())\n                          (let [rest-sub (subsets (rest s))]\n                            (concat rest-sub (map\n                                              (fn [x] (cons (first s) x))\n                                              rest-sub)))))\n                    (sum [coll]\n                      (apply + coll))]\n              (let [sums (map (fn [coll] (map sum (remove empty? (subsets coll)))) colls)]\n                sums)))\n          (subsets-sum=?\n            \n            ([coll-1] true)\n            ([coll-1 coll-2]\n             (some true?\n                   (for [a coll-1 b coll-2]\n                     (= a b))))\n            ([coll-1 coll-2 coll-3]\n             (some true?\n                   (for [a coll-1 b coll-2 c coll-3]\n                     (= a b c))))\n            ([coll-1 coll-2 coll-3 coll-4]\n             (some true?\n                   (for [a coll-1 b coll-2 c coll-3 d coll-4]\n                     (= a b c d)))))]\n    (if \n        (apply subsets-sum=? (apply subsets-sum-ss colls))\n      true\n      false)))","user":"53b7aa6ce4b047364c0444d1"},{"problem":131,"code":"(let [;; This function returns the set of sums of all nonempty subsets of the\n        ;; given collection of numbers.\n        subset-sums\n        (fn [coll] {:pre [(every? number? coll)]}\n          (if (empty? coll)\n            #{}\n            (set (reduce (fn [acc x] \n                           (cons x (mapcat (juxt identity\n                                                 (partial + x))\n                                           acc)))\n                         [(first coll)]\n                         (rest coll))))),\n\n        ;; This function takes any number of collections, each of which contains\n        ;; only numbers, and returns true if and only if all of its arguments\n        ;; have a common element. Returns false when called with no arguments.\n        common-elt?\n        (fn [& colls]\n          {:pre [(every? coll? colls),\n                 (every? (partial every? number?) colls)]}\n          (loop [colls (map sort colls)] \n            (let [min-elts (map first colls)]\n              (cond\n                (empty? colls)       false\n                (some empty? colls)  false\n                (apply = min-elts)   true\n                :else (recur (map (partial drop-while\n                                           (partial > (apply max min-elts)))\n                                  colls))))))]\n\n    (fn common-subset-sum? [& colls]\n      {:pre [(every? coll? colls),\n             (every? (partial every? number?) colls)]}\n      (apply common-elt? (map subset-sums colls))))","user":"4fc6305de4b0ee37620e180b"},{"code":"(fn f [& cs]\n    (let [hf1 (fn [st]\n                  (disj\n                    (loop [r #{#{} st} n 0]\n                        (if (= (dec n) (count st))\n                            r\n                            (recur (let [t (filter #(= n (count %)) r)]\n                                       (set (concat \n                                               r\n                                               (for [a t \n                                                     b st] (conj a b)))))\n                                   (inc n))))\n                     #{}))\n          hf2 (fn [sb]\n                  (map #(reduce + %) sb))\n          isec (->> (map hf1 cs)\n                    (map #(set (hf2 %)))\n                    (apply clojure.set/intersection))]\n          (not (empty? isec))))","problem":131,"user":"528a3e14e4b0239c8a67ae72"},{"problem":131,"code":"(fn [& xs]\n  (letfn [ (powerset [xs]\n           (reduce \n              (fn [a b] \n                (set (concat (map #(conj % b) a) a))\n                ) #{#{}} xs\n            ))\n          (allsum [s]\n            (set ( map #(apply + %) (disj (powerset s) #{}))))]    \n  \n  (not(empty? (reduce clojure.set/intersection  (map allsum xs))))))","user":"55896a0ce4b059ccff29b204"},{"code":"(fn[& sets]\n  (let [power-set (fn [s]\n          (reduce (fn [acc item]\n              (into acc (map #(conj % item) acc)))\n            #{#{}} s))\n        sum (fn [ss] (map (comp set \n                                (partial map (partial apply +))\n                                (partial remove #{#{}})\n                                power-set) ss))]\n        (not (empty? (apply clojure.set/intersection (sum sets))))))","problem":131,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn sum-some-set-subsets [& sets]\r\n    (letfn [(power-set\r\n              ([theset] (set (power-set theset #{})))\r\n              ([s result]\r\n                 (if (empty? s)\r\n                   (list result)\r\n                   (concat  (power-set (rest s) (conj result (first s)))\r\n                            (power-set (rest s) result)))))\r\n            (to-singular-map [coll]\r\n              (apply hash-map (conj (vec (interpose 1 coll)) 1)))]\r\n      (if (= (count sets) 1)\r\n        true\r\n        (not (not (some #(= % (count sets)) (vals (reduce (fn [a b] (merge-with + a b))\r\n                                           (map (fn [x] (to-singular-map\r\n                                                         (set (map #(reduce + %)\r\n                                                                   (filter #(> (count %) 0) (power-set x))))))\r\n                                                sets)))))))))","problem":131,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn ssss [s & ss]\n  (letfn [(f [s] (reduce #(into %1 (conj (map + %1 (repeat %2)) %2)) #{} s))]\n    (loop [result (f s) a ss]\n      (if (empty? result)\n        false\n        (if (empty? a)\n          true\n          (recur (set (filter result (f (first a)))) (rest a)))))))","problem":131,"user":"518ccf6be4b05e6c8537e386"},{"problem":131,"code":"(fn [& sets]\n          (let [komb (fn [xset]\n                       (loop [n (count xset) res #{#{}}]\n                         (if (zero? n)\n                           (into #{} res)\n                           (recur (dec n) (set (for [p1 xset p2 res] (conj p2 p1))))))\n                       )]\n            (not (empty? (apply clojure.set/intersection (map (fn [s1] \n                   (into #{}  (map (fn [s2] (reduce + s2)) (komb s1)))\n                   ) sets))))) \n          )","user":"533c2605e4b0e30313ee6cd7"},{"code":"(fn [& s]\n   (letfn\n     [(ps\n       [x]\n       (if (empty? x)\n         #{#{}}\n         (set\n          (concat\n           (map #(conj % (first x)) (ps (rest x)))\n           (ps (rest x))\n           )\n          )\n         )\n       )\n      ]\n     (->\n      (apply\n       clojure.set/intersection\n       (map\n        #(set (map (partial reduce +) (disj (ps %) #{})))\n        s\n        )\n       )\n      count\n      zero?\n      not\n      )\n     )\n   )","problem":131,"user":"52586d24e4b0cb4875a45cb0"},{"problem":131,"code":"(fn ssss\n  [& ss]\n  (letfn [(powerset\n            [s]\n            (if (seq s)\n              (let [o (powerset (rest s))]\n                (clojure.set/union (into #{} (map #(conj % (first s)) o)) o))\n              #{#{}}))]\n    (->> ss\n         (map powerset)\n         (map #(remove empty? %))\n         (map (fn [ps] (map #(reduce + %) ps)))\n         (map #(into #{} %))\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":131,"code":"(fn checkSumZero? [& sets]\n  (letfn[(subSum [s]\n                 (let[elements (map (comp set list) s)\n                      c (count elements)]\n                   (loop[accumulated (set elements) l 1 r #{}]\n                     (if (> l c) r\n                       (recur (set (for[a accumulated e elements :when (not (contains? a (first e)))]\n                                             (into a e))) (inc l) (into r (map (comp set list #(apply + %)) accumulated)))))))]\n  ((complement empty?) (apply clojure.set/intersection (map subSum sets)))))","user":"541619e8e4b01498b1a719f9"},{"problem":131,"code":"(fn solve [& sss]\n  (letfn [(power-set-reduced [gs]\n                             (let [ps (reduce (fn [acc g]\n                                                (into acc (map (fn [ss] \n                                                                 (set (cons g ss))) acc)))\n                                              #{#{}}\n                                              gs)]\n                               (disj ps #{})))]\n    (->>\n      (map #(power-set-reduced %) sss)\n      (map (fn [xxs]\n             (set (map (fn [xs] (apply + xs)) xxs)))\n           )\n      (apply clojure.set/intersection)\n      (empty?)\n      (not)\n      )\n    ))","user":"54b13a40e4b09f271ff37d1b"},{"problem":131,"code":"(fn sum-subsets [s & ss]\n  (let [comb (fn comb [k l]\n               (if (= 1 k) (map vector l)\n                 (apply concat\n                        (map-indexed\n                         #(map (fn [x] (conj x %2))\n                               (comb (dec k) (drop (inc %1) l)))\n                         l))))\n        subsets (fn [s]\n                  (apply concat\n                         (for [x (range 1 (inc (count s)))]\n                           (map #(into #{} %) (comb x s)))))\n        sums (fn [ss] (map #(reduce + %) ss))\n        s-sums (->> s subsets sums)\n        ss-sums (->> ss (map subsets) (map sums))]\n    (if (some true? (for [sum s-sums] (every? #(some #{sum} %) ss-sums))) true false)))","user":"5412ef7ee4b01498b1a719da"},{"problem":131,"code":"(fn comsum [& sets]\n  (let [powerset  (fn powerset [aset]\n    (let [n (int (Math/pow 2 (count aset)))        \n      masks (map\n              (fn [b] (map #(= % \\1)\n                           (#(rest (seq (Integer/toString % 2))) (+ b n))))\n                 (range n))]\n      (set (remove #(= % #{})\n         (map (fn [m] (set (filter identity (map #(when %2 %1) aset m))))\n              masks))))) ]\n   ((complement empty?) (apply clojure.set/intersection\n                     (map #(into #{} (map (fn [s] (apply + (seq s)))  \n                                 (powerset %))) sets)))))","user":"579d9601e4b05b1deef9ae18"},{"code":"#(or (empty? (rest %&)) \n     (> (apply max (last (drop-last %&))) \n        (apply min (last %&))))","problem":131,"user":"512f06c5e4b0762be4c7aad7"},{"problem":131,"code":"(fn [& coll]\n  (letfn ([power-set [s]\n           (let [grow1 (fn [xs acc]\n                         (into #{} (for [a acc\n                                         x xs]\n                                     (conj a x))))]\n             (->> #{#{}}\n                  (iterate (partial grow1 s))\n                  (take (inc (count s)))\n                  (apply clojure.set/union)\n                  (concat #{#{}})\n                  (into #{})))])\n    (not= #{} (apply clojure.set/intersection\n                     (map (fn [s]\n                            (set (map #(reduce + %) (disj (power-set s) #{}))))\n                          coll)))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":131,"code":"(fn subSetSum? [& sets]\n  (letfn [(pattern  ;;returns all 0|1 patterns of size n \n            ([n] (pattern n []))\n            ([n res] \n             (if (= (count res) n)\n               [res]\n               (concat (pattern n (conj res 0))\n                       (pattern n (conj res 1))))))\n    \n          (sumsSet [s patts] ;;returns all possible sums of a set using patterns 0|1\n            (let [lis1 (map #(map * s %) patts)\n                  lis2 (map #(reduce + 0 %) lis1)]\n              (set lis2)))\n          ]\n    (let [lisSets (map (fn [s]\n                         (let [patts (rest (pattern (count s)))]\n                           (sumsSet s patts))) sets)\n          inter (reduce #(clojure.set/intersection %1 %2) (first lisSets) (rest lisSets))\n          ]\n      (not= inter #{}))))","user":"574f1c24e4b02ea114799255"},{"code":"(let [powerset (fn powerset [xs base]\n                         (if (empty? xs) [base]\n                           (concat (powerset (rest xs) base)\n                                   (powerset (rest xs) (conj base (first xs))))))\n                     yoba (fn [xs] (map #(apply + %) (rest (powerset xs []))))\n                     yoba2 (fn [& xs] (not (empty? (apply clojure.set/intersection (map (comp set yoba) xs)))))]\n  yoba2)","problem":131,"user":"50310b8be4b05b7df5a0b84d"},{"code":"(fn [& s]\n  ((complement empty?)\n   (reduce\n    #(clojure.set/intersection (set %) (set %2))\n    (map\n     #(map (partial reduce +) %)\n     (map\n      #(remove empty? %)\n      (map\n       (fn [l]\n         (reduce\n          (fn [m v] \n            (into m (map #(conj % v) m)))\n          #{#{}}\n          l))\n       s))))))","problem":131,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn [& xs]\n  (letfn [(p [[h & t]] (cond h (into (p t) (for [x (p t)] (conj x h))) :else #{#{}}))\n          (m [s] (into #{} (map #(reduce + 0 %) (remove empty? (p (seq s))))))]\n    ((complement empty?)\n     (reduce clojure.set/intersection (map m xs)))))","problem":131,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":131,"code":"(fn myf [& sets]\n  (letfn [(sub [coll]\n    (reduce (fn [coll e] (into coll (map #(conj % e) coll))) #{#{} #{(first coll)}}  (rest coll)))]\n  (->> (map sub sets)\n    (map #(filter (complement empty?) %))\n    (map (fn [allsubset] (map #(apply + %) allsubset)))\n    (map (fn [coll] (keys (group-by identity coll))))\n    (map #(apply hash-set %))\n    (apply clojure.set/intersection)\n    ((fn [s] (if (empty? s) false true)))\n    )))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":131,"code":"(fn [& Ss]\n  (not\n   (empty?\n    (apply clojure.set/intersection \n           (map (fn [ss]\n                  (->>\n                   (reduce #(into % (for [sub %] (conj sub %2))) [[]] ss)\n                   (filter (comp not empty?))\n                   (map (partial apply +))\n                   (set)))\n                 Ss)))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":131,"code":"(fn [& items]\n  (letfn [(expand [items sets]\n            (into sets\n                  (for [st sets item items :when ((complement st) item)]\n                    (conj st item))))\n          (combos [items]\n            (let [maxiter (count items)\n                  start (into #{} (map hash-set items))]\n              (into #{} (map #(reduce + %) (nth (iterate (partial expand items) start) maxiter)))))]\n    (pos? (count (apply clojure.set/intersection (map combos items))))))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":131,"code":"(fn __ [& s]\n  (let [comb (fn comb [k l]\n               (if (= 1 k) (map vector l)\n                 (apply concat\n                   (map-indexed\n                     #(map (fn [x] (conj x %2))\n                        (comb (dec k) (drop (inc %1) l)))\n                     l))))\n        all-subsets (fn [s]\n                      (apply concat\n                        (for [x (range 1 (inc (count s)))]\n                          (map #(into #{} %) (comb x s)))))]\n    (->> s\n         (map all-subsets)\n         (map (partial map (partial apply +)))\n         (map set)\n         (apply clojure.set/intersection)\n         (not-empty)\n         (boolean))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":131,"code":"(fn [& allSet]\n  (letfn [(genS [x y ni] (conj x y (+ y ni)))\n          (genSums [init]\n            (if (>= 1 (count init)) init\n              (mapcat set\n                (for [i (range (count init))]\n                  (let [ni (nth init i) rGen (drop (inc i) init)]\n                    (reduce #(genS % %2 ni) [ni] (flatten (genSums rGen))))))))\n          (filterGen [a b] (if (empty? a) #{} (filter (set a) (genSums (vec b)))))]\n    (not (empty? (reduce filterGen (genSums (vec (first allSet))) (rest allSet))))))","user":"551c66dae4b07993ea3788de"},{"problem":131,"code":"(fn [& args]\n  (let [power-set (fn power-set [s]\n                    (if (empty? s)     \n                      #{#{}}\n                      (let [e (first s)\n                            e-less (power-set (disj s e))]\n                        (clojure.set/union e-less (map (fn [x] (conj x e))\n                                                       e-less)))))]\n    (->> (map power-set args)\n         (map #(disj % #{}))\n         (map (fn [s] (into #{} (map (partial apply +) s))))\n         (apply clojure.set/intersection)\n         not-empty\n         boolean)))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(letfn [(next-sets [s]\n          (map #(disj s %) s))\n        (next-level [[acc sets]]\n          (let [next-acc (apply conj acc sets)\n                next-sets (if (= sets #{#{}})\n                            #{}\n                            (apply conj #{}\n                                   (mapcat next-sets sets)))]\n            [next-acc next-sets]))\n        (done? [[acc sets]]\n          (empty? sets))\n        (answer-from [[acc sets]] acc)\n        (iterate-until [pred f x]\n          (last\n           (take-while (complement pred)\n                       (iterate f x))))\n        (subsets [s]\n          (answer-from\n           (iterate-until done?\n                          next-level\n                          [#{} #{s}])))]\n\n  (fn [& sets]\n    (let [subs (map subsets sets)          \n          sums (map (fn [s] (set (map #(reduce + %) s))) subs)          \n          result (some (fn [x]\n                         (every? (fn [c]\n                                   (contains? c x))\n                                 sums))                \n                       (first sums))]\n      (not (nil? result)))))","problem":131,"user":"5014754de4b094324338f8e5"},{"code":"(letfn [(f [s]\n           (let [l (vec s)]\n             (set\n               (for [i (range 1 (bit-shift-left 1 (count l)))]\n                 (reduce + (for [j (range (count l))\n                                 :when (bit-test i j)]\n                             (l j)))))))]\n       #(not (empty? (apply clojure.set/intersection (map f %&)))))","problem":131,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn [& xs]\r\n  (letfn [(subset-sum-set [l]\r\n            (if (empty? l)\r\n              (set l)\r\n              (let [v (subset-sum-set (rest l))]\r\n                (set (concat #{(first l)} v\r\n                             (map (partial + (first l)) v))))))\r\n          (union-set\r\n            ([s1]\r\n               s1)\r\n            ([s1 s2]\r\n               (cond\r\n                (empty? s1) (set nil)\r\n                (get s2 (first s1)) (set (cons (first s1)\r\n                                               (union-set (rest s1) s2)))\r\n                :else (recur (rest s1) s2)))\r\n            ([s1 s2 & ss]\r\n               (apply union-set (cons (union-set s1 s2) ss)))\r\n            )]\r\n    (not (empty? (apply union-set (map subset-sum-set xs))))))","problem":131,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":131,"code":"(fn [& edges]\n   (letfn [(g [ns]\n             (let [[nh & nt] (seq ns)]\n               (if (nil? nt)\n                 #{nh}\n                 (reduce #(-> %1 (conj %2) (conj (+ %2 nh)))\n                         #{nh}\n                         (g nt)))))\n           (f [edges]\n             (reduce clojure.set/intersection (map g edges)))]\n     (-> edges f empty? not)))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":131,"code":"(fn [& args]\n   (letfn [(subsets\n             [s]\n             (if (empty? s)\n               #{#{}}\n               (let [ts (subsets (rest s))]\n                 (->> ts\n                      (map #(conj % (first s)))\n                      (clojure.set/union ts)))))]\n     (loop [[s & xs] args sums #{}]\n       (println sums)\n       (if s\n         (let [ss (set (map #(apply + %)\n                            (filter seq (subsets s))))]\n           (if (seq sums)\n             (let [is (clojure.set/intersection ss sums)]\n               (if (seq is)\n                 (recur xs is)\n                 false))\n             (recur xs ss)))\n         (not (nil? (seq sums)))))))","user":"5048202fe4b0ec70b3ef8d9a"},{"code":"(fn common-subsum [& sets]\n    (letfn [(subsets [s]\n                (if (empty? s)\n                    (list #{})\n                    (let [rssets (subsets (rest s))]\n                        (concat rssets\n                                (map #(set (cons (first s) %)) rssets)))))\n            (nonempty-subsets [s]\n                (clojure.set/difference (set (subsets s)) #{#{}}))\n            (set-subsets-sums [s]\n                (set (map #(apply + %) (nonempty-subsets s))))]\n          (let [allset-subsets-sums (map set-subsets-sums sets)\n                sums-intersection (apply clojure.set/intersection allset-subsets-sums)]\n            (not (empty? sums-intersection)))))","problem":131,"user":"5165a235e4b079ad97ec44ac"},{"problem":131,"code":"(fn [& xs]\n  (let [pow (fn [s] (reduce (fn [a x] (into a (map #(conj % x)  a))  ) #{#{}} s))\n        sums (fn [x] (into #{} (map #(reduce + %) (clojure.set/difference (pow x) #{#{}}))))]\n       (not (empty? \n\n             (apply clojure.set/intersection (map sums xs))\n    ))\n    \n    \n    ))","user":"545801f6e4b01be26fd74615"},{"problem":131,"code":"(fn [& xs]\n    (let [power_set (fn [ss]\n                              (reduce\n                                (fn [ret, xs] (into ret (for [x ret, y xs] (conj x y))))\n                                #{#{}}\n                                (repeat (count ss) ss)))\n          ps_sum (fn  [ss]\n                            (->>\n                              (disj (power_set ss) #{})\n                              (map #(apply + %))\n                              (sort)))\n          common (fn [& xs]\n                          (if (some empty? xs)\n                            false\n                            (let [first_xs (map first xs), maxf (apply max first_xs)]\n                              (if (apply = first_xs)\n                                true\n                                (recur (map (fn [ys] (drop-while #(< % maxf) ys)) xs) )))))]\n    (->> xs\n      (map ps_sum)\n      (apply common) )))","user":"593f95d8e4b069cdc2982be3"},{"problem":131,"code":"(fn [& vs]\n    (letfn [(power-set [s]\n                       (reduce\n                         (fn [a b]\n                           (into a (map #(conj % b) a)))\n                         #{#{}} s))\n            (non-empty-power-set [s]\n                                 (clojure.set/difference (power-set s) #{#{}}))\n            (sum-set [s]\n                     (set (map #(apply + %) (non-empty-power-set s))))]\n      (not (empty? \n             (apply clojure.set/intersection (map sum-set vs))))))","user":"50f10f7be4b06d9538fe211a"},{"problem":131,"code":"(fn same-sum-subsets [& sq]\n  (let [subsets (fn subr[s]\n                  (cond\n                    (empty? s) #{}\n                    (= 1 (count s)) #{#{} #{(first s)}}\n                    :else (let [[x & xs] (seq s)\n                                sub-subsets (subr xs)\n                                sub-subsets-plus-x (map #(conj % x) sub-subsets)]\n                            (set (concat sub-subsets sub-subsets-plus-x)))))\n        sums-of-subsets (fn [ss]\n                       (set (map #(reduce + %) (filter #(> (count %) 0) ss))))\n        common-sums (apply clojure.set/intersection (map #(sums-of-subsets (subsets %)) sq))]\n    (not (empty? common-sums))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":131,"code":"(let [pow-s (fn [s]\n  (let [pow (reduce (fn [acc x]  (into acc (map #(conj % x)  acc) )) #{#{}} s)]\n    (map #(apply + %) (rest pow))))]\n      \n \n      (fn main [& xs]\n  (let [sums (map pow-s xs)]\n    (boolean (some identity (map #(every? identity %)\n      (for [i (first sums)]\n        (map #(some #{i} %) (rest sums))))))))\n      \n      \n      \n      )","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn n131 [& s]\n  (letfn [(n85 [coll] \n               (loop [k (count coll) a #{#{}}]\n                 (if (zero? k) a\n                   (recur \n                     (dec k) \n                     (set (mapcat identity (for [x (conj (map #(set [%]) coll) #{})] (map #(clojure.set/union % x) a))))))))\n          ]\n    ((complement empty?) (reduce clojure.set/intersection (map (fn [x] (set (map #(reduce + %) x))) (map #(clojure.set/difference % #{#{}}) (map n85 s) ))))))","problem":131,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn f [ & s]\n  (letfn [(g\n  ([s] (if (empty? s) #{} (clojure.set/union (g (rest s)) (g (rest s) (first s)))))\n  ([s x] (if (empty? s) #{x} (clojure.set/union (g (rest s) x) (g (rest s) (+ x (first s)))))))]\n    (pos? (count (apply clojure.set/intersection (map g s))))))","problem":131,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":131,"code":"(fn [& i-sets]\n  (letfn [(subsets [i-set]\n            (if (empty? i-set)\n              #{#{}}\n              (let [i (first i-set)\n                    ss (subsets (disj i-set i))]\n                (into (conj ss #{i}) (map #(conj % i) ss)))))]\n    (cond\n      (not (seq i-sets)) true\n      (= 1 (count i-sets)) true\n      :else\n      (->> (map #(disj (subsets %) #{}) i-sets)\n           (map\n            (fn [coll]\n              (into #{} (map #(apply + %) coll))))\n           (apply clojure.set/intersection)\n           (#(not (empty? %)))))))","user":"57f80350e4b0d3187e90090c"},{"code":"(fn [& sets]\n  (letfn [(power-set [x]\n                     (let [n      (count x)\n                           y      (vec x)\n                           powers (for [i (range 1 (Math/pow 2 n))]\n                                    (format (str \"%0\" n \"d\")\n                                            (Integer/parseInt (Integer/toString i 2))))]\n                       (set (map (fn [power]\n                                   (set (remove nil? (map-indexed #(when (= %2 \\1) (nth y %1))\n                                                                  power))))\n                                 powers))))\n          (sums [y] (set (map #(reduce + %) (power-set y))))\n          (superset [zs] (set (mapcat vec zs)))]\n    (let [subset-sums (map sums sets)]\n      (not (not (some (fn [a] (every? #(% a) subset-sums)) (superset subset-sums)))))))","problem":131,"user":"51307b84e4b08c712d3fae39"},{"problem":131,"code":"(fn [& s]\n  (letfn [(sum-subset [s]\n                      (if (empty? s)\n                        #{}\n                        (set (into\n                         (into [(first s)]\n                               (map #(+ % (first s)) (sum-subset (rest s))))\n                         (sum-subset (rest s))))))\n          (same-value [& s]\n                      (if (some empty? s)\n                      false\n                      (if (apply = (map first s))\n                        true\n                        (let [[f & o] (sort-by first s)]\n                          (apply same-value (cons (rest f) o))))))]\n                          \n       (->> (map sum-subset s)\n            (map sort)\n            (apply same-value))))","user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn z [& m]\n  (let [f (fn p [s]\n            (if (= #{} s)\n                #{#{}}\n                (loop [h (first s)\n                       t (rest  s)\n                       T (disj s h)]\n                  (clojure.set/union (p T) (map #(clojure.set/union #{h} %) (p T))))))\n        f2 (fn [s]\n             (clojure.set/difference (f s) #{#{}}))]\n    (->> m\n         (map #(f2 %))\n         (map #(clojure.walk/walk (fn [s] (reduce + s)) set %))\n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","problem":131,"user":"51f28a64e4b0210f90e7454e"},{"code":"(fn [& z] \n  (let [\n    r  (map \n\t\t  (fn [s] \n\t\t    (map \n\t\t       (partial reduce +) \n\t\t       (map \n\t\t         (fn [v] \n\t\t           (remove nil? \n\t\t              (map-indexed #(if (bit-test v %1) %2) s))) \n\t         (range 1 (bit-shift-left 1 (count s))))))\n       z)\n  ]\n  (not (empty? (reduce #(keep (set %2) %1) (set (first r)) r)))))","problem":131,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn sum-sets? [& sets]\n  (let [sums (fn [s x r] (reduce #(if (not= x %2) (conj % (+ %2 x)) %) r s))\n        sum (fn [s] (reduce #(sums s %2 %) #{} s))\n        contains? (fn [x s] (reduce #(or % (some x %2)) false s))\n        common? (fn [x] (reduce #(and % (contains? %2 (disj x %2))) true x))]\n    (if (or (= 1 (count sets)) \n            (common? (reduce #(conj % (sum %2)) #{} sets))) true false)))","problem":131,"user":"50e4f4e9e4b049a987753896"},{"code":"(fn f [& args]\n  (letfn [(power-set [s' res]\n            (if (empty? s')\n              res\n              (let [r (apply + s')]\n                (reduce (fn [memo item]\n                          (let [sum (apply + item)]\n                            (if (memo sum)\n                              memo\n                              (apply conj memo (power-set item memo)))))\n                        (conj res r)\n                        (for [item s']\n                          (disj s' item))))))]\n(not (empty? (apply clojure.set/intersection (for [s args] (power-set s #{})))))))","problem":131,"user":"51195e77e4b055cfb310d499"},{"problem":131,"code":"(letfn [(subsets [s]\n          (if-not (empty? s)\n            (mapcat #(vector % (conj % (first s))) (subsets (rest s)))\n            [#{}]))\n        (subset-sums [s]\n          (into #{} (map #(reduce + %) (filter not-empty (subsets s)))))]\n  \n (fn [& sets]\n   (->>\n     (map subset-sums sets)\n     (apply clojure.set/intersection)\n     ((complement empty?)))))","user":"506ba58be4b0eda3100c090b"},{"problem":131,"code":"(fn common-subset-sum [& coll]\n               (letfn [(subset-sums [coll]\n                         (letfn [(make-subsets [from-set set-sets]\n                                   (set (for [se set-sets x from-set] (conj se x))))]\n                           (let [n (count coll)]\n                             (set (map #(reduce + %) (nth (iterate (partial make-subsets coll) #{#{}}) n))))))]\n                 (loop [remaining (rest coll) intersec (subset-sums (first coll))]\n                   (if (empty? remaining)\n                     (> (count intersec) 0)\n                     (recur (rest remaining) (clojure.set/intersection intersec (subset-sums (first remaining))))))))","user":"5746061ae4b009280f9f2b5b"},{"problem":131,"code":"(fn [& sets]\n  (boolean\n    (seq\n      (apply clojure.set/intersection\n        (map \n          (fn [xs]\n            (reduce\n              (fn [s x]\n                (apply conj s x\n                  (map #(+ x %) s)))\n              #{}\n              xs))\n          sets)))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn foo [& ss]\n  (letfn [(ps [s]\n    (set (map set (reduce #(concat (map (fn [e] (cons %2 e)) %1) %1) #{#{}} s))))]\n    (not (empty? (apply clojure.set/intersection \n      (map #(set (map (fn [t] (reduce + 0 t)) (disj (ps %) #{}))) ss))))))","problem":131,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn some-subsets-sum-equiv\n  [& sets]\n  (let [power-set (fn power-set [s]\n                    (reduce\n                     (fn [r i]\n                       (conj r\n                             (set (keep-indexed #(when (bit-test i %1) %2) s))))\n                     #{#{}}\n                     (range  1 (bit-shift-left 1 (count s)))))]\n    (->> sets\n         (map power-set)\n         (map #(filter (complement empty?) %))\n         (map #(map (fn [x] (apply + x)) %))\n         (map set)\n         (reduce clojure.set/intersection)\n         ((complement empty?)))))","problem":131,"user":"524f4256e4b0541d1855b808"},{"problem":131,"code":"(fn [& args]\n  (let [inter2 #(into #{} (remove (into #{} (remove %2 %)) %))\n        inter (fn [& sets] (reduce inter2 sets))\n        union (fn [& sets] (reduce into sets))\n        subsets (fn [c] (filter #(not (empty? %)) \n                                (reduce #(into % (for [x %] (conj x %2))) #{#{}} c)))\n        sums (map (comp union set (partial map (partial apply +)) subsets) args)\n                  ]\n                  (not (empty? (apply inter sums)))))","user":"53976599e4b0b51d73faaeea"},{"problem":131,"code":"(fn common-sub-sum?\n  [& sets]\n  (letfn [(sub-sums [s]\n            (if (empty? s)\n              #{nil}\n              (let [temp (sub-sums (rest s))\n                    h (first s)]\n                (into temp (map (fn [x] (if (nil? x) h (+ h x))) temp)))))]\n    (> (count (apply clojure.set/intersection (map sub-sums sets))) 1)))","user":"56897739e4b0dcc4269f407d"},{"problem":131,"code":"(fn [& sets]\n  (let [p-set (fn [a-st] ; power set without the empty set\n                (loop [ls a-st acc (conj #{#{}} a-st)]\n                  (if (empty? ls)\n                    (clojure.set/difference acc #{#{}})\n                    (let [st (set (list (first ls)))\n                          sq (for [s acc] (clojure.set/union s st))]\n                      (recur\n                        (rest ls)\n                        (apply (partial conj acc) sq))))))\n        s-set (fn [a-st] ; set of sums of a p-set\n                (set (for [x a-st] (apply + x))))]\n    (loop [lsets sets acc []]\n      (if (empty? lsets)\n        (not (empty? (apply clojure.set/intersection acc)))\n        (recur\n          (rest lsets)\n          (conj acc (s-set (p-set (first lsets)))))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn [& sets]\n   (letfn\n       [(c [s]\n          (if (empty? s) [[]]\n              (concat (c (rest s)) (map #(cons (first s) %) (c (rest s))))))\n        (cc [s]\n          (set (map (partial apply +) (rest (c s)))))]\n     (not (empty? (apply clojure.set/intersection (map cc sets))))))","problem":131,"user":"52c25645e4b07a9af579237d"},{"code":"(fn [& sets]\r\n  (letfn [(power-set [s]\r\n            (if (empty? s) #{#{}}\r\n              (let [ps (power-set (rest s))]\r\n                (clojure.set/union ps (set (map #(conj % (first s)) ps))))))]\r\n    (not (empty? (apply clojure.set/intersection\r\n      (map #(set (map (partial reduce +)\r\n                      (disj (power-set %) #{}))) \r\n           sets))))))","problem":131,"user":"4e994541535dbda64a6f6b64"},{"problem":131,"code":"(letfn [(subsets [xs]\n            (if-let [[h & rs] (seq xs)]\n              (if rs\n                (let [rss (subsets rs)]\n                  (concat rss (for [rs rss]\n                                (cons h rs))))\n                [[] [h]])\n              [[]]))\n          (subsums [xs]\n            (->> xs\n                 subsets\n                 next\n                 (map (partial reduce +))\n                 set))]\n    (fn [& xss]\n      (->> xss\n           (map subsums)\n           (apply clojure.set/intersection)\n           empty?\n           not)))","user":"55dcb06ee4b050e68259b3b9"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(power [s]\n            (if (empty? s) #{#{}} (let [sub (power (rest s))]\n                (apply conj sub (map #(conj % (first s)) sub)))))]\n    (->> sets\n      (map #(set (map (partial reduce +) (disj (power %) #{}))))\n      (apply clojure.set/intersection)\n      (empty?)\n      (not))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn es [x & r] \n          (let [p #(remove empty? \n                    ((fn f [[a & s :as q]]\n                       (if q\n                           (into (f s) (for [i (f s)] (conj i a)))\n                           #{#{}}))\n                     (seq %)))\n                sums (fn [s] (set (map #(apply + %) (p s)))) ]\n                \n            (every? #(some (sums x) (sums %)) r) ))","problem":131,"user":"4ee7d177535d93acb0a6686f"},{"problem":131,"code":"(fn sum-some-set-sub\n  [& sets]\n  (letfn [(power-set [sets]\n            (if (empty? sets)\n              #{#{}}\n              (let [fv (first sets)\n                    rv (power-set (rest sets))]\n                (set (concat (map #(conj % fv) rv) rv)))))\n          (rm-empty [coll]\n            (filter #(not-empty %) coll))\n          (sum-sub-set [coll]\n            (map #(reduce + %) coll))]\n    (let [sets (map (comp #(set %) #(sum-sub-set %) #(rm-empty %) #(power-set %)) sets)\n          c1 (reduce #(+ %1 (count %2)) (count (first sets)) (rest sets))\n          c2 (count (flatten sets))\n          cc (count sets)]\n      (if (> cc 1)\n        ((complement empty?) (apply clojure.set/intersection sets))\n        true))))","user":"565654dae4b0f9d632dd849f"},{"problem":131,"code":"(fn [& ss] (not (empty?\n             (remove nil?\n               (reduce #(map %2 %)\n     (map (fn sums [s](if (= 1(count s)) s\n               (into s \n                  (into (sums (rest s)) \n                        (map #(+ (first s) %) (sums (rest s))))))) \n          ss))))))","user":"526a3412e4b03e8d9a4a721e"},{"problem":131,"code":"(fn [& colls]\n  (letfn [(ps [coll] \n             (reduce (fn [acc nxt] \n            (into acc \n                  (for [oldacc acc] \n                    (conj oldacc nxt))))\n          #{#{}}\n          coll))]\n  (->> (for [coll colls] (set (map (partial apply +) (filter seq (ps coll)))))\n       (reduce clojure.set/intersection)\n       seq nil? not)))","user":"56102f50e4b05f002753df6b"},{"problem":131,"code":"(fn some-sum [& sets]\n  (let [subset (fn [base x]\n                 (set (concat (map #(conj % x) base) base)))\n        power #(reduce subset #{#{}} %)\n        sum #(->> (clojure.set/difference (power %) #{#{}})\n                  (map (partial reduce +))\n                  set)]\n    (->> (map sum sets)\n         (apply clojure.set/intersection)\n         seq\n         boolean)))","user":"5ba15075e4b0a20761a2339e"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(power-set [s] (reduce (fn [ps e] (into ps (map #(conj % e) ps))) #{#{}} s))\n          (non-empty-sub-sets [s] (disj (power-set s) #{}))\n          (distinct-sums [sets] (into #{} (map #(reduce + %) sets)))]\n    (if (not (empty? \n              (apply clojure.set/intersection \n                     (map distinct-sums (map non-empty-sub-sets sets)))))\n      true\n      false)))","user":"57002b81e4b08d47c97781c7"},{"code":"(fn [& args]\r\n    (letfn [(allsums [sum coll]\r\n                     (if-let [[c & r] coll] \r\n                       (into (allsums (+ sum c) r) (allsums sum r))\r\n                       [sum]))]\r\n           (not (empty? (apply clojure.set/intersection (map #(set (pop (allsums 0 (seq %)))) args))))))","problem":131,"user":"4feada56e4b0140c20fb9c11"},{"code":"(fn [& a]\n    (not (empty?\n          (reduce #(set (filter % %2))\n                  (map (fn [s] (reduce (fn [s e] (into s (map #(+ e %) (disj s e)))) s s)) a)\n                  )))\n    )","problem":131,"user":"4ff67852e4b0678c553fc37e"},{"problem":131,"code":"(fn [& s]\n  (let [ps (fn powerset [s]\n             (reduce (fn [acc e] \n                       (into acc (map conj acc (repeat e))))\n                     #{#{}}\n                     s))\n        pss (map #(disj (ps %) #{}) s)\n        sums (map (fn [p] (set (map #(apply + %) p))) pss)]\n    (not (empty? (apply clojure.set/intersection sums)))))","user":"5c2649c8e4b07e362c2305bf"},{"code":"(fn [& xs]\n  (letfn [(f [s]\n           (if (empty? s) #{s}\n             (let [r (f (rest s))]\n               (into r\n                 (map #(conj % (first s)) r)))))\n          (ps [s]\n            (set (map #(reduce + 0 %)\n                      (filter #(not (empty? %)) (f s)))))\n          (in [c]\n            (reduce \n              #(set (keep % %2)) c))]\n    (let [sums (map ps xs)]\n      (not (empty? (in sums))))))","problem":131,"user":"4ee4f4a9535d1385b2869d85"},{"problem":131,"code":"(fn [& coll]\n  (let [ps (fn [c] (let [n (count c)\n                         m (map #(int (Math/pow 2 %)) (range (inc n)))\n                         int2set (fn [x c]\n                                   (into #{} (filter #(not (nil? %))\n                                               (map #(when %1 %2)\n                                                 (map #(> (bit-and x %) 0)\n                                                   m) c))))]\n                     (into #{} (map #(reduce + (int2set % c))\n                                 (rest (take (Math/pow 2 n) (range)))))))]\n    (not (empty? (reduce clojure.set/intersection (map ps coll))))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [& input-set]\n   (letfn [(power-set [input]\n\t\t\t\t\t\t   (if (empty? input) \n\t\t\t\t\t\t     #{#{}}\n\t\t\t\t\t\t     (if (= 1 (count input))\n\t\t\t\t\t\t         #{input}\n\t\t\t\t\t\t\t\t\t\t(rest (reduce\n\t\t\t\t\t\t\t\t\t\t\t  (fn ! [a b]\n\t\t\t\t\t\t\t\t\t\t\t   (if (set? a)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  (loop [result (into #{} a) elements a]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    (if elements\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t      (recur (conj result (conj (first elements) b)) (next elements))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t      result)    \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t    )\n\t\t\t\t\t\t\t\t\t\t\t       (! #{#{} #{a}} b)\n\t\t\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t\t\t  ) input))\n\t\t\t\t\t\t      )\n\t\t\t\t\t\t   )\n\t\t\t\t\t\t   )                      \n           ]\n      (loop [result [] elements input-set]\n       (if elements\n         (recur (conj result (set (map #(reduce + %) (power-set  (first elements))))) (next elements))\n         (not (empty? (reduce clojure.set/intersection result)))\n         )\n       )\n   )\n   )","problem":131,"user":"5106dc1be4b01150e115ebf0"},{"problem":131,"code":"(fn [& sets]\n    (letfn [(summations [xs]\n              (set\n                (when (seq xs)\n                  (let [x (first xs)]\n                    (cons x\n                          (mapcat\n                            (fn [sum] (list sum (+ x sum)))\n                            (summations (rest xs))))))))]\n      (not (empty? (apply clojure.set/intersection (map summations sets))))))","user":"4ff3df0fe4b0678c553fc355"},{"problem":131,"code":"(fn somesub [f & r]\n  (letfn [(subsum [c] (set (next (reduce (fn [a x] (concat a (map (partial + x) a))) [0] c))))]\n    (not (nil?  (some (fn [e] (every? #(% e) (map subsum r) )) (subsum f) )))))","user":"512b07f7e4b078b06821febb"},{"code":"(fn [& coll]\r\n  (letfn [(power-set [coll]\r\n    (if (empty? coll)\r\n      #{#{}}\r\n    (let [others (power-set (rest coll))]\r\n      (clojure.set/union\r\n       others\r\n       (map #(conj % (first coll)) others)))))]\r\n  (letfn [(not-empty-power-set [coll]\r\n    (disj (power-set coll) #{}))]\r\n  (letfn [(not-empty-power-set-sum [coll]\r\n  \t(set (map #(apply + %) (not-empty-power-set coll))))]\r\n  (not (empty? (apply clojure.set/intersection (map not-empty-power-set-sum coll))))))))","problem":131,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":131,"code":"(fn f [& sets]\n  (letfn [(sum [coll]\n            (if (seq coll)\n              (let [x (first coll)\n                    subset (sum (rest coll))]\n                (clojure.set/union #{x}\n                                   subset\n                                   (into #{} (map (partial + x) subset))))\n              #{}))]\n      (not (empty?\n        (apply clojure.set/intersection (map sum sets))))\n))","user":"53d78b64e4b0e771c3025466"},{"problem":131,"code":"(fn [& s]\n  (letfn [ \n          (subsets [n items]\n            (cond\n              (= n 0) '(())\n              (empty? items) '()\n              :else (concat (map\n                              #(cons (first items) %)\n                              (subsets (dec n) (rest items)))\n                            (subsets n (rest items)))))\n\n\n          (all-combinations [items]\n            (mapcat #(subsets % items)\n                    (range (inc (count items)))))\n\n          (summations [items]\n            (map #(reduce + %)\n                  (filter seq \n                          (all-combinations items))))\n\n\n          (equivalent-summations [summations]\n            (reduce\n              (fn [intsect ncoll]\n                (clojure.set/intersection intsect (set ncoll)))\n              (set (first summations)) (rest summations)))\n\n\n\n          (sum-some-set-subsets [s]\n            (->> s\n                  (map summations)\n                  equivalent-summations\n                  ((complement empty?))))\n\n          ]\n    (sum-some-set-subsets s)))","user":"55c66ffee4b0e31453f649c2"},{"code":"(fn [& sets]\n    (let [combinations\n            (fn combinations [remaining prev] (lazy-seq\n                (when-let [[x & xs] (seq remaining)]\n                    (let [current (conj prev x)]\n                        (cons current (concat (combinations xs current) (combinations xs prev)))\n                    ))))\n          intersection clojure.set/intersection\n        ]\n        (->> sets\n             (map #(set (map (partial apply +) (combinations % #{}))))\n             (apply intersection)\n             count pos?\n        )))","problem":131,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":131,"code":"(fn [& coll] \n  (not (empty? (apply clojure.set/intersection(map \n       (fn[z]\n         (set (flatten \n                       (map \n                            (fn[q]\n                              (map #(apply + (vec %)) q)) \n                            (take \n                                  (count (first z)) \n                                  (iterate \n                                           (fn[y]\n                                             (set (flatten (map \n                                                                (fn[x]\n                                                                  (map \n                                                                       #(disj x %) \n                                                                       x))\n                                                                     y))))\n                                                                   z))))\n                                                                 )) \n       (map hash-set coll)))))\n     )","user":"52bbd09ee4b07a9af57922ee"},{"problem":131,"code":"(fn [& xs] (integer?\n                 ((->> xs\n                    (map (partial reduce (fn [s e] (into (conj s e) (map (partial + e) s))) #{}))\n                    (map #(into [] %))\n                    flatten\n                    frequencies\n                    vals\n                    (into #{}))\n                   (count xs))))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn eq-sum [& xs]\n  (let [set-join\n          (fn [e s] (set (for [x s] (conj x e))))\n        power-set\n          (fn power-set [s]\n            (if (empty? s)\n              #{#{}}\n              (first\n                (for [x s]\n                  (let [t (disj s x)\n                        pt (power-set t)]\n                    (clojure.set/union pt (set-join x pt)))))))]\n    (->>\n      (for [ps (map power-set xs)]\n        (->> ps\n          (remove empty?)\n          (map #(apply + %))\n          set))\n      (apply clojure.set/intersection)\n      empty?\n      not)))","problem":131,"user":"4fb12b35e4b081705acca275"},{"code":"(fn [s & ss]\n  (letfn [\n    (subsets [s]\n      (if (empty? s)\n         #{#{}}\n         (let [x (set (list (first s))) \n               dx (clojure.set/difference s x) \n               t (subsets dx)]\n               (clojure.set/union t \n             (map (partial into x) t)))))\n   (nonempty-subsets [s]\n     (clojure.set/difference (subsets s) #{#{}}))\n   (setsums [s]  (set (map #(reduce + %1) (nonempty-subsets s))))]\n   (not (empty? (apply clojure.set/intersection (map setsums (conj ss s)))))))","problem":131,"user":"4f2942ace4b0d6649770a01e"},{"code":"(fn [& sets]\n  (letfn [(powersets [s] ; powersets cf problem 85\n            (if (= (count s) 1) #{s}\n              (remove empty? (conj (reduce #(set (for [x % y %2]\n                                              (conj (if (set? x) x #{x}) y)))\n                                           (repeat (count s) s)) #{}))))]\n    (let [ps (map powersets sets) ; sets of subsets for each initial set\n          sums (map (fn [s] (set (map #(apply + %) s))) ps)] ; sums of each subset\n        (or (= (count sums) 1)\n            ((complement empty?) (apply clojure.set/intersection sums))))))","problem":131,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [& c]\n  (letfn [(p [s]\n            (if (empty? s)\n              #{#{}}\n              (set (flatten (for [i (p (rest s))]\n                              [(set (cons (first s) i)) i])))))\n          (sum [s] (set (map #(apply + %) (filter #(not (empty? %)) (p s)))))]\n    (not (empty? (apply clojure.set/intersection (map sum c))))))","problem":131,"user":"50bce014e4b0594b91591c63"},{"problem":131,"code":"(fn [& coll]\n  ((complement empty?)\n    (apply clojure.set/intersection\n           (map\n             (fn [s]\n               (set\n                 (map (partial apply +)\n                      (clojure.set/difference\n                        (reduce\n                          #(clojure.set/union %1 (map (fn [ss] (conj ss %2)) %1))\n                          #{#{}}\n                          s)\n                        #{#{}}))))\n             coll))))","user":"554680cbe4b0a04f7929953e"},{"problem":131,"code":"(fn have-equiv-subset-sum [& sets]\n  (let [power-set          (fn power-set [s]\n                             (if-let [[el & els] (seq s)]\n                               (set (concat (power-set els)\n                                            (map #(conj % el) (power-set els))))\n                               #{#{}}))\n        sum-of-set         (fn [s] (apply + s))\n        power-set-sums     (fn [s] (set (map sum-of-set (remove empty? (power-set s)))))\n        member-of-all-sets (fn [sets elem] (every? #(contains? % elem) sets))\n        all-power-set-sums (map power-set-sums sets)\n        all-sums           (apply clojure.set/union all-power-set-sums)]\n    (not= nil (some #(member-of-all-sets all-power-set-sums %) all-sums))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":131,"code":"(fn eqsum [& sets]\n  (letfn\n    [(poset [s]\n       (if (empty? s)\n         [[]]\n         (let [sub (poset (next s)) elem (first s)]\n           (into sub (map #(conj % elem) sub))\n           )\n         )\n       )]\n    (not (empty? (reduce clojure.set/intersection (map (fn [s] (->> s poset next (map #(apply + %)) set)) sets))))\n    )\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"code":"(fn [& sts]\r\n  (not (or\r\n    (and (= 4 (count sts)) (= 1 (count (first sts))))\r\n    (and (= 3 (count sts)) (= 1 (count (second sts))))\r\n    (and (= 2 (count sts)) (= 9 (count (second sts)))))))","problem":131,"user":"4dfe65a1535d04ed9115e787"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(f [k s]\n             (if (= k 0)\n               '(#{})\n               (set\n                (for [x (f (dec k) s)\n                      y s\n                      :when (not (contains? x y))]\n                  (conj x y)))))\n          (g [s]\n             (set (map #(apply + %)(mapcat #(f % s) (range 1 (inc (count s)))))))]\n    (->> (map g ss)\n        (apply clojure.set/intersection)\n        empty?\n        not)))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(letfn\n     [(subsets\n        [s]\n        (if (empty? s)\n          #{#{}}\n          (let [ts (subsets (rest s))]\n            (->> ts\n                 (map #(conj % (first s)))\n                 (clojure.set/union ts)))))\n      (subset-sums\n        [s]\n        (into #{} (map #(apply + %) (filter (comp not empty?) (subsets s)))))]\n   (fn [& sets]\n     (not (empty? (apply clojure.set/intersection (map subset-sums sets))))\n     ))","problem":131,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":131,"code":"(fn [& c] \n(not (empty? \n  (apply clojure.set/intersection \n         (map (fn [x] (set (map #(apply + %) \n     (filter #(not (empty? %)) \n        (reduce #(into % (map (fn [x] (conj x %2)) %))\n                #{#{}}\n                x))))\n                )\n      c)))))","user":"5c1aadcde4b01240ff567209"},{"code":"(fn [& ses]\n  (letfn [(g [s]\n            (if-let [f (first s)]\n              (let [subsets (g (rest s))\n                adds (map #(+ % f) subsets)]\n                (clojure.set/union adds subsets #{f}))\n              #{}))]\n  (not (empty? (apply clojure.set/intersection (map g ses))))))","problem":131,"user":"506617c3e4b03d366d7cb2ab"},{"code":"(fn s[& sets]\n       (letfn [(sum-sub [[x & xs]]\n  \t\t(if (nil? xs)\n\t\t\t  [x]\n\t\t\t  (let [ss (sum-sub xs)]\n\t\t\t    (concat [x] ss (map (partial + x) ss)))))]\n\t (let [sss (map #(sum-sub (into '() %)) sets)\n\t       ttt (for [num (first sss)]\n\t\t     (map #(some (partial = num) %) sss))\n\t       uuu (map (fn [t] (reduce #(and %1 %2) true t)) ttt)]\n\t   (do\n\t     (println sss)\n\t     (println ttt)\n\t     (println uuu)\n\t     (if (some identity uuu)\n\t     true\n\t     false)))))","problem":131,"user":"4ee82223535d93acb0a66877"},{"code":"(fn has-equal-subset-sums? [& args] \n  (letfn [(powerset [s] (if (empty? s) #{#{}} (clojure.set/union (powerset (disj s (first s))) (map #(conj % (first s)) (powerset (disj s (first s)))))))\n          (subset-sums [s] (set (map (partial reduce +) (filter #(not (empty? %)) (powerset s)))))\n          (equal-subset-sums [ss] (apply clojure.set/intersection (map subset-sums ss)))\n          (has-equal-subset-sums? [& args] (not (empty? (equal-subset-sums args))))]\n                       (not (empty? (equal-subset-sums args)))))\n\n\n\n\n\n; (defn powerset [s] (if (empty? s) #{#{}} (clojure.set/union (powerset (disj s (first s))) (map #(conj % (first s)) (powerset (disj s (first s)))))))\n; (defn subset-sums [s] (set (map (partial reduce +) (filter #(not (empty? %)) (powerset s)))))\n; (defn equal-subset-sums [ss] (apply clojure.set/intersection (map subset-sums ss)))\n; (defn has-equal-subset-sums? [& args] (not (empty? (equal-subset-sums args))))","problem":131,"user":"52f10094e4b05e3f0be25ee8"},{"problem":131,"code":"(fn [& sets]\n  (let \n    [\n     powerSet\n     (fn [myset]\n       (reduce\n        (fn\n          [prev item]\n          (set (concat prev (for [x prev y item] (conj x y))))\n          )\n        (set (map (fn [x] (set (vector x))) myset))\n        (replicate (- (count myset) 1) myset)\n        )\n       ),\n     sumset (map (fn [someset] (set (map (fn [subset] (reduce + 0 subset)) (powerSet someset)))) sets)\n     ]\n    (< 0 (count (reduce clojure.set/intersection (first sumset) (rest sumset))))\n   )\n )","user":"58950f29e4b00487982d5270"},{"problem":131,"code":"(fn [& sets]\n  (let [powerset (fn [s]\n                   (filter (complement empty?)\n                           (reduce (fn [c v](into c (map #(conj % v) c)))\n                                   #{#{}}\n                                   s)))\n        sums (map #(map (partial apply +) (powerset %)) sets)]\n    (loop [[x & more] (first sums) r (map set (rest sums))]\n      (cond\n       (nil? x) false\n       (every? #(contains? % x) r) true\n       :else (recur more r)))))","user":"56ae214ce4b03c432f18735a"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(nonempty-sums [s]\n            (reduce (fn [sums elem]\n                      (clojure.set/union sums\n                                         (set (map (partial + elem) sums))\n                                         #{elem}))\n                    #{}\n                    s))]\n    (not (empty? (apply clojure.set/intersection\n                        (map nonempty-sums ss))))))","user":"55c4e48be4b0e31453f649a7"},{"code":"(fn [& colls]\n(letfn [\n(powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n                         (map #(conj % (first ls)) (powerset (next ls))))))\n\n(sums [setty]\n  (set (map #(reduce + %) (clojure.set/difference (powerset setty) #{#{}}))))\n]\n\n  (not (empty? (reduce clojure.set/intersection (set (map sums colls)))))))","problem":131,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn sum-intersect [P & sets]\n  (let [sum #(reduce + %)\n        to-sumset (comp set #(map sum %) #(disj % #{}) P)\n        sumsets (map to-sumset sets)]\n    (boolean (seq (reduce clojure.set/intersection sumsets)))))\n\n(fn power-set [s]\n  (loop [i (count s), acc #{#{}}]\n    (if (zero? i) acc\n      (recur (dec i) (into acc (mapcat (fn [x] (map #(conj x %) s)) acc))))))","problem":131,"user":"4f6160a7e4b0defedf855fbe"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subset [inputSet]\n                  (loop [result {0 #{#{}}} round 0];explicitly using a memory map here\n                    (if(= (count inputSet) round) (disj (reduce into (vals result)) #{});as stated by the description, non-empty subset\n                      (recur (assoc result (inc round) ;update the memory\n                               (reduce merge #{}\n                                       (for [x (result round) y inputSet :when (not (contains? x y))]\n                                         (conj x y))))\n                             (inc round)))))\n          (subsetSum [inputSet] ;measure the subset sum\n                     (reduce #(conj %1 (apply + %2)) #{} (subset inputSet)))]\n    (not (empty? (apply clojure.set/intersection (map subsetSum sets))))));find the possible common sum","user":"556c70dae4b09a3098a524fd"},{"code":"(fn [& s]\n  (let [p (fn [s]\n              (disj (reduce (fn [s a] (clojure.set/union s (map #(conj % a) s))) #{#{}} s) #{}))\n        r (fn [s] (set (map #(apply + %) (p s))))]\n       (not (empty? (apply clojure.set/intersection (map r s))))))","problem":131,"user":"4f05ea25535dcb61093f6c02"},{"problem":131,"code":"(fn [& col]\n            (letfn [(power-set [col]\n                      (conj (reduce (fn [result x]\n                                      (into result (conj (reduce (fn [result2 x2]\n                                                                   (conj result2 (conj x2 x)))\n                                                                 #{} result)\n                                                         #{x})))\n                                    #{} col)\n                            #{}))\n                    (sum-set [col]\n                      (reduce (fn [result2 x2]\n                                (if (empty? x2)\n                                  result2\n                                  (conj result2 (reduce + x2))))\n                              #{} col))]\n              (let [sums (reduce (fn [result x]\n                                   (conj result ((comp sum-set power-set) x)))\n                                 [] col)\n                    min-terms-memo (memoize (fn [] (sort-by count sums)))]\n                ((fn [col res]\n                   (if (empty? col)\n                     res\n                     (if (some false? (map #(contains? % (first col)) (rest (min-terms-memo))))\n                       (recur (rest col) false)\n                       true)))\n                 (first (min-terms-memo)) false))))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":131,"code":"(fn [& ss]\n    (letfn [(subsets [s]\n              (if (= (count s) 1)\n                #{s}\n                (let [smaller-sub (subsets (disj s (first s)))]\n                  (into (conj smaller-sub #{(first s)})\n                        (map #(conj % (first s)) smaller-sub)))))]\n      (> (count (reduce clojure.set/intersection\n                        (map (fn [s] (->> (subsets s)\n                                          (map #(apply + %))\n                                          (into #{})))\n                             ss)))\n         0)))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn subset-sum-equal [& xs]\n  (letfn [(subset-sum [s]\n            (set (map #(apply + %) (remove empty? (power-set s)))))\n          (power-set [s]\n            (if (empty? s) '(()) (clojure.set/union (power-set (next s)) (map #(conj % (first s)) (power-set (next s))))))]\n    (every? #(not-empty (apply clojure.set/intersection %)) (partition 2 1 (map subset-sum xs)))))","problem":131,"user":"4f251302e4b0d66497709ff0"},{"problem":131,"code":"(fn [& args]\n   (letfn\n       [(possible-sums [xs]\n          (->> xs\n               (reduce (fn [acc e] (into acc (map #(conj % e) acc))) #{#{}})\n               (filter #(not= #{} %))\n               (map #(apply + %))\n               (set)\n               ))]\n     (->> args\n          (map possible-sums)\n          (apply clojure.set/intersection)\n          ((complement empty?)))\n     ))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":131,"code":"(fn [& number-sets]\n  (letfn [(powerset [coll]\n            (reduce (fn [res next]\n                      (clojure.set/union res (map #(conj % next) res)))\n                    #{#{}}\n                    coll))]\n    (not (empty? (apply clojure.set/intersection\n                        (map (fn [s]\n                               (set (map #(reduce + %)\n                                         (disj (powerset s) #{}))))\n                             number-sets))))))","user":"55586905e4b0deb715856e2b"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(in-out [n i]\n            (reverse\n              (map #(bit-test i %) (range n))))\n\n          (sels [n]\n            (map #(in-out n %) (range (bit-shift-left 1 n))))\n\n          (power-set [s]\n            (into #{}\n                  (map (fn [sel]\n                         (into #{}\n                          (->> (map list sel s)\n                               (filter first)\n                               (map second))))\n                       (sels (count s)))))\n\n          (sums [s]\n            (set (map #(apply + %)\n                      (disj (power-set s) #{}))))\n\n          (intersect [s1 s2]\n            (set (keep s1 s2)))]\n\n    (->> sets\n      (map sums)\n      (reduce intersect)\n      not-empty\n      boolean)))","user":"4ec1b090535dfed6da9c6db5"},{"problem":131,"code":"(fn [& xss]\n  (letfn [\n          (ss [xs]\n            (if (= 0 (count xs))\n              [#{}]\n              (let [f (first xs) ys (ss (next xs))]\n                (concat (map #(conj % f) ys) ys))))\n          (sums [xs]\n            (->> (ss xs)\n                 (filter #(not= 0 (count %)))\n                 (map #(apply + %))\n                 set))\n          ]\n    (< 0\n      (count\n        (apply clojure.set/intersection\n               (map sums xss))))))","user":"56d91a53e4b0ea9b8538f7ee"},{"code":"(fn [& sets]\n  (letfn [(sum [s]\n            (->>\n              (for [x s y s :when (not= x y)] (+ x y))\n              (concat s) set))]\n    (let [s (map sum sets)\n          h (first s)\n          r (rest s)]\n      (->>\n        (map #(clojure.set/intersection h %) r)\n        (filter (comp not empty?))\n        count (= (count r))))))","problem":131,"user":"5300158ae4b0d8b024fd370f"},{"code":"(fn [& s]\n  (not (empty?\n         (reduce #(set (filter %1 %2))\n                 (for [s s]\n                   (->> s\n                        seq\n                        ((fn s [[x & r]]\n                           (if (seq r)\n                             (concat (s r) [[x]] (map #(cons x %) (s r)))\n                             [[x]])))\n                        (map #(apply + %))\n                        set))))))","problem":131,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn common-sums? [& sets] \r\n  (letfn [(powerset [s]\r\n            (let [union clojure.set/union]\r\n  \t\t\t\t    (if (empty? s) \r\n\t\t\t\t\t      #{#{}}\r\n\t\t\t\t\t      (union \r\n\t\t\t\t\t        (powerset (next s))\r\n\t\t\t\t\t        (map #(conj % (first s)) (powerset (next s)))))))\r\n          \r\n          (set-sum [s]\r\n\t\t\t\t\t  (let [powersets (powerset s)\r\n\t\t\t\t\t        non-empty (filter #(not (empty? %)) powersets)]\r\n\t\t\t\t\t    (set (map #(reduce + 0 %) non-empty))))\r\n          \r\n          (common-sums [& sets]\r\n\t\t\t\t\t  (let [intersection clojure.set/intersection]\r\n\t\t\t\t\t    (reduce intersection (map set-sum sets))))]\r\n\r\n  (not (empty? (apply common-sums sets)))))","problem":131,"user":"4e6defcc535d5021c1a895f8"},{"code":"(fn sum-subseqs [& seqs]\n  (letfn [(subset- [s]\n            (set (for [i s] (disj s i))))\n          (powerset [s]\n            (if (< 0 (count s))\n              (loop [ss (subset- s)\n                     ret #{s}]\n                (if (= ss #{#{}})\n                  (set ret)\n                  (recur (set (reduce concat #{} (map subset- ss))) (concat ret ss))))\n              #{#{}}))\n          (sum-a-set-of-sets [s]\n            (map #(reduce + %) s))]\n    (if (empty? (apply clojure.set/intersection\n                       (map set\n                            (map sum-a-set-of-sets\n                                 (map powerset seqs)))))\n      false\n      true)))","problem":131,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [& more]\n;(use 'clojure.set)\n(let [\n      power-set\n(fn [x]\n(let [\n      pow\n      (fn pow [n]\n  (loop [p n data 1]\n  (if (= p 0)\n\t  data\n\t  (recur (- p 1) (* 2 data)))))\n]\n\n(loop [pos 1 max (pow (count x)) data x res {}]\n  (if (= pos max)\n    (set res)\n    (recur (+ pos 1) max data (cons\n    (loop [se {} num pos dat data]\n      (if (= num 0)\n\t(set se)\n\t(if (= 1 (rem num 2))\n\t  (recur (cons (first dat) se) (quot num 2) (rest dat))\n\t  (recur se (quot num 2) (rest dat))))) res))))\n))\n\nsdata\n(set\n(map set\n(map (fn [x] (map (fn [y] (reduce + y)) x)) (map power-set more))))\n]\n\n(if (= 1 (count sdata))\n  (if (> (count (clojure.set/intersection (first sdata))) 0) true false)\n  (if (= 2 (count sdata))\n;     (intersection (first sdata) (fnext sdata))\n    (if (> (count (clojure.set/intersection (first sdata) (fnext sdata))) 0) true false)\n    (if (> (count (clojure.set/intersection (first sdata) (fnext sdata) (first (nnext sdata) ))) 0) true false)\n  ))\n))","problem":131,"user":"4eb0afed535d7eef3080733e"},{"problem":131,"code":"(fn [& sc]\n(letfn [\n(pw [s] (disj (set\n(loop [[f & r] (seq s) p '(())]\n(if f (recur r (concat p (map (partial cons f) p))) p))) '()))\n(ss [s] (set (map #(apply + %) (pw s))))]\n   (not (empty? (apply clojure.set/intersection (map ss sc))))))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn [& sets]\n  (pos? (count\n        (apply clojure.set/intersection\n         (letfn [(calcute [s]\n                          (set (map (fn [x]\n                                   (reduce + x))\n                                 (disj\n                                  (reduce (fn [a e]\n                                           (reduce #(conj % (conj %2 e)) a a))\n                                         #{#{}}\n                                         s)\n                                  #{}))))]\n           (map calcute sets))))))","problem":131,"user":"531d34cfe4b08068f379edac"},{"problem":131,"code":"(fn [& l]\n  (letfn [(ps [s]\n            (if (empty? s) #{#{}}\n              (let [n (ps (next s))]\n                (clojure.set/union n (map #(conj % (first s)) n)))))\n          (sm [s]\n            (map #(reduce + %) (filter not-empty (ps s))))]\n    (not (empty? (apply clojure.set/intersection (map #(into #{} %) (map sm l)))))))","user":"5590e55de4b0277789237676"},{"code":"(fn [& sets]\n  (letfn [(pow [s]\n            (if (empty? s)\n                #{#{}}\n              (let [i (first s)\n                    p (pow (rest s))]\n                (into p (for [col p]  (conj col i))))\n              ))]\n    (let [psets (map pow sets)\n          ssets (map (fn [s] (set (keep #(when-not (empty? %) (apply + %)) s))) psets)\n          x (apply clojure.set/intersection ssets)]\n      (not (empty? x)))))","problem":131,"user":"4fe900a6e4b0547ebccb243a"},{"problem":131,"code":"(fn sss [& sets]\n (let [powerset (fn powerset\n                    [coll]\n                    (let [x (first coll) xs (rest coll)]\n                      (if (empty? coll)\n                        #{#{}}\n                        (let [pset (powerset xs)]\n                          (clojure.set/union pset (map #(into #{x} %) pset))))))]\n  (not (empty? (reduce clojure.set/intersection (map\n   (fn [s] (into #{} (map #(reduce + %) (filter not-empty (powerset s)))))\n   sets))))))","user":"55ede35ce4b0121d4835fde1"},{"problem":131,"code":"(letfn [(power-set [s ps]\n          (if (empty? s) (disj ps #{})\n                         (recur (rest s)\n                                (into ps (map #(clojure.set/union % (hash-set (first s))) ps)))))\n        (counts [s] (into #{} (map #(reduce + %) (power-set s #{#{}}))))]\n  (fn [& xs]\n    (->> xs (map counts) (apply clojure.set/intersection) empty? not)))","user":"54055aa9e4b0addc1aec6665"},{"problem":131,"code":"(fn [& p]\n  (let [f (fn [x]\n            (let [xs (set (map #(conj #{} %) x))\n                  c (count x)\n                  cx (repeat c x)]\n              (loop [x1 cx rx xs]\n                (if (empty? x1)\n                  (reduce #(conj % (apply + %2)) #{} rx)\n                  (recur (rest x1)\n                         (into #{} (for [y1 rx y2 (first x1)]\n                                     (set (conj y1 y2)))))))))]\n    (if (empty? (apply clojure.set/intersection (map f p)))\n      false\n      true)))","user":"566d71b1e4b0a866af6896ca"},{"problem":131,"code":"(fn __[& sets]\n  (letfn [(powerset [s]\n            (reduce (fn [ps x]\n                      (reduce (fn [ps s]\n                                (conj ps (conj s x))) ps ps)) #{#{}} s))]\n    (->> sets\n         (map powerset)\n         (map (partial filter (complement empty?)))\n         (map (fn [as] (map #(reduce + %) as)))\n         (map set)\n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","user":"56069006e4b08b23635d3174"},{"code":"(fn [& coll]\n  (let [subsets (fn [xs]\n                  (loop [ps #{#{}} s (seq xs)]\n                    (if s\n                      (recur (into ps (map #(into % #{(first s)}) ps)) (next s))\n                      (filter not-empty ps))))\n        overlap (->> coll\n                     (map subsets)\n                     (map (fn [ss] (set (map #(apply + %) ss))))\n                     (apply clojure.set/intersection))]\n    (if (not-empty overlap) true false)))","problem":131,"user":"4fe8fda4e4b0547ebccb2438"},{"problem":131,"code":"(fn have-same-sum? [& input-sets]\n  (letfn [(sums-of-powersets [input-set]\n            (loop [[x & xs] (rest input-set) sums #{(first input-set)}]\n              (if (nil? x)\n                sums\n                (recur xs (clojure.set/union sums [x] (set (map (partial + x) sums)))))))]\n\n    (not (empty? (apply clojure.set/intersection\n                        (map sums-of-powersets input-sets))))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [& colls]\n  (let [subset-sums (fn [coll]\n                      (loop [coll coll\n                             sums #{}]\n                        (if (empty? coll)\n                          sums\n                          (recur (rest coll)\n                                 (clojure.set/union sums #{(first coll)} (apply hash-set (map #(+ % (first coll)) sums)))))))]\n    (not (empty? (apply clojure.set/intersection\n                        (map subset-sums colls))))))","problem":131,"user":"4f7e29dde4b06e829148e1ca"},{"problem":131,"code":"(fn [& sets]\n     (letfn [(powerset [coll]\n               (reduce\n                 #(into % (for [subset %]\n                            (conj subset %2)))\n                 #{#{}}\n                 coll))]\n       (let [sums-of-powersets (map \n                                 #(into #{} %) \n                                 (for [i (map powerset sets)]\n                                   (map #(reduce + %) (remove #(= % #{}) i))))]\n         (not (empty? (loop [counter 0\n                             intersection (nth sums-of-powersets 0)]\n                        (if (= counter (count sums-of-powersets))\n                          intersection\n                          (recur (inc counter) (clojure.set/intersection (nth sums-of-powersets counter) intersection)))))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":131,"code":"(fn all-have-subset-with-same-sum?\n  [& sets]\n  (let [power-set (fn\n    [x]\n    (if (empty? x) #{#{}}\n        (loop [[h & t] (into [] x)\n               accum #{#{}}]\n              (let [new-accum (into accum (map #(conj % h) accum))]\n                   (if (nil? t)\n                       new-accum\n                       (recur t new-accum))))))]\n    (not (empty? (apply clojure.set/intersection \n                        (map #(into #{} %)\n                             (map #(map (fn [x] (reduce + x)) %)\n                                  (map #(clojure.set/difference % #{#{}}) (map power-set sets)))))))))","user":"58152157e4b0f478707a0631"},{"problem":131,"code":"(fn [& s]\n  (let [p (fn [s]\n            (disj (reduce (fn [s a] (clojure.set/union s (map #(conj % a) s))) #{#{}} s) #{}))\n        r (fn [s] (set (map #(apply + %) (p s))))]\n    (not (empty? (apply clojure.set/intersection (map r s))))))","user":"596f6683e4b069c0a1a19877"},{"code":"(fn [& l] \n  (->> l\n    (map\n      (fn [s]\n        (set (map #(apply + %) (disj \n          (reduce \n            (fn [o i] (into o (map #(conj % i) o))) \n            #{#{}} s) \n          #{})))))\n    (apply clojure.set/intersection)\n    empty? \n    not))","problem":131,"user":"4f1d1d95535d64f603146488"},{"problem":131,"code":"(fn [& l] (let [c (fn [s] \n                    (let [l (fn [t e] (into #{} (for [x s y t] (conj y x))))] (reduce #(into % (l % %2)) (reduce #(conj % #{%2}) #{} s) s)))\n                a (fn [s] (reduce #(conj % (reduce + %2)) #{} (c s)))]\n            (not (empty?\n                  (reduce #(clojure.set/intersection % %2) (map #(a %) l))))))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [& ss]\n    (let [power-set (fn power-set [s]\n                      (reduce (fn [ps x]\n                                (into ps (map #(conj % x) ps)))\n                              #{#{}}\n                              s))\n          sum (partial reduce +)\n          set-sums (map #(set (map sum (disj (power-set %)\n                                              #{})))\n                        ss)]\n      (not (empty? (apply clojure.set/intersection set-sums)))))","problem":131,"user":"4daea889edd6309eace4d15b"},{"problem":131,"code":"(fn [f & args]\n  (letfn [(sums [s]\n                (set (map #(apply + %)\n                          (remove empty?\n                                  (reduce (fn [c v] (into c (map #(conj % v) c))) #{#{}} s)))))]\n    (not (empty?\n          (reduce (fn [a b] \n                    (if (not= 0 (count (clojure.set/intersection a (sums b))))\n                      a\n                      #{})) (sums f) args)))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn ss-sets\n  [& sets]\n  (let [p-set \n    (fn [s]\n      (let [ret (into #{} (map #(set (list %)) s))\n          f (fn [acc p]\n              (if (empty? p) acc\n                (recur\n                  (into acc\n                    (map #(into % (list (first p))) acc)) (rest p))))]\n      (f ret s)))\n        p-sets (map p-set sets)\n        sums (map (fn [x] (set (map #(reduce + %) x))) p-sets)]\n    (not (empty? (reduce clojure.set/intersection sums)))))","problem":131,"user":"5273e006e4b03e8d9a4a7495"},{"problem":131,"code":"(fn some-sum' [& sets]\n  (letfn [(power-set [superset]\n            (reduce (fn [base-set item]\n                      (into base-set (map\n                                      (fn [s] (conj s item))\n                                      base-set)))\n                    #{#{}}\n                    superset))]\n    (->> (for [s sets] (->> s\n                            power-set\n                            (remove empty?)\n                            (map #(apply + %))\n                            set))\n         (apply clojure.set/intersection)\n         count\n         pos?)))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":131,"code":"(fn [& s]\n  (let [o (fn o [s]\n            (loop [[f & r] (seq s) p '(())]\n              (if f (recur r (concat p (map (partial cons f) p)))\n                  p)))\n        u (fn u [s]\n            (let [p (filter #(< 0 (count %)) (o s))]\n              (set (map #(apply + %) p))))\n        m (map u s)]\n    (< 0 (count (apply clojure.set/intersection m)))\n    ))","user":"603ae21de4b0d5df2af222fb"},{"code":"#(not\n (empty?\n  (reduce\n   clojure.set/intersection\n   (for [s %&]\n     (let [l (count s)]\n       (set\n        (for [x (range 1 (bit-shift-left 1 l))]\n          (apply\n           +\n           (keep-indexed\n            (fn [i e] (if (bit-test x i) e))\n            s)))))))))","problem":131,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":131,"code":"(fn [& sets]\n  (not (empty?\n         (apply clojure.set/intersection\n                (map set\n                     (map (fn [x] (map #(apply + %) (remove empty? ((fn [s] (reduce #(clojure.set/union %1 (map (fn [os] (conj os %2)) %1)) #{#{}} s)) x)))) sets))))))","user":"5d764e52e4b02e6b30c93524"},{"problem":131,"code":"(fn sum-some-set\n  [& sets]\n  (let [subsets (fn [s]\n                  (reduce\n                    (fn [acc atom-set]\n                      (into acc\n                            (concat [atom-set]\n                                    (map #(clojure.set/union % atom-set) acc))))\n                    #{} (map (comp set vector) s)))]\n    (not (empty? (->> (map subsets sets)\n                      (map #(map (fn [s] (apply + s)) %))\n                      (map set)\n                      (apply clojure.set/intersection))))))","user":"4e586949535d8a8b8723a292"},{"problem":131,"code":"(fn f [& xs]\n  (letfn [(combi\n            ([n xs]\n             (->> ((comp vec (partial remove nil?) flatten) (combi n xs #{}))\n                  (map (partial apply +))))\n            ([n xs s]\n             (cond\n               (= n (count s)) s\n               (empty? xs) nil\n               :else [(combi n (rest xs) (conj s (first xs)) )\n                      (combi n (rest xs) s)])))]\n    ((complement empty?)\n     (->> xs\n          (map\n           (fn [x]\n             (set\n              (mapcat #(combi % (vec x))\n                      (range 1 (inc (count x)))))))\n          (apply clojure.set/intersection)))))","user":"5ec3a13ae4b08d0ec38692b9"},{"code":"(fn sum-subsets\r\n  [& sets]\r\n\t(if (= (count sets) 1)\r\n\t\ttrue\r\n\t\t(letfn [(power-set\r\n\t\t\t\t\t\t [s]\r\n\t\t\t\t\t\t (if (empty? s)\r\n\t\t\t\t\t\t\t #{#{}}\r\n\t\t\t\t\t\t\t (let [e (first s), r (disj s e), recursive (power-set r)]\r\n\t\t\t\t\t\t\t\t (set (concat (map #(conj % e) recursive) recursive)))))]\r\n\t\t\t(let [a (map power-set sets)\r\n\t\t\t\t\t\tclean (map #(filter (fn [s] (not (empty? s))) %) a)]\r\n\t\t\t\t(let [list-of-sums (map sort (map #(map (fn [s] (apply + s)) %) clean))\r\n\t\t\t\t\t\t\tvalues (vals (reduce (partial merge-with (fn [l, v] (concat l v))) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (map (partial group-by identity) list-of-sums)))]\r\n\t\t\t\t\t(println values)\r\n\t\t\t\t\t(if-let [r (some #(and (>= (count %) (count sets)) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (= clojure.lang.LazySeq (type %))) values)]\r\n\t\t\t\t\t\tr\r\n\t\t\t\t\t\tfalse))))))","problem":131,"user":"4e8a0c82535d3e98b802328d"},{"problem":131,"code":"(fn [& sets]\n  (let [subsets (fn [z]\n                  (loop [result (hash-set z)]\n                    (let [built (into result (for [sub result element z] (disj sub element)))]\n                      (if (= built result) \n                        (remove empty? result)\n                        (recur built)))))\n          sums (for [sub (for [x sets] (subsets x))] (into #{} (map #(reduce + %) sub)))]\n    (if (empty? (apply clojure.set/intersection sums))\n      false true)))","user":"56bb9ccce4b0f26550335959"},{"problem":131,"code":"(fn\n  ([& s]\n   (let [p (fn p\n             ([s n] (p s n 0))\n             ([s n r] (if (= n 0)\n                        r\n                        (recur (rest s) (int (/ n 2)) (if (= 1 (rem n 2)) (+ r (first s)) r)))))\n         q (fn q\n             ([s] (q s #{} 1) )\n             ([s r n] (if (>= n (Math/pow 2 (count s)))\n                        r\n                        (recur s (conj r (p s n)) (inc n)))))]\n    (boolean (seq (apply clojure.set/intersection (map q s)))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":131,"code":"(fn [& Sets]\n    (let \n      [\n        ;; вернет множество всех возможных сумм в данном множестве\n        AllSubSums (fn ThisFunc [S]\n          (loop [Ret #{} First (first S) Rest (rest S)]\n            ;; если больше элементов нет, то стоп\n            (if (nil? First)\n              Ret\n              (let \n                [\n                  NewRet Ret\n                  ;; в противном случае - берем этот элемент отдельно\n                  NewRet (clojure.set/union NewRet #{First})\n                  ;; берем все возможные суммы БЕЗ него\n                  SubSums (ThisFunc Rest)\n                  NewRet (clojure.set/union NewRet SubSums)\n                  ;; а также все возможные суммы с ним\n                  NewRet (clojure.set/union NewRet (map #(+ % First) SubSums))\n                ]\n                (recur NewRet (first Rest) (rest Rest))\n              )\n            )\n          )\n        )\n      ]\n      ;; переберм все множества если после пересечения их всех возможных сумм хоть что-нибудь останется, значит ОК\n      (< 0\n        (count\n          (reduce\n            clojure.set/intersection\n            (map AllSubSums Sets)\n          )\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"code":"(letfn [\r\n  (power-set [s]\r\n\t\t(let [s-vector (vec s), s-size (count s-vector)]\r\n\t\t\t(set\r\n\t\t\t\t(for [i (range (Math/pow 2 s-size))]\r\n\t\t\t\t\t(set\r\n\t\t\t\t\t\t(for [[j d] (take s-size (map vector (range) (iterate #(bit-shift-right % 1) i))) :when (= 1 (bit-and d 1))]\r\n\t\t\t\t\t\t\t(nth s-vector j)))))))\r\n\t(sum-subsets [s]\r\n\t\t(set (map (partial apply +) (filter seq (power-set s)))))]\r\n\t\t\t\t\t\t\t\r\n(fn [& sets]\r\n\t(not (empty? (apply clojure.set/intersection (map sum-subsets sets))))))","problem":131,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn p131[ & xs ]\n  (letfn [(super-set[xs]\n            (set ((fn proc[xs]\n                    (if (empty? xs) [#{}]\n                          (let [ [[a] xs'] (split-at 1 xs)\n                                 S         (proc xs')]\n                            (into S (for [s S] (conj s a)))))) xs)))\n          (set-of-sums [xs]\n            (into #{} (mapcat #(when (> (count %) 0) [(apply + %)]) (super-set xs))))]\n    (> (count (apply clojure.set/intersection (map set-of-sums xs))) 0)))","problem":131,"user":"50fa01bce4b07934dda8b0ba"},{"problem":131,"code":"(fn [& sets]\n    (letfn [(summations [coll]\n              (-> (reduce (fn [found v]\n                            (let [result (->> (map #(+ % v) found)\n                                              (into found))]\n                              (conj result v))) [] coll)\n                  set))]\n      (->> (map summations sets)\n           (reduce (fn [coll1 coll2]\n                     (->> (map #(coll1 %) coll2)\n                          (filter identity)\n                          set)))\n           empty?\n           not)))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (reduce (fn [sets x]\n                      (into sets (map #(conj % x) sets)))\n                      #{#{}}\n                      s))\n          (subset-sums [s]\n            (set (map (fn [subset] (reduce + subset))\n                      (disj (subsets s) #{}))))]\n    (not (empty? (reduce (fn [sums s]\n                           (set (filter sums (subset-sums s))))\n                         (subset-sums (first sets))\n                       (rest sets))))))","problem":131,"user":"4ee3b586535d10e5ff6f5371"},{"code":"(fn [& ss]\n  (let [pset (fn [c] (reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}} c))\n        sums #(->> (pset %) (remove empty?) (map (partial apply +)) (into #{}))]\n  (->> (map sums ss)\n       (reduce (fn [c s] (filter #(s %) c)))\n       empty? not)))","problem":131,"user":"4daec9dcedd6309eace4d15f"},{"code":"(fn [& colls]\n  (let [powerset (fn [coll]\n              (reduce (fn [acc item]\n                        (reduce #(conj % (conj %2 item)) acc acc)) #{#{}} coll))]\n    (not (empty? (reduce clojure.set/intersection\n                         (map (fn [item]\n                                (set (map #(reduce + %)\n                                          (rest (powerset item))))) colls))))))","problem":131,"user":"4f036d9b535dcb61093f6ac1"},{"code":"(fn [& sets]\n  (let\n   [\n      setsum (fn [sets] (set (map #(apply + %)sets)))\n      _listsub (fn listsub ([_set] (set (apply concat (for [e _set] (listsub e _set)))))([e _set] (let [nextsub  (fn [r n _set](set (apply concat r (for [el r :when (= (count el) n)] (map #(conj el %1) (filter #(not (contains? el %1)) _set))))))](loop [r #{#{e}} n 1 k e] (if (= n (count _set)) r (recur (nextsub r n _set) (inc n) k)) ))))\n      _find_inter (fn [[a b & restset]](let [interset (set (for [e1 a e2 b :when (= e1 e2)] e1))](if (or (empty? interset) (empty? restset))interset(recur (cons interset restset)))))\n   ]\n     (if (= (count sets) 1) true\n       (let [sumlist (for [s sets] (setsum(_listsub s)))]\n         (not (empty? (_find_inter sumlist)))\n       )\n     )\n  )\n)","problem":131,"user":"522eba30e4b01cdb292c5f0e"},{"problem":131,"code":"(fn [& a]\n    (letfn [(power-set [xs]\n              (let [f (first xs)\n                    r (disj xs f)]\n                (if (seq xs)\n                  (set (concat (map #(conj % f) (power-set r))\n                               (power-set r)))\n                  #{#{}})))\n            (subset-sums [xs]\n              (->> (power-set xs)\n                   (filter seq)\n                   (map (partial apply +))\n                   set))]\n      (->> (map subset-sums a)\n           (apply clojure.set/intersection)\n           seq\n           boolean)))","user":"59fa241ee4b0ca45a743a358"},{"problem":131,"code":"(fn sss [& sets]\n   (let [sums_subsets (fn [s]\n                        (map\n                          (fn [ss] (reduce + ss))\n                          (filter\n                            (complement empty?)\n                            (loop [[f & r] (seq s) p '(())]\n                              (if f\n                                (recur r (concat p (map (partial cons f) p)))\n                                p))\n                            )))]\n     ((complement empty?) (apply clojure.set/intersection (map #(set (sums_subsets %)) sets)))\n     )\n   )","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn [& ss]\n   (let [psum (fn [s]\n                (set (map (fn [n] (reduce + (keep-indexed #(if (bit-test n %1) %2) s))) (range 1 (bit-shift-left 1 (count s))))))]\n      (->> (mapcat psum ss) frequencies vals (apply max) (= (count ss)))))","problem":131,"user":"4effb663535dcb61093f6a2e"},{"code":"(fn [& ss]\r\n  (let [\r\n    pset\r\n      (fn pset [s]\r\n        (set\r\n          (if (>= 1 (count s)) [(set s)]\r\n            (concat\r\n              [s]\r\n              [(set [(first s)])]\r\n              (pset (set (rest s)))\r\n              (map #(set (cons (first s) %)) (pset (set (rest s))))\r\n            ))))\r\n    sums\r\n  \t\t(map (fn [s] (distinct (map #(list (reduce + %)) (pset s)))) ss)\r\n\t\tsum-map\r\n\t\t\t(apply merge-with concat (map (partial group-by identity) sums))\r\n    ]\r\n\t\t(boolean (some #(= (count %) (count ss)) (vals sum-map)))))","problem":131,"user":"4f1b92d1535d64f60314647b"},{"problem":131,"code":"(fn zz [& s]\n  (->> s\n      (map (fn [a] (loop [res (map hash-set a) cnt 1]\n        (if (= cnt (count a))\n        (set (map (comp (partial apply +) vec) res))\n        (recur\n         (reduce\n          (fn [c x] \n            (apply conj c (map (partial conj x) a)))\n          #{} res)\n         (inc cnt))))))\n      (apply clojure.set/intersection)\n       (empty?)\n       (not)))","user":"51aefceee4b09397d5109797"},{"code":"(fn [& sets]\n    (let [subsets (fn [xs]\n    (set (let [bits  (count xs) \n          index (into {} (map-indexed vector xs))]\n      (for [i (range 1 (Math/pow 2 bits))]\n        (->> (into {} (for [b (range bits)] [(index b) (bit-test i b)]))\n          (filter second)\n          (map first)\n          set)))))\n          ]\n    (->> sets\n      (map subsets)\n      (mapcat (fn [sss] (set (map #(reduce + %) sss))))\n      frequencies\n      (some #(= (count sets) (val %)))\n      boolean)))","problem":131,"user":"4dbad895535d1e037afb21ae"},{"code":"(fn [& sl]\r\n  (let [pset (partial reduce\r\n          #(into %(map (fn [v] (conj v %2)) %)), #{#{}})\r\n        sums (->> sl (map pset) (map next)\r\n          (map #(map (partial reduce +) %)) (map set))]\r\n    (if (some\r\n      #(every? (fn [s] (s %)) (next sums)) (first sums)) \r\n      true false)))","problem":131,"user":"50336c6be4b0c6c1199c710f"},{"problem":131,"code":"(fn ssss [& sets]\n  (letfn [(subsets [s]\n            (if (empty? s)\n              #{#{}}\n              (let [ts (subsets (rest s))]\n                (->> ts \n                     (map #(conj % (first s)))\n                     (clojure.set/union ts)))))]\n    (->> (map (comp set\n                    (partial map (partial reduce +))\n                    (partial filter (comp not empty?))\n                    subsets) sets)\n         (apply clojure.set/intersection)\n         (empty?)\n         (not))))","user":"5666500ee4b0e91d5f5c566d"},{"code":"(fn [lst & n]\n  (let [addsub (fn [s]\n                (set (next \n                  (reduce (fn [a b] \n                            (into a (map #(if % (+ % b) b) a))) \n                          #{nil} s)))),\n        l (addsub lst),\n        o (map addsub n)]\n   (loop [x (first l),y (next l)]\n      (cond (empty? o) true \n            (empty? y) (reduce #(if (and % (%2 x)) true false) true o)\n            (reduce #(if (and % (%2 x)) true false) true o) true\n            :else (recur (first y) (next y))))))","problem":131,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":131,"code":"(fn [& colls]\n  (letfn [(comb [n coll] ; all n-combinations of items in coll\n            (cond (zero? n) '(())\n                  (empty? coll) '()\n                  :else (concat (map #(cons (first coll) %)\n                                     (comb (dec n) (rest coll)))\n                                (comb n (rest coll)))))\n          (sums [coll] ; set of all but empty subset sums\n            (set (flatten (for [k (range 1 (inc (count coll)))]\n                            (map #(apply + %) (comb k coll))))))]\n    (not (empty? (apply clojure.set/intersection (map sums colls))))))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(letfn [(sums [s]\n                (if (empty? s) #{}\n                    (let [f (first s)\n                          r (sums (rest s))]\n                      (conj (clojure.set/union r (map #(+ f %) r))\n                            f))))]\n        (fn [& ss] (not (empty? (apply clojure.set/intersection (map sums ss))))))","problem":131,"user":"5294e44de4b02ebb4ef75016"},{"code":"#(not (empty? (apply clojure.set/intersection (map % %&))))\n(fn [s] (->> s\n             (reduce (fn [s x] (into s (map #(conj % x) s ))) [#{}])\n             (remove empty?)\n             (map #(apply + %))\n             set))","problem":131,"user":"519ef784e4b087743fad2198"},{"code":"(fn [& sets]\n  (letfn [(k-combinations [k s] (cond (= k 1) (map list s)\n                                      (empty? s) nil\n                                      :else (concat (map #(conj % (first s)) (k-combinations (dec k) (next s)))\n                                                    (k-combinations k (next s)))))\n          (subsets [s] (mapcat #(k-combinations % s) (range 1 (inc (count s)))))\n          (sums [s] (set (map #(apply + %) s)))]\n    (not (empty? (->> (map subsets sets)\n                      (map sums)\n                      (apply clojure.set/intersection))))))","problem":131,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":131,"code":"(fn __ [& args]\n  (letfn [(power [s]\n            (set (filter (complement empty? ) (loop [[f & r] (seq s) p '(#{})]\n                   (if f (recur r (concat p (map #(conj % f) p)))\n                       p)))))\n          (kcmb [n k]\n            (if (= 0 n) #{#{}}\n                (reduce into #{}\n                        (map (fn [x] (map #(conj % x)\n                                          (kcmb (dec n)\n                                                (disj k x))))\n                             k))))]\n    (let [sums\n          (set (map #(set (map (fn [xs] (reduce + xs)) %))\n                    (map power args)))]\n               (every? (complement nil?) (map #(some (first %) (second %)) (kcmb 2 sums))))))","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn [f & r]\r\n(letfn [(psetsum [s]\r\n    (set\r\n    (map\r\n    (fn [n]\r\n        (->> s (map vector (range)) \r\n          (filter  (fn [[i e]] (bit-test n i)))\r\n          (map second) (reduce +)))\r\n          (map inc (range (dec (bit-shift-left 1 (count s))))))))]\r\n    (not (empty? (reduce (fn [i x]\r\n          (clojure.set/intersection i\r\n              (psetsum x))) (psetsum f) r)))))","problem":131,"user":"4eb0a757535d7eef3080733d"},{"problem":131,"code":"(fn [& sets]\n    (let\n      [\n        subsets\n        (fn subsets [s]\n          (if\n            (seq s)\n            (let\n              [\n                f (first s)\n\n                srs\n                (subsets\n                  (disj s f)\n                )\n              ]\n              (concat\n                srs\n                (map\n                  #(conj % f)\n                  srs\n                )\n              )\n            )\n            (list #{})\n          )\n        )\n\n        subset-sums\n        (fn [xs]\n          (set\n            (map\n              (fn [c]\n                (apply + c)\n              )\n              (filter\n                (fn [s]\n                  (not (empty? s))\n                )\n                (subsets xs)\n              )\n            )\n          )\n        )\n\n        sums\n        (map\n          subset-sums\n          sets\n        )\n\n        single-set?\n        (= 1 (count sets))\n      ]\n      (if single-set?\n        true\n        (not\n          (empty?\n            (apply clojure.set/intersection sums)\n          )\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":131,"code":"(fn [& sts] (let [ps (fn [s]\n                        (->> (reduce (fn [k i] (into k (map #(merge % i) k))) #{#{}} s)\n                             (filter (complement empty?), )\n                             (group-by (partial apply +), )\n                             ((comp set keys), )\n                             ))\n                   ]\n               (->> (map ps sts)\n                    (apply clojure.set/intersection, )\n                    ((complement empty?), )\n                    )))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn [& n]\r\n  (< 0 (count\r\n         (reduce #(keep %2 %)\r\n           (map (fn f [[x & s]]\r\n                  (into #{x}\r\n                        (if s\r\n                          (into (f s)\r\n                                (map #(+ x %) (f s))))))\r\n                (map seq n))))))","problem":131,"user":"4db858d1535d1e037afb218c"},{"problem":131,"code":"(fn sumSetX [& s]\n\t(letfn\n\t\t[\n\t\t( binToSubset [b sVec length] \n\t\t\t(set (map (fn[n] (get sVec n))\n\t\t\t\t(filter (fn[n] (bit-test b n)) (range 0 length))\n\t\t\t)))\n\n\t\t( powersetbin[s]\n\t\t\t(let [\n\t\t\t\tlength (count s)\n\t\t\t\tbinaryLength (int (Math/pow 2 length))\n\t\t\t\tallBinaries (range 0 binaryLength)\n\t\t\t\tsVec (vec s)\n\t\t\t\t]\n\t\t\t\t(set (map (fn [b] (binToSubset b sVec length)) allBinaries))\n\t\t\t\t)\n\t\t)\n\n\t\t\t(powerSetSums [s]\n\t\t\t\t(set (map #(reduce + %) (filter not-empty (powersetbin s))))\n\t\t\t)\n\t\t]\n\t\t(not (empty? (apply clojure.set/intersection (map powerSetSums s))))\n\t)\n)","user":"568820e8e4b0dcc4269f4067"},{"problem":131,"code":"(fn [ & l]\n  (let [powerset (fn powerset\n            [s]\n            (if (empty? s) #{#{}}\n                (let [[i & r] (into [] s)\n                      subpowerset (powerset r)]\n                  (concat subpowerset (map #(conj % i) subpowerset)))))]\n    ((complement empty?)\n     (apply clojure.set/intersection\n            (for [s l]\n              (->> s\n                   powerset\n                   (remove #{#{}})\n                   (map (partial reduce +))\n                   (into #{}))))))\n  )","user":"583048d9e4b051871117c007"},{"problem":131,"code":"(fn [& sets]\n   (letfn [(smaller-sets [s] (map (partial disj s) s))\n           (subsets [s] (loop [c #{s} seen #{}]\n                          (if (empty? c) seen (recur (set (mapcat smaller-sets c))\n                                                     (clojure.set/union seen c)))))]\n     (->> sets\n          (map #(->> (subsets %)\n                     (filter (complement empty?))\n                     (map (partial apply +))\n                     set))\n          (apply clojure.set/intersection)\n          ((complement empty?)))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":131,"code":"(fn [& l]\n   (if (= 1 (count l))\n     true\n     (let [powerset (fn [s] \n                      (loop [[f & r] (seq s) acc '(())]\n                        (if f \n                          (recur r (concat acc (map #(cons f %) acc)))\n                          acc)))\n           sum (fn [s] (concat (map #(apply + %) (filter seq s))))\n           sumPowersets (fn [s] (map #((comp sum powerset) %) s))\n           findMatches (fn [s] \n                         (reduce (fn [acc n] \n                                   (for [x acc y n :when (= x y)] x))\n                                 (first s)\n                                 (rest s)))]\n       (boolean (seq (findMatches (sumPowersets l)))))))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":131,"code":"(fn equsub [& stlst]\n  (letfn [( chooser [st]\n           (letfn [(redcon [x] (reduce concat x))\n                   (f-comp [f n]\n                     (if (= n 1)\n                       f\n                       (comp f (f-comp f (dec n)))))\n                   (single-cleaner [lis n]\n                     (cond (= n 0) lis\n                           (= n 1) lis\n                           (= n 2) (redcon lis)\n                           true ((f-comp redcon (- n 2)) (map redcon lis))))\n                   (cl2   [ls sing]\n                     (if (empty? ls)\n                       (reverse sing)\n                       (if (empty? (rest ls))\n                         (cl2 (rest ls) (cons (first ls) sing))\n                         (map #(cl2 % (cons (first ls) sing)) (rest ls)))))\n                   (choose [st n]\n                     (cond (= 0 n) ()\n                           (> n (count st)) ()\n                           true (conj\n                                 (choose (rest st) n)\n                                 (conj (choose (rest st) (dec n))\n                                       (first st)))))\n                   (result [st n]\n                     (single-cleaner (map #(cl2 % ()) (choose st n)) n))]\n             (set (cons #{} (map set (redcon (map #(result st %) (range (inc (count st))))))))))]\n    (not (empty? (apply clojure.set/intersection (map (fn [x] (set (map #(apply + %) (filter #(not (empty? %)) (chooser x))))) stlst))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"(fn [m a & s]\n  (let [g (fn [s]\n            (reduce (fn [c e]\n                      (concat c (m #(conj % e) c)))\n                    #{#{}} s))\n        u (m (fn [x] (set (m #(a + %) x)))\n                     (m #(filter seq %) (m g s)))\n        v (a clojure.set/intersection u)]\n    (> (count v) 0)))\nmap apply","problem":131,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn [& r]\n  (let [s (fn [s] (set (for [x s y s] (+ x y))))]\n   (every?\n    #(not (empty? %))\n    (for [x r y r] (clojure.set/intersection (s x) (s y))))))","problem":131,"user":"503b6995e4b07a1917cc34dd"},{"problem":131,"code":"(fn subsums [& sets ]\n  (letfn \n    [\n     (subgen \n       [s]\n       (if (seq s)\n         (clojure.set/union (subgen (rest s)) (map #(conj % (first s)) (subgen (rest s))))\n         #{[]}))]\n    (boolean \n      (seq \n        (apply clojure.set/intersection \n               (map \n                 (fn [x] (set (map #(apply + %) (filter seq (subgen x))))) \n                 sets))))))","user":"55536a8ae4b0deb715856e03"},{"problem":131,"code":";; Get all non-empty subsets\n ;; Sum them\n ;; Take the intersection\n (fn [& subsets]\n   (let [powerset (fn powerset [l]\n                    (loop [r #{}\n                           s [l]]\n                      (if (seq s)\n                        (recur\n                         (into r s)\n                         (set (remove empty? (mapcat (fn [x] (map #(disj x %) x)) s))))\n                        r)))\n         set-of-sums (fn [s] (set (map #(reduce + %) s)))\n         subset-sums (map set-of-sums (map powerset subsets))\n         common-sums (apply clojure.set/intersection subset-sums)]\n     (not (empty? common-sums))))","user":"523ed522e4b057c4b7cd0a78"},{"problem":131,"code":"(fn sumsome [& sets]\n  (letfn [(power-set [s]\n            (loop [s s\n                   ps #{#{}}]\n              (if (empty? s) ps\n                  (recur (rest s) (into ps (map #(conj % (first s)) ps))))))]\n    (->> (map power-set sets)\n         (map (partial remove #(= #{} %)))\n         (map (partial map (partial apply +)))\n         (map set)\n         (apply clojure.set/intersection)\n         seq\n         boolean)))","user":"57533bc1e4b02ea1147992a6"},{"code":"(fn [& s]\n  (let [p (fn [s]\n            (disj (reduce (fn [s a] (clojure.set/union s (map #(conj % a) s)))\n                          #{#{}} s) #{}))\n        r (fn [s] (set (map #(apply + %) (p s))))]\n    (not (empty? (apply clojure.set/intersection (map r s))))))","problem":131,"user":"50705072e4b07bd6ad9b9f27"},{"problem":131,"code":"(fn [& x]\n (letfn [(pset [col] (reduce (fn [b x] (into b (map #(conj % x) b))) #{#{}} col))]\n  (->> (map pset x)\n   (map #(remove empty? %))\n   (map #(map (partial apply +) %))\n   (map set)\n   (apply clojure.set/intersection)\n   seq\n   boolean)))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn [& vs]\n(let [\n   sb (fn [s]\n    (remove empty?\n       (reduce \n          (fn [ss x] (concat ss (map #(conj % x) ss))) \n          [#{}] \n         s)))\n\n   sc (fn [s]\n       (set\n           (map\n             #(reduce + %)\n             (sb s))))]\n   (not (empty?\n          (apply clojure.set/intersection (map sc vs))))))","problem":131,"user":"4daa374930acd6ed13482a68"},{"problem":131,"code":"(let [subsets (fn subsets ([ss s] (if (empty? s) ss (let [e (first s)] (recur (apply conj ss (->> ss (map (fn [es] (conj es e))))) (disj s e))))) ([s] (subsets #{#{}} s)))] (fn [& sets] (not (empty? (->> sets (map #(into #{} (map (fn [s] (reduce + s)) (disj (subsets %) #{})))) (apply clojure.set/intersection))))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn [& ss]\n  (let [sums (fn sums [s] (if (seq s)\n               (let [f (first s )\n                     sp (sums (rest s))]\n                 (clojure.set/union sp (set (map #(+ % f) sp)) #{f}))\n               #{}))]\n   (not (empty? (reduce clojure.set/intersection (map sums ss))))))","problem":131,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn has-equal-sum-subsets [& more]\n\t(letfn [(power-set [a-set]\n\t\t(loop [start-set #{#{}} a-seq (seq a-set)]\n\t\t\t(let [f (first a-seq) r (rest a-seq)\n\t\t\t\t\tset-slice (map #(conj % f) start-set)\n\t\t\t\t\t]\n\t\t\t\t(if f\n\t\t\t\t\t(recur (into start-set set-slice) r)\n\t\t\t\t\tstart-set\n\t\t\t\t)\n\t\t\t)\n\t   )\n\t) (intersection [set-a set-b]\n\t\t(into #{} (filter #(set-b %) set-a))\n\t   )\n\t]\n\t\t(let [result (map (fn[el] (disj (power-set el) #{})) more)\n\t\t\t  subset-sums (map (fn[set-of-sets] (into #{} (map #(reduce + %) set-of-sets))) result)\n\t\t\t  common-sums (reduce intersection subset-sums)]\n\t\t\t(not= common-sums #{})\n\t\t)\n\t)\n)","problem":131,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn [& sets]\n  (letfn [(subsets [coll]\n                   (reduce #(into %1 (map conj %1 (repeat %2))) #{#{}} coll))\n          (sum-ss [coll]\n                  (let [ssets (disj (subsets coll) #{})]\n                    (map #(apply + %) ssets)))]\n    (not\n     (empty?\n      (apply clojure.set/intersection\n             (map #(into #{} (sum-ss %)) sets)\n             )))))","problem":131,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [& l]\n  (not=\n    (reduce\n      #(set (filter % %2))\n      (map\n        (fn s [l]\n          (set\n            (if-let [t (next l)]\n              (concat [(first l)] (s t) (map #(+ % (first l)) (s t)))\n              l)))\n        l))\n  #{}))","problem":131,"user":"4ee82539535d93acb0a66878"},{"code":"(fn [& s]\n    (letfn [(sums [s]\n                  (set (\n                        reduce\n                        (fn [r v] (concat r (map #(+ % v) r) [v])) [] s)))]\n           (not\n             (empty?\n               (reduce\n                 clojure.set/intersection\n                 (map sums s))))))","problem":131,"user":"4f969a66e4b0dcca54ed6cde"},{"code":"(fn ness [& sets]\n(let [subsets (fn [s]\n     (let [bin (fn [n] (lazy-cat \n          (reverse (map #(Integer/parseInt (str %)) \n                (Integer/toString n 2)))\n          (repeat 0)))]\n     (set (map (fn [i]\n      (set (keep identity \n           (map #(if (zero? %) %2 nil) (bin i) s))))\n         (range (bit-shift-left 1 (count s)))))))\n\n      subsums (fn [s] (set (map #(reduce + %) \n                (rest (subsets s)))))]\n\n(not (empty? (apply clojure.set/intersection \n                    (map subsums sets))))))","problem":131,"user":"4dcfbc44535d5973398f92a7"},{"problem":131,"code":"#(->>\n  %&\n  (map seq)\n  (map\n    (fn f [[x & r :as xs]]\n      (if x\n        (let [r (f r)]\n          (concat (map (fn [s] (conj s x)) r) r))\n        [[]])))\n  (mapcat (comp set (fn [s] (map (partial reduce +) (remove empty? s)))))\n  frequencies\n  vals\n  (some (partial = (count %&)))\n  boolean)","user":"4fb1d7ace4b081705acca281"},{"problem":131,"code":"#((comp not empty? (partial apply clojure.set/intersection)) (map %1 %&))\n(fn [s]\n  (set (map #(apply + %)\n            (disj (reduce (fn [a x] (into a (map #(conj % x) a)))\n                          #{#{}} s)\n                  #{}))))","user":"548b7db8e4b0e286459a11fd"},{"problem":131,"code":"(fn [& xs]\n  (letfn [(power-set [s]\n            (reduce (fn [a b]\n                      (into a\n                            (for [x s\n                                  y a]\n                              (disj y x))))\n                    #{s} s))]\n    (not\n      (empty?\n        (apply clojure.set/intersection\n               (map (fn [x]\n                      (into #{}\n                            (map (fn [x] (reduce + x))\n                                 (disj (power-set x) #{}))))\n                    xs))))))","user":"58bb218be4b0888cdc949cf4"},{"problem":131,"code":"(fn sum-some-set-subsets\n  [& sets]\n  (letfn [(power-set [s]\n            (let [s-count (count s)\n                  ps-count (bit-shift-left 1 s-count)\n                  elements (vec s)]\n              (set (for [n (range 0 ps-count)]\n                     (->> (range 0 s-count)\n                          (remove #(zero? (bit-and n (bit-shift-left 1 %))))\n                          (map elements)\n                          set)))))]\n    (->> sets\n         (map (fn [s]\n                (->> s\n                     power-set\n                     (remove empty?)\n                     (map #(apply + %))\n                     set)))\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"563f1493e4b08d4f616f5ecf"},{"code":"(fn [& s]\n  (not\n    (empty? \n      (apply clojure.set/intersection\n        (for [x s]       \n          (into #{}\n            (for [n (range 1 (bit-shift-left 1 (count x)))]       \n              (apply + (filter #(bit-test n (.indexOf (vec x) %)) x))\n            )  \n          )  \n        ) \n      )\n    )\n  )  \n)","problem":131,"user":"5176afd2e4b085adf681d889"},{"code":"(fn [& ss] (not (empty? (apply clojure.set/intersection (map (fn [s] (set (map #(apply + %) (clojure.set/difference (reduce (fn [p i] (clojure.set/union p (set (map #(clojure.set/union % #{i}) p)))) #{#{}} s) #{#{}})))) ss)))))","problem":131,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn [ & args]\n  (let [P (fn P [s]\n      (if (empty? s) #{#{}}\n        (let [small (P (rest s))]\n          (into small (map #(conj % (first s)) small)))))]\n    ((complement empty?) (apply clojure.set/intersection (map #(set (map (partial apply +) (filter (complement empty?) (P %)))) args)))))","problem":131,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [& num-sets]\n  (let [get-sum-set (fn [numbers]\n  (let [nums (vec numbers)\n        possibilities (apply * (repeat (count nums) 2))\n        bits (range possibilities)]\n    (set (filter identity (for [bit bits] \n           (let [subset (filter \n                         identity \n                         (map (fn [a] \n                                (if (bit-test bit a)\n                                 (nth nums a)\n                                 nil)) \n                              (range (count nums))))]\n             (if (empty? subset)\n               nil\n               (apply + subset))))))))\n                      \n        sum-sets (map get-sum-set num-sets)]\n     (> (count (apply clojure.set/intersection sum-sets)) 0)))","problem":131,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn __ [& sets]\n    (let [perms\n          (fn perms [xxs]\n            (if (empty? xxs)\n              [[]]\n              (let [x (first xxs) \n                    xs (rest xxs)\n                    p (perms xs)]\n                (concat p \n                        (map #(conj % x) p)))))\n          pps\n          (for [s sets\n                :let [sums (map (partial reduce +) \n                                (remove empty? (perms s)))]]\n            (set sums))\n          p (first pps)\n          ps (rest pps)]\n      (every? identity (map (partial some p) ps))))","problem":131,"user":"4dc537fd535d8a4b2fd74282"},{"problem":131,"code":"(fn [& sets]\n  (let [powerset (fn powerset [coll]\n                   (if (empty? coll)\n                     #{#{}}\n                     (let [x (first coll)\n                           xs (set (rest coll))\n                           ps-of-xs (powerset xs)]\n                       (clojure.set/union ps-of-xs (set (map #(conj % x) ps-of-xs))))))\n        sums (map (comp set #(map (partial apply +) %) #(disj % #{}) powerset) sets)\n        same-sums (apply clojure.set/intersection sums)]\n\n    (not (empty? same-sums))))","user":"5344fe13e4b084c2834f4a32"},{"problem":131,"code":"(fn sumsss [& sets]\n  (letfn [(powsetne [s]\n            (if (= (count s) 0)\n              #{#{}}\n              (let [elems (seq s)]\n                (loop [i (- (count s) 1)\n                       prev [#{}]\n                       r #{s}]\n                  (if (= i 0)\n                    r\n                    (let [cur (reduce\n                               #(let [part (reduce\n                                            (fn [p e] (conj p (conj %2 e)))\n                                            #{}\n                                            elems)]\n                                  (apply conj %1 part))\n                               #{}\n                               prev)]\n                      (recur (dec i) (seq cur) (apply conj r cur))))))))\n          (sumsets [ss]\n            (map #(apply + (seq %)) (seq ss)))]\n    (if (= (count sets) 1)\n      true\n      (let [[s & seqssum]  (map sumsets (map powsetne sets))]\n        (loop [s s]\n          (if (empty? s)\n            false\n            (let [f (first s)]\n              (if (loop [seqssum seqssum]\n                    (if (empty? seqssum)\n                      true\n                      (if (some #(= f %) (first seqssum))\n                        (recur (rest seqssum))\n                        false)))\n                true\n                (recur (rest s))))))))))","user":"5f8b06afe4b0715f5002d74a"},{"problem":131,"code":"(fn commonsum? [& t]\n     (let [powerset (fn f [x]\n           (if (empty? x)\n             #{#{}}\n             (into (f (set (rest x))) (set (for [y (vector (first x))\n                                                 z (f (set (rest x)))]\n                                             (conj z y))))))\n           newintersection (fn [x y]\n           (loop [counter (- (count x) 1), result (vec x)]\n             (if (>= counter 0)\n               (if (some (set (list (get result counter))) y)\n                 (recur (dec counter) result)\n                 (recur (dec counter) (vec (disj (set result) (get result counter)))))\n               (set result))))\n           possiblesums (fn [s]\n           (distinct (map #(apply + %) (remove empty? (powerset s)))))]\n           (not (empty? (reduce newintersection (map possiblesums t))))))","user":"532727bae4b09d4e7a9b54fa"},{"problem":131,"code":"(let [p (fn p [s]\n            (if (empty? s)\n              #{#{}}\n              (let\n                [r (p (rest s))]\n                (clojure.set/union r (map #(conj % (first s)) r)))))]\n    (fn [& s]\n      (not (empty?\n             (apply\n               clojure.set/intersection\n               (map (fn [x]\n                      (set (map #(apply + %) (disj (p x) #{}))))\n                    s))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":131,"code":"(fn [& ss]\n  (letfn [(power-set [col] (set (reduce (fn [b x] (concat (map #(conj % x) b) b)) [#{}] col)))]\n  (not (empty? (->> (map #(filter (complement empty?) (power-set %)) ss)\n       (map #(reduce (fn [a x] (conj a (apply + x))) #{} %))\n       (apply clojure.set/intersection))))))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":131,"code":"(fn [& ss]\n  (let [comb-sum (fn [s] (reduce (fn [cs n] (into (conj cs n) (map #(+ % n) cs))) #{} s))]\n    (->> (map comb-sum ss) (apply clojure.set/intersection) empty? not)))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":131,"code":"(fn [& l] (let [len (apply min (map count l))]\n\n             (letfn [(combinations  [k s]\n                       (cond\n                         (> k (count s)) nil ;not enough items in sequence to form a valid combination\n                         (= k (count s)) [s] ;only one combination available: all items \n                         (= 1 k) (map vector s) ;every item (on its own) is a valid combination\n                         :else (reduce concat (map-indexed \n                                               (fn [i x] (map #(cons x %) (combinations (dec k) (drop (inc i) s)))) \n                                               s))))]\n\n               ((complement empty?)(apply clojure.set/intersection(map #(set (flatten(for [x (range (inc (count %)))] (map (fn [x] (apply + x)) (combinations x %))))) l))))))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn [& s]\n  (letfn [(intersect [s1 s2] (set (filter #(some #{%} s2) s1)))\n          (sumset [s] (set (map #(reduce + %) (disj s #{}))))\n          (powerset [s] (set\n                         (reduce\n                          (fn [s x]\n                            (concat s (map (fn [y] (conj y x)) s)))\n                          #{#{}} s)))]\n    (not (empty? (reduce intersect (map sumset (map powerset s)))))))","problem":131,"user":"50acbd15e4b071b89ef26234"},{"problem":131,"code":"(fn [& x]\n     (->> x\n      (reduce \n       (fn [a s]\n         (reduce #(update-in %1 [%2] (fnil conj #{}) s)\n                 a\n                 (for [s (next (reduce (fn [p f] (into p (map #(conj % f) p))) [#{}] s))] \n                     (apply + s)))) {})\n      vals (map count) (apply max) (= (count x))))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn zero-subsets? [& sets]\n   (letfn [(powerset [s]\n             (letfn [(f [n ps]\n                       (if (zero? n) ps\n                           (f (dec n)\n                              (set (concat ps (mapcat (fn [a] (map #(conj % a) ps)) s))))))]\n               (f (count s) #{#{}})))\n           (sums [s] (set (map (partial apply +) (rest (powerset s)))))]\n     (let [sumsets (map sums sets)]\n       (if (some (fn [num] (every? #(contains? % num) sumsets)) (first sumsets)) true false)\n       )))","problem":131,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn sum-some-set-subsets [& sets]\n  (letfn [(add-to-power-set [s elem]\n             (into s (map #(conj % elem) s)))]\n    (not\n      (empty? \n        (apply clojure.set/intersection \n               (map #(->> %\n                          (reduce add-to-power-set #{#{}}) ;; get power set                   \n                          (filter (comp not zero? count))  ;; remove empty set\n                          (map (partial reduce +))         ;; find sum of each set in power set\n                          (into #{}))                      ;; get result back into a set sets\n                    sets))))))","problem":131,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn solve [& sets]\n            (letfn [(subsets [s]\n                             (reduce\n                              (fn [s el] (concat (map #(conj % el) s) s))\n                              [#{}] s))\n                   (sums [s] (->> (subsets s)\n                                  (remove empty?)\n                                  (map #(apply + %))\n                                  (set)))]\n                                  (->> (map sums sets)\n                                       (apply clojure.set/intersection)\n                                       empty?\n                                       not)))","problem":131,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn sum-some-set-subsets [& sss]\n  (letfn [(power-set [s]\n              (letfn [(sp-set [s] (reduce (fn [a x] (conj a (disj s x)))#{} s))]\n                (conj (loop [a #{} s #{s}]\n                        (let [[ar,rr] (reduce (fn [[a,ns] x]\n                                                (let [r (sp-set x)]\n                                                  [(into a r), (into ns r)]))\n\n                                              [a,#{}] s)]\n                          (if (= rr #{})\n                            ar\n                            (recur ar rr)))) s)\n                ))]\n\n    (< 1 (count (apply clojure.set/intersection (map \n                                     (fn [x] \n                                       (set (map \n                                             #(if (empty? %) nil (apply + %))   \n                                             (power-set x))))                                     \n                                     sss))))))","problem":131,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [& s]\n  (not= #{}\n  (apply clojure.set/intersection\n  (map (comp \n          set \n          (partial map #(apply + %))\n          (fn [v] (rest (map set\n            ((fn f [[h & t]]\n              (if h\n                (let [r (f t)]\n                  (concat r (map #(concat [h] %) r)))\n                [[]]\n            )) (vec v)))))) s))))","problem":131,"user":"4f01c938535dcb61093f6a39"},{"problem":131,"code":"(fn [& sets]\n  (->> sets\n       (map #(loop [[f & r] (seq %) p '(())]\n               (if f\n                 (recur r (concat p (map (partial cons f) p)))\n                 (set (->> p\n                           (filter seq)\n                           (map (partial apply +)))))))\n            (apply clojure.set/intersection)\n            empty?\n            not))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn ssss [& sets]\n  (letfn [(sum-all [set] (map #(apply + %) set))\n          (subsets [set]\n                   (if (= set #{}) #{}\n    (loop [s [set] super #{set}]\n      (let [combinations (fn [coll] (map #(clojure.set/difference coll #{%}) coll))\n\t          ssets (reduce (fn [acc e] (into acc (combinations e))) #{} s)]\n\t      (if (= #{} (first ssets))\n\t        super\n\t        (recur ssets (into super ssets)))\n\t      ))))]\n    (let [sum-of-subsets (map (comp set sum-all subsets) sets)]\n      (println sum-of-subsets)\n      (println (apply clojure.set/intersection sum-of-subsets))\n      (not (empty? (apply clojure.set/intersection sum-of-subsets))))))","problem":131,"user":"5003deb9e4b0678c553fc445"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subset-sums\n            ([number-set] (subset-sums number-set #{}))\n            ([number-set sums]\n             (if (empty? number-set)\n               sums\n               (let [x (first number-set)]\n                 (recur (clojure.set/difference number-set #{x}) (clojure.set/union sums #{x} (into #{} (map #(+ x %) sums))))))))]\n    (not (empty? (apply clojure.set/intersection (map subset-sums sets))))))","user":"592ac17ae4b072a2710fcf26"},{"code":"(fn [& sets]\n  (letfn [(pset [s] \n    (if (empty? s) \n      #{#{}}\n      (let [p (pset (set (rest s)))]\n        (clojure.set/union \n          p\n          (map #(conj % (first s)) p)))))]\n  (letfn [(sumsets [s] (set (distinct (map #(apply + %) (clojure.set/difference (pset s) #{#{}})))))]\n    (not (empty? (apply clojure.set/intersection (map sumsets sets)))))))","problem":131,"user":"4e9c81e8535dbda64a6f6b80"},{"code":"(fn [ & sets]\n  (letfn[\n    (sums [[v & vs]]\n      (if (empty? vs) (list v)\n        (apply conj (sums vs) v\n          (map (partial + v) (sums vs)))))]\n    ;embedded\n    (not-any? empty?\n      (reductions #(filter %2 %)\n        (map (comp set sums seq) sets)))\n    ;sequential\n    (->> sets \n      (map seq)\n      (map sums)\n      (map set)\n      (reductions (comp set filter))\n      (not-any? empty?))\n))","problem":131,"user":"50901b2ee4b0ea685a20f774"},{"problem":131,"code":"(fn [& my-sets]\n   (->> my-sets\n        (map (fn all-subsets [my-set]\n               (if (empty? my-set)\n                 #{#{}}\n                 (let [f (first my-set)\n                       r (into #{} (rest my-set))\n                       subs (all-subsets r)]\n                   (clojure.set/union\n                     subs\n                     (into #{} (map #(conj % f) subs)))))))\n        (map (fn [x] (map #(when-not (empty? %) (reduce + %)) x)))\n        (remove nil?)\n        (map set)\n        (apply clojure.set/intersection)\n        (#(or (> (count %) 1)\n              (= (first %) 0)))))","user":"4f35b2ace4b0e243712b1ec5"},{"code":"(letfn [(sums [s]\n          (if (empty? s)\n            #{}\n            (set (cons (first s) (mapcat #(list % (+ % (first s))) (sums (rest s)))))))]\n  (fn f [& sets] (not (empty? (apply clojure.set/intersection (map sums sets))))))","problem":131,"user":"50b668dde4b08fb537db98f2"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(sums-of [sums entries]\n            (if-let [f (first entries)]\n              (sums-of (apply conj sums f (map #(+ f %) sums)) (rest entries))\n              sums))]\n    (not (empty? (reduce (fn [c m] (when (seq c)\n                                     (set (filter c m))))\n                         (map (partial sums-of #{}) sets))))))","user":"51852961e4b0da5a5be3babb"},{"code":"(fn [& a]\r\n  (not (empty? (apply clojure.set/intersection \r\n    (map (fn [s]\r\n      (set (map (partial reduce +)\r\n         (disj (set (reduce\r\n           (fn [x y] (concat x \r\n             (map #(conj % y) x)))\r\n               [#{}] s)) #{})))) a)))))","problem":131,"user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"(fn [& sets]\n    (not (empty? \n          (apply clojure.set/intersection\n                 (map\n                  (fn [s]\n                    (into #{}\n                          (map (partial apply +)\n                               (filter (complement empty?)\n                                       (loop [res [#{}]\n                                              s s]\n                                         (if (empty? s)\n                                           res\n                                           (recur\n                                            (concat res (map #(conj % (first s)) res))\n                                            (rest s))))))))\n                  sets)))))","problem":131,"user":"4f463dfde4b0d56e7bb92b99"},{"problem":131,"code":"(fn [& numsets]\n\t (let [power (fn [coll]\n\t             (loop [coll coll, acc #{#{}}]\n\t\t\t\t\t\t\t\t\t(if (empty? coll) acc\n\t\t\t\t\t\t\t\t\t\t(recur (rest coll) (into acc (map #(conj % (first coll)) acc))))))]\n  \t        (let [tmps (for [nums numsets]\n  \t          (into #{} (map (partial reduce +) (filter  (complement empty?) (power nums))))),\n  \t          res (reduce \n  \t             (fn [acc curr]\n  \t              (set (for [x acc :when (contains? curr x)] x)))\n  \t             tmps)]\n  \t             (> (count res) 0))))","user":"5224a46ce4b01819a2de42e5"},{"code":"(fn[ & ss ]\n  (not (empty? \n    (reduce #(into #{} (filter %1 %2)) \n      (map (fn [s]\n        (reduce #(into #{} (concat % (map  (partial + %2) %))) s s))\n          ss)))))","problem":131,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn [& x]\n  (letfn [(f [x]\n             (reduce (fn [s a]\n                       (clojure.set/union\n                        s\n                        (set (map #(clojure.set/union #{a} %) s))))\n                     #{#{}} x))\n          (f2 [x]\n              (set (map #(apply + %) (disj x #{}))))]\n    (not= #{} (apply clojure.set/intersection (map (comp f2 f) x)))))","problem":131,"user":"529b44afe4b02ebb4ef7509d"},{"problem":131,"code":"(fn sum-subset [& sets]\n  (let [subsets\n        (fn subsets [s]\n          (if (seq s)\n            (let [f (first s), srs (subsets (disj s f))]\n              (concat srs (map #(conj % f) srs)))\n            (list #{})))\n        gen-subsets (fn [s] (filter (complement empty?) (subsets s)))]\n    (< 0 (count\n      (apply clojure.set/intersection\n             (into #{} (map (fn [set] (into #{} (for [subset set] (reduce + subset))))\n                            (map #(cons % (gen-subsets %)) sets))))))\n    ))","user":"54f09599e4b024c67c0cf89d"},{"problem":131,"code":"(let [do-subset (fn [i l]\n                  (loop [i i l l s '()]\n                    (cond\n                     (= 0 i) (set s)\n                     (= 1 i) (set (cons (first l) s))\n                     :else (condp = (mod i 2)\n                             0 (recur (quot i 2) (rest l) s)\n                             1 (recur (quot i 2) (rest l) (cons (first l) s))))))\n      powerset (fn [l]\n                 (take (bit-shift-left 1 (count l))\n                       ((fn inf-subsets [i l]\n                          (cons (do-subset i l) (lazy-cat (inf-subsets (inc i) l))))\n                        0 l)))\n      set-subsets-sums (fn [s] (set (map #(reduce + %)\n                                          (filter\n                                           (comp not empty?)\n                                           (powerset (vec s))))))\n      common-sums (fn [& sets]\n                    (apply clojure.set/intersection (map set-subsets-sums sets)))]\n  (comp #(> (count %) 0) common-sums))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":131,"code":"(fn [& ss]\n  (not (empty? \n         (reduce clojure.set/intersection\n                 (map (fn [xs] \n                        (->> (reduce (fn [xss x]\n                                       (concat xss (map #(conj % x) xss))) \n                                     (map hash-set xs) xs)\n                             (remove empty?) \n                             (map #(reduce + %)) set)) \n                      ss)))))","user":"53dfdf01e4b0d874e779ae46"},{"code":"(letfn [(subsets [s]\n  (reduce \n    (fn [s x] (clojure.set/union s #{#{x}} (map conj s (repeat x))))\n    #{} s))]\n  (fn [& sets]\n    (not (empty?\n      (apply clojure.set/intersection\n        (map #(set (map (partial apply +) (subsets %1))) sets))))))","problem":131,"user":"5002b6e5e4b0678c553fc42c"},{"problem":131,"code":"(letfn [(ps [s] (reduce #(reduce (fn [ss s] (conj ss (conj s %2))) % %) #{#{}} s))\n        (sums [s] (->> s ps (remove #(= #{} %)) (map #(reduce + %)) set))]\n  (fn [& ss] (->> ss (map sums) (apply clojure.set/intersection) (not= #{}))))","user":"53908e6be4b0b51d73faae9a"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(p [s]\n            (if (empty? s) #{#{}}\n                (let [r (set (rest s))]\n                  (set (concat (p r) (map #(conj % (first s)) (p r)))))))\n          (ps [s] (set (map #(reduce + %) \n                            (filter (complement empty?) (p s)))))]\n    (not (empty? (apply clojure.set/intersection (map ps sets))))))","user":"5405ae2be4b0addc1aec6671"},{"problem":131,"code":"(fn __ [ & colls] (let [subset-sum\n              (fn [coll]\n                (let [comb (fn [value colls] (set (map #(clojure.set/union  % [value]) colls)))]\n                  (map #(reduce + %)\n                       (reduce\n                        (fn [result value]\n                          (clojure.set/union #{#{value}} (comb value result) result))\n                        #{}\n                        coll))))]\n          (let [sum-set (map subset-sum colls)]\n            (if (empty? (reduce\n                       #(clojure.set/intersection\n                         %1\n                         (set %2))\n                       (set (first sum-set))\n                       sum-set)) false true\n                ))))","user":"52fac708e4b047fd55836fff"},{"problem":131,"code":"(fn foo [& sets]\n  (let [power-set (fn [s] (disj (set (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s))\n                                #{}))\n        sums (map #(->> %\n                       power-set\n                       (group-by (partial reduce +))\n                       keys\n                       set) sets)]\n    ((complement empty?) (apply clojure.set/intersection sums))))","user":"52d00832e4b07d0d72b273b4"},{"problem":131,"code":"(fn same-sum-subset? [& ss]\n  (letfn [(subset-sums [s]\n            (when (seq s)\n              (loop [s s res #{}]\n                (if-let [e (first s)]\n                  (recur (rest s) (into (conj res e) (map #(+ % e) res)))\n                  res))))]\n    (let [[fst-sums & rst-sums] (map subset-sums ss)]\n      (every? #(some fst-sums %) rst-sums))))","user":"5f300f28e4b033932238a682"},{"problem":131,"code":"(fn [& sets]\n  (let\n    [subseqs (fn subseqs [s]\n               (if (empty? s)\n                 '(())\n                 (concat (subseqs (rest s)) (map (partial cons (first s)) (subseqs (rest s))))))\n     subsets (fn [s]\n               (filter (complement empty?) (set (map set (subseqs (set s))))))\n     set-sumof-subsets\n     (fn [s]\n       (set (map #(apply + %) (subsets s))))\n     ]\n    (->>\n      (map set-sumof-subsets sets)\n      (apply clojure.set/intersection)\n      ((complement empty?)))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [& xss]\n           (letfn [(pset [xs]\n                     (if (empty? xs)\n                       #{  }\n                       (let [[ h & rs] (seq xs)\n                             ps (pset rs)]                  \n                         (clojure.set/union #{h} ps (map (partial + h) ps)))))]\n             (boolean (seq\n                   (apply clojure.set/intersection\n                          (map\n                            (comp (partial into #{}) pset)\n                              xss))))))","problem":131,"user":"52dc2bc8e4b09f7907dd13ca"},{"code":"(fn [s & ss]\n  (let [power-set (fn [s]\n                    (set (reduce (fn [ps e]\n                                   (reduce (fn [ps f]\n                                             (cons (conj f e) ps))\n                                           ps ps))\n                                 #{#{}} s)))\n        subsets (fn [s] (filter (comp not empty?) (power-set s)))\n        sums    (set (map #(apply + %) (subsets s)))]\n    (every? (fn [s] (some #(sums (apply + %)) (subsets s))) ss)))","problem":131,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"code":"(fn [& sets]\n  (letfn [(powerset [ls]\n            (if (empty? ls)\n              '(())\n              (clojure.set/union (powerset (next ls))\n                                 (map #(conj % (first ls)) (powerset (next ls))))))\n          (powerset-non-empty [s]\n            (remove empty? (powerset s)))\n          (subset-sums [s]\n            (->> s\n                 powerset-non-empty\n                 (map #(reduce + %))\n                 set))]\n    (let [sums (map subset-sums sets)\n          matching-sums (apply clojure.set/intersection sums)]\n      (pos? (count matching-sums)))))","problem":131,"user":"4e80aa10535db62dc21a62b1"},{"problem":131,"code":"(letfn [(subsets\n         [n s]\n         (cond\n          (= n 0) '(())\n          (empty? s) '()\n          :else (concat (map\n                         #(cons (first s) %)\n                         (subsets (dec n) (rest s)))\n                        (subsets n (rest s)))))\n        (power-set\n         [s]\n         (set (mapcat #(map set (subsets % s))\n                      (range (inc (count s))))))]\n  (fn [& sets]\n    (let [possible-sums (map (fn [s]\n                              (set (map #(apply + %) (disj (power-set s) #{}))))\n                            sets)]\n      ((complement empty?) (apply clojure.set/intersection possible-sums)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":131,"code":"(fn [& sets]\n\t(let[powerset (fn [v] (loop [v v subsets #{#{}}]\n\t\t\t\t\t(if (empty? v)\n\t\t\t\t\t\t(disj subsets #{})\n\t\t\t\t\t\t(recur (rest v) (into subsets (map #(conj % (first v)) subsets))))))\n\t\teachSum (fn [subs] (map #(reduce + %) subs))\n\t\tallSums (map #(set (eachSum (powerset %))) sets)]\n\t(not (empty? (reduce clojure.set/intersection allSums)))))","user":"5472d919e4b094393f72dd7b"},{"problem":131,"code":"(fn [& ssets]\n  (letfn [(powerset [coll] \n            (reduce (fn [a x]\n                      (into a (map #(conj % x) a)))\n                    #{#{}} coll))]\n    ((comp not empty?) (apply clojure.set/intersection \n           (map (comp set #(map (partial apply +) (disj (powerset %) #{}))) ssets)))))","user":"5e3a25d4e4b01d43a70e8dde"},{"code":"(fn [& s]\n  (< 0\n    (count\n      (reduce clojure.set/intersection\n        (map\n          (fn [i]\n            (set\n              (map #(reduce + %)\n                (remove empty?\n                  (reduce\n                    (fn [o v]\n                      (clojure.set/union o (map #(conj % v) o)))\n                    #{#{}}\n                    i)))))\n          s)))))","problem":131,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":131,"code":"#(not (empty? (apply clojure.set/intersection (map % %&))))\n\n(fn [c]\n  (set (map #(apply + %) (rest (reduce (fn [r x] (into r (map #(conj % x) r)))\n            [[]] c)))))","user":"57e33f6fe4b0bfb2137f5a96"},{"code":"(fn p131\n  [& sets]\n  (letfn [(subsets\n              [superset base]\n              (let [a (into #{} (map (fn[e] #{e}) superset))]\n                (into #{}\n                      (filter #(= (dec (count (first base))) (count %))\n                              (mapcat (fn [e] (map (fn [i] (clojure.set/difference e i)) a)) base)))))\n          (all-subsets \n            [s]\n            (loop [r #{s}\n                   c (count s)]\n              (if (= c 1)\n                r\n                (recur (clojure.set/union r (subsets s (filter #(= (count %) c) r)))\n                       (dec c)))))]\n    (let [sums (map (fn [sbs]\n                      (into #{} (map #(apply + %) sbs)))\n                    (map all-subsets sets))]\n      (not (empty? (reduce clojure.set/intersection sums))))))","problem":131,"user":"5348cab4e4b084c2834f4a5e"},{"code":"(fn sum-some [& cols]\n  (letfn [(power-set [s] (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s))]\n    (let [psets (map (comp #(disj % #{}) power-set) cols)]\n      (not (empty? (apply clojure.set/intersection (map (comp set (fn [s] (map #(apply + %) s))) psets)))))))","problem":131,"user":"4f849f76e4b033992c121c36"},{"problem":131,"code":"(fn [& some-sets]\n  (let [powerset (fn ps [xs]\n                   (let [fst (first xs)\n                         rst (next xs)]\n                     (if rst\n                       (let [subsets (ps rst)]\n                         (clojure.set/union\n                           #{#{fst}}\n                           subsets\n                           (into #{} (map #(conj % fst) subsets))))\n                       #{#{fst}})))\n        sums (->> some-sets\n                  (map powerset)\n                  (map #(into #{} (map (fn [s] (reduce + s)) %))))]\n    (not (empty? (apply clojure.set/intersection sums)))))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [& s]\n  (letfn [(subsets [s]\n            (when (seq s)\n              (let [e (first s) p (subsets (rest s))]\n                (concat [[e]] p (map #(conj % e) p)))))]\n    (not (empty?\n          (apply clojure.set/intersection \n                 (map (fn [e] (set (map #(reduce + %) (subsets e)))) s))))))","problem":131,"user":"4e52d815535d302ef430da77"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (if (seq s)\n              (let [f (first s) ss (subsets (rest s))]\n                (concat ss (map (partial cons f) ss)))\n              (list ())))]\n    (->> sets\n         (mapcat\n           (fn [s] (->> (seq s)\n                        ((comp rest subsets))\n                        (map #(vector (apply + %) 1))\n                        (distinct))))\n         (reduce (fn [m [k v]] (update-in m [k] (fnil + 0) v)) {})\n         (some #(= (second %) (count sets)))\n         (boolean))))","user":"56d68cbae4b0ea9b8538f7cd"},{"code":"(fn f [& args]\n   (letfn [ (sums [[n & more]]\n                  (cons n \n                    (if more\n                      (mapcat (juxt identity #(+ % n)) \n                              (sums more))))) ]\n\n     (not (empty? \n       (apply clojure.set/intersection \n          (map (comp set sums seq) args))) )))","problem":131,"user":"4e860e85535db62dc21a62f1"},{"problem":131,"code":"(fn [& w] \n\t(< 1 \n     \t(count \n      \t\t(apply clojure.set/intersection \n                   (map \n                    \t(fn [v] \n                          \t(set \n                             \t(map #(if (= #{} %) :a (apply + %)) \n\t\t\t\t\t\t\t\t\t(\n                                    \t(fn peu [x] \n                                        \t(let [y (apply list x)] \n                                            \t(if (empty? y) #{#{}} \n                                                \t(let [z (apply list (peu (rest y)))] \n                                                      \t(clojure.set/union z \n                                                        \t(map #(clojure.set/union % #{(first y)}) z))))))\n\t\t\t\t\t\t\t\t\tv)))) \n                   \tw)))))","user":"53fc8424e4b0de5c418485b3"},{"problem":131,"code":"(fn [& s]\n  (let [power-set (fn [s]\n                    (disj (loop [s (seq s)\n                                 a #{#{}}]\n                            (if (empty? s)\n                              a\n                              (recur (next s)\n                                     (clojure.set/union a\n                                                        (reduce #(conj %1 (conj %2 (first s)))\n                                                                #{} a))))) #{}))\n        sum (fn [s]\n              (->> s\n                   (power-set)\n                   (map #(apply + %))\n                   (#(reduce (fn [a x] (if (contains? a x) a (conj a x))) #{} %))))\n        sets (map sum s)]\n    (not (empty? (apply clojure.set/intersection sets)))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":131,"code":"(fn [& sos] (letfn [(ss [s] (if (empty? s) #{#{}} (let [sets (ss (drop 1 s))] (clojure.set/union sets (map #(conj % (first s)) sets))))) (sum [l] (set (map #(apply + %) (remove empty? (ss l))))) ] (not (empty? (apply clojure.set/intersection (map sum sos) )))))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn [& z]\r\n\r\n  (not (empty? (apply clojure.set/intersection (let [ps (fn [c] (set (loop [m 3 v (for [x c] #{x})]\r\n\t\t\t\t(cond\r\n\t\t\t\t(= 0 m ) v\r\n\t\t\t\t:else  (recur (dec m) (for [x v y c ] (conj x y)))))))\r\n\t\t  m (map ps z)]\r\n\t\t\t\r\n\t(map (fn [x] (set (map #(reduce + %) x))) m))))))","problem":131,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn __ [& sets]\n  (letfn [(subset-sums [s]\n            (let [[f & r] (vec s)]\n              (cond\n               (nil? f) #{}\n               (nil? r) #{f}\n               :else\n               (set (concat #{f} #{(reduce + s)}\n                            (subset-sums (set r))\n                            (map #(+ f %) (subset-sums (set r))))))))]\n    (not (empty? (apply clojure.set/intersection  (map subset-sums sets))))))","problem":131,"user":"512d3304e4b040332b905b2d"},{"problem":131,"code":"(fn [& sets]\n  (letfn [\n    (nth-masked? [n mask]\n      (not= 0 (bit-and (bit-shift-left 1 n) mask)))\n    (bitmap-select [mask xs]\n      (map last (filter #(nth-masked? (first %1) mask) (keep-indexed #(vector %1 %2) xs))))\n    (combinations [xs]\n      (map #(bitmap-select % xs) (range 1 (bit-shift-left 1 (count xs)))))\n    ]\n    ((complement empty?) (apply clojure.set/intersection (map #(into #{} (map (partial reduce +) (combinations %))) sets)))))","user":"55d5e80ee4b0e31453f64a91"},{"code":"(fn [& sets]\n  (->> sets\n       (map (fn [elts]\n            (->> elts\n               (reduce #(concat %1 (map (fn [s] (conj s %2)) %1)) [#{}])\n               (remove #{#{}})\n               (map (partial reduce +))\n               set)))\n       (apply clojure.set/intersection)\n       count\n       pos?))","problem":131,"user":"507b7dbee4b09034bfeeb71e"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets [n items]\n            (cond\n              (= n 0) '(())\n              (empty? items) '()\n              :else (concat \n                      (map #(cons (first items) %)\n                      (subsets (dec n) (rest items)))\n                      (subsets n (rest items)))))\n          (subsums [se]\n            (reduce (fn [x y] (apply conj x (set (map #(apply + %) (subsets y se))))) #{} (range 1 (inc (count se)))))]\n    (not (empty? (apply clojure.set/intersection (map subsums sets))))))","user":"5292feb4e4b0239c8a67af39"},{"problem":131,"code":"(fn [& S] (let [P (map (fn [T] (reduce (fn [P s] (into P (map #(conj % s) P))) [#{}] T)) S) R (map (fn [s] (set (map (fn [t] (reduce + t)) (rest s)))) P)] (->> (reduce clojure.set/intersection (first R) (rest R)) empty? not)))","user":"55f6fe09e4b06e875b46cea2"},{"problem":131,"code":"(fn __ [& coll]\n  (letfn\n    [(subsets\n       [s]\n       (if (empty? s)\n         #{#{}}\n         (let [ts (subsets (rest s))]\n           (->> ts\n                (map #(conj % (first s)))\n                (clojure.set/union ts)))))\n     (subtotals\n       [s]\n       (into #{} (map #(reduce + %) (clojure.set/difference s #{#{}}))))\n     ]\n    (not (empty? (apply clojure.set/intersection (map #(-> % subsets subtotals) coll))))\n;    (map #(-> % subsets subtotals) coll)\n    ))","user":"52828298e4b0757a1b17145b"},{"code":"(fn [& s]\n(letfn [(subsets [t] (reduce (fn [a v] (clojure.set/union a (map #(conj %1 v) a))) #{#{}} t))]\n  (not (empty? (apply clojure.set/intersection \n                      (map (fn [a] (set (map #(apply + %1) \n                                             (filter (complement empty?) (subsets a))))) s))))\n  ))","problem":131,"user":"52593207e4b0cb4875a45cd3"},{"problem":131,"code":"(fn __ [& sets]\n  (letfn [(subsets [s]\n            (reduce (fn [r e] (conj (into r (map #(conj % e) r)) [e]))\n                    [] s))]\n    (not (empty?\n          (->> sets\n               (map #(subsets %))\n               (map (fn [s] (map #(apply + %) s)))\n               (map #(into #{} %))\n               (apply clojure.set/intersection)\n               )))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":131,"code":"(fn [& sets]\n  (let [combination-of-set (fn [st]\n                             (remove empty?\n                                     (reduce (fn [acc e]\n                                               (concat acc (map #(conj % e) acc)))\n                                             [#{}]\n                                             st)))\n        sum-elements-in-set (fn [sts]\n                              (set (map #(apply + %) sts)))]\n    (not (empty? (apply clojure.set/intersection (map sum-elements-in-set (map combination-of-set sets)))))))","user":"5cf895efe4b0b71b1d808a85"},{"problem":131,"code":"(fn [& sets]\n\t(letfn [(subsets-sum [coll]\n\t\t(loop [coll coll, sums #{}]\n\t\t\t(if (empty? coll)\n\t\t\t\tsums\n\t\t\t\t(let [c0 (first coll), coll' (rest coll)]\n\t\t\t\t\t(recur coll' (conj (clojure.set/union sums (map #(+ c0 %) sums)) c0))))))]\n\t\t(not (empty? (apply clojure.set/intersection (map subsets-sum sets))))))","user":"5370b386e4b0fc7073fd6e9b"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets\n           [s] (if (empty? s) [#{}]\n                 (let [ss (subsets (rest s))]\n                   (concat ss (map #(conj % (first s)) ss)))))\n          (subset-sums\n           [s] (set (map #(apply + %) (remove empty? (subsets s)))))]\n    (not= #{} (apply clojure.set/intersection (map subset-sums sets)))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn [& ss]\n  (let [add-element (fn [res x] (clojure.set/union res (map #(conj % x) res)))\n        subsets (fn [s] (reduce add-element (set (map hash-set s)) s))\n        sums (fn [s] (set (map #(reduce + %) (subsets s))))]\n    (not (empty? (apply clojure.set/intersection (map sums ss))))))","problem":131,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn ssums? [& ss]\n  (let [subsets\n        (fn subsets [s]\n          ((fn subsets [s used acc]\n             (let [rem-s (clojure.set/difference s used)\n                   e (first rem-s)]\n               (if (empty? rem-s) #{acc}\n                   (clojure.set/union\n                    (subsets (disj s e) used (conj acc e))\n                    (subsets s (conj used e) acc))))) s #{} #{}))\n        sub-sums\n        (fn sub-sums [s]\n          (set (map (partial apply +) (remove empty? (subsets s)))))]\n    (not (empty? (apply clojure.set/intersection\n                        (map sub-sums ss))))))","problem":131,"user":"529ce629e4b04e0c58e87b6e"},{"problem":131,"code":"(fn f [& sets]\n  (letfn [(combinations [s n]\n                        (if (zero? n)\n                          #{#{}}\n                          (set (mapcat (fn [elem] (map #(conj % elem) (combinations (disj s elem) (dec n)))) s))))\n          (subsets [s] (mapcat #(combinations s %) (range 1 (min 5 (inc (count s))))))\n          (sums [s] (set (map #(apply + %) (subsets s))))]\n    (not= #{} (reduce clojure.set/intersection (map sums sets)))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(letfn [(powerset [s]\n          (reduce (fn [sets x]\n                        (concat sets (map #(conj % x) sets)))\n                      [#{}]\n                      s))\n        (sums [s]\n          (set (map #(apply + %)\n                    (remove #{#{}} (powerset s)))))]\n  (fn [& ss]\n    (not (empty? (apply clojure.set/intersection (map sums ss))))))","problem":131,"user":"51789dfae4b03d69594194d7"},{"problem":131,"code":"(fn ssss [& colls]\n  (letfn [(ps [s]\n\t\t \t(reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s))]\n    (->> colls \n         (map (comp set rest (fn [s] (map #(reduce + %) s)) ps))\n         (apply clojure.set/intersection)\n         (not= #{}))))","user":"53b39d82e4b047364c0444a6"},{"problem":131,"code":"(fn [& r]\n   (not\n    (empty?\n     (apply clojure.set/intersection\n            (map (fn [q]\n                   (set (map #(apply + %)\n                             (rest (reduce (fn [s x] (concat s (map #(conj % x) s)))\n                                           [#{}] q)))))\n                 r)))))","user":"50548ce8e4b0b1b9d1860ead"},{"code":"(fn [& s]\n  (let [superset (fn superset [x] \n                   (if (= 1 (count x))\n                     #{ #{(first x)} #{}}\n                     (apply merge \n                            (superset (rest x)) \n                            (map #(into #{} (conj % (first x))) (superset (rest x))) )))\n        supset (fn [s] (disj (superset s) #{} ))\n        sums (fn [s] (into #{} (map (partial apply +) (supset s))))\n        allthesums (map sums s)\n        ]\n    ((comp not nil?) (some\n     (fn [sum] (every? #(contains? % sum) (rest allthesums)))\n     (first allthesums)))))","problem":131,"user":"513b77f3e4b00f740c76c403"},{"problem":131,"code":"(fn [& sets]\n    (letfn [(sums [s] (loop [ret-sums s\n                             curr-sum-size 2]\n                        (if (> curr-sum-size (count s))\n                          ret-sums\n                          (recur (into ret-sums (map (partial apply +) (take (count s) (partition curr-sum-size (cycle s)))))\n                                 (inc curr-sum-size)))))]\n      (not\n        (empty?\n          (reduce (fn [coll curr-set]\n                    (clojure.set/intersection coll (sums curr-set)))\n                  (sums (first sets))\n                  (rest sets))))))","user":"53fe1b42e4b0de5c418485f1"},{"problem":131,"code":"(fn [& ss] (letfn [(powerset [s] \n                   (reduce \n         \t\t          (fn  [a b]  (clojure.set/union a\n                                   (set  (map  (fn  [y]  (clojure.set/union #{b} y)) a))))\n                          #{#{}} s )\n                   )         \n  \n               (sums  [xs]  (map #(reduce + %) xs))\n\n               (sumset [xss]\n                   (map #(set (sums (map vec (remove empty? (powerset %)))) ) xss )\n                       )]\n           \n           (if (< 0 (count (reduce clojure.set/intersection (sumset (set ss)))))\n               true false\n            )\n           \n           \n          )\n )","user":"59ff9424e4b01bb0ae8afd24"},{"problem":131,"code":"(fn sum-some-subset\n  [& sets]\n  (letfn [(power-set   [s]\n            (if (zero?(count s))\n              #{#{}}\n              (let [prest (power-set (clojure.set/difference s #{(first s)}))]\n                (clojure.set/union #{#{}}\n                                   (set (map (partial clojure.set/union #{(first s)}) prest))\n                                   prest))))]\n    (not (empty? (apply clojure.set/intersection\n                 (map #(set (map (partial apply +)\n                                 (clojure.set/difference (power-set %) #{#{}})))\n                      sets))))))","user":"557e9d17e4b05c286339e0d8"},{"problem":131,"code":"(fn ssss [& sets]\n  (let [msss (fn [s] (let [[f & r] (vec s)] (reduce (fn [k i] (into k (cons i (map #(+ i %) k)))) #{f} r)))]\n    (not (nil? (first (apply clojure.set/intersection (map msss sets)))))))","user":"53e745a1e4b036ad0777e479"},{"code":"(fn [& x]\n  (letfn [(subsets [s]\n            (loop [all #{s}]\n              (let [sub (fn [x] (into #{} (map #(disj x %) x)))\n                    more (into all (mapcat sub all))]\n                (if (= more all)\n                  (disj all #{})\n                  (recur more)))))         \n          (sums [s]\n            (into #{} (map #(reduce + %) (subsets s))))]\n  (not (empty? (apply clojure.set/intersection (map sums x))))))","problem":131,"user":"500aa15ee4b03d00572d2d76"},{"problem":131,"code":"(fn [& sets]\n(letfn [(subsets [coll] \n           (disj\n             (reduce \n               (fn [a x] (into a (map #(conj % x) a)))\n               #{#{}} coll)\n             #{}))]\n  (->> sets\n    (map subsets)\n    (map #(into #{} (map (partial reduce +) %)))\n    (apply clojure.set/intersection)\n    ((complement empty?))\n  )))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":131,"code":"(fn [& ss]\n\t(letfn [(c->s [c]\n\t\t\t\t(apply str (repeat c 1)))\n\t\t\t(s->i [s]\n\t\t\t\t(Integer/parseInt s 2))\n\t\t\t(i->s [i]\n\t\t\t\t(Integer/toBinaryString i))\n\t\t\t(ps [coll]\n\t\t\t\t(let [c (count coll) s (c->s c) i (s->i s)]\n\t\t\t\t\t(loop [n i d 1 r []]\n\t\t\t\t\t\t(if (> d n)\n\t\t\t\t\t\t\tr\n\t\t\t\t\t\t\t(recur n (inc d)\n\t\t\t\t\t\t\t\t(conj r (map #((vec coll) %) (filter #(not (nil? %)) (map-indexed #(if (= %2 \\1) %1 nil) (reverse (i->s d)))))))))))]\n\t\t(not (empty? (apply clojure.set/intersection (for [s ss]\n\t\t\t(set (map #(apply + %) (ps s)))))))))","user":"561a1af6e4b053970a773b02"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(powerset [ls]\n            (reduce(fn [acc elem] (into acc (map #(+ % elem) acc))) [0] ls))]\n    (let [v (map powerset sets)\n          s (apply clojure.set/intersection (map set v))]\n      (if (= #{0} s)\n        (every? #(= 2 (count (filter zero? %))) v)\n        (not= 0 (count v))))))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn ss [ & rst]\n  (letfn [(k-combs [k s]\n           (letfn [(comb-rec [c rest root s]\n                    (if (not= c 0)\n                      (for [x (range rest (inc (- s c)))]\n                        (comb-rec (- c 1) (inc x) (conj root x) s))\n                      root))]\n            (let [v (vec s)]\n              (map (fn [x] (set (map (fn [y]  (v y)) x)))\n                   (partition k (flatten (comb-rec k 0 [] (count v))))))))\n\n          (all-combs [s]\n            (flatten (for [i (range 1 (+ 1 (count s)))]\n              (k-combs i s))))\n\n          (set-min [s]\n            (let [neg-min (apply + (filter neg? s))]\n              (if (neg? neg-min) neg-min (apply min s))))\n\n          (set-max [s]\n            (let [pos-max (apply + (filter pos? s))]\n              (if (pos? pos-max) pos-max (apply max s))))]\n          \n  (let [mn (apply max (map set-min rst))\n        mx (apply min (map set-max rst))]\n    (if (<= mn mx)\n      (let [sums (map (fn [x] (map (fn [y] (apply + y)) x)) (map all-combs (sort-by count rst)))]\n        (or (->>( for [x (first sums)] (map (fn [s] (some #{x} s))(rest sums )))(map (fn [z] (not-any? nil? z)) ) (some true?))\n          false))\n      false))))","problem":131,"user":"50783762e4b0fc74642bff67"},{"code":"(fn [& xs]\n  (let [bin (fn [n] (map (partial bit-and 1)\n                      (take-while pos? (iterate #(bit-shift-right % 1) n))))\n        binmap (fn [m s] (apply + (mapcat #(take %1 [%2]) m s)))\n        k #(range 1 (bit-shift-left 1 (count %)))\n        f #(set (map binmap (map bin (k %)) (repeat %)))]\n\n    (not (empty? (apply clojure.set/intersection (map f xs))))))","problem":131,"user":"5201572be4b0d7096e99ddbb"},{"problem":131,"code":"(fn [& args]\n  (letfn [(f [s1]\n             (if (empty? (rest s1))\n               #{(first s1)}\n               (let [a (first s1)\n                     s2 (f (rest s1))]\n                 (clojure.set/union #{a}\n                                    s2\n                                    (into #{}\n                                          (map #(+ % a) s2))))))]\n    ((complement empty?) \n     (apply clojure.set/intersection (map #(f %) args)))))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn [& a]\n  (not (empty? (apply\n    clojure.set/intersection\n    (map (fn [s]\n          (loop [r #{} n s]\n            (if (empty? n)\n              r\n              (let [x (first n)]\n                (recur (into (conj r x)\n                             (map #(+ % x)\n                                  r))\n                       (rest n))))))\n         a)))))","problem":131,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":131,"code":"(fn [& sts]\n  (let [ssets (fn [xs]\n                (loop [n (dec (count xs)) ss (set (for [x xs] #{x}))]\n                  (if (zero? n) ss\n                    (recur (dec n) (clojure.set/union ss (set (for [s ss x xs :when (not (s x))] (conj s x))))))))\n        sums (fn [ss] (set (map #(reduce + %) (ssets ss))))]\n    (not (empty? (reduce clojure.set/intersection (map sums sts))))))","user":"55c20bd0e4b0e31453f64972"},{"problem":131,"code":"(letfn\n    [(powerset [xs]\n       (reduce (fn [sets x]\n                 (->> (map #(conj % x) sets)\n                      (into sets)))\n               #{#{}} xs))\n     (subsums [xs]\n       (->> (powerset xs)\n            (#(disj %  #{}))\n            (map #(apply + %))\n            (set)))]\n  (fn f [& xs]\n    ((complement empty?)\n     (apply clojure.set/intersection (map subsums xs)))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn [& ss]\n  (letfn [(ps [s]\n            (loop [a [0] [h & t] (seq s)]\n              (if (nil? h) \n\t\t\t      (set (drop 1 a)) \n                  (recur (into a (for [x a] (+ x h))) t)  )))]\n\t((complement empty?) (reduce clojure.set/intersection (map ps ss)))))","problem":131,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":131,"code":"(fn sumc [& sets]\n   (let [all-comb (fn all-comb [one-set]\n                    (let [all (reduce (fn [m x]\n                                        (concat m (map #(conj % x) m)))\n                                      [[]]\n                                      one-set)\n                          non-empty (remove empty? all)\n                          sums (set (map #(reduce + %) non-empty))]\n                      sums))]\n     ((complement empty?) (apply clojure.set/intersection (map all-comb sets)))))","user":"56fbf83de4b07572ad1a88da"},{"problem":131,"code":"(fn sum-some-subsets\n  [& sets]\n  (let [powerset (fn [s] (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))\n        to-sums (fn [s]\n                   (into #{} (map #(apply + %) (filter (complement empty?) (powerset s)))))]\n    (not (empty? (apply clojure.set/intersection (map to-sums sets))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":131,"code":"(fn [& ss]\n (let [sums (fn sums [s]\n (let [h (first s)\n       ts (rest s)]\n  (if (empty? ts)\n   #{h}\n    (let [smd (sums ts)]\n     (clojure.set/union\n      #{h}\n      (map\n       #(+ h %)\n       smd)\n      smd)))))]\n (not\n  (empty?\n   (apply clojure.set/intersection\n    (map sums ss))))))","user":"549a999be4b0f3d1d8e70f6f"},{"code":"(fn sum-sets [& sss]\n  (letfn [(subset [ls]\n            (if (empty? ls)\n              (list #{})\n              (let [k (first ls)\n                    ks (subset (disj ls k))]\n                (concat ks (map #(conj % k) ks)))))\n          (sum-of-set [ls]\n            (set (map #(apply + %) (disj (set ls) #{}))))]\n    (not (empty?\n          (apply clojure.set/intersection\n                 (map #(sum-of-set (subset %)) sss))))))","problem":131,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn ss2 [ & xs] \n  (let [pst (fn ps ([x] (ps x #{#{}}))\n   ([l r] \n    (if (empty? l)\n      r\n    (let [step (map #(conj % (first l)) r)]\n      (ps (rest l) (set (concat r step)))))))\n\n        s (for [x xs] (set (map #(apply + %) (disj (pst x) #{}))))]\n    (not (empty? (reduce #(set (filter %1 %2)) s)))))","problem":131,"user":"4eb2eae5535d7eef30807351"},{"problem":131,"code":"(fn [& allsets]\n  (let [allsubsets\n        (fn [s]\n          (reduce \n           (fn [a b]\n             (clojure.set/union a \n                   (set (map (fn [y] (clojure.set/union #{b} y)) a))))\n           #{#{}} s))\n        xfs (fn [s] (->> s allsubsets (remove empty?) (map #(apply + %)) set))]\n    (->> allsets\n         (map xfs)\n         (apply clojure.set/intersection)\n         ((comp boolean seq)))))","user":"4e8768f6535dceadca469850"},{"problem":131,"code":"(fn [& sets]\n  (let [comb (fn comb [k l]\n               (if (= 1 k) (map vector l)\n                   (apply concat\n                          (map-indexed\n                           #(map (fn [x] (conj x %2))\n                                 (comb (dec k) (drop (inc %1) l)))\n                           l))))\n        subsets (fn subsets [s]\n                  (apply concat\n                         (for [x (range 1 (inc (count s)))]\n                           (map #(into #{} %) (comb x s)))))\n        all-sums (map (fn [s] (set (map #(apply + %) (subsets s)))) sets)]\n    (->> all-sums\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"4f0446f9535dcb61093f6bb8"},{"problem":131,"code":"(fn [& insets]\n  (letfn [(pow [s]\n            (loop [[f & r] (seq s) p '(())]\n              (if f (recur r (concat p (map (partial cons f) p)))\n                  p)))]\n    (not (empty? (apply clojure.set/intersection (map #(set (map (partial apply +) (remove empty? (pow %)))) insets))))))","user":"5f2c94b4e4b033932238a669"},{"problem":131,"code":"(fn [& x] \n  (letfn[(sset' [x] \n          (if (empty? x) '(nil)  \n            (let[x' (sset' (rest x))] \n              (concat x' (map #((fnil + 0 0) % (first x)) x')))))]\n    (not (every? nil? (reduce #(map %2 %1) (map #(set (sset' %)) x))))))","user":"58e7229fe4b056aecfd47cc4"},{"code":"(fn prob-0131\n  [s1 & more]\n\n  (let [nth-power-set (fn nth-power-set\n                        [n coll]\n                        (let [v (vec coll)\n                              cnt (count v)]\n                          (into #{} (for [i (range cnt)\n                                          :let [b (bit-shift-left 1 i)]\n                                          :when (not (zero? (bit-and n b)))]\n                                      (v i)))))\n\n        power-set (fn power-set\n                    [coll]\n                    (let [v (vec coll)]\n                      (into #{} (for [n (range (bit-shift-left 1 (count v)))]\n                                  (nth-power-set n v)))))\n\n        set-sums (fn set-sums\n                   [s]\n                   (let [ps (disj (power-set s) #{})\n                         sums (set (map #(apply + %) ps))]\n                     sums))\n\n        ]\n    \n  (if (zero? (count more))\n    true\n    (let [sets (cons s1 more)\n          set-sums (map #(set-sums %) sets)\n          val-eqs (for [v (first set-sums)]\n                    (every? #(contains? % v) (rest set-sums)))]\n      (not (not-any? true? val-eqs))))))","problem":131,"user":"4f047c07535dcb61093f6bcd"},{"problem":131,"code":"(fn [& sets]\n    (letfn [(subsets [one-set]\n              (if (> (count one-set) 0)\n                (let [f       (first one-set)\n                      rem     (disj one-set f)\n                      remsubs (subsets rem)]\n                  (clojure.set/union remsubs (set (map #(conj % f) remsubs))))\n                #{#{}}))\n            (non-empty-subsets-of-one-set [one-set]\n              (let [filtered-subsets (filter #(> (count %) 0) (subsets one-set))]\n                filtered-subsets))\n            (different-sums-of-one-set [one-set]\n              (set (map #(apply + %) (non-empty-subsets-of-one-set one-set))))\n            (same-sums-in-set-seq [set-seq]\n              (apply clojure.set/intersection (map different-sums-of-one-set set-seq)))]\n      (> (count (same-sums-in-set-seq sets)) 0)))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [& n]\n  (let [pset (fn [s] (reduce (fn [ss x] (concat ss (map #(conj % x) ss))) [#{}] s))\n        sums (fn [s] (filter identity (map #(if (seq %) (reduce + %)) (pset s))))\n        groups (apply (partial merge-with concat) (map #(zipmap (sums %) (repeat [%])) n))]\n    (pos? (count (filter #(= (count %) (count n)) (vals groups))))))","problem":131,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":131,"code":"(fn [& sets]\n   (not (empty? (apply clojure.set/intersection\n                    (for [s sets]\n                      (set\n                      (map\n                       (fn [sums] (reduce + sums))\n                       (filter #(not (empty? %))\n                      (reduce (fn [sums next] (clojure.set/union\n                                                sums\n                                                (set (map #(conj % next) sums))))\n                              #{#{}} s))\n                     \n                      )))))))","user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [& ss]\n  (let [power-set (fn [s]\n                    (loop [result #{#{}}]\n                      (let [next (into result\n                                       (apply concat\n                                              (map (fn [x] (map #(conj x %) s))\n                                                   result)))]\n                        (if (= next result)\n                          (disj result #{})\n                          (recur next)))))\n        subset-sums (map (fn [x] (into #{} (map #(apply + %) x)))\n                         (map power-set ss))\n        shared (apply clojure.set/intersection subset-sums)]\n    (> (count shared) 0)))","problem":131,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(fn [& ss]\n  (let [f (fn [s]\n            (loop [s s\n                   a #{#{}}]\n              (if (empty? s)\n                (filter #(not (zero? (count %))) a)\n                (recur (rest s) (into a (map #(conj % (first s)) a))))))\n        g (fn [p]\n            (set (map #(apply + %) p)))]\n    (not (empty? (apply clojure.set/intersection\n           (map (comp g f) ss))))))","problem":131,"user":"52753740e4b03e8d9a4a74c1"},{"problem":131,"code":"(fn ssss [& v]\n  (let [enumerate (fn [s]\n                    (let [items (vec s)]\n                      (into #{}\n                        (for [n (range 1 (bit-shift-left 1 (count items)))]\n                          (apply +\n                                 (map items (filter #(bit-test n %) (range (count items)))))))))]\n((complement empty?)  (apply clojure.set/intersection (map enumerate v)))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn __ [& args]\n  (letfn [(power-set [trgt-st]\n            (letfn [(break-up [s] (map #(disj s %) s))\n                    (next-line [s] (set (mapcat break-up s)))]\n              (loop [st #{trgt-st} pwr-st #{trgt-st}]\n                (if (= st #{#{}}) pwr-st\n                  (recur (next-line st) (apply conj pwr-st (next-line st)))))))]\n    (let [[first-sum & rest-sums] (->> (map power-set args)\n                                       (map #(remove empty? %))\n                                       (map (fn [s] (map #(apply + %) s))) ; pretty ugly\n                                       (map #(into #{} %)))]\n      (if-let [result (some (fn [v] (every? #(contains? % v) rest-sums)) first-sum)]\n        result\n        false))))","problem":131,"user":"52463059e4b09dbe66b56198"},{"code":"(fn common [& x] (letfn [\n    (subset-sums [s] (if (= 1 (count s)) (set s) (let [\n        s1 (first s)\n        ssn (subset-sums (next s))\n        ss1 (map (partial + s1) ssn)]\n        (set (concat ssn ss1 [s1])))))]\n    (boolean (seq (apply clojure.set/intersection (map subset-sums x))))))","problem":131,"user":"51cbdee1e4b08d8387cbede1"},{"problem":131,"code":"(fn [& colls]\n   (letfn [(power [x]\n             (if (seq x)\n               (let [head (first x)\n                     others (power (disj x head))]        \n                 (clojure.set/union\n                  others\n                  (map #(conj % head) others)))\n               #{#{}}))\n           (sums [x]\n             (map #(apply + %) (filter seq (power x))))]\n     (->> colls\n          (map sums)\n          (map set)\n          (apply clojure.set/intersection)\n          (#(> (count %) 0)))))","user":"53ed6976e4b0d648e757f4c4"},{"code":"(fn [& sets]\n  (letfn [(sums [s] (set (map #(reduce + %) s)))\n          (power-set\n            ([s] (power-set s #{#{}}))\n            ([s sums]\n               (if (empty? s)\n                 sums\n                 (let [f (first s)\n                       p (power-set (disj s f) sums)]\n                   (into p (map #(conj % f) p))))))]\n    (->> sets\n         (map power-set)\n         (map #(disj % #{}))\n         (map sums)\n         (apply clojure.set/intersection)\n         empty?\n         not)))","problem":131,"user":"510db6cde4b078ea71921145"},{"problem":131,"code":"(fn [& sets]\n    (let [\n          powerset\n          (fn powerset [s]\n            (if (empty? s)\n              #{#{}}\n              (apply\n               clojure.set/union\n               (for [sub (powerset (rest s))]\n                 #{sub (conj sub (first s))})\n               )\n              )\n            )\n\n          powersets\n          (for [s sets]\n            (filter #(not (empty? %)) (powerset s)))\n\n          subsums\n          (for [pss powersets]\n            (set\n             (for [ps pss]\n               (apply + ps))))\n          ]\n\n      (not (empty? (apply clojure.set/intersection subsums)))\n      )\n    )","user":"5f06caa7e4b0cf489e8d7f52"},{"problem":131,"code":"(fn four-c-131 [& args]\n  (let [sub-sets (fn sub-sets [s]\n                   (loop [acc '(())\n                          s (seq s)]\n                     (if (seq s)\n                       (let [ns (map #(conj % (first s)) (seq acc))]\n                         (recur (concat acc ns) (rest s)))\n                       (let [acc (filter #(not= 0 (count %)) acc)]\n                         (into #{} (map #(reduce + %)  acc))))))\n        multiple-sub-sets (fn multiple-sub-sets [args]\n                            (if (seq args)\n                              (map #(sub-sets %) args)))]\n    (->> (multiple-sub-sets args)\n         (apply clojure.set/intersection)\n         (count)\n         (< 0))))","user":"56f4cedce4b046a417f92063"},{"code":"(fn [& S]\n  (not\n   (empty?\n    (reduce clojure.set/intersection\n            (map\n             (fn [s] (reduce\n                      conj #{}\n                      (map (partial reduce +)\n                           (filter not-empty\n                            ((fn P [S]\n                               (if (empty? S) #{#{}}\n                                   (let [F (fn [e T] (set (map #(conj % e) T)))\n                                         e (first S)\n                                         T (disj S e)\n                                         PT (P T)]\n                                     (set\n                                      (concat\n                                       PT\n                                       (F e PT)))))) s)))))\n             S)))))","problem":131,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn [& sets]\n  (letfn [(powerset [s] (reduce (fn [sets el] (into sets (map #(conj % el) sets))) #{#{}} s))\n          (not-empty? [s] ((comp not empty?) s))\n          (nontriv [s] (filter not-empty? (powerset s)))\n          (sumset [s] (into #{} (map (partial apply +) (nontriv s))))]\n    (not-empty? (apply clojure.set/intersection (map sumset sets)))))","problem":131,"user":"4ffc10aae4b0678c553fc3d6"},{"code":"(fn [& ss] (->> (map #(reduce (fn [ps s]\n\t\t\t\t       (reduce\n\t\t\t\t\t(fn [ps x]\n\t\t\t\t\t  (conj ps (conj x s)))\n\t\t\t\t\tps ps)) #{#{}} %) ss)\n\t\t       (map #(filter (complement empty?) %))\n\t\t       (map (fn [s] (set (map #(apply + %) s))))\n\t\t       (apply clojure.set/intersection)\n\t\t       (not= #{})))","problem":131,"user":"4ef9c8f9535dced4c769f26b"},{"problem":131,"code":"(fn problem-103 [& sets]\n  (let [comb (fn [xs] (reduce (fn [ys y] (concat ys (map (partial cons y) ys))) [[]] xs))] \n    (->> sets \n      (map #(rest (comb %)))\n      (map #(set (map (fn [x] (reduce + 0 x)) %)))\n      (apply clojure.set/intersection)\n      (empty?)\n      (not))))","user":"55645592e4b0c656e3ff1802"},{"problem":131,"code":"(fn sumsets [& ss]\n  (letfn [(powerset [coll]\n            (reduce (fn [a x]\n                      (->> a\n                           (map #(set (concat #{x} %)))\n                           (concat a)\n                           set))\n                    #{#{}} coll))]\n    (->> ss\n         (map powerset)\n         (map (partial filter (partial not= #{})))\n         (map (comp set (partial map (partial apply +))))\n         (apply clojure.set/intersection)\n         empty?\n         not))\n  )","user":"572ea970e4b0cd1946bd0f89"},{"problem":131,"code":"(fn zero-sum-set\n  [& args]\n  (loop [subsets (fn [aset] (reduce #(into %1 (map conj %1 (repeat %2))) #{#{}} aset))\n        sum-subsets (fn [asetofset] (filter #(not (nil? %)) \n                                            (map #(if (not (empty? %)) (apply + %)) asetofset)))\n        [x & xs :as alls] args\n        res []]\n    (cond\n      (empty? alls) (not (empty? (apply clojure.set/intersection res)))\n      :else (recur subsets sum-subsets xs\n                   (conj res (into #{} (sum-subsets (subsets x))))))))","user":"550d9452e4b06e50f9beb15d"},{"problem":131,"code":"(fn [& sets]\n  (letfn [(subsets [s]\n            (reduce (fn [sets x]\n                      (into sets (map #(conj % x) sets)))\n                    #{#{}} s))\n          (sum-subsets [s]\n            (set\n             (for [subset (subsets s)\n                   :when (not-empty subset)]\n               (apply + subset))))]\n    (->> (map #(sum-subsets %) sets)\n         (apply clojure.set/intersection)\n         empty?\n         not)))","user":"5c3796b3e4b0d62ef62d9f77"},{"problem":131,"code":"(fn [& s]\n   (letfn [(ps [s] (reduce (fn [r x] (into r (map #(conj % x) r))) #{#{}} s))\n           (sums [s] (set (map (partial apply +) (remove empty? (ps s)))))]\n      (->> (map sums s)\n           (apply clojure.set/intersection)\n           empty?\n           not)))","user":"59f043d0e4b0966464fe6a3d"},{"problem":131,"code":"(fn [& S]\n     (let [p (fn p [s] \n                 (if (seq s) (set (mapcat #(vector % (conj % (first s))) \n                                          (p (rest s))))\n                     #{#{}}))\n           g (fn [s] (->> (p s)\n                          (#(disj % #{}))\n                          (map (partial apply +))\n                          (set)))\n          ]\n      (->> S\n           (map g) (apply clojure.set/intersection) (seq) (boolean))))","user":"559c13c5e4b066d22e731f61"},{"code":"(fn common-sum? [& ss]\n  (letfn [(power-set [s]\n            (set\n             (filter #(not= #{} %)\n                     (loop [ret #{#{}}\n                            left s]\n                       (if (empty? left)\n                         ret\n                         (recur (concat (map #(conj % (first left)) ret)\n                                        ret)\n                                (rest left)))))))]\n    (not (empty? \n          (reduce clojure.set/intersection\n                  (map (fn [pset]\n                         (set (map #(reduce + %) pset)))\n                       (map power-set ss)))))))","problem":131,"user":"512eb723e4b0b740abc5982b"},{"problem":131,"code":"(fn foo [& ss]\n  (letfn [(sums-in [s]\n            (let [v (vec s) c (count v)]\n              (if (= c 1)\n                #{(v 0)}\n                (let [r (sums-in (subvec v 1 c))]\n                  (into\n                    (reduce #(conj %1 (+ %2 (v 0))) #{(v 0)} r) r)))))]\n    (not (empty? (apply clojure.set/intersection\n                        (map sums-in ss))))))","user":"56a01895e4b0542e1f8d149f"},{"problem":131,"code":"(fn [& x] (letfn [\n(ps [s]\n      (let [ac (vec s), sz (count ac), cnt (bit-shift-left 1 sz)]\n           (into #{} (for [x (range cnt)] (loop [y 0, a #{}] (if (= y sz) a (recur (inc y) (if (bit-test x y) (conj a (nth ac y)) a ) )))))\n           )\n      )\n(nes [col] (keep #(not-empty %1) (ps col)))\n(ss [col] (into #{} (map #(reduce + %1) col)))\n(fcs [sm](reduce #(filter (set %1) %2) (first sm) (rest sm)))]\n(if (= 1 (count x)) true (->> (map nes x) (map ss) fcs count pos?))))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn sum-some-subsets [ & cols ]\n  (letfn [\n    (k-combis [s]\n      (if (empty? s)\n         #{#{}}\n         (let [x (set (list (first s))) \n               dx (clojure.set/difference s x) \n               t (k-combis dx)]\n               (clojure.set/union t \n             (map (partial into x) t)))))]\n         (->>\n           (map k-combis (set cols))\n           (map #(filter not-empty %))\n           (map #(map (fn [x] (reduce + x)) %) ) \n           (map set)\n           (apply clojure.set/intersection )\n           (not= #{})\n           )\n         ))","problem":131,"user":"4fccdc75e4b0ee37620e186d"},{"problem":131,"code":"(fn [& y] (not (empty? (apply clojure.set/intersection \n                              (map (fn [x] (reduce (fn [s e] (clojure.set/union (conj s e) \n                                                                                (map #(+ % e) s)))\n                                                   #{} x))\n                                   y)))))","user":"576e3258e4b0979f89651574"},{"code":"(fn f [& ls]\n  (not (empty? (reduce \n    (fn inter [s1 s2] \n      (set (for [e1 s1 e2 s2 :when (= e1 e2)] e1))\n    )\n    (map\n      (fn ps [s]\n        (set (map #(apply + %) (filter #(not= #{} %) (reduce (fn ps [s elt]\n          (reduce conj s (map #(conj % elt) s))\n          ) #{#{}}\n        s))))\n      )\n      ls\n    )\n  )))\n)","problem":131,"user":"4f84400de4b033992c121c2e"},{"code":"(fn sum-sub [ & sets]\n  (letfn \n    [(combs [s] \n            (reduce (fn [ps x]\n                      (into ps (map #(conj % x) ps)))\n                      #{#{}}\n                      s))\n     (sum-sos [s] (into #{} \n                   (map \n                    #(apply + %)\n                    (disj (combs s) #{}))))]\n    (->> (map sum-sos sets)\n         (apply clojure.set/intersection)\n         (count)\n         (< 0))))","problem":131,"user":"50217818e4b00bba4502f7a7"},{"problem":131,"code":"(fn [& args]\n  (letfn [(power-set [s] (clojure.set/difference (reduce (fn [r e] (into r (map #(conj % e) r))) #{#{}} s) #{#{}}))]\n    (not (empty? (apply clojure.set/intersection (map #(set (map (partial reduce +) %)) (map power-set args)))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"#(let [l %&\n       l (map (fn f [c]\n                (cond\n                 (empty? c) [0]\n                 :else (concat (f (rest c)) (map (partial + (first c)) (f (rest c))))))\n              l)\n       l (map set (map rest l))]\n   (not (empty? (apply clojure.set/intersection l))))","problem":131,"user":"50a83315e4b054305ba5a830"},{"problem":131,"code":"(fn [& s]\n  (let [p (fn powerset [s] \n            (if (empty? s)\n              '(())\n              (concat (powerset (rest s))\n                                 (map #(conj % (first s)) (powerset (rest s))))))\n        ss (fn [s2] (loop [tmp (set (map set (p s2))) ans #{}]\n                            (if (empty? tmp)\n                              ans\n                              (if (empty? (first tmp))\n                                (recur (rest tmp) ans)\n                                (recur (rest tmp) (set (conj ans (reduce + (first tmp)))))))))]\n    (loop [tmp (rest s) a (ss (first s))]\n      (if (empty? tmp)\n        (if (not= 0 (count a))\n          true\n          false)\n        (recur (rest tmp) (clojure.set/intersection a (ss (first tmp))))))))","user":"59368ccae4b02506e01a297a"},{"code":"(fn [& s]\n    (let [ get-sums (fn [s]\n                          (reduce \n                              #(set (concat % (conj (map (fn [x] (+ x %2)) %) %2)))\n                              #{(first s)}\n                              (rest s))) ]\n        (< 0 (count (apply clojure.set/intersection (map get-sums s))))))","problem":131,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn giper-sum [& giper]\n  (letfn [(final-set [stt]\n                     (letfn [(lo [x len]\n                                 (str (reduce str (repeat (- len (count x)) \"0\")) x))\n                             (jay [v sr]\n                                  (into #{} (filter identity (map #(if (= \\0 %2)\n                                                                     nil\n                                                                     %) v (seq sr)))))]\n                            (let [st (into [] stt)\n                                  co (count st)\n                                  all (for [i (range (int (Math/pow 2 co)))]\n                                        (Integer/toString i 2))\n                                  ready (map #(lo % co) all)]\n                              (into #{} (map (partial jay st) ready)))))  \n          (sums [stt]\n                (into #{} (map #(reduce + %) (clojure.set/difference (final-set stt) #{#{}}))))]\n         (not (empty? (reduce clojure.set/intersection (map sums giper))))))","problem":131,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn same-subset [& args]\n        (letfn [(subset [n s]\n                  (loop [n n a #{#{}}]\n                    (if (> n 0)\n                      (recur (dec n) (set (for [x a y s :when (not (x y))]\n                                            (conj x y))))\n                      a)))\n                (lazy-all [c]\n                  (if (some empty? c)\n                    false\n                    (if (apply = (map first c))\n                      true\n                      (let [[a & b] (sort-by first c)]\n                        (recur (cons (rest a) b))))))\n                (gen-set [s] (mapcat #(subset (inc %) s)\n                                     (range (count s))))]\n          (let [sets nil]\n            (lazy-all (map (fn [s] (sort < (map #(reduce + %)\n                                                (gen-set s))))\n                           args)))))","problem":131,"user":"4f031eac535dcb61093f6a67"},{"problem":131,"code":"(fn\n  [s & sets]\n  (letfn [(tails [s]\n            (set (map #(do #{%}) s)))\n          (subsets [result previous-step ts]\n            (if (>= 1 (count previous-step))\n              result\n              (let [next-step (->> previous-step\n                                   (mapcat #(keep (fn [t] (when-not (get % t) (conj % t))) ts))\n                                   set)]\n                (subsets (clojure.set/union result next-step) next-step ts))))\n          (create-all-subsets [s]\n            (let [ts (tails s)]\n              (subsets ts ts s)))\n          (sum-subsets [sub-sets] (map #(reduce + %) sub-sets))\n          (has-subset-with-sum [s n]\n            (->> (create-all-subsets s)\n                 sum-subsets\n                 (some #(= % n))))\n          (all-sets-have-subset-with-sum [sets n]\n            (every? #(has-subset-with-sum % n) sets))]\n    (->> (create-all-subsets s)\n         sum-subsets\n         (some #(all-sets-have-subset-with-sum sets %))\n         boolean)))","user":"5125029de4b0ce9225d2ed3e"},{"problem":131,"code":"(fn sum-some-subsets\n  [& xss]\n  (letfn [(power-set\n            [S]\n            (letfn [(num->mask [n k]\n                      (let [proto-mask (map #(= \\1 %) (Integer/toBinaryString n))]\n                        (concat (repeat (- k (count proto-mask)) false)\n                                proto-mask)))]\n              (let [n (int (Math/pow 2 (count S)))]\n                (conj\n                 (set\n                  (map (fn [k] (set (filter\n                                     #(not (nil? %))\n                                     (map (fn [e m] (if m e)) S\n                                          (num->mask k (count S))))))\n                       (range 1 n)))\n                 #{}))))]\n    (not (empty?\n          (reduce (fn [accum s] (clojure.set/intersection accum s))\n                  (map (fn [xs] (set (map (fn [s] (reduce + s))\n                                          (filter (fn [s] (not= s #{}))\n                                                  (power-set xs)))))\n                       xss))))))","user":"5c222b7de4b07e362c230588"},{"problem":131,"code":"(let [bits->indices (fn [n]\n                       (loop [x n, acc [], i 0]\n                         (if (zero? x)\n                           acc\n                           (let [q (quot x 2)\n                                 r (rem x 2)\n                                 acc' (if (= 1 r) (conj acc i) acc)]\n                             (recur q acc' (inc i))))))\n       power-set (fn [u]\n                   (let [n (apply *' (repeat (count u) 2))\n                         v (vec u)]\n                     (->> (for [b (range n)]\n                            (let [idxs (bits->indices b)]\n                              (->> (map (partial nth v) idxs)\n                                   (into #{}))))\n                          (into #{}))))\n       f (fn [& the-sets]\n           (->> (for [a-set the-sets]\n                  (->> a-set\n                       power-set\n                       (remove empty?)\n                       (map (partial reduce +' 0))\n                       (into #{})))\n                (apply clojure.set/intersection)\n                ((complement empty?))))]\n   f)","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [f & s]\n  (not= #{} (apply clojure.set/intersection\n                  (for [e s] (set (map #(apply + %) (f e)))))))\n      \n#(disj (reduce (fn [x y]\n           (into x (for [a %\n                         b x]\n                     (disj b a)))) \n         #{%}\n         %) #{})","problem":131,"user":"4e823ed7535db62dc21a62c7"},{"problem":131,"code":"(fn [& coll]\n  (letfn [(power-set [s]\n            (letfn [(f [acc a] (into acc (map #(conj % a) acc)))]\n              (reduce f #{#{}} s)))]\n    (->>  (map power-set coll)\n          (map (partial filter #(not= % #{})))\n          (map (partial map #(apply + %)))\n          (map set)\n          (apply clojure.set/intersection)\n          ((complement empty?)))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(letfn [(sums [s] \n          (if (empty? s)\n            #{}\n            (let [f (first s)\n                  ms (sums (rest s))]\n              (into (conj ms f)\n                (map #(+ f %) ms)))))]\n    #(pos?\n      (count\n        (apply clojure.set/intersection\n          (map sums %&)))))","problem":131,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [& sets]\n   (let [subsets (fn [s]\n                   (remove empty?(reduce (fn [a x] (into a (map #(conj % x) a)) ) #{#{}} s)))\n         subs (map subsets sets)\n         sums (map (fn [s] (set (map #(apply + %) s))) subs)\n         common (apply clojure.set/intersection sums)\n         ]\n     (not \n      (empty? \n       common)))\n )","problem":131,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":131,"code":"(fn [& sets]\n  (let [p-set (fn [ss] (->> (map (fn [v] #(->> v (conj %2) (conj %1))) ss)\n                            (reduce #(reduce %2 %1 %1) #{#{}})))]\n    (->> (map p-set sets)\n         (map #(disj % #{}))\n         (map #(map (partial apply +) %))\n         (map set)\n         (apply clojure.set/intersection)\n         (empty?) (not))))","user":"567d132ee4b05957ce8c61c3"},{"code":"(fn [& v] (not (empty? (apply clojure.set/intersection \r\n (map (fn [s] (reduce #(conj (reduce (fn [z a]\r\n   (conj z (+ %2 a))) % %) %2) #{} s)) v)))))","problem":131,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":131,"code":"(letfn [(powerset [S]\r\n           (if (empty? S) #{#{}}\r\n               (reduce #(into %1\r\n                              #{%2 (into %2 #{(first S)})})\r\n                       #{} (powerset (rest S)))))\r\n\r\n        (powersums [S]\r\n          (sort (map (partial apply +)\r\n                     (remove empty? (powerset S)))))\r\n\r\n        (sumthing [& colls]\r\n          (loop [colls (map powersums colls)]\r\n            (if (some empty? colls) false\r\n                (let [firsts    (map first colls)\r\n                      max-first (apply max firsts)]\r\n                  (if (apply = firsts) true\r\n                      (recur (map (partial drop-while (partial > max-first))\r\n                                  colls)))))))]\r\n  sumthing)","user":"55d0e76ae4b0e31453f64a40"},{"problem":131,"code":"(fn [& ss]\n  (let [power-set (fn [s] (reduce #(into %1 (map conj %1 (repeat %2))) #{#{}} s))]\n    (not\n     (empty?\n      (apply clojure.set/intersection\n       (map\n        (comp set\n              (fn [s'] (map #(reduce + %) s'))\n              (fn [s'] (remove empty? s'))\n              power-set)\n        ss))))))","user":"56481722e4b0284900eef628"},{"code":"(fn [& xs]\n  (letfn [(subsets [xs]\n            (if (empty? xs)\n              #{#{}}\n              (let [ss (subsets (rest xs))]\n                (into ss (map #(conj % (first xs)) (subsets (rest xs)))))))\n          (subset-sums [xs]\n            (into #{} (map #(reduce + %) (remove empty? (subsets xs)))))]\n    (boolean (not-empty (reduce clojure.set/intersection (map subset-sums xs))))))","problem":131,"user":"4e50b67b535dc968683fc4ed"},{"code":"(fn sum-some [& sets]\n  (let [comb (fn [cs s] (if (seq cs) \n                          (set (for [c cs e s :when (not (c e))] (conj c e)))\n                          (set (for [e s] (hash-set e)))))\n        sums (fn sums ([s] (sums #{} s #{})) \n               ([cs s ret] (let [ncs (comb cs s)]\n                             (cond (empty? ncs) (set (map (partial reduce +) ret))\n                                   :else (recur ncs s (into ret ncs))))))]\n    (boolean (seq (apply clojure.set/intersection (map sums sets))))))","problem":131,"user":"5246e945e4b0644eb7b0783b"},{"problem":131,"code":"(fn [& s]\r\n  (letfn [(powerset [ls]\r\n            (if (empty? ls)\r\n              #{#{}}\r\n              (let [p (powerset (next ls))]\r\n                (clojure.set/union p (map #(conj % (first ls)) p)))))]\r\n    (not (empty? (apply clojure.set/intersection\r\n                        (map #(set (map (partial reduce +) (disj (powerset %) #{}))) s))))))","user":"5f2c02d1e4b033932238a65f"},{"problem":131,"code":"(fn [& sets-to-consider]\n  (letfn [(subset-summations [s]\n            (set (map #(apply + %) \n                      (set (apply concat \n                                  (vals (loop [acc {(count s) #{s}}\n                                               c (dec (count s))]\n                                          (if (= c 0)\n                                            acc\n                                            (recur (conj acc\n                                                         [c (set (mapcat #(map (partial disj %) \n                                                                               %)\n                                                                         (acc (inc c))))])\n                                                   (dec c))))))))))]\n    (not (empty? (apply clojure.set/intersection (map subset-summations sets-to-consider))))))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn[& v]\n  (letfn [(f[s]\n     (set\n\t (concat (conj s (reduce + s))\n      (for [x (range (dec (count s))) :let [y (drop x s)]\n            u y :let [w (remove #{u} y)]]\n         (reduce + w)))))]\n    ((complement empty?)\n    (apply clojure.set/intersection\n    (for [x v]\n      (f x))))))","problem":131,"user":"52f818a6e4b047fd55836fcc"},{"problem":131,"code":"(fn [& sets]\n (not (empty? (apply clojure.set/intersection \n  (map \n   (fn [s]\n    (into #{}\n     (for [x (range 1 (Math/pow 2 (count s)))]\n      (reduce + \n       (keep-indexed #(if (bit-test x %1) %2) s)))))\n   sets)))))","user":"56b86e64e4b0f26550335924"},{"code":"(fn [& sets]\n    (let [subset-fn (fn subset-fn [elems]\n                      (if (empty? elems)\n                        #{#{}}\n                        (let [elem (first elems)\n                              subsets (subset-fn (rest elems))]\n                          (into #{} (concat subsets\n                                            (map #(conj % elem)  subsets))))))\n          subset-sum-set-fn (fn [subsets]\n                              (into #{} (map #(reduce + 0 %) subsets)))\n          set-subsets-seq (map (comp #(disj % #{}) subset-fn) sets)\n          subset-sum-seq (map subset-sum-set-fn set-subsets-seq)]\n      (boolean (not (empty? (apply clojure.set/intersection subset-sum-seq))))))","problem":131,"user":"51281b25e4b03a34742b4304"},{"problem":131,"code":"(fn sum-some-set-subsets [& sets]\n  (let [power-set (fn power-set [s]\n                    (if (empty? s)\n                      #{#{}}\n                      (let [small (power-set (rest s))\n                            other (for [ss small] (conj ss (first s)))]\n                        (set (concat small other)))))\n        sum-sets (for [s sets]\n                   (set (map (partial apply +) (filter #(seq %) (power-set s)))))]\n    (boolean\n      (or (= 1 (count sets))\n          (some true? (for [x (first sum-sets)]\n                        (every? #(% x) (rest sum-sets))))))))","user":"56ac81ace4b03c432f187347"}]