[{"problem":50,"code":"(fn [c]\n   (vals (group-by class c)))","user":"56990b68e4b0542e1f8d143a"},{"code":"(fn [input]\n  (loop [l input m {}]\n    (if (empty? l)\n      (set (vals m))\n      (let [f (first l) \n            r (rest l)\n            e (m (type f))\n            x (if (nil? e) \n                [(type f) [f]]  \n                [(type f) (conj e f)])]\n        (recur r (conj m x))))))","problem":50,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn [x] (vals(group-by type x)))","problem":50,"user":"4f00f997535dcb61093f6a34"},{"code":"(fn [l]\n  (vals (group-by type l)))","problem":50,"user":"4e568873535d8a8b8723a283"},{"problem":50,"code":"(fn [col]\n  (loop [typeset (set (map type col)) result [] ]\n    (if (empty? typeset)\n      result\n      (recur (rest typeset) (conj result (filter #(= (type %) (first typeset)) col)))\n    )\n  )\n)","user":"57e396cde4b0bfb2137f5a9e"},{"problem":50,"code":"(fn [coll] (apply hash-set (map #(second %) (group-by class coll))))","user":"55079e55e4b021ccfedb96aa"},{"code":"#((comp set vals) (group-by type %))","problem":50,"user":"5271b940e4b03e8d9a4a73fb"},{"code":"(fn [xs] (set (map (fn [t] (filter #(= (type %) t) xs)) (distinct (map type xs)))))","problem":50,"user":"51307b84e4b08c712d3fae39"},{"problem":50,"code":"(fn split-by-type [coll]\n  (partition-by type (sort-by #(str (type %)) coll)))","user":"5d7aa22ee4b02e6b30c9354e"},{"problem":50,"code":"(fn [s] (map #(nth % 1) (group-by type s)))","user":"5da71eaee4b000c986472c15"},{"code":"(fn [a]\n  (-> (group-by type a) vals set))","problem":50,"user":"52213426e4b0e6a83c8925c4"},{"problem":50,"code":"(fn separate [coll]\n  (for [[_ ret] (group-by class coll)]\n    ret))","user":"55b69e37e4b01b9910ae2999"},{"problem":50,"code":"(fn [xs]\n  (vals\n   (reduce\n    (fn [acc item]\n      (let [k (type item)]\n        (assoc acc k (conj (or (get acc k) []) item))))\n    {}\n    xs)))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":50,"code":"(fn spt [coll]\n  (->>\n    coll\n   (group-by type)\n   (vals)\n   (set)))","user":"5bc28638e4b07a9b28b10033"},{"problem":50,"code":"(fn group-by-type [coll]\n  (vals (group-by type coll)))","user":"5383668ee4b06839e8705edd"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      (vals))","user":"56669819e4b0e91d5f5c5674"},{"problem":50,"code":"(fn[l] \n  (map reverse\n       (vals\n         (loop [l (apply list l) nl {}]\n           (if-not (seq l)\n             nl\n             (recur (pop l) (assoc nl (type (first l)) (conj (nl (type (first l))) (first l))))\n             )\n           ) \n         ) \n       ) \n  )","user":"54b90836e4b0ed20f4ff6e9d"},{"problem":50,"code":"(fn [coll]\n  (loop [c coll m {}]\n    (if (empty? c) (vals m)\n      (recur (rest c)\n       (let [v (first c) t (type v)]\n        (assoc m t\n          (conj (get m t []) v)\n        )\n       )\n      )\n    )\n  )\n)","user":"5a424954e4b0447ef91cc5f0"},{"code":"(fn splitbytype [coll]\r\n  (vals (group-by type coll)))","problem":50,"user":"4e123905535d04ed9115e7ce"},{"problem":50,"code":"(fn [ltype] \n  (loop [col ltype out []]\n    (let [\n          eqtype? #(= (type (first col)) (type %))\n          neqtype? #(not (eqtype? %))\n          group (filter eqtype? col)\n          restgrp (filter neqtype? col)\n          newout (conj out group)\n          ]\n      (if (empty? restgrp)\n        newout\n        (recur restgrp newout)\n        )\n      )\n    )\n  )","user":"574986cae4b009280f9f2b9c"},{"problem":50,"code":"(fn [xs]\n   (into #{} (vals (group-by type xs))))","user":"52b89d55e4b07a9af57922b3"},{"problem":50,"code":"(fn [coll] \n  (let [types (set (map type coll))]\n    (map (fn [t] (filter #(= t (type %)) coll))\n         types)))","user":"5561d2c2e4b0c656e3ff17cd"},{"problem":50,"code":"(fn\n  [vs]\n  (let [tinfo (reduce\n                (fn [a v]\n                  (let [t (type v)]\n                    (if (get a t)\n                      (assoc a t (conj (get a t) v))\n                      (assoc a t [v]))))\n                {}\n                vs)]\n    (into #{} (map second tinfo))))","user":"53161a56e4b08068f379ed3e"},{"code":"(fn [coll]\n  (filter (complement empty?)\n          (list (filter sequential? coll) \n           \t\t(filter number? coll)\n                (filter keyword? coll)\n                (filter string? coll))))","problem":50,"user":"5361a4f2e4b0243289761e47"},{"code":"(fn split-by-type [s]\n  (loop [tm {}\n         remain s]\n     (if (empty? remain) (set (vals tm))\n        (let [nextelt (first remain)\n              nexttype (class nextelt)\n              typevec (vec (tm nexttype))\n              newtypevec (conj typevec nextelt)]\n          (recur (assoc tm nexttype newtypevec)\n                 (rest remain))))))","problem":50,"user":"4f036fb3535dcb61093f6ac8"},{"problem":50,"code":"#(->> (group-by type %) (map second))","user":"5e8ce2fee4b0cb0169546328"},{"problem":50,"code":"(fn [s]\n  (map #(nth % 1) (group-by type s)))","user":"53f77b6ae4b0de5c4184855f"},{"problem":50,"code":"(fn [S] (vals (group-by type S)))","user":"55f6fe09e4b06e875b46cea2"},{"problem":50,"code":"(fn [s]\n  (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} s)))","user":"565a3e25e4b068f2fe63dbfb"},{"problem":50,"code":"(fn [coll] (for [[k v] (group-by #(type %) coll)] v))","user":"58637221e4b0f14aab7c881d"},{"problem":50,"code":"(fn\n  [col]\n  (->>\n    [keyword? number? string? vector?]\n    (map #(filter % col))\n    (filter not-empty)\n    (map #(apply vector %))))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":50,"code":"(fn [seq]\n    ((fn [s acc]\n      (if (empty? s)\n        (vals acc)\n        (let [cur (first s)\n              k (type cur)\n              v (get acc k [])]\n          (recur (rest s) (assoc acc k (conj v cur)))\n        )\n      )\n      ) seq {})\n    )","user":"5681afaae4b0945ebc182a87"},{"code":"(fn [coll] (let [f #(str (type %))] (partition-by f (sort-by f coll))))","problem":50,"user":"5092fe10e4b097f48cc3857e"},{"problem":50,"code":"#(vals (reduce\n  (fn [r x]\n    (into r (hash-map (type x) (conj (get r (type x) []) x)))) {} %))","user":"53e4fa2ce4b036ad0777e454"},{"code":"(fn [c]\n    (distinct (for [t (map #(type %) c)]\n      (filter #(= (type %) t) c))))","problem":50,"user":"4f9920a3e4b0dcca54ed6cfc"},{"code":"(fn [x]\n (let [atypes (set (map #(type %) x))]\n  (for [atype atypes]\n   (vec (filter #(not= % nil) (for [el x]\n    (if (= (type el) atype)\n    \tel)))))))","problem":50,"user":"52747090e4b03e8d9a4a74a5"},{"problem":50,"code":"(fn split-by-type [v]\n  (reduce\n   #(if-let [found \n          (first \n           (filter \n            (fn [sub-array] \n              (= \n               (type %2) \n               (type (first sub-array)))) \n            %1))] \n      (conj (disj %1 found) (conj found %2))\n      (conj %1 [%2]))\n   #{}\n   v))","user":"5ed52854e4b016b56eae05d2"},{"problem":50,"code":"(fn [coll]\n  (let [types (distinct (map #(type %) coll))\n        result (reduce (fn [acc curr] (assoc acc curr [])) {} types)]\n    (vals (reduce (fn [acc curr] (assoc acc (type curr) (conj (get acc (type curr)) curr))) result coll))))","user":"5fac50f4e4b08cb800c85ae5"},{"problem":50,"code":"(fn\n  [coll]\n  (vals\n   (reduce (fn [acc x]\n             (let [ttype (type x)]\n               (assoc acc ttype (conj (get acc ttype []) x))))\n     {}\n     coll)))","user":"5cf1d9e3e4b0aaa82f112a18"},{"problem":50,"code":"(fn split-by [coll]\n  (vals (group-by type coll)))","user":"5d6f063de4b04d129b00f2d1"},{"code":"(fn [coll] (map second (group-by type coll)))","problem":50,"user":"4fb01e53e4b081705acca260"},{"problem":50,"code":"(fn [s] (vals(group-by type s)))","user":"585030cbe4b0b7285a6f4e78"},{"problem":50,"code":"(fn split-by-type \n  [s]\n  (vals \n   (reduce \n     (fn \n       [m v]\n       (let [t (type v)]\n          (if (nil? (get m t))\n            (assoc m t [v])\n            (assoc m t (conj (get m t) v)))))\n     {}\n     s)))","user":"56e0f485e4b03a7c14b85a1c"},{"problem":50,"code":"(fn [coll]\n  (loop [coll coll x (first coll) r (new java.util.LinkedHashMap)]\n    (if (not x)\n      (vals r)\n      (recur (rest coll)\n             (first (rest coll))\n             (let [ v (.get r (type x))]\n               (if v\n                 (.put r (type x) (conj v x))\n                 (.put r (type x) (conj [] x)))\n               r)))))","user":"5823d3e6e4b051871117beb8"},{"code":";; (fn [sq] (map second (group-by type sq)))\n;; (fn [sq] (vals (group-by type sq)))\n#(vals (group-by type %))","problem":50,"user":"533696b9e4b0e30313ee6c7c"},{"problem":50,"code":"(fn [coll]\n    (into #{} (vals (group-by class coll))))","user":"59636cc2e4b066ee0a44b0c7"},{"code":"(fn [xs]\n  (let [tagged (for [x xs] [(type x) x])\n        merger (fn [m [k v]]\n                 (let [acc (or (m k) [])\n                       new-v (conj acc v)]\n                   (assoc m k new-v)))]\n    (vals (reduce merger {} tagged))))","problem":50,"user":"52487654e4b05ef8e38e63dc"},{"code":"(fn [c] (vals (group-by type c)))","problem":50,"user":"4db86aee535d1e037afb2193"},{"code":"(fn split-type [coll]\n  (set \n   (vals \n    (reduce \n      #(assoc % \n        (class %2) \n        (concat (get % (class %2) []) (list %2) )) \n     {} coll))))","problem":50,"user":"502a5fa4e4b09e8f859a9fbd"},{"problem":50,"code":"(fn [s]\n  (let [types (set (map class s))]\n    (for [t types :let [x (filter #(= t (class %)) s)]] x)\n    ))","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn split-by-type \n  ([items] (split-by-type items {}))\n  ([items split] \n   (if (empty? items)\n     (vals split)\n     (let [next-item (first items)\n           k (class next-item)\n           part (split k)\n           part-to-list (if (nil? part) [next-item] (conj part next-item))]\n       (split-by-type (rest items) (assoc split k part-to-list))))))","problem":50,"user":"517531c6e4b07031762f2eea"},{"problem":50,"code":"(fn type-grouper [coll]\n  (vals (reduce\n          (fn willy [acc val]\n            (if (contains? acc (type val))\n              (update-in acc [(type val)] #(conj % val))\n              (conj acc {(type val) [val]})))\n          {}\n          coll)))","user":"5779556de4b0979f8965166e"},{"problem":50,"code":"#(vals (apply merge-with concat (for [z %] {(class z) [z]})))","user":"574a71b7e4b02ea1147991fb"},{"code":"#(set (vals (reduce (fn [result v] (let [t (class v)\r\n                             c (get result t [])]\r\n                            (assoc result t (conj c v)))) {} %1)))","problem":50,"user":"4def301c535d08e6dec9fe12"},{"code":"(fn [l] \n  (for [x l] (vec (filter #(= (type %) (type x)) l))))","problem":50,"user":"533ee560e4b085b17e897d98"},{"problem":50,"code":"#( map second ( group-by type % ) )","user":"5d5c6675e4b09db18d4482ec"},{"problem":50,"code":"#(set (map second (set (group-by type %))))","user":"5dee144ae4b093ff71727591"},{"problem":50,"code":"(fn inner [col]\n    (println col)\n    (if (empty? col)\n      []\n      (cons\n        (filter #(= (type (first col)) (type %)) col)\n        (inner \n          (filter #(not (= (type (first col)) (type %))) col)\n          )\n        )\n      )\n    )","user":"55c3149de4b0e31453f64987"},{"code":"#(->> % (group-by class) vals)","problem":50,"user":"4db8f6c4535d1e037afb219e"},{"problem":50,"code":"(fn [x] (loop [x x m (hash-map )]\n    (if (empty? x)\n        (set (vals m))\n        (recur\n          (rest x)\n          (assoc m\n                 (type (first x))\n                 (conj (get m (type (first x)) []) (first x)))\n        )\n    )\n  )\n)","user":"5bdf651ee4b0ed4b8aab4c6d"},{"code":"#(set (map second (group-by class %)))","problem":50,"user":"52774dd2e4b03e8d9a4a74ff"},{"problem":50,"code":"(fn [s]\n        (vals (group-by type s)))","user":"546c4377e4b00cfc9eacc177"},{"problem":50,"code":"#(set (.values (group-by type %)))","user":"5e0ceca5e4b099d064962f91"},{"problem":50,"code":"(fn [x] (->> (group-by class x)\n     (map last)))","user":"4fc93728e4b0ee37620e1844"},{"code":"(fn [s]\n  (loop [ret {} s s]\n    (if (empty? s)\n      (vals ret)\n      (let [x (first s)\n            tp (type x)]\n        (recur (assoc ret tp (conj (vec (ret tp)) x)) (rest s))))))","problem":50,"user":"4fb4f42ae4b081705acca2b4"},{"code":"(fn [coll] (map (fn [c] (filter #(= (class %) c) coll)) (set (map class coll))))","problem":50,"user":"4e14108c535d04ed9115e7dd"},{"problem":50,"code":"(fn [coll] \n  (let [f #(str (type %))]\n    (partition-by f \n      (sort-by f coll))))","user":"564c8e99e4b0284900eef674"},{"code":"#(set (map second  \t(group-by type %1)))","problem":50,"user":"518c5236e4b087e178201de0"},{"code":"(fn sp [s]\n  (vals\n  (reduce #(assoc %1 (type %2) (conj (%1 (type %2)) %2))\n          (let [types (into #{} (map type s))]\n            (zipmap types (repeat (count types) [])))\n          s)))","problem":50,"user":"5175533fe4b0dea9bbfba575"},{"problem":50,"code":"(fn [coll]\n  (for [cls (set (map class coll))]\n    (filter #(= cls (class %)) coll)))","user":"5abbbd46e4b073f1774426db"},{"code":"(fn type-filter [lst]\n  (let [types [string? keyword? number? vector?]\n        type-lst (for [t types](filter t lst))]\n    (set (filter (complement empty?) type-lst))))","problem":50,"user":"5374adc3e4b06d7f452d9e27"},{"code":"#(partition-by class (sort-by (comp str type) %))","problem":50,"user":"52a503e4e4b0c58976d9abe1"},{"problem":50,"code":"(fn [coll]\n  (let [type-set (set (map type coll))]\n    (set \n     (map (fn [t] (filter #(= (type %) t) coll)) type-set))))","user":"574ff497e4b02ea114799266"},{"code":"(fn [coll] (->> (group-by type coll) vals set))","problem":50,"user":"533b1dc4e4b0e30313ee6cc7"},{"code":"(fn [x]\n   (vals (group-by (fn [y] (class y)) x)))","problem":50,"user":"525372ade4b0541d1855b8f3"},{"problem":50,"code":"(fn [xs]\n  (let [ts (set (map type xs))]\n    (for [ty (vec ts)]\n       (vec (filter #(= ty (type %)) xs))\n      )\n   )\n)","user":"53ca23e3e4b00fb29b2212c6"},{"problem":50,"code":"(comp vals\n      (partial group-by type))","user":"51c611c4e4b03a28d42333bf"},{"code":"(fn [s] (map val (reduce (fn [acc,e] (if (acc (type e))\n     (update-in acc [(type e)] #(conj % e))\n     (assoc acc (type e) [e])\n    )) {} s)))","problem":50,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [coll]\n  (set (vals (group-by type coll))))","problem":50,"user":"523bde95e4b07becd5be2202"},{"problem":50,"code":"(fn [v] (remove empty? ((juxt \n                        #(filter number? %) \n                        #(filter keyword? %) \n                        #(filter string? %)\n                        #(filter vector? %)) v)))","user":"5ec0db8be4b00a66d4a9528d"},{"code":"(fn sbt [l]\n  (set (vals (group-by class l))))","problem":50,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":50,"code":"(fn split-by-type\n   [s]\n   (vals (reduce (fn [type-map next-elem]\n                   (let [key (type next-elem)]\n                     (assoc-in type-map [key] (conj (get type-map key []) next-elem))))\n                 {}\n                 s)))","user":"552d487ee4b076ab5578f7e4"},{"problem":50,"code":"(fn segregate [x]\n     (filter (fn [item] (not= item []))\n             [(vec (filter keyword? x)) (vec (filter number? x)) (vec (filter string? x)) (vec (filter vector? x))]))","user":"560c37b5e4b05f002753df2e"},{"problem":50,"code":"(fn [col] \n  (map val (group-by class col)))","user":"5af4446de4b0cc2b61a3bc93"},{"problem":50,"code":"(fn [coll]\n    (vals (group-by type coll)))","user":"5777cffae4b0979f89651651"},{"problem":50,"code":"(fn \n  [coll]\n  (-> (group-by type coll) (vals))\n  )","user":"5d5a79cce4b02ba5928a6833"},{"code":"#(set (vals (group-by type %)))","problem":50,"user":"4dadca03c9a9d6ed4199dc57"},{"problem":50,"code":"(fn [in]\n  (map\n    #(map (fn [g] (nth g 2)) %)\n    (partition-by first\n                  (sort\n                    (map-indexed (fn [idx v] (vector (str (type v)) idx v))\n                                 in)))))","user":"605b49b7e4b079a07f8593f8"},{"problem":50,"code":"(fn split-by-type [coll]\n  (set (map second (group-by type coll))))","user":"5146f343e4b04ef915e3731e"},{"problem":50,"code":"#(->> % (group-by type) vals)\n;; #(vals (group-by type %))","user":"5254b45fe4b0541d1855b9a0"},{"problem":50,"code":"(fn [coll] \n  (vals  (reduce\n          #(let [tp (type %2) \n                 mp (get %1 tp [])\n                 rs (conj mp %2)]\n             (assoc %1 tp rs))\n          {} coll))\n)","user":"558fec41e4b0277789237666"},{"problem":50,"code":"(fn[coll] (apply hash-set \n                 (vals \n                  (reduce \n                   (fn[acc, v] \n                     (let [s (get acc (type v) [])] \n                       (assoc acc (type v) (conj s v)))) {} coll))))","user":"5339cb07e4b0e30313ee6caf"},{"code":"#(into #{} (map val (group-by type %)))","problem":50,"user":"515a6151e4b0394f658fe241"},{"problem":50,"code":"#(map val (group-by type %)\n)","user":"56c50599e4b05cc29241ee9e"},{"problem":50,"code":"(fn [x]\n  (vals (group-by type x)))","user":"572a856be4b0f4d77e65123b"},{"code":"#(remove empty? (conj (vector (filter string? %)) (seq (filter keyword? %)) (filter integer? %) (filter vector? %)))","problem":50,"user":"4e218464535d04ed9115e816"},{"problem":50,"code":"#(loop [[head & tail] %\n        res {}]\n   (if (nil? head)\n     (set (vals res))\n     (recur tail\n            (let [t (type head)\n                  tt (get res t)]\n              (assoc res t\n                (if (nil? tt) [head] (conj tt head))\n              )\n            )\n     )\n   )\n )","user":"53f7820be4b0de5c41848560"},{"problem":50,"code":"(fn [s] (map second (reduce (fn [dict obj] (let [cl (str (class obj))] (if (contains? dict cl) (assoc-in dict [cl (count (dict cl))] obj) (assoc-in dict [cl] [obj])))) {} s)))","user":"59468de7e4b07ddc2dafad88"},{"problem":50,"code":"(fn [coll]\n   (->> (interleave (map (comp str class) coll) coll)\n        (partition 2)\n        (sort-by first)\n        (partition-by (comp identity first))\n        (map #(map second %))))","user":"596a66cde4b069c0a1a19803"},{"problem":50,"code":"#(reduce\n  (fn [acc [k v]] (conj acc v))\n  #{}\n  (group-by type %))","user":"543c5200e4b032a45b86933e"},{"problem":50,"code":"(fn [x] (vals ( #(group-by type %1)  x ) ) )","user":"56f18d0ce4b04a395b9a0496"},{"code":"(fn [x]\n  (loop [in x out []]\n    (if (empty? in)\n      out\n      (let [t (type (first in))]\n        (recur (filter #(not= t (type %)) in) (conj out (filter #(= t (type %)) in)))))))","problem":50,"user":"53468f6ce4b084c2834f4a3f"},{"problem":50,"code":"(fn [sq]\n (map val (reduce (fn [hsh e]\n              (let [tp (type e)\n                       v (get hsh tp [])]\n                (assoc hsh tp (conj v e)))\n              )\n          {} sq)))","user":"4f867b25e4b033992c121c51"},{"problem":50,"code":"#(filter (fn [coll] (not (empty? coll))) (list (filter number? %) (filter keyword? %) (filter string? %) (filter vector? %)))","user":"548f11a0e4b0e286459a122d"},{"code":"(fn typejoin [xs]\n  (vals (group-by type xs)))","problem":50,"user":"5114ab7be4b0ce5098ee73b5"},{"problem":50,"code":"(fn [vs](set (map second (group-by type vs))))","user":"5ce41d1be4b0a17bb84e2b50"},{"code":"(fn spty\r\n  ([lis] (spty lis {}))\r\n  ([lis m] (let[f (first lis) n (next lis) k (. f (getClass)) v (m k) r (assoc m k (conj (if (nil? v) [] v) f)) ]\r\n                (if n\r\n                  (recur n r)\r\n                  (vals r))))\r\n)","problem":50,"user":"4e44358f535dc968683fc4a8"},{"problem":50,"code":"(fn [coll]\n  (let [t #(str (type %))]\n  (partition-by t (sort-by t coll))))","user":"53bf9cfbe4b0c98a41f5cca4"},{"code":"(fn [c](map #(val %) (group-by type c)))","problem":50,"user":"50e90813e4b033b0e80d11e7"},{"problem":50,"code":"(fn [coll]\n   (vals (reduce (fn [resu item]\n                   (let [t (type item)\n                         v (get resu t)]\n                     (if v\n                       (assoc resu t (conj v item))\n                       (assoc resu t (vector item)))))\n                 {}\n                 coll)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":50,"code":"(fn [lst]\n  (let [types (into #{} (map class lst))]\n    (map (fn [t]\n           (filter #(= t (class %)) lst))\n         types)))","user":"55ede35ce4b0121d4835fde1"},{"code":"#(set (map (fn [a] (first (rest a))) (group-by type %1)))","problem":50,"user":"4ff3e771e4b0678c553fc356"},{"code":"(fn[x](partition-by #(type %) (sort-by #(str (type %)) x)))","problem":50,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":50,"code":"#(->>\n  %\n   (map (fn [x] [(class x) x]))\n   (sort-by (fn [x] (str (first x))))\n   (partition-by first)\n   (map (fn [x] (map second x)))\n   )","user":"5b118b7be4b0cc2b61a3be34"},{"code":"(fn [s] (->> (group-by type s) vals set))","problem":50,"user":"526d6968e4b03e8d9a4a72d9"},{"problem":50,"code":"(fn [s]\n  (set (partition-by type \n                     (let [types (distinct (map type s))\n                           num-types (count types)]\n                     \t(for [k (range (* num-types (count s)))\n                              :let [q (quot k (count s))\n                                    r (rem k (count s))]\n                              :when (= (type (nth s r)) (nth types q))]\n                          (nth s r))))))","user":"536673a8e4b0243289761e76"},{"code":"#(map last (group-by class %))","problem":50,"user":"5115cf87e4b0ce5098ee73c3"},{"problem":50,"code":"(fn [xs]\n  (loop [xs xs\n         acc []]\n    (cond\n      (empty? xs) acc\n      :else (recur (remove #(= (type (first xs)) (type %)) xs)\n                   (conj acc (filter #(= (type (first xs)) (type %)) xs))))))","user":"51c116d4e4b0c9c822882942"},{"code":"(fn bytype [coll & res]\n   (if (empty? coll)\n       (map reverse (vals (first res)))\n   (let [v (first coll)\n         k (keyword (str (type v)))\n         r (if (nil? res) {} (first res))\n         l (cons v (k r))]\n         (bytype (rest coll) (assoc r k l))\n     )\n     )\n)","problem":50,"user":"50ca2faee4b0a409464667dc"},{"code":"(fn [s]\n  (->> s\n       (reduce #(assoc %1 (class %2) (conj (get %1 (class %2) []) %2)) {})\n       vals))","problem":50,"user":"53527551e4b084c2834f4af0"},{"code":"(fn [v] \n  (let [c (reduce #(conj % (class %2)) #{} v)]\n    (map (fn [t] (filter #(instance? t %) v)) c)\n  ))","problem":50,"user":"52d7a930e4b09f7907dd1379"},{"problem":50,"code":"(fn splitByType [s]\n  (loop [in s, out #{}]\n    (let [[x xs] in]\n      (if (nil? x)\n        out\n        (recur (filter #(not= (class x) (class %)) in)\n               (conj out (filter #(= (class x) (class %)) in)))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":50,"code":"(fn [se]\n   (map (fn [t] (vec (filter #(= (type %) t) se))) (map #(type %) se)))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":50,"code":"#(vals\n   (reduce (fn [items item]\n             (assoc items (type item) (conj (get items (type item) []) item))) {} %))","user":"4fe3338ee4b0e8f79898fea8"},{"problem":50,"code":"(fn split [coll]\n  (into #{}\n    (for [key-type (set (map class coll))]\n      (filter #(= key-type (class %)) coll))))","user":"59971e2de4b07157cc8daacc"},{"code":"(fn [c]\r\n   (vals (group-by #(type %1) c)))","problem":50,"user":"4ff07688e4b0678c553fc324"},{"problem":50,"code":"(fn f ([s] (f s {}))\n  ([s m] (if (empty? s)\n           (vals m)\n           (let [t (type (first s))]\n             (recur\n               (rest s)\n               (if \n                 (contains? m t)\n                 (conj m {t (conj (m t) (first s))})\n                 (conj m {t [(first s)]})))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":50,"code":"(fn [items]\n  (loop [items items result {}]\n    (let [item (first items) key (type item)]\n      (if (nil? item)\n        (vals result)\n        (recur (rest items) \n               (if (contains? result key)\n                 (assoc result key (conj (result key) item))\n                 (assoc result key [item])))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(fn [coll]\n  (vals\n   (loop [[x & xs :as l]   coll\n         res              {}]\n    (if (empty? l)\n      res\n      (recur xs (update-in res [(type x)]\n                           (fn [l] (vec (conj l x)))))))))","problem":50,"user":"4e71705e535d5021c1a89649"},{"problem":50,"code":"(fn [s] (-> (group-by type s)\n    vals\n    ))","user":"5619a4d0e4b053970a773afd"},{"code":"(fn [s] (vals (reduce #(merge-with into % {(.getClass %2) [%2]}) {} s)))","problem":50,"user":"5191e91de4b08962174cf733"},{"problem":50,"code":"#(apply hash-set (vals (group-by class %)))","user":"54d127b7e4b0e8a36923e5de"},{"code":"(fn splitByType [xs] (\n  loop [m {}, entries xs] \n  (if (empty? entries) (vals m) \n    (recur \n      (assoc m (type (first entries)) (concat (get m (type (first entries)) '()) (list (first entries)))) \n      (rest entries)))))","problem":50,"user":"50ef311fe4b0a78662fa2651"},{"code":"(fn [x]\n(vals (group-by type x)))","problem":50,"user":"4eb0afed535d7eef3080733e"},{"problem":50,"code":"(fn split-by-type [coll]\n  (vals\n    (reduce\n      #(let [k (type %2)] \n         (assoc %1 k (conj (get %1 k []) %2)))\n      {}\n      coll)))","user":"5f300f28e4b033932238a682"},{"problem":50,"code":"(fn[x]\n  (vals\n   (group-by #(type %) x)))","user":"553093bee4b076ab5578f817"},{"problem":50,"code":"(fn split-by-type [s]\n  (for [t (set (map #(type %) s))]\n    (filter #(= (type %) t) s)))","user":"56f53962e4b046a417f9206c"},{"problem":50,"code":"; succinct\n#(vals (group-by type %))\n\n; first try\n#_#(second (apply map list (group-by type %)))","user":"55e7d06ee4b050e68259b496"},{"problem":50,"code":"(fn split-by-type [coll]\n    (reduce (fn [setr [_ value]]\n                (conj setr value))\n            #{}\n            (group-by type coll)))","user":"552bd5c2e4b0ffed3738f969"},{"problem":50,"code":"(fn [coll] (-> (group-by class coll) vals (into #{})))","user":"5a535572e4b05d388ecb6c0b"},{"problem":50,"code":"(fn [coll]\n   (for [[k v] (group-by type coll)] v))","user":"55b54ecbe4b01b9910ae2987"},{"code":"(fn split-by-type [coll] (vals (group-by type coll)))","problem":50,"user":"50e4f4e9e4b049a987753896"},{"problem":50,"code":"(fn z [coll]\n  (->> (group-by type coll)\n       (map second)))","user":"583667c7e4b089d5ab817cfb"},{"problem":50,"code":"(fn [coll] (map (fn [classses] (filter #(= (class %) classses) coll)) (set (map class coll))))","user":"5751f2a2e4b02ea114799292"},{"problem":50,"code":"(comp vals (partial group-by type) )","user":"5a12dea3e4b04bbd27e6da44"},{"problem":50,"code":"; make a hash table with types as keys, then get just the values\n(fn slitByType [xs]\n  (loop [ys xs, m {}]\n    (cond\n     (empty? ys) (set (vals m))\n     (m (type (first ys))) (recur (rest ys) (assoc m (type (first ys)) (conj (m (type (first ys))) (first ys))))\n     :else (recur (rest ys) (assoc m (type (first ys)) [(first ys)])))))","user":"5aa5951ae4b0d174b936c899"},{"problem":50,"code":"#(vals (reduce (fn [type-map e] (cond\n                         (contains? type-map (type e)) (assoc type-map (type e) (concat (get type-map (type e)) [e]))\n                         :else (assoc type-map (type e) [e])\n                         )) {} %))","user":"5c7c1d8ee4b0d597f478ca88"},{"code":"(fn my-type-splitter [x]\n  (vals (group-by type x)))","problem":50,"user":"4eb2c45e535d7eef3080734d"},{"code":"(fn classify [myvec]\n  (let [fn-accum (fn [x y]\n                   (let [mykeyword (keyword (str (type y)))\n                         orig-vec (get x mykeyword [])]\n                     (assoc x mykeyword (conj orig-vec y))))\n        type-map (reduce fn-accum {} myvec)]\n    (println type-map)\n    (vals type-map)))","problem":50,"user":"51f82769e4b09be9c177e527"},{"problem":50,"code":"(fn split-by-type[s]\n\t(vals (reduce #(let [t (type %2)]\n\t\t\t(assoc %1 t (concat (get %1 t []) (list %2))))\n\t\t{}\n\t\ts\n\t))\n)","user":"57a9db97e4b0b8559636fc5b"},{"code":"(fn [map]   \n  (vals (group-by type map)))","problem":50,"user":"5300aa1de4b0d8b024fd3710"},{"code":"(comp vals (partial reduce (fn [h e] (let [t (type e) ol (vec (h t))] (assoc h t (conj ol e)))) {}))","problem":50,"user":"5137c3b0e4b0509a8b470482"},{"problem":50,"code":"(fn [items]\n   (into #{}\n         (->\n          ((fn [items] (group-by #(type %) items))\n           items)\n          vals)))","user":"59c87d49e4b0a024fb6ae55b"},{"code":"(fn [coll]\r\n  (reduce (fn [r t]\r\n            (conj r (filter #(= (type %1) t) coll)))\r\n         #{}\r\n         (reduce #(conj %1 (type %2)) #{} coll)))","problem":50,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn [s] (set (vals (group-by #(type %) s))))","problem":50,"user":"4fc13433e4b081705acca32b"},{"problem":50,"code":"(fn\n  [coll]\n  (vals (group-by type coll))\n  )","user":"595d0897e4b066ee0a44b00f"},{"code":"(fn split-by-type \n  [input]\n  (set (vals (group-by #(class %) input))))","problem":50,"user":"5300b750e4b0d8b024fd3711"},{"code":"(fn [s] (set (map last (reduce (fn [m e] (update-in m [(first e)] (comp vec conj) (last e))) {} (map #(vector (type %) %) s)))))","problem":50,"user":"503255d0e4b0e78df07b092b"},{"code":"(fn\n  [coll]\n  (set (vals (group-by class coll))))","problem":50,"user":"4ef7a483535dced4c769f258"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (vals\n    (reduce\n      (fn [res x]\n        (update-in res\n                [(type x)]\n                #(or (and (nil? %1) (vector %2)) (conj %1 %2))\n                x))\n      {}\n      coll)))","user":"5d7b90ede4b02e6b30c93552"},{"problem":50,"code":"(fn splitbytype [coll] (map val (group-by type coll)))","user":"57131dfbe4b07c98581c3a98"},{"problem":50,"code":"(fn [coll]\n    (vals (group-by class coll)))","user":"56eaad95e4b04a395b9a040f"},{"problem":50,"code":"(fn [seq]\n  (->> seq\n       (group-by type)\n       (map #(last %))))","user":"60849bd6e4b0736b099e42f2"},{"problem":50,"code":"#(let [type-aggregate (fn[new_map val] (merge-with into new_map {(type val) [val]}))]\n  (vals (reduce type-aggregate {} %)))","user":"5da05bcce4b000c986472bd0"},{"problem":50,"code":"(fn foo\n  ([x] (foo x {})) \n  ([[x & xs] type-map] \n       (if (nil? x) \n           (vals type-map) \n           (let [x-type (type x) type-vector (type-map x-type)]\n                (foo xs (assoc type-map x-type\n                              (if-let [type-vec type-vector]\n                                      (conj type-vec x)\n                                      [x])))))))","user":"5747e22ce4b009280f9f2b7c"},{"code":"#(partition-by type (sort-by (comp str type) %))","problem":50,"user":"4e399685535deb9a81d77f40"},{"problem":50,"code":"(fn [list] \n  (->> (group-by type list)\n       (vals)\n       set))","user":"5fe5a64de4b05ac5b16ea187"},{"code":"(fn type-split [s]\n  (if (not (empty? s))\n    (conj (type-split (filter #(not= (type %) (type (first s))) s))\n          (vec (filter #(= (type %) (type (first s))) s)))\n    #{}))","problem":50,"user":"5356e04fe4b04ce2eb3ed271"},{"code":"(fn [s] (set (vals (group-by #(class %) s))))","problem":50,"user":"4f2942ace4b0d6649770a01e"},{"problem":50,"code":"(fn [col]\n  (->> col (reduce (fn [m e] (update-in m [(type e)] #(if % (conj % e) [e]))) {}) vals))","user":"56df254be4b0ca2494a095ea"},{"code":"(fn splittype [xs] (when-not (empty? xs) (let [thetype (filter #(= (type (first xs)) (type %)) xs), othertype (filter #(not= (type (first xs)) (type %)) xs)] (cons thetype (splittype othertype)))))","problem":50,"user":"5211d195e4b07aea8afc4f76"},{"problem":50,"code":"(fn __ [col]\n  (->> (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} col)\n      (reduce #(conj %1 (second %2)) [])))","user":"5ac91d90e4b0e27600da77bd"},{"problem":50,"code":"(fn type-splitter\n   [coll]\n   (vals (group-by type coll)))","user":"542725fce4b01498b1a71b22"},{"code":"(fn splittype [col]\n   (vals\n   (loop [res {} col col]\n     (if (empty? col)\n       res\n       (let [f (first col) t (type f)]\n         (recur\n          (assoc res t (conj (get res t []) f))\n          (rest col)))))))","problem":50,"user":"51684318e4b03f62cda68cd6"},{"problem":50,"code":"(fn split-type [col]\n  (map second (reduce (fn [m x] (assoc m\n                                       (class x)\n                                       (conj (get m (class x) []) x)))\n                      {}  col)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":50,"code":"#(->> % (group-by type) (vals) (set))","user":"5ec0de29e4b00a66d4a9528e"},{"code":"#(map val (group-by type %))","problem":50,"user":"4f1b0008535d64f603146473"},{"code":"(fn [s] (remove empty? (conj () (filter string? s) (filter vector? s) (filter number? s) (filter keyword? s))))","problem":50,"user":"513ca934e4b0b86ece9f3228"},{"problem":50,"code":"#(set (vals (reduce (fn [dict item]\n                     (merge-with into dict\n                                 {(type item) (vector item)}))\n                   {}\n                   %)))","user":"53f31dafe4b0742d9025b0f0"},{"code":"(fn [l]\n  (let [types (set (map type l))\n        same-type #(fn [x] (= (type x) %))]\n    (map #(filter (same-type %) l) types)))","problem":50,"user":"515ead6be4b049add99a053e"},{"problem":50,"code":"(fn split-by-type\n  [col]\n  (->> col\n       (group-by type)\n       vals))","user":"5ff454a1e4b05ac5b16ea20d"},{"code":"#(loop [data %1, res {}]\r\n         (cond (not ( seq data)) (vals res)\r\n               (not (res (type (first data))))  (recur (rest data)  (conj res  [(type (first data)) [(first data)]])) \r\n               :else \t\t\t\t\t\t\t(recur (rest data)  (assoc-in res [(type (first data))] (conj (res (type (first data))) (first data))))))","problem":50,"user":"52f5eefbe4b09b582c12c9cb"},{"code":"(fn [coll]\n  (vals\n    (reduce #(assoc %1 (type %2) (conj (vec (%1 (type %2))) %2))\n            {} coll)))","problem":50,"user":"4f2baf1ae4b0d6649770a04c"},{"problem":50,"code":"(fn [se]\n  (vals (reduce #(\n            let [t (type %2)\n                  o (or (get %1 t) [])]\n              (assoc %1 t (conj o %2))\n              \n            \n            \n            ) {} se)\n  \n  ))","user":"54903056e4b0b312c081ff2e"},{"problem":50,"code":"(fn [col]\n  (map second (group-by type col))\n  )","user":"4ebbff41535dfed6da9c6d78"},{"problem":50,"code":";(fn [col] (vals (group-by #(type %) col)))\n#(vals (group-by type %))","user":"555994fbe4b0deb715856e39"},{"code":"(fn [coll]\n   (set \n    (vals\n     (reduce\n      (fn [retr val]\n        (let [the-type (class val)]\n          (if (contains? retr the-type)\n            (assoc retr\n              the-type\n              (conj (get retr the-type)\n                    val))\n            (assoc retr\n              the-type\n              [val]))))\n      {}\n      coll))))","problem":50,"user":"5014754de4b094324338f8e5"},{"problem":50,"code":"(fn [a-seq] (vals (reduce #(let [type-seq (get %1 (type %2))]\n                       (do (println %2) \n                         (if (nil? type-seq)\n                          (assoc %1 (type %2) [%2])\n                          (assoc %1 (type %2) (conj type-seq %2))))) \n                              {}\n                              a-seq)))","user":"5235493ee4b05e80434a5064"},{"code":"(fn [col]\n       (loop [more (map #(list (type %) %) col)\n\t      grouped {}]\n\t (if (empty? more)\n\t   (vals grouped)\n\t   (recur\n\t    (rest more)\n\t    (merge-with concat grouped\n\t\t\t(hash-map (ffirst more) [(second (first more))] ))))))","problem":50,"user":"4eae2f9e535d7eef30807324"},{"problem":50,"code":"(fn split-by-type [coll]\n  (loop [acc {}\n         [first-item & rest-items] coll]\n    (let [curr-type (str (type first-item))\n          type-found (get acc curr-type)]\n      (cond \n       (nil? first-item) (vals acc)\n       type-found (recur (assoc acc curr-type\n                             (conj type-found first-item))\n                           rest-items)\n       :else (recur (assoc acc curr-type [first-item]) rest-items)))))","user":"55bbfd60e4b01b9910ae29ed"},{"problem":50,"code":"(fn [col]\n  (for [i (distinct (map type col))]\n  (vec (filter (fn [x] (= (type x) i)) col))))","user":"608e3bf7e4b03bd49d9f36bd"},{"problem":50,"code":"(fn split-by-type [coll]\n  (loop [type-map {}\n         curr-item (first coll)\n         lft-coll (rest coll)]\n    (if (nil? curr-item)\n      (set (vals type-map))\n      (recur (merge-with concat type-map {(type curr-item) [curr-item]})\n             (first lft-coll)\n             (rest lft-coll)))))","user":"53791ab7e4b06839e8705e4d"},{"problem":50,"code":"(fn split-by-type [coll]\n  (for [[key value] (group-by type coll)]\n   value))","user":"5d6691cee4b0db5d338d15e9"},{"problem":50,"code":"(fn [coll]\n  (into #{} \n    (map second\n      (reduce \n        (fn [acc v] \n          (let [typ (type v)\n                group (get acc typ [])]\n            (assoc acc typ (conj group v))))\n        {}\n        coll))))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":50,"code":"(fn [col] (partition-by type (sort #(compare (-> % type str) (-> %2 type str)) col)))","user":"5465febde4b01be26fd746e1"},{"problem":50,"code":"(fn [seq]\n  (vals (group-by type seq))\n  )","user":"5dc9c4f2e4b02f9375f4e1f0"},{"code":"(fn [xs] (map (fn [c] (filter (fn [x] (= (class x) c)) xs)) (into #{} (map class xs))))","problem":50,"user":"531f1e63e4b08068f379edc2"},{"code":"(fn[a] (filter #(< 0 (count %1)) (reduce #(into %1 (vector (filter %2 a))) #{} [string? number? keyword? vector?])))","problem":50,"user":"50b25f2ce4b03ea88043355f"},{"problem":50,"code":"(fn [xs]\n  (loop [xs xs\n         result {}]\n    (if (empty? xs)\n      (map reverse (vals result))\n      (let [f (first xs)\n            c (class f)\n            cs (get result c)]\n        (recur (rest xs) (assoc result c (conj cs f)))))))","user":"5e8f87c7e4b0cb0169546342"},{"code":"(fn [c]\n\t(reduce #(conj %1 (second %2)) #{}\n\t\t(reduce #(assoc %1 (type %2) (conj (vec (%1 (type %2))) %2))\n                {} c)))","problem":50,"user":"53300924e4b019098a6f8b55"},{"code":"(fn split-by-type [coll]                                                                                                                     \r\n    (vals                                                                                                                                     \r\n     (reduce (fn [m x]                                                                                                                         \r\n               (let [t (type x)]                                                                                                              \r\n                 (if (contains? m t)                                                                                                          \r\n                   (assoc m t (conj (m t) x))                                                                                                 \r\n                   (assoc m t [x]))))                                                                                                         \r\n             {}                                                                                                                               \r\n             coll)))","problem":50,"user":"4f149e0f535d64f60314643d"},{"code":"(fn sbt \n  ([x] (sbt x (hash-map)))\n  ([x y]\n   (if (empty? x) \n     (vals y)\n     (sbt (rest x) \n          (merge-with concat y\n            (hash-map (type (first x))\n                      (concat (get (type (first x)) y [])\n                              (list (first x)))))))))","problem":50,"user":"52e17e66e4b09f7907dd1423"},{"code":"(fn xx [x]\n  (let [\n        fn-type (fn[x] (str (type x)))\n        sorted (sort-by fn-type x)\n        ]\n   (set (partition-by fn-type sorted) )\n))","problem":50,"user":"52d36f60e4b099d49816f0c2"},{"code":"#(filter not-empty\n              [(filter string? %)\n               (filter keyword? %)\n               (filter number? %)\n               (filter vector? %)])","problem":50,"user":"50705886e4b07bd6ad9b9f2a"},{"code":"(fn  [mylist]\n\t(reduce \n\t\t#(loop [done []\n\t\t\tremaining %1]\n\t\t\t(cond\n\t\t\t\t(empty? remaining) \n\t\t\t\t\t(conj done [%2])\n\t\t\t\t(= (type %2) (type (first (first remaining))))\n\t\t\t\t\t(concat done [(conj (first remaining) %2)] (rest remaining))\n\t\t\t\t:else (recur (conj done (first remaining)) (rest remaining))))\n\t\t[] \n\t\tmylist))","problem":50,"user":"51dd9370e4b0c33a4e1da40c"},{"code":"(fn [a-seq] (vals (reduce \n                    (fn [a-map val] \n                        (assoc a-map (.getName (type val))\n                          (if (a-map (.getName (type val))) \n                              (conj (a-map (.getName (type val))) val) \n                              [val])))\n                    {} a-seq)))","problem":50,"user":"4e6dc95a535d5021c1a895f1"},{"problem":50,"code":"#(for [[k v] (group-by class %)]\n       v)","user":"5405885ee4b0addc1aec6668"},{"problem":50,"code":"(fn [incol]\n  (let [addnotempty (fn [ocol ovec]\n                      (if (not (empty? ovec))\n                        (conj ocol (vec (reverse ovec)))\n                        ocol))\n        addiftype (fn [ncol ntype nval] \n                    (if (ntype nval) \n                      (conj ncol nval) \n                      ncol))]\n    (loop [col incol\n           strvec '()\n           intvec '()\n           keyvec '()\n           vecvec '()]\n      (if (empty? col)\n        (addnotempty (addnotempty (addnotempty (addnotempty '() strvec) intvec) keyvec) vecvec)\n        (let [fval (first col)]\n          (recur (rest col) \n                 (addiftype strvec string? fval)\n                 (addiftype intvec integer? fval)\n                 (addiftype keyvec keyword? fval)\n                 (addiftype vecvec vector? fval)))))))","user":"56197b47e4b053970a773af8"},{"problem":50,"code":"(fn [coll] \n  (->> coll \n       (group-by type) \n       (map #(val %))))","user":"541d3c0fe4b01498b1a71a7e"},{"problem":50,"code":"(fn [v] (filter (complement empty?) (map #(% v) (map #(partial filter  %) [list? vector? string? keyword? number?]))))","user":"563f2eaae4b08d4f616f5ed1"},{"code":"(fn [x]\n    (vals (#(group-by type %) x)))","problem":50,"user":"52474133e4b05ef8e38e635e"},{"code":"#((fn [l h]\n    (if (empty? l)\n      (map reverse (vals h))\n      (let [hd (first l)\n            typ (type hd)\n            items-of-type (get h typ)\n            without-type (dissoc h typ)]\n        (recur (rest l) (assoc without-type typ (cons hd items-of-type)))))) % (hash-map))","problem":50,"user":"4ff355a1e4b0678c553fc34d"},{"code":"#(vals (reduce (fn [acc elm]\r\n  \t  (let [elm-type (type elm)\r\n\t\t\telm-coll (conj (get acc elm-type []) elm)]\r\n\t\t    (assoc acc elm-type elm-coll)))\r\n\t\t{}\r\n\t\t%))","problem":50,"user":"4dd6d7ee535d2dad7130b5cb"},{"problem":50,"code":"#(vals (group-by type %))\n\n;#(vals (reduce (fn [acc elem] \n;                   (if-let [type-seq (acc (type elem))]\n;                     (assoc acc (type elem) (conj type-seq elem))\n;                     (assoc acc (type elem) [elem])))\n;                 {} %))","user":"52f3568fe4b05e3f0be25f0e"},{"problem":50,"code":"(fn [lst]\n  (->> lst\n   (reduce (fn [dct item]\n     (let [typee (type item)\n           has-key (contains? dct typee)\n           value (if has-key (dct typee) [])]\n       (assoc dct typee (conj value item)))) {})\n   (into [])\n   (map #(nth % 1))))","user":"591f05b4e4b09b4ee5954c42"},{"problem":50,"code":"(fn [col] (let [vecs (filter vector? col)\n                nums (filter number? col)\n                strs (filter string? col)\n                keyw (filter keyword? col)]\n            (filter seq[nums keyw strs vecs])))","user":"5d1a1082e4b0902706380e0e"},{"code":"(fn [xs] (vals (reduce #(conj % {(type %2) (conj (% (type %2)) %2)}) {} (reverse xs))))","problem":50,"user":"508ee17ae4b0706b2ed3ef8d"},{"code":"(fn [sq]\r\n    (let [fns [string? keyword? number? coll?]\r\n          f (fn [pred] (filter pred sq))]\r\n      (reduce \r\n        #(let [r (f %2)] (if (empty? r) %1 (conj %1 r))) \r\n        '() \r\n        fns)\r\n      ))","problem":50,"user":"4f0da4e4535d0136e6c22319"},{"problem":50,"code":"(fn func\n  [input-seq]\n  (vals (group-by class input-seq)))","user":"55a62092e4b0acc240e31554"},{"code":"(fn [s]\n     (set (vals (group-by type s)))\n     )","problem":50,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":50,"code":"(fn [coll]\n  (letfn [(filter-with [f coll]\n            (reduce\n             (fn [[coll-true coll-false] x]\n               (if (f x)\n                 [(conj coll-true x) coll-false]\n                 [coll-true (conj coll-false x)]))\n             [[] []]\n             coll))]\n    (loop [res #{} tcoll coll]\n      (if (empty? tcoll)\n        res\n        (let [[coll-true coll-false] (filter-with #(= (type %) (type (first tcoll))) tcoll)]\n          (recur (conj res coll-true) coll-false))))))","user":"5576f299e4b05c286339e077"},{"problem":50,"code":"(fn [coll]\n  (set (map #(apply list %) (vals (group-by type coll\n   )))))","user":"5245e320e4b09dbe66b56177"},{"problem":50,"code":"(fn [m]\n    (let [val<-type (group-by type\n                              m)]\n      (set (vals val<-type))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":50,"code":"(fn [s]\n  (let [r (fn [m x]\n            (let [t (type x)]\n              (assoc m t (conj (get m t []) x))))]\n    (vals (reduce r {} s))))","user":"5d929ceae4b0915913b1d412"},{"code":"(comp vals (partial group-by class))","problem":50,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [coll]\n  (->> coll (group-by class) vals))","problem":50,"user":"51ab4082e4b04e3dc0c27b31"},{"problem":50,"code":"(fn [x]\n  (->> x\n       (group-by type)\n       vals\n       set))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn [xs] (map #(second %) (group-by type xs)))","problem":50,"user":"504f865ee4b0a02f9cffde90"},{"problem":50,"code":"(fn __ [xs]\n  (vals (group-by type xs)))","user":"526759b3e4b03e8d9a4a715b"},{"problem":50,"code":"(fn [c]\n  (let [types (set (map type c))]\n    (set (for [t types] (filter #(= (type %) t) c)))))","user":"523578efe4b0a643f2dcb74c"},{"problem":50,"code":"(fn [coll]\n   (->> coll\n       (reduce (fn [m x]\n                 (let [lst (get m (type x) [])]\n                   (assoc m (type x) (conj lst x))))\n               {})\n       vals\n       ))","user":"5935b010e4b04f87174def55"},{"code":"(fn [x]\n   (vals (group-by type x)))","problem":50,"user":"52a5a8ebe4b0c58976d9abed"},{"problem":50,"code":"(fn [s] (vals (group-by type s)) )","user":"54b95f3de4b0ed20f4ff6eab"},{"problem":50,"code":"(fn solution [input]\n  (vals (group-by type input)))","user":"5e2ef900e4b05b4b015161fc"},{"problem":50,"code":"(fn [coll]\n  (let [types (reduce conj #{} (map type coll))]\n    (loop [ts   types\n           ret #{}]\n    \t(if (empty? ts)\n          ret\n          (recur (rest ts) (conj ret (filter #(= (first ts) (type %)) coll)))))))","user":"5b13f482e4b0cc2b61a3be58"},{"problem":50,"code":"(fn split-by-type [xs]\n  (let [groups (group-by first \n                         (map #(list (.toString (type %)) %) xs))]\n    (for [v (vals groups)]\n      (map second v))))","user":"5688a01be4b0dcc4269f406d"},{"problem":50,"code":"(fn [y]\n\n\t(vals\n      (reduce  \n        (fn [coll x]\n          (let [xtype (keyword (str (type x)))\n                innervec (xtype coll)\n                newvec (vec (conj innervec x))]\n            (assoc coll xtype newvec))) {} y)))","user":"593744abe4b02506e01a299b"},{"problem":50,"code":"#((comp set vals) (group-by class %))","user":"58800fd4e4b0f1effa3b7606"},{"code":"(fn [src]\n   (vals (group-by class src)))","problem":50,"user":"52c58440e4b0c2d177d620f7"},{"problem":50,"code":"(fn by-type[c]\n  (map val (group-by type c)))","user":"4dd76bf9535d2dad7130b5d1"},{"problem":50,"code":"(fn split-by-type [coll]\n  (map #(vec (reverse %)) (vals (reduce (fn [m e]\n                                          (let [t (keyword (str (type e)))]\n                                            (assoc m t (conj (m t) e))\n                                            )\n                                          ) {} coll)))\n  )","user":"5488872ee4b0e286459a11d3"},{"problem":50,"code":"(comp #(map second %) #(group-by type %))","user":"56bf4ac0e4b0f26550335985"},{"code":"(fn [lst] (vals (group-by (fn [item] (type item)) lst)))","problem":50,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":50,"code":"(fn mytest [args]\n\n    (let [\n\n            hashmap-seq (map #(hash-map (type %) %) args)\n\n            keys-seq (into #{} (map keys hashmap-seq))\n\n            ;merged-map  (apply cons hashmap-seq)\n\n            ;res         (map #(into [] (flatten %)) (vals merged-map))\n\n            myfliter (fn [myseq mykey]\n\n                (map vals (filter #(= mykey (keys %)) myseq))\n\n              )\n      ]\n      ;(println keys-seq)\n\n      (into #{} (map #(into [] %) (map #(reduce concat %) (map (partial myfliter hashmap-seq) keys-seq))))\n\n      ;(println merged-map)\n\n      ;(into #{}  res)\n\n      )\n\n\n    )","user":"55897fe2e4b059ccff29b205"},{"code":"(fn [s] (set (vals (loop [r s a {}] (if (empty? r) a (recur (rest r) (let [fr (first r) tfr (type fr)] (if \n                                                                       (a tfr) \n                                                                       (assoc a tfr (conj (a tfr) fr))\n                                                                       (assoc a tfr [fr])))))))))","problem":50,"user":"536f2faee4b0fc7073fd6e79"},{"problem":50,"code":"(fn split-type [xs]\n  (let [ts (vec (set (map type (set xs))))\n        type-check (fn [t] (filterv #(= (type %) t) xs))]\n    (println ts)\n    (set (map type-check ts))))","user":"59f7f55de4b0ca45a743a313"},{"code":";; here it is *without* using group-by\n(fn sbt ([[f & col] & [cmap]]\n  (let [v (get cmap (type f))]\n    (cond (nil? cmap) (sbt col {(type f) (conj [] f)})\n          (nil? col)  (vals (conj cmap [(type f) (conj v f)]))\n          (nil? v)    (sbt col (conj cmap [(type f) (conj [] f)]))\n          :else       (sbt col (conj cmap [(type f) (conj v f)]))))))","problem":50,"user":"53806e5be4b06839e8705ec1"},{"code":"(fn split-by-type [sq]\r\n  (into #{} (vals (group-by type sq))))","problem":50,"user":"4f82e14be4b033992c121c0c"},{"code":"(fn [s]\n          (apply hash-set \n                 (map #(val %) \n                      (apply merge-with \n                             concat \n                             (apply map \n                                    hash-map [(map class s) (map vector s)])))))","problem":50,"user":"4f03f197535dcb61093f6b84"},{"code":"#(into #{} (vals (group-by type %1)))","problem":50,"user":"52b1d41ce4b0c58976d9ace6"},{"problem":50,"code":"(fn [coll]\n  (into #{}\n        (vals (group-by type coll))))","user":"5408ec4de4b0addc1aec66d0"},{"problem":50,"code":"(fn [v]\n  (reduce (fn [acc x]\n            (if-let [sametype (first (filter #(= (type x) (type (first %))) acc))]\n              (conj (disj acc sametype) (conj sametype x))\n              (conj acc [x])))\n          #{}\n          v))","user":"5622af0fe4b03f08ee9a922b"},{"code":"#(vals (apply merge-with concat (map (fn [x] (hash-map (class x) [x])) % )))","problem":50,"user":"50783762e4b0fc74642bff67"},{"code":"(fn [xs]\n  (letfn [(sort [coll]\n            (let [tpe (class (first coll))]\n              (if (seq coll)\n                (concat (filter \n                         #(= tpe (class %)) \n                                coll) \n                        (sort\n                         (remove #(= tpe (class %))\n                                 coll)))\n                coll)))]\n    (partition-by class (sort xs))))","problem":50,"user":"51533ecde4b0252ac4b16619"},{"problem":50,"code":"(fn [coll] \n  (partition-by type \n                (sort-by #(str (type %)) \n                         coll)))","user":"5bf1b957e4b0a6d31fed216f"},{"code":"(fn [x] (map (fn [t] (filter #(= (type %) t) x)) (set (map type x))))","problem":50,"user":"4ef6e689535dced4c769f24f"},{"problem":50,"code":"(fn [x]\n  (->> x\n\t(reduce (fn [acc v] (update-in acc (vector (type v)) #(conj % v))) {})\n\t(map (fn [[k v]] (into [] (reverse v))))))","user":"5a7a09e6e4b03baeef9276ca"},{"problem":50,"code":"(fn [seq] (let [typecons (map (juxt type identity) seq)]\n                          (map (fn [type] (map second (filter #(= (first %) type) typecons))) (distinct (map first typecons)))))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      (map val))","user":"50738138e4b054001656acc9"},{"code":"(fn [c] (map #(val %) (group-by class c)))","problem":50,"user":"52f1bc81e4b05e3f0be25eef"},{"code":"#(vals (group-by (fn [x] (.getClass x)) %))","problem":50,"user":"50e0d5a3e4b061dbdced723d"},{"problem":50,"code":"#(map reverse \n      (vals\n       (reduce\n        (fn [m v]\n          (update-in m [(class v)] (fn [x] (conj x v))))\n        {} %)))","user":"55f7e056e4b06e875b46ceb4"},{"problem":50,"code":"(fn [x]\n (map second (group-by type x))\n)","user":"54283a7ae4b01498b1a71b2f"},{"code":"(fn [s]\n  (loop [type-seq (distinct (map type s))\n         return-seq ()]\n    (if (= 0 (count type-seq))\n      return-seq\n      (recur\n       (rest type-seq)\n       (cons (filter #(if (= (type %) (first type-seq)) true false) s) return-seq)))))","problem":50,"user":"4fdf2b50e4b05e33b9224f93"},{"problem":50,"code":"(fn [s]\n  (vals (group-by #(type %1) s)))","user":"58eac340e4b056aecfd47d24"},{"problem":50,"code":"(fn answer [coll]                                                                                                                                                                                                \n  (let [types (set (map type coll))]                                                                                                                                                                               \n    (loop [res (apply hash-map (interleave types (repeat (count types) [])))                                                                                                                                       \n           c coll]                                                                                                                                                                                                 \n      (if (empty? c)                                                                                                                                                                                               \n        (set (map second (set  res)))                                                                                                                                                                              \n        (recur (assoc res (type (first c)) (vec (concat (res (type (first c))) [(first c)]))) (rest c))))))","user":"56a94562e4b07966d5a8a074"},{"code":"(fn [coll]\n   (partition-by class (sort-by #(str (class %)) coll)))","problem":50,"user":"5038f8d2e4b088a6a14ca75f"},{"problem":50,"code":"#(vals\n  ((fn by-class [m l]\n    (let [item (first l)\n          c (class item)]\n      (if item\n        (by-class (assoc m c (conj (get m c []) item)) (rest l))\n        m))) {} %))","user":"57ffd1a9e4b0a837a8b30c2a"},{"code":"(fn [coll] (map (fn [[x y]] y) (group-by type coll)))","problem":50,"user":"4f0404df535dcb61093f6b91"},{"code":"(fn [s]\n  (let [types (set (map type s))]\n    (set \n      (reduce\n      (fn [r t] (conj r (filter #(= t (type %)) s)))\n      []\n      types))))","problem":50,"user":"4dbdc9da535d020aff1edf4c"},{"code":"#(map second \n      (apply merge-with concat\n             (map (fn [x] {(type x) [x]}) %)\n             )\n      )","problem":50,"user":"5298d3f4e4b02ebb4ef75068"},{"code":"(fn [col] (vals \r\n  (reduce (fn [m n] (update-in m [(type n)] conj n))\r\n           (zipmap (map type col) (repeat []))\r\n            col)))","problem":50,"user":"4e0e0529535d04ed9115e7b9"},{"problem":50,"code":"(fn split-by-type [coll]\n  (into #{} (map second (group-by type coll))))","user":"5693a53ee4b0dcc4269f4106"},{"problem":50,"code":"(fn splitty [col]\n  (loop [[first & rest] col\n         map {}]\n    (if (nil? first)\n      (vals map)\n      (do\n        (let [ty (type first)]\n          (recur rest (if (contains? map ty)\n                        (update-in map [ty] conj first)\n                        (assoc map ty [first]))))))))","user":"5c195cb2e4b01240ff5671f7"},{"code":"(fn group-types [s]\n  (vals (group-by type s)))","problem":50,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"#(let [op [number? keyword? string? coll?]]\n   (letfn [(split-by-type [opcol col]\n                          (if (empty? opcol) nil\n                          \t(cons ((group-by (first opcol) col) true ) (split-by-type (rest opcol) col))))]\n     (filter coll? (split-by-type op %))))","problem":50,"user":"51cbaf14e4b08d8387cbedda"},{"problem":50,"code":"(fn [coll]\n  (set (vals (group-by #(cond \n                         \t\t\t\t(integer? %) \"int\"\n                         \t\t\t\t(keyword? %) \"key\"\n                         \t\t\t\t(string? %) \"string\"\n                         \t\t\t\t(vector? %) \"vector\") coll))))","user":"53f5c402e4b0db01ade6f9d4"},{"problem":50,"code":"(fn split-by-type[xs]\n  (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} xs)))","user":"5d5e0259e4b0c9e5857d4fef"},{"code":"#(mapcat rest (group-by type %))","problem":50,"user":"4fad33e8e4b081705acca236"},{"problem":50,"code":"#(->> %\n      (reduce (fn [accum, x]\n                           (assoc accum (type x) (conj (accum (type x) []) x)))\n                         {})\n      vals\n      (apply hash-set))","user":"56a38a4ce4b0542e1f8d14cc"},{"problem":50,"code":"(fn [coll] (map (comp reverse second) (reduce (fn [acc ele] (let [type-ele (type ele)] (if ((complement contains?) acc type-ele) (assoc acc type-ele (list ele)) (assoc acc type-ele (conj (get acc type-ele) ele))))) {} coll)))","user":"5e04ce34e4b0a607a9a45d71"},{"code":"(fn [s]\n  (set (vals (group-by (fn [n] (type n))  s)) ) )","problem":50,"user":"5101192ae4b0bef64c30e266"},{"code":"#(into #{} (vals (group-by class %)))","problem":50,"user":"4f0e995e535d0136e6c22326"},{"problem":50,"code":"(fn sptp\n  [init]\n  (reduce \n    (fn [acc elem]\n      (if-let [buddy (some #(when (= (class elem) (class (first %))) %) acc)]\n        (concat (remove #{buddy} (into #{} acc)) (vector (conj buddy elem))) \n        (concat acc (vector (vector elem))) )\n    ) \n    #{} \n    init))","user":"53d6b266e4b0e771c3025459"},{"code":"(fn [xs]\n  (map #(second %) (seq (group-by type xs))))","problem":50,"user":"52b9c62ce4b07a9af57922c3"},{"code":"(fn [coll]\n  \t(filter #(not (empty? %))\n\t\t\t(cons (filter #(number? %) coll)\n\t\t\t(cons (filter #(keyword? %) coll)\n\t\t\t(cons (filter #(string? %) coll)\n\t\t\t(cons (filter #(coll? %) coll) \n\t\t\t'()))))))","problem":50,"user":"4e6a63fd535d8ccf87e9feda"},{"code":"(fn split-by-type\n  [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4e3bcccd535deb9a81d77f56"},{"problem":50,"code":"(fn type-split\n  [s]\n  (loop [old-seq s\n         new-seq []]\n       (if (empty? old-seq)\n           new-seq\n           (recur (remove #(= (type (first old-seq)) (type %)) old-seq) (conj new-seq (filter #(= (type (first old-seq)) (type %)) old-seq))))))","user":"55acd080e4b03311e7b73298"},{"code":"(fn [s]\n  (map vec\n    (partition-by #(.getClass %)\n      (sort-by #(.getName (.getClass %)) s))))","problem":50,"user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn [l] (map #(filter (fn [x] (= (type x) %)) l) (set (map type l))))","problem":50,"user":"519e70d5e4b0acf32bc6a42c"},{"problem":50,"code":"(fn [seq] (map last (group-by type seq)))","user":"555bd27ae4b0b056612e2244"},{"problem":50,"code":"(fn split-by-type [v]\n  (vals (group-by #(type %) v)))","user":"57af249fe4b0fbc9809a272b"},{"problem":50,"code":"(fn [s]\n  (let [map\n  (reduce \n   (fn [acc el]\n     (let [el-type (type el)\n           sub (get acc el-type [])\n           sub (conj sub el)\n           acc (assoc acc el-type sub)]\n       acc)\n     )   \n   {}\n   s\n   )]\n   (vals map)\n        )\n  )","user":"56fbe0cce4b07572ad1a88d8"},{"problem":50,"code":"(fn type-set [x]\n  (map second (group-by class x))\n)","user":"5394bb65e4b0b51d73faaece"},{"problem":50,"code":"(fn split-by-type [s] (vals(group-by type s)))","user":"58b2f085e4b0ebc645576d15"},{"code":"(fn [s]\r\n    (map (fn [t] (filter #(= t (type %)) s)) (set (map type s)) ))","problem":50,"user":"4e8768f6535dceadca469850"},{"problem":50,"code":"(fn [xs]\n  (let [xs-types (distinct (map type xs))]\n    (loop [[t & ts] xs-types ys '()]\n      (if (not(nil? t))\n        (letfn [(filter-types [] (filter (fn [x] (= t (type x))) xs))]\n          (recur ts (cons (filter-types) ys)))\n        ys))))\n\n; (fn [xs] (vals (group-by (fn [x] (type x)) xs)))","user":"5661e09ae4b068f2fe63dc70"},{"code":"; The source code for partition-by is beyond me at this point.\n; There's a lot going on in there.\n;\n(fn [coll]\n  (partition-by type\n    (sort-by #(str (type %)) coll)))","problem":50,"user":"4eed26af535d93acb0a668bb"},{"code":"(fn [l]\n  (vals\n  (reduce\n    #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2))\n    {}\n    l)))","problem":50,"user":"4f04f847535dcb61093f6beb"},{"problem":50,"code":"(fn [elements] \n  (loop [result {}\n         my-elements elements]\n  (if-let [elem (first my-elements)]\n    (recur (merge-with concat result {(type elem) [elem]}) (next my-elements))\n    (vals result))))","user":"546e4ab8e4b00cfc9eacc19c"},{"problem":50,"code":"(fn [x]\n\t(let [komp (fn [k] (str (class k)))]\n     \t(set (partition-by komp (sort-by komp x)))\n   \t)\n)","user":"53d5e45ae4b0e771c302544e"},{"code":"(fn [ls]\r\n  (filter (complement empty?)\r\n          (map\r\n            (partial (fn [ls t] (filter #(= (type %) t) ls)) ls)\r\n               [java.lang.Long clojure.lang.Keyword java.lang.String clojure.lang.PersistentVector])))","problem":50,"user":"4f9aa97ae4b0dcca54ed6d0e"},{"problem":50,"code":"(fn [coll]\n  (loop [[head & tail :as remaining] coll\n         acc (hash-map)]\n    (cond\n     (empty? remaining) (map reverse (vals acc))\n     (number? head) (recur (rest remaining) (assoc acc :number (cons head (:number acc))))\n     (keyword? head) (recur (rest remaining) (assoc acc :keyword (cons head (:keyword acc))))\n     (string? head) (recur (rest remaining) (assoc acc :string (cons head (:string acc))))\n     (seq head) (recur (rest remaining) (assoc acc :seq (cons head (:seq acc)))))))","user":"51a7bf26e4b0da5f497bde8c"},{"problem":50,"code":"#(vals (reduce (fn [acc v] (assoc acc \n                               (class v) \n                               (conj (get acc (class v) []) v)))\n                 {}\n                 %))","user":"513e8141e4b02b2a3d8235c1"},{"problem":50,"code":"(fn [coll]\n   (->>\n     (group-by type coll)\n     (seq)\n     (map second)\n     (set)\n     )\n   )","user":"5a43347ee4b0447ef91cc603"},{"problem":50,"code":"#(vals (reduce (fn [a b]\n            (assoc a (class b) \n              (conj (a (class b) []) b))) {} %))","user":"544e9022e4b0e3978000698b"},{"code":"(fn [p]\n  (vals (\n(fn splaa [[f & n]]\n  (if (empty? n)\n    {(type f) (list f)}\n    (let [res (splaa n)\n          typ (type f)\n          col (res typ (list))]\n      (assoc res typ (conj col f)))))\n         p)))","problem":50,"user":"53908e6be4b0b51d73faae9a"},{"code":"(fn [s]\n   (map second\n        (reduce #(conj %1 [(class %2)\n                           (conj (%1 (class %2) [])  %2)])\n                {} s)))","problem":50,"user":"4ee868be535d93acb0a6687d"},{"code":"(fn [s]\n  (->> (group-by class s)\n       (vals)))","problem":50,"user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn prob-0050 [xs]\n  (vals (apply merge-with concat\n               (map #(hash-map (type %) [%]) xs))))","problem":50,"user":"4f047c07535dcb61093f6bcd"},{"problem":50,"code":"(fn by-type\n  [& args]\n  (map val (apply group-by class args)))","user":"53ac4719e4b047364c04445c"},{"problem":50,"code":"(fn [xs]\n   (->\n    (reduce (fn [acc x]\n              (let [t (type x)\n                    for-t (get acc t [])]\n                (assoc acc t (conj for-t x)))\n              )\n            {}\n            xs)\n    (vals)\n    (set)))","user":"51bb08a4e4b0fe3ecfb46446"},{"problem":50,"code":"(fn splt [s]\n  (set (vals (reduce (fn [m v]\n                       (let [k (type v)] \n                        (if (contains? m k)\n                          (update-in m [k] #(conj % v))\n                          (assoc-in m [k] [v]))))\n                     {} s))))","user":"558bb38fe4b0277789237631"},{"problem":50,"code":"(fn [v]\n    (reduce (fn [r va] (conj r (second va))) [] (reduce (fn [r va] (assoc r (type va) (into [] (conj (r (type va)) va)))) {} v))\n  )","user":"57f28b22e4b0511f1d294def"},{"problem":50,"code":"#(into #{} (vals(group-by type %)))","user":"570377c1e4b08d47c97781f1"},{"code":"(fn [coll] \n\t(vals (group-by class coll)))","problem":50,"user":"520242bae4b030ee0c5b26e3"},{"code":"(fn [coll]\n  (let [append-to-map (fn [m v]\n                        (if (contains? m (type v))\n                          (assoc m (type v) (conj (m (type v)) v))\n                          (assoc m (type v) (vector v))))\n        helper (fn [res coll]\n                 (if (empty? coll)\n                   res\n                   (recur (append-to-map res (first coll)) (rest coll))))]\n    (set (vals (helper {} coll)))))","problem":50,"user":"527c166de4b03e8d9a4a75b3"},{"code":"(fn [lst] (let [k (set (map type lst))]\n  (map (fn [l] (filter #(= (type %) l) lst)) k)))","problem":50,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [s]\n  (letfn [(to-map [e] {(type e) (conj '() e)})]\n    (vals (reduce #(merge-with concat %1 %2) (map to-map s)))))","problem":50,"user":"50b29029e4b03ea880433563"},{"problem":50,"code":"#(->> (group-by type %)\n      (map second)\n      (into #{}))","user":"54f4adc8e4b0f2f3c5226e86"},{"code":"#(vals (group-by (fn [x] (type x)) %))","problem":50,"user":"4eebfd03535d93acb0a668ab"},{"problem":50,"code":"(fn [x] (vals (reduce #(assoc % (type %2) (conj (get % (type %2) []) %2)) {} x)))","user":"52c7f036e4b0c2d177d62126"},{"code":"(fn [l] (map (fn [x] (filter #(= (type %) x) l)) (map type l)))","problem":50,"user":"4e78c208535db95036265722"},{"code":"(fn [in] (apply hash-set (vals (group-by type in))))","problem":50,"user":"529936e7e4b02ebb4ef7507b"},{"code":"(fn collect-type [coll]\n    (set (vals (loop [res {} coll coll]\n                   (if (empty? coll)\n                     res\n                     (let [i (first coll)\n                           t (type i)]\n                       (recur (assoc res t (conj (or (res t) []) i)) (rest coll))))))))","problem":50,"user":"50c113bee4b096f585049c37"},{"code":"#(vec (.values (group-by class %)))","problem":50,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [col]\n     (partition-by type (sort-by #(-> % type str) col)))","problem":50,"user":"5036eba7e4b0af0658af77a5"},{"code":"(fn divide [xs]\n  (if (empty? xs)\n    ()\n    (cons (filter (fn [y] (= (type y) (type (first xs)))) xs)\n          (divide (filter (fn [y] (not= (type y) (type (first xs)))) xs)))))","problem":50,"user":"4db51ce0535d87e67b28fe06"},{"problem":50,"code":"(fn split-by-type [coll]\n  (map second (group-by type coll)))","user":"5b1d61b3e4b03cfeda66ecfe"},{"code":"#(vals (group-by class %1))","problem":50,"user":"510fd798e4b04c71fce993dc"},{"code":"(fn [s] (vals (reduce #(assoc % (type %2) (conj (get % (type %2) []) %2)) {} s)))","problem":50,"user":"50ed4626e4b01236b1d4983c"},{"problem":50,"code":"(fn homogena [sekv]\n  (set (vals (group-by class sekv))))","user":"584d99c5e4b0b7285a6f4e42"},{"problem":50,"code":"(fn [coll]\n  (reduce\n   (fn [acc t]\n    (conj acc (filter\n               (comp (partial = t) type)\n               coll)))\n   []\n   (distinct (map type coll))))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":50,"code":"(fn [coll]\n    (map (fn [x]\n           (val x))\n     (group-by type coll)))","user":"591072e0e4b0163c97b36ebc"},{"problem":50,"code":"(fn [coll]\n   (loop [[el & _ :as coll] coll\n          m (array-map)]\n     (if coll\n       (recur (next coll)\n              (assoc m (class el) (conj (get m (class el) []) el)))\n       (vec (vals m)))))","user":"5712854ce4b07c98581c3a89"},{"problem":50,"code":"(fn [x] (map (fn [t] (filter #(= t (type %)) x)) (set (map type x))))","user":"569c1038e4b0542e1f8d145f"},{"problem":50,"code":";; (fn [c] (vals (reduce (fn [a v] (let [t (type v)] (assoc a t (conj (vec (get a t)) v)))) {} c)))\n#(vals (group-by type %))","user":"5a5894d9e4b05d388ecb6c81"},{"problem":50,"code":"(fn [x]\n  (loop [coll (rest x) result [(vector (first x))]]\n    (if (empty? coll)\n      result\n      (recur (rest coll) (loop [result2 result]\n                            (if (empty? result2)\n                              (conj result (vector (first coll)))\n                              (if (= (type (first coll)) (type (first (first result2))))\n                                   (assoc result (.indexOf result (first result2)) (conj (nth result (.indexOf result (first result2))) (first coll)))\n                                   (recur (rest result2)))))))))","user":"57344edbe4b0cd1946bd1008"},{"problem":50,"code":"(fn [x] (map reverse (vals (reduce #(update-in %1 (vector (type %2)) conj %2) {} x))))","user":"5910a43de4b0163c97b36ebf"},{"problem":50,"code":"(fn [coll]\n  (->> (group-by #(type %) coll)\n       (vals)))","user":"60a42199e4b00e9e6653c454"},{"code":"#(vals (group-by type %1))","problem":50,"user":"4ee82223535d93acb0a66877"},{"problem":50,"code":"#(->> %\n    (reduce \n     (fn [typemap item] \n       (let [itemtype (type item)] \n         (assoc typemap itemtype (conj (get typemap itemtype []) item)))) {})\n    vals)","user":"5d25abc9e4b02ea6f0fb6a37"},{"problem":50,"code":"(fn [s]\n  (vals\n   (group-by (fn [x] (type x)) s)))","user":"573a0ecce4b0cd1946bd1088"},{"problem":50,"code":"(comp \n vals (partial group-by class))","user":"593c71cbe4b069cdc2982b90"},{"code":"(fn [s]\n  (vals\n    (reduce\n      (fn [t s]\n        (assoc t\n          (type s)\n          (conj\n            (get t\n              (type s)\n              [])\n            s)))\n      {}\n      s)))","problem":50,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":50,"code":"(fn [v] (map last (group-by type v)))","user":"5739ff3ae4b0cd1946bd1084"},{"problem":50,"code":"(fn [x] (map #(% 1) (group-by type x)))","user":"5835bc73e4b089d5ab817ce9"},{"problem":50,"code":"(fn [a]\n  (let [testers [number? keyword? string? vector?]]\n    (reduce #(let [st (filter %2 a)]\n               (if (empty? st)\n                 %1\n                 (conj %1 st))) [] testers)))","user":"5649542fe4b0284900eef63f"},{"code":"(fn f [coll]\n  (let [ separate (fn [f s] [(filter f s), (filter (complement f) s)])\n         [xs ys] (separate #(= (type (first coll)) (type %)) coll)]\n    (if (empty? ys) [xs] (conj (f ys) xs))))","problem":50,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [l]\n  (for [x l]\n    (filter #(= (type %) (type x)) l)))","problem":50,"user":"4f7869c2e4b0fbe0118ec589"},{"problem":50,"code":"#(set (map val (group-by type %1)))","user":"540479e7e4b0addc1aec665a"},{"code":"(fn [s] (vals (reduce #(assoc % (type %2) (concat (% (type %2)) (list %2))) {} s)))","problem":50,"user":"50dfb660e4b061dbdced7228"},{"problem":50,"code":"(fn [col] \n  (let [types (set (map type col))] \n    (mapcat (fn [typ] (conj [] (filter (fn [x] (= typ (type x))) col))) types)))","user":"5146fd44e4b0d12420447958"},{"problem":50,"code":"(fn [somevec]\n  (vals (group-by type somevec) )\n)","user":"56bff105e4b060a8e693e3a4"},{"code":"(fn [values]\n  ((comp vals reduce)\n    (fn [m v]\n      (conj m\n        (let [t (type v)]\n          {t\n            (let [a (m t)]\n              (if a\n                (conj a v)\n                [v]))})))\n    {} values))","problem":50,"user":"4f8d340be4b02e764a0a51a8"},{"problem":50,"code":"(fn f50 [coll]\n  (->>\n   (group-by class coll)\n   (map second)\n   (into #{})))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":50,"code":"#(vals (reduce (fn [acc x] (if (contains? acc (class x))\n                             (into acc {(class x) (into (get acc (class x)) [x])})\n                             (into acc {(class x) [x]}))) {} %))","user":"552b6ddbe4b0ffed3738f965"},{"code":"(comp vals (partial  reduce (fn [xs x]\n         (let [k (type x)\n               v (conj (get xs k []) x)]\n           (assoc xs k v))) {} ))","problem":50,"user":"51780bfce4b0f89a8f53839c"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce\n    (fn [theMap theValue]\n      (let [theType (type theValue)]\n        (if (contains? theMap theType)\n          (assoc theMap theType (conj (get theMap theType) theValue))\n          (assoc theMap theType [theValue] ))))\n    {} coll)))","user":"53c1b787e4b00fb29b221266"},{"code":"(fn split-by-type [a-seq]\n   (let [type-map(group-by #(type %) a-seq)]\n       (into #{} (for [[k v] type-map] v)) \n   )\n)","problem":50,"user":"52763696e4b03e8d9a4a74d7"},{"problem":50,"code":"#(vals ((partial group-by type) %))","user":"54f2a1b8e4b024c67c0cf8cb"},{"code":"(fn\n  [coll]\n  (vals (group-by type coll)))","problem":50,"user":"52ba447ee4b07a9af57922ce"},{"code":"(fn [s]\n      (loop [s s\n             result #{}]\n        (if (empty? s)\n          ;return\n          result\n          ;else recur    \n          (let [x (first s)\n                of-type? #(= (type x) (type %))]\n            (recur (remove of-type? s)\n                   (conj result (filter of-type? s)))))))","problem":50,"user":"4f88e3eee4b033992c121c72"},{"problem":50,"code":"(comp vals #(group-by type %1))","user":"576c2ecae4b07c67f59d1fbb"},{"code":"#(vals (reduce (fn [m x]\n  (assoc m (type x) (conj (m (type x) []) x))) {} %))","problem":50,"user":"4e6f1b7a535d5021c1a89618"},{"problem":50,"code":"(fn [col]\n     (map second (group-by type col)))","user":"5d887d27e4b0915913b1d3a8"},{"problem":50,"code":"(fn [c]\n            (vals (group-by #(type %) c)))","user":"551e6526e4b030e6a24d00e8"},{"code":"(fn [s] (partition-by type (sort-by #(str (type %1)) s)))","problem":50,"user":"4fa67030e4b081705acca1b7"},{"code":"(fn [s] \n  (set \n    (vals\n      (reduce \n        (fn [m x] (update-in m [(type x)] \n                    #(conj (or % []) x)))\n          {} s))))","problem":50,"user":"4f06dcad535dcb61093f6c16"},{"problem":50,"code":"#(vals (into [] (group-by type %)))","user":"58a2b57fe4b02bd94d917ede"},{"problem":50,"code":"(fn [coll] \n  (partition-by #(str (type %)) \n                (sort-by #(str (type %)) coll)))","user":"56e6ef89e4b02e7e935eb6d0"},{"problem":50,"code":"(fn [v]\n  (set (vals (group-by type v))))","user":"53f35c34e4b0742d9025b0f4"},{"code":"(fn [array] \n  (vals (group-by type array)))","problem":50,"user":"520f46f9e4b0101e4be6fcee"},{"code":"(fn [eles] (loop [[x :as l]  eles\n                  result []]\n             (if (nil? x )\n               result\n               (let [{seq_of_x_eles true others false}  (group-by #(instance? (class x) %) l)\n                     next_res (conj result seq_of_x_eles)] \n                 (recur others next_res)))))","problem":50,"user":"5220909fe4b0e6a83c89259f"},{"code":"(fn [x] (loop [s x e (first x) r []]\n                  (if (empty? s)\n                    r\n                    (let [t (filter #(= (class e) (class %)) s)\n                          new-s (remove (set t) s)]\n                      (recur new-s (first new-s) (conj r t))))\n                  ))","problem":50,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":50,"code":"(fn [x] (vals (group-by #(class %1) x)))","user":"536829c8e4b0243289761e8b"},{"problem":50,"code":";(\n#(->> %\n      (group-by type)\n      (vals)\n      (into #{}))\n;  [:a :b])","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":50,"code":"(fn [coll] (into #{} (vals (group-by class coll))))","user":"5ab564f8e4b073f177442639"},{"problem":50,"code":"(fn [ls]\n    (set (vals (group-by #(type %) ls))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":50,"code":"(fn [coll]\n    (set\n      (map (fn [pair]\n             (second pair))\n           (group-by type coll))))","user":"5e7b1ef4e4b085ba37836e10"},{"problem":50,"code":"(fn[s] \n  (partition-by type \n    (sort-by #(str (type %)) s)))","user":"5654d0e1e4b0f9d632dd848c"},{"problem":50,"code":"(fn [coll]\n  (->\n    (fn [groups el]\n      (let [k (type el)\n            v (get groups k [])]\n        (assoc-in groups [k] (conj v el))))\n    (reduce {} coll)\n    vals))","user":"5169d422e4b051e2a73aba53"},{"problem":50,"code":"(fn [xs]\n    (vals (group-by type xs)))","user":"54be792ee4b0ed20f4ff6eeb"},{"problem":50,"code":"(fn [xs]\n  (vals (reduce\n         (fn [xs x]\n           (if (contains? xs (type x))\n             (merge xs (vector (type x) (conj (get xs (type x)) x)))\n             (merge xs (vector (type x) [x]))))\n         {}\n         xs)))","user":"5f5e7158e4b02876ed9fcff0"},{"problem":50,"code":"(fn [s]\n  (map last (group-by type s))\n  )","user":"5ac37d0fe4b0e27600da7718"},{"problem":50,"code":"#(->> %\n               (group-by class)\n               vals)","user":"58c4b11ae4b021aa9917ed2c"},{"problem":50,"code":"(fn [xs]\n  (loop [origin-xs xs\n         target-map {}]\n    (if (empty? origin-xs)\n      (->> target-map\n        (map #(last %))\n        (into #{}))\n      (let [head (first origin-xs)\n            handler (comp vec conj)\n            updater #(update-in target-map [%1] handler %2)\n            check-fns [keyword? :cate-key\n                       string? :cate-string\n                       number? :cate-number\n                       vector? :cate-vec]\n            val-type (->> check-fns\n                          (partition 2)\n                          (some (fn [[check-fn cate-type]]\n                                  (when (check-fn head)\n                                    cate-type))))]\n        (recur (rest origin-xs)\n               (updater val-type head))))))","user":"58fed70de4b0438e51c2cfdd"},{"code":"(fn [coll] (set (map second (group-by class coll))))","problem":50,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"#(let [types (set (map type %))]\n  (for [current-type types]\n    (filter (fn [ele] (= current-type (type ele))) %)))","problem":50,"user":"5071b614e4b0e3170b5a867d"},{"code":"(fn splitByType [li] (set ( vals((fn createMap \n  ([li]\n    (if (empty? li)\n      (hash-map)      \n    (let [f (first li)\n          t (type f)\n          mp (createMap (rest li) )] \n      (if (contains? mp t) \n        (assoc mp t  (vec( cons f (get mp t ) ))) \n        (assoc mp t  (vector f))))))) li))))","problem":50,"user":"4e8d5edd535d65386fec2134"},{"problem":50,"code":"(fn [s]\n  (loop [seq s result #{}]\n    (if (empty? seq)\n      result\n      (let [t (type (first seq))\n            result1 (filter #(= (type %) t) seq)\n            result2 (remove #(= (type %) t) seq)]\n        (recur result2 (conj result (vec result1)))))))","user":"576844cde4b0a07e8fc180ce"},{"code":"#(loop [[h & t] %1, res {}] \n  (if h (recur t (assoc res (class h) (if-let [l (res (class h))] (conj l h) [h]))) (vals res)))","problem":50,"user":"4eabb245535d7eef30807319"},{"problem":50,"code":"#(vals (group-by type %))\n\n;(fn [coll]\n;  (map\n;   (fn [current-type] (filter #(= (type %) current-type) coll))\n;   (set (map type coll))))","user":"5afb3426e4b0cc2b61a3bcf5"},{"problem":50,"code":"(fn [c] (map #(second %)(group-by type c)))","user":"53d5a63be4b0e771c3025449"},{"problem":50,"code":"(fn myf [xs] (map second (group-by type xs)))","user":"56b280e3e4b0982f16b37e06"},{"code":"#(map (fn[[k v]]v) (group-by type %))","problem":50,"user":"4f296a80e4b0d6649770a02a"},{"problem":50,"code":"(fn red-fn\n  [[x & xs]]\n  (cond \n   \t(nil? x) #{}\n   \t:else\n  \t\t(let [f #(= (type x) (type %))]\n  \t\t(conj (red-fn (remove f xs)) (conj (filter f xs) x)))))","user":"553aad97e4b09218d5f44ff9"},{"code":"#(partition-by (comp str type) (sort-by (comp str type) %))","problem":50,"user":"4e79ff2a535db169f9c796a9"},{"problem":50,"code":"#(->> (group-by type %) (vals) (set))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(comp vals #(group-by class %))","problem":50,"user":"4f4319ebe4b0d7d3c9f3fd13"},{"problem":50,"code":"(fn p [col]\n  (vals (group-by class  col)))","user":"53664e3be4b0243289761e74"},{"code":"(fn [x] (into #{} (vals (group-by type x))))","problem":50,"user":"52016690e4b0b2e020a18f0f"},{"code":"(fn [x] (into #{} (vals (apply merge-with concat (map #(hash-map (class %) [%]) x)))))","problem":50,"user":"4feada56e4b0140c20fb9c11"},{"problem":50,"code":"#(-> (group-by type %)\n     vals\n     set)","user":"5beda647e4b0a6d31fed2122"},{"code":"(comp vals (fn cat-by-type [coll]\n  (reduce (fn [map n]\n            (let [t (type n)]\n        (assoc map t (conj (get map t []) n)))) {} coll)))","problem":50,"user":"4fe91fa2e4b0547ebccb2440"},{"problem":50,"code":"(fn [x] (vals (group-by #(type %) x)) )","user":"5a6afb1de4b0512ff01cda2f"},{"code":"(fn [c]\n  (filter #(not (empty? %))\n    (map vec\n      (list\n        (filter number? c)\n        (filter keyword? c)\n        (filter string? c)\n        (filter vector? c)))))","problem":50,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn\n  [list]\n  (let [vectorized-list (map vector list)]\n  (vals (reduce (fn [final-list element]\n                 (merge-with (fn\n  [first second] \n  (if (nil? first)\n    [second]\n    (concat first second)))\n\n                             final-list\n                             {(type (first element)) element}))\n               {}\n               vectorized-list))))","problem":50,"user":"52382dd6e4b0fae3832e99f1"},{"problem":50,"code":"#(->> (group-by type %) (vals))","user":"5409a12fe4b0addc1aec66df"},{"problem":50,"code":"(fn [cs] (vals (#(group-by type %) cs)))","user":"4fc04d75e4b081705acca324"},{"problem":50,"code":";#(vals (reduce (fn [m x] (assoc m (type x) (conj (m (type x) []) x))) {} %1))\n#(vals (group-by type %))","user":"5a544eeee4b05d388ecb6c24"},{"code":"(fn\n  [s]\n  (vals (group-by #(type %) s)))","problem":50,"user":"52f3af46e4b05e3f0be25f14"},{"problem":50,"code":"(fn [v] (->> v (group-by type) vals set))","user":"567a680ee4b05957ce8c6198"},{"code":"(fn [c] (vals (group-by #(type %) c)))","problem":50,"user":"52c1bd29e4b07a9af579236a"},{"problem":50,"code":"(fn split-type [s]\n   (map reverse \n        (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2)) %2))\n           {}\n           s))))","user":"545e9cf1e4b01be26fd7467f"},{"code":"(fn mysplit                                                                                     \n  [s]                                                                                             \n  (loop [acc {} items s]                                                                          \n    (if (empty? items)                                                                            \n      (map vec (map reverse (vals acc)))                                                          \n      (recur (update-in acc [(type (first items))] #(conj % (first items))) (rest items))         \n      )                                                                                           \n    )                                                                                             \n  )","problem":50,"user":"50573ed8e4b0012181721987"},{"code":"(fn [s]\n  (loop [s s a {}]\n    (if (empty? s) (map reverse (vals a))\n        (let [f (first s) t (type f)]\n          (recur (rest s) (assoc a t (cons f (get a t))))))))","problem":50,"user":"4f03d0fe535dcb61093f6b6d"},{"problem":50,"code":"(fn [coll]\n  (loop [dict {}\n         coll coll]\n    (if (empty? coll)\n      (vals dict)\n      (recur (let [x (first coll)]\n               (update-in dict [(type x)] (fnil conj []) x))\n             (rest coll)))))","user":"55ba4a78e4b01b9910ae29cf"},{"problem":50,"code":"(fn [x] (into #{} (map last (group-by class x))))","user":"5bec37e2e4b0f319e2d7ec96"},{"code":"(fn [coll]\n    (let [m {}]\n      (loop [m m coll coll]\n        (if (empty? coll) (vals m)\n            (let [el (first coll)\n                  typ (type el)\n                  newval (conj (get m typ []) el)]\n              (recur (assoc m typ newval) (next coll)))))))","problem":50,"user":"50bca033e4b0594b91591c5d"},{"problem":50,"code":"(fn [seq]\n  (loop [rest-seq seq\n         nums []\n         strs []\n         colls []\n         keywords []]\n    (if (empty? rest-seq)\n      (remove empty? [nums strs colls keywords])\n      (let [val (first rest-seq)]\n        (let [add? (fn [pred in-seq] (if (pred val) (conj in-seq val) in-seq))]\n          (recur (rest rest-seq)\n                 (add? number? nums)\n                 (add? string? strs)\n                 (add? coll? colls)\n                 (add? keyword? keywords)))))))","user":"5f15a50fe4b091ba50b4dbbc"},{"problem":50,"code":"(fn subseq-by-type [xs]\n  (vals (reduce (fn [acc x]\n                  (let [t (type x)]\n                    (assoc acc t (conj (or (acc t) []) x))))\n                {}\n                xs)))","user":"5db0d470e4b0f8c104ccfc9e"},{"problem":50,"code":"(fn [coll]\n  (vals (group-by #(class %) coll)))","user":"593c1e3be4b069cdc2982b86"},{"problem":50,"code":"(fn [l] (partition-by type (sort-by #(str (type %)) l)))","user":"566e6850e4b0a866af6896da"},{"code":"(fn [l] (for [j (set (map type l))] (filter #(= j (type %)) l)))","problem":50,"user":"50ef3e5de4b0a78662fa2652"},{"problem":50,"code":"(fn func [seqs]\n        (loop [seqs seqs\n               keyw [] integ [] strings [] vectors [] ]\n          (cond (empty? seqs) \n                (remove empty? (set (list keyw integ strings vectors)))\n                (keyword? (first seqs)) \n                (recur (rest seqs)\n                       (conj keyw  (first seqs)) integ strings vectors)\n                (string? (first seqs)) \n                (recur (rest seqs)\n                       keyw integ (conj strings (first seqs)) vectors)\n                (integer? (first seqs)) \n                (recur (rest seqs)\n                       keyw (conj integ (first seqs)) strings vectors)\n                (vector? (first seqs)) \n                (recur (rest seqs)\n                       keyw integ strings (conj vectors (first seqs)))\n                )\n          ))","user":"6038b6b4e4b0d5df2af222ef"},{"code":"(fn my-split-by-type [s]\n  (vals\n   (reduce\n    (fn [type-map item]\n      (assoc type-map (type item) (concat (type-map (type item)) [item])))\n    {}\n    s)))","problem":50,"user":"5310e7aee4b08068f379ecdc"},{"problem":50,"code":"(fn [coll]\n  (map second (group-by class coll)))","user":"556a6137e4b09a3098a524e0"},{"problem":50,"code":"#(set(vals(group-by type %)))","user":"56dc483fe4b0ea9b8538f81b"},{"code":"(fn [s]\n   (vals (group-by type s)))","problem":50,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":50,"code":"(fn [l]\n  (for [x (group-by class l)]\n    (second x)))","user":"600ae927e4b074f607df6689"},{"code":"(fn [l]\n  (let [f (fn [m elem]\n            (let [type (type elem)]\n              (if (m type)\n                (update-in m [type] conj elem)\n                (assoc m type [elem]))))\n        type-map (reduce f {} l)]\n    (vals type-map)))","problem":50,"user":"52e6351ae4b09f7907dd146e"},{"code":"(fn [s] (vals (group-by type s)))","problem":50,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"#(vals (reduce (fn [m v]   \n  (let [k (.getClass v)]   \n    (assoc m  k (conj (m k []) v))))  \n  {} %))","problem":50,"user":"4f69f34fe4b07046d9f4ef90"},{"problem":50,"code":"(fn homo-set [s] (letfn [(homo-map [s acc]\n                                   (cond\n                                    (empty? s) acc\n                                     (contains? acc (type (first s))) (homo-map (rest s) (assoc acc (type (first s)) (conj (acc (type (first s))) (first s))))\n                                     :else (homo-map (rest s) (assoc acc (type (first s)) [(first s)]))))]\n                   (map first (map rest (homo-map s {})))))","user":"5ee93720e4b029a2061bbeb7"},{"code":"(fn\n  [coll]\n  (loop [result #{}\n         xs coll]\n    (if (not (seq xs))\n      result\n      (recur (conj result (filter #(= (type (first xs)) (type %)) xs)) (remove  #(= (type (first xs)) (type %)) xs)))))","problem":50,"user":"51857e64e4b0da5a5be3babe"},{"problem":50,"code":"(fn [xs] (set (vals (reduce (fn [acc x] \n                              (let [x-type (type x)\n                                    type-vect (acc x-type [])]\n                                (assoc acc x-type (conj type-vect x)))) {} xs))))","user":"5b1c16e1e4b03cfeda66ecf2"},{"code":"(fn [x]\n  (vals (group-by type x))\n)","problem":50,"user":"50254e70e4b0b0b8afb15aa7"},{"problem":50,"code":"(fn [sq]\n          (->> sq\n               (group-by type)\n               (map val)))","user":"5c995fa4e4b048ec896c5a96"},{"problem":50,"code":"#(vec (vals (apply merge-with (comp vec concat) (for [k %] {(type k) (vector k)}))))","user":"5b100648e4b0cc2b61a3be17"},{"code":"(fn split-by-type\n  [xs]\n  (loop [s xs\n         acc '()\n         t (type (first s))]\n    (if (empty? s)\n      acc\n      (recur\n       (keep #(if (not= t (type %)) %) s)\n       (concat acc \n               (vector (reduce \n                 (fn [l r]\n                   (if (= t (type r))\n                     (conj l r)\n                     l))\n                 []\n                 s)))\n       (type (first (keep #(if (not= t (type %)) %) s)))))))","problem":50,"user":"5287f34ee4b0239c8a67ae43"},{"problem":50,"code":"(fn [s] \n  (for [t (set (map type s))]\n    (filter #(= t (type %)) s)\n    \n    \n    ))","user":"5720fc08e4b0c5bde472c0a3"},{"problem":50,"code":"(fn [ s] ( map second (group-by type s)) )","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":50,"code":"(fn [s]\n  (loop [i 0\n         m {}]\n    (do (println i m) (if (= i (count s))\n       (set (vals m))\n       (cond (sequential? (nth s i))\n             (recur (inc i)\n                    (if (not (contains? m :seq))\n                      (assoc m :seq (vector (nth s i)))\n                      (assoc m :seq (conj (get m :seq) (nth s i)))))\n             (number? (nth s i))\n             (recur (inc i)\n                    (if (contains? m :n)\n                      (assoc m :n (conj (get m :n) (nth s i)))\n                      (assoc m :n (vector (nth s i)))))\n             (string? (nth s i))\n             (recur (inc i)\n                    (if (contains? m :s)\n                      (assoc m :s (conj (get m :s) (nth s i)))\n                      (assoc m :s (vector (nth s i)))))\n             (keyword? (nth s i))\n             (recur (inc i)\n                    (if (contains? m :k)\n                      (assoc m :k (conj (get m :k) (nth s i)))\n                      (assoc m :k (vector (nth s i))))))))))","user":"57d57f65e4b0bd073c2023b3"},{"code":"(fn [seq]\n  (let [results ()]\n    (into #{} (map vec (filter not-empty (conj results\n                                               (filter (fn [x] (if (= java.lang.String (type x)) x)) seq)\n                                               (filter (fn [x] (if (= java.lang.Long (type x)) x)) seq)\n                                               (filter (fn [x] (if (= clojure.lang.Keyword (type x)) x)) seq)\n                                               (filter (fn [x] (if (= clojure.lang.PersistentVector (type x)) x)) seq)))))))","problem":50,"user":"50052fd0e4b0678c553fc45d"},{"code":"(fn [l] (for [t (set (map type l))]\n           (for [x l :when (= t (type x))] x)))","problem":50,"user":"5084cb7de4b0fb8f40674bfb"},{"problem":50,"code":"(fn [x]\n  (vals (group-by class x)))","user":"584b0422e4b089d5ab817ef4"},{"problem":50,"code":"(fn [s]\n  (let [types (into #{} (map type s))]\n    (for [type types]\n      (filter (partial instance? type) s))))","user":"58cfb517e4b03c36ff7e58b9"},{"code":"(fn [b]\n  (map #(second %) (group-by type b)))","problem":50,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [a]\n(set \n  (map second \n    (apply merge-with concat \n      (map #(hash-map (type %) [%]) a)))))","problem":50,"user":"4f0333f6535dcb61093f6a77"},{"problem":50,"code":"#(vals (group-by (fn [t] (type t)) %))","user":"5722bf99e4b0c5bde472c0d6"},{"code":"#(vals (reduce (fn [m x]\n          (conj m \n            { (type x)\n              (vec\n                (conj (m (type x)) x))} )) {} %))","problem":50,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":50,"code":";#(vals (group-by type %))\n\n\n#(vals (reduce (fn [m x]\n                 (assoc m (class x) (conj (get m (class x) []) x))) {} %))","user":"5707abfce4b0b0fb43fd068d"},{"code":"#(set (map second (group-by type %)))","problem":50,"user":"4eb44d78535d7eef30807360"},{"problem":50,"code":"(fn [l]\n  (vals (reduce (fn [m e]\n            (conj m [(class e) \n                     (if (m (class e))\n                       (conj (m (class e)) e)\n                       [e])]))\n          {} l)))","user":"56051095e4b08b23635d3162"},{"problem":50,"code":"#(->> %1\n      (group-by type)\n      (vals))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":50,"code":"(fn [coll]\n  (set (vals (group-by class coll))))","user":"54fdbe3fe4b07d26eda61d3b"},{"problem":50,"code":"(fn [ung]\n  (for [[typ type-vals] (group-by first  (for [u ung] [(type u) u]))]\n    (map second  type-vals)))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":50,"code":"(fn homogenize [coll]\n  (loop [result-set {}\n         remaining coll]\n    (let [v (first remaining)]\n\t    (cond\n\t      (empty? remaining) (vals result-set)\n\t      (not (contains? result-set (type v)))\n\t      \t(recur  (assoc result-set (type v) [v])\n\t         \t\t(rest remaining))\n          :else (recur (assoc result-set (type v) (conj (get result-set (type v)) v))\n                       (rest remaining))))))","user":"57c0917be4b05aa3c4741c95"},{"code":"(fn spit-by-type [s]\n  (let [put-in-map (fn [m v]\n                     (let [k (-> v type str (clojure.string/split #\"\\s+\") last)]\n                       (if (contains? m k)\n                         (update-in m [k] conj v)\n                         (assoc-in m [k] [v]))))\n        process-items (fn [data]\n                       (loop [s2 data, result {}]\n                         (if (empty? s2)\n                           result\n                           (recur (rest s2) (put-in-map result (first s2))))))\n        ]\n    (vals (process-items s))))","problem":50,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn x-collect\r\n  [coll]\r\n\t(vals\r\n\t\t(reduce \r\n\t\t(fn [data, x] \r\n\t\t\t(let [type-vec (get data (type x) [])]\r\n\t(assoc data (type x) (conj type-vec x))\r\n\t\t\t)\r\n) {} coll)))","problem":50,"user":"4ddeb916535d08e6dec9fdd9"},{"code":"(fn [xs] (vals (group-by #(type %1) xs)))","problem":50,"user":"4e4ca885535dc968683fc4df"},{"problem":50,"code":"#(loop [seq %\n        types {}]\n   (if (empty? seq)\n     (set (vals types))\n     (let [head (first seq)\n           type (type head)\n           list (get types type [])]\n       (recur (rest seq) (assoc types type (conj list head))))))","user":"57155980e4b07c98581c3ad7"},{"problem":50,"code":"(fn [xs]\n  (let [taketype (fn [ys outset]\n                   (if-let [t (type (first ys))]\n                     (recur (remove #(= (type %) t) ys) (conj outset (filter #(= (type %) t) ys)))\n                     outset))]\n    (taketype xs #{})))","user":"51000111e4b00d7ad4cab15e"},{"code":"(fn split-by-type [coll]\n  \"Return set with collections of elements splitted according to type\"\n  (let [type-assoc (fn [m el]\n                     (let [t (type el)]\n                       (assoc m t (conj (or (m t) []) el))))]\n    (-> (reduce type-assoc {} coll)\n        (vals)\n        (set))))","problem":50,"user":"523b82efe4b07becd5be21f0"},{"code":"(fn [coll]\n   (loop [result {} elements coll]\n     (if elements\n       (recur\n         (if (result (class (first elements)))\n           (into result {(class (first elements)) (conj (result (class (first elements))) (first elements))})\n           (into result {(class (first elements)) [(first elements)]})\n           )\n         (next elements))\n       (vals result)\n       )   \n   )\n   )","problem":50,"user":"5106dc1be4b01150e115ebf0"},{"code":"(fn [s] (set (map (fn [ti] (vec (filter #(= (type %) ti) s))) (set (map type s)))))","problem":50,"user":"5235a902e4b0a643f2dcb750"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce #(update-in %1 [(type %2)] (fn [x] (conj (vec x) %2))) {} coll)))","user":"524740e7e4b05ef8e38e635d"},{"problem":50,"code":"(fn splittype\n  [lst]\n  (into #{} (for [tp (set (map (fn [el] (type el) ) lst))]\n    (filter #(= tp (type %))  lst)\n\n    ))\n\n  )","user":"59692530e4b069c0a1a197e4"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce #(let [key (type %2)]\n                   (assoc-in %1 [key]\n                             (conj (get %1 key []) %2)))\n                {}\n                coll)))","user":"60b1add0e4b0e0fa5f1b4227"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (for \n    [the-type (-> (map type coll) distinct)] \n    (filter #(= the-type (type %)) coll) ))","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [coll]\n  (loop [tmp {} col coll]\n\t   (let [cur (first col)] ' (swank.core/break)\n\t\t(if (nil? cur)\n\t\t    (vals tmp)\n\t\t    (recur  (assoc tmp (class cur) (conj (get tmp (class cur) []) cur)) (next col))))))","problem":50,"user":"4e739e13535dff18050a9c76"},{"problem":50,"code":"(fn [x] (partition-by type (sort-by #(str (type %) ) x)))\n\n\n;better solution\n; #(vals (group-by type %))","user":"55e01f4ee4b050e68259b406"},{"problem":50,"code":"(fn [xs] \n  (vals (group-by #(type %) xs)))","user":"55815973e4b05c286339e0f6"},{"problem":50,"code":"(fn f[l]\n  (map\n    (fn [t]\n      (vec \n        (filter\n          (fn [el]\n            (= t (type el)))\n          l)))\n    (set (map type l))))","user":"5626447fe4b00e49c7cb47bd"},{"code":"(fn typesplit [col]\n  (->> col\n       (reduce (fn [c x]\n            (let [t (type x)]\n               (assoc c t (cons x (c t))))) {})\n       vals\n       (map reverse)))","problem":50,"user":"50053d6ce4b0678c553fc45e"},{"problem":50,"code":"(fn [stuff] (vals (group-by class stuff)))","user":"54f06aede4b024c67c0cf896"},{"problem":50,"code":"(fn [s]\n   (let [split (fn [s types acc]\n                 (if (empty? s) (set acc)\n                   (let [type-name (type (first s))\n                         type-numb (types type-name)]\n                     (println type-name)\n                     (if (nil? type-numb) (recur s (assoc types type-name (count types)) (conj acc []))\n                       (recur (rest s) types (assoc acc type-numb (conj (nth acc type-numb) (first s))))))))] \n     (split s {} [])))","user":"57780e4fe4b0979f89651657"},{"problem":50,"code":"(fn split-by-type [lst]\n  (set (vals (group-by type lst))))","user":"534f8c9ae4b084c2834f4acd"},{"problem":50,"code":";;(fn split-by-type [xs]\n;;  (for [[key value] (group-by class xs)]\n;;    value))\n\n#(vals (group-by class %))","user":"593910eae4b02506e01a29f4"},{"problem":50,"code":"(fn type-split\n  [xs]\n  (set (vals (group-by class xs))))","user":"5c222b7de4b07e362c230588"},{"problem":50,"code":"(fn [sq]\n  (let [tests [sequential? number? string? keyword?]]\n    (filter seq (map (fn [tst] (filter tst sq)) tests))))","user":"55b527cbe4b01b9910ae2985"},{"code":"(fn [l] (set (vals (group-by type l))))","problem":50,"user":"527ba695e4b03e8d9a4a7596"},{"problem":50,"code":"(fn [items]\n  (loop [result [] [head & split-list] items]\n    (if (nil? head)\n      result\n      (recur (conj result \n                   (filter #(if (= (type head) (type %)) %) \n                           (conj split-list head)))\n             (filter #(if (not= (type head) (type %)) %) split-list)))))","user":"55a0d79fe4b0acc240e31502"},{"problem":50,"code":"(fn part-by-type [coll]\n  (reduce\n   (fn [xs x]\n     (conj xs (filter #(= x (type %)) coll)))\n   []\n   (set (map type coll))))","user":"542cb77ae4b0dad94371f2aa"},{"problem":50,"code":"(fn [items]\n   (let [get-index (fn [item lst]\n                     (loop [rm (seq lst), i 0]\n                       (cond (empty? rm) -1\n                             (= (type item) (-> rm first first type)) i\n                             :else (recur (rest rm) (inc i)))))]\n     (loop [rm (seq items), acc (vector)]\n       (cond (empty? rm) acc\n             :else (let [item (first rm)\n                         i (get-index item acc)]\n                     (cond (= -1 i) (recur (rest rm) (conj acc (vector item)))\n                           :else (recur (rest rm) (assoc acc i (conj (acc i) item)))))))))","user":"538e36c7e4b0b51d73faae81"},{"problem":50,"code":"#(vals (loop [s %\n              h {}]\n         (if (empty? s)\n           h\n           (recur (rest s)\n                  (assoc h\n                    (class (first s))\n                    (if (not (h (class (first s))))\n                      [(first s)]\n                      (conj (h (class (first s))) (first s))))))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":50,"code":"#(vals\n        (group-by\n         type\n         %))","user":"56949fc5e4b0dcc4269f4120"},{"problem":50,"code":"(fn [coll] (vals (reduce #(update-in %1 [(class %2)] (fn [old] (conj (or old []) %2))) {} coll)))","user":"5773f3a9e4b0979f896515f2"},{"code":"#(->> %\n\t  (group-by type)\n\t  vals)","problem":50,"user":"502ade49e4b0614b52996120"},{"problem":50,"code":"(fn [coll]\n   (-> (group-by type coll)\n     vals))","user":"51bd255ce4b0df1216cefd94"},{"code":"(fn [seq] (vals (group-by class seq)))","problem":50,"user":"4f4ac35ae4b0d56e7bb92c18"},{"code":"(fn [items]\n  (map val (group-by type items)))","problem":50,"user":"511720eae4b0063b4e3e16da"},{"problem":50,"code":"; stolen elegant solution #(vals (group-by type %))\n(fn typefilter [coll]\n    (for [typ (set (map #(type %) coll))]\n      (filter #(= typ (type %)) coll)\n    )\n)","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":50,"code":";; http://www.4clojure.com/problem/50\n(fn split-by-type\n  [coll]\n  (set (vals (reduce (fn [a b] (update-in a [(type b)] #(conj (vec %1) %2) b)) {} coll))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn [coll] (map  #(filter (fn [x] (instance? % x)) coll) (set  (map type coll))))","problem":50,"user":"52f528f0e4b05e3f0be25f2a"},{"code":"(fn [x]\n  (let [p #(str (type %))]\n    (partition-by p (sort-by p x))))","problem":50,"user":"4e6472b7535d8ccf87e9fe6c"},{"code":"(fn s [x]\n  (partition-by type (sort-by #(str (type %)) x)\n))","problem":50,"user":"4ef0f1a1535dced4c769f212"},{"problem":50,"code":"#(->>\n  %\n  (group-by class)\n  (map rest)\n  (map first)\n  (into #{}))","user":"5895385fe4b00487982d5279"},{"code":"(fn foo [x]\n  (if (empty? x) x\n    (concat (list ((fn bar [x y]\n                     (if (empty? x) x\n                       (if (= (type y) (type (first x)))\n                              (concat (list (first x)) (bar (rest x) y))\n                              (bar (rest x) y)))) x (first x)))\n            (foo ((fn [x y]\n                    (remove #(= (type y) (type %)) x)) x (first x))))))","problem":50,"user":"5078300de4b0fc74642bff66"},{"code":"(fn [s]\n  (letfn [(strip [coll v]\n            (let [t (type v) prev (coll t)]\n              (assoc coll t (if (nil? prev) [v] (conj prev v)))))]\n    (.values (reduce strip {} s))))","problem":50,"user":"511d6a01e4b022853b0e07a5"},{"problem":50,"code":"(fn split-by-type [col]\n  (vals (group-by type col))\n  )","user":"5d321852e4b01671435dbce8"},{"code":"(fn [xs]\n  (set (vals (group-by class xs))))","problem":50,"user":"5173726be4b098276e74652c"},{"code":"(fn [v]\n  (vals (group-by #(type %) v))\n  )","problem":50,"user":"52d42021e4b09f7907dd132a"},{"code":"(fn [col]\n  (map reverse (vals \n    (reduce (fn [result elem] \n\t\t          (assoc result (type elem) (cons elem (get result (type elem)))))\n\t\t  {} col))))","problem":50,"user":"4fc7db47e4b0ee37620e182a"},{"problem":50,"code":"(fn [s] (vals (reduce #(assoc %1 (type %2) (conj (%1 (type %2) []) %2)) {} s)))","user":"4f070ce6535dcb61093f6c1e"},{"problem":50,"code":"(fn [sq]\n  (vals (group-by #(type %) sq)))","user":"59032c0fe4b022d14a2aaf9f"},{"code":"(fn [coll]\n   (vals (group-by type coll)))","problem":50,"user":"506c0a02e4b0eda3100c090d"},{"code":"(fn f [x]\r\n  (vals (group-by type x))\r\n  )","problem":50,"user":"50a85af1e4b054305ba5a833"},{"problem":50,"code":"#(loop [kinds {} remaining %]\n   (let [kind (class (first remaining))]\n     (cond\n      (empty? remaining) (vals kinds)\n      (contains? kinds kind) (recur kinds (rest remaining))\n      :else (recur (assoc kinds kind (filter (fn [item] (= (class item) kind)) %)) (rest remaining)))))","user":"55d332f5e4b0e31453f64a5f"},{"problem":50,"code":"(fn [lst0]\n  (loop [lst lst0 mp {}]\n    (if (empty? lst)\n      (map reverse (vals mp))\n      (let [k (type (first lst))]\n        (recur (rest lst)\n               (assoc mp k (cons (first lst) (mp k)))\n               )))))","user":"5c62979fe4b0fca0c162264c"},{"code":"(fn [s] (map second (group-by type s)))","problem":50,"user":"4f244f26e4b0d66497709fea"},{"code":"(fn [xs]\n  (map (fn [item-type] \n         (filter #(= (type %) item-type) xs))\n       (set (map #(type %) xs))))","problem":50,"user":"5102ac9de4b00c483ae176fa"},{"problem":50,"code":"(fn f [x]\n  (loop [s x, trh [], mir [], t (type (first x)), res #{}]\n    (if (or (seq s) (seq trh))\n      (recur (if (seq s)\n               (rest s)\n               trh)\n             (if (seq s)\n               (if (= (type (first s)) t)\n                 trh\n                 (conj trh (first s)))\n               [])\n             (if (seq s)\n               (if (= (type (first s)) t)\n                 (conj mir (first s))\n                 mir)\n               [])\n             (if (seq s)\n               t\n               (type (first trh)))\n             (if (seq s)\n               res\n               (conj res mir)))\n      (conj res mir))))","user":"593d6793e4b069cdc2982ba6"},{"code":"#(map (fn [x] (filter (partial instance? (type x)) %)) %)","problem":50,"user":"4fa4ef2ee4b081705acca1a9"},{"problem":50,"code":"(fn [s]\n  (map #(reverse %)\n    (vals\n      (reduce\n        (fn [result each]\n          (assoc result (type each) (cons each (get result (type each)))))\n        {}\n        s))))","user":"5989e080e4b021a7a535fed6"},{"code":"(fn [col]\r\n  (clojure.set/difference (set \r\n    (for [f (list keyword? string? coll? number?)]\r\n    (for [x col :when (f x)] x))) #{()}))","problem":50,"user":"50bfe725e4b080409b860f26"},{"problem":50,"code":"(fn split-by-type [coll]\n  (reduce (fn [cons-coll current] \n            (loop [inner-coll (first cons-coll)\n                   outer-coll cons-coll]\n              (println inner-coll)\n              (if (empty? inner-coll) \n                (conj cons-coll (vector current))\n                (if (some #(= (type current) (type %)) inner-coll)\n                  (assoc cons-coll (.indexOf cons-coll inner-coll) \n                                   (conj inner-coll current))\n                  (recur (first (rest outer-coll)) (rest outer-coll))))))\n          []\n          coll))","user":"53d40508e4b00fb29b221332"},{"problem":50,"code":"(fn __ [s] (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} s)))","user":"5be2e670e4b0ed4b8aab4ccc"},{"problem":50,"code":"(fn seperate-types [xs]\n  (->> xs\n       (reduce (fn [m v] (update-in m [(type v)] (fnil conj [] ) v)) {})\n       (vals)))","user":"58e37946e4b005f69f193cae"},{"problem":50,"code":"(fn  [s]\n    (vals\n        (group-by #(cond \n                         (= (class %) (class 1)) \"Long\"\n                         (= (class %) (class :a)) \"Keyword\"\n                         (= (class %) (class \"a\")) \"String\"\n                         (= (class %) (class [])) \"PersistentVector\")\n                     s)))","user":"57e3f709e4b0bfb2137f5aaf"},{"problem":50,"code":"(fn f50 [x]\n (vals (group-by type x)))","user":"535aee3be4b04ce2eb3ed2aa"},{"problem":50,"code":"(fn [items] \n  (let [numbers (filter #(= (type %) java.lang.Long) items)\n        keywords (filter #(= (type %) clojure.lang.Keyword) items)\n        vectors (filter #(= (type %) clojure.lang.PersistentVector) items)\n        strings (filter #(= (type %) java.lang.String) items)]\n        (filter #(not (empty? %)) (list numbers keywords vectors strings))))","user":"550b5c10e4b06e50f9beb143"},{"problem":50,"code":"(fn [xs] (vals (reduce #(update-in %1 [(class %2)] (fnil conj []) %2) {} xs)))","user":"567b39b6e4b05957ce8c61a3"},{"problem":50,"code":"(fn \n  [x]\n(vals (group-by type x))\n  \n\n  )","user":"5650ac8be4b0284900eef6c2"},{"code":"(fn [c]\n (vals\n   (reduce\n    (fn [m x]\n      (let [a #(conj (or % []) %2)\n            u #(update-in m [%] a x)]\n        (cond (number? x)\n              (u :n)\n              (keyword? x)\n              (u :k)\n              (string? x)\n              (u :s)\n              (vector? x)\n              (u :v)\n              :else (u :?)\n              ))) {} c)))","problem":50,"user":"512700c4e4b083bb8f88cf14"},{"problem":50,"code":"(fn [col]\n  (map reverse (vals (reduce (fn [newcols val]\n    (merge newcols {(class val) (conj (newcols (class val)) val) } )\n  ) {} col)))\n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"problem":50,"code":"(fn [c]\n  (let [types (set \n               (map type c))]\n    (for [t types]\n      (filter #(= (type %) t) c))))","user":"5c56e264e4b0fb8c5ffd9a39"},{"problem":50,"code":"(fn [sequ]\n  (vals (group-by type sequ)))","user":"5777c3d6e4b0979f8965164f"},{"problem":50,"code":";;#(vals (group-by type %))\n;\n#(->> % (group-by type) vals)","user":"595fd721e4b066ee0a44b06e"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (reduce (fn [acc c]\n                 (update-in acc [(type c)] concat [c])) {})\n       vals\n       set))","user":"5256c4c1e4b0541d1855ba36"},{"problem":50,"code":"(fn sbtype [coll]\n  (vals (reduce (fn [ret e]\n                  (assoc ret (type e) (let [v (get ret (type e))]\n                                        (if v (conj v e) [e])))) {} coll)))","user":"5c547cf0e4b0fb8c5ffd9a0b"},{"code":"(fn [mixed]\n  (loop [strings []\n         symbols []\n         numbers []\n         vectors []\n         head (first mixed)\n         tail (rest mixed)]\n    (cond \n      (nil? head) (filter not-empty [strings symbols numbers vectors])\n      :else (case (str (.getClass head))\n              \"class java.lang.String\" (recur (conj strings head) symbols numbers vectors (first tail) (rest tail))\n              \"class clojure.lang.Keyword\" (recur strings (conj symbols head) numbers vectors (first tail) (rest tail))\n              \"class java.lang.Long\" (recur strings symbols (conj numbers head) vectors (first tail) (rest tail))\n              \"class clojure.lang.PersistentVector\" (recur strings symbols numbers (conj vectors head) (first tail) (rest tail))))))","problem":50,"user":"4f6fd91ae4b07046d9f4efed"},{"code":"(fn [v]\n  (set\n   (partition-by type\n                 (sort-by #(str (type %)) v)\n                 )\n   )\n  )","problem":50,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"(fn [x] \n  (vals (group-by type x)))","problem":50,"user":"525aa499e4b0cb4875a45cf7"},{"problem":50,"code":";(print (\n  (fn [coll]\n    (vals (group-by type coll)))      \n;#{1 2 :a 3 :b}))","user":"5c5d2e90e4b01df32ab732af"},{"code":"(fn [coll]\n  (->> coll\n    (group-by #(class %))\n    vals))","problem":50,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":50,"code":"(fn [c]\n  (loop [c c result '()] \n    (if (empty? c)\n      result\n      (recur\n       (filter (fn [x] (not (= (type x) (type (first c))))) c)\n       (conj result ((fn select-type [b-coll b-type]\n                       (loop [c-coll b-coll result '()]\n                         (if (empty? c-coll)\n                           (reverse result)\n                           (recur\n                            (rest c-coll) \n                            (if (= (type (first c-coll)) b-type) \n                              (conj result (first c-coll)) \n                              result)))))\n                     c (type (first c)))\n             )\n       )\n      )\n    )\n  )","user":"563d12f9e4b0bfe05bf11845"},{"problem":50,"code":"(fn [s] (partition-by type (sort #(compare (str (type %1)) (str (type %2))) s)))","user":"589e704ae4b02bd94d917e5e"},{"problem":50,"code":"#(vals (reduce (fn[m i]\n          (let[iv (m (class i))]\n           (assoc m (class i) (conj (vec iv) i)))) {} %))","user":"541619e8e4b01498b1a719f9"},{"problem":50,"code":"(fn [seq] (let [itemSorter (fn [agg item] (let [type (str (type item))] (assoc agg type (conj (vec (get agg type)) item))))]\n            (vals (reduce itemSorter {} seq))))","user":"5e566668e4b027a2e10ac0f9"},{"code":"(fn [coll] (for [x (set (map type coll))] (filter #(= (type %) x) coll)))","problem":50,"user":"524469dee4b0d8acf9ed6a9d"},{"code":"(fn split-by-type [coll]\r\n  (loop [result {} coll coll ]\r\n    (if (empty? coll)\r\n      (vals result)\r\n      (recur\r\n        (let [tp (type (first coll))]\r\n          (assoc result tp\r\n            (conj\r\n              (if (empty? (result tp)) [] (result tp))\r\n              (first coll))))\r\n        (rest coll)))))","problem":50,"user":"4fd170fce4b04c3a95aa0411"},{"problem":50,"code":"(fn [s]\n    (vals (group-by (fn [x]\n                      (type x))\n                    s)))","user":"6026d2cae4b0d5df2af22232"},{"code":"(fn split-by-type\r\n  ([coll]\r\n     (split-by-type coll '()))\r\n  ([coll split-coll]\r\n     (if (= '() coll)\r\n       split-coll\r\n       (let [filter-by-class #(= (class %) (class (first coll)))\r\n      class-coll (filter filter-by-class coll)\r\n\t    rest-coll (remove filter-by-class coll)]\r\n\t(split-by-type rest-coll (cons class-coll split-coll))))))","problem":50,"user":"4f17ab99535d64f603146457"},{"code":"(fn split-by-type\n  [coll]\n  (loop [coll coll\n         res #{}]\n    (if (not (empty? coll))\n      (let [f (fn [coll item]\n                (= (type (first coll)) (type item)))]\n        (recur\n         (remove (partial f coll) coll)\n         (conj res (filter (partial f coll) coll))))\n      res)))","problem":50,"user":"51937eb3e4b04df54c098022"},{"problem":50,"code":"(fn [coll]\n   (let [t (reduce #(if (get %1 (str (type %2))) \n                      (assoc %1 (str (type %2)) \n                             (conj (%1 (str (type %2))) %2))\n                      (assoc %1 (str (type %2)) [%2]))\n               (sorted-map) coll)]\n        (map #(vec (get t %)) (keys t))))","user":"56d3bc2de4b0ea9b8538f7b0"},{"code":"(fn [c] (map last (group-by #(type %) c)))","problem":50,"user":"4f0f01c0535d0136e6c22329"},{"code":"(fn [s] (->> s (group-by type) vals ) )","problem":50,"user":"51729002e4b044b2ef48a850"},{"problem":50,"code":"#(map (fn [[item-type valo]] (identity valo)) (group-by type %))","user":"575aa61ae4b02ea11479934e"},{"problem":50,"code":"(fn [x]\n  (vals (reduce #(if (not (contains? %1 (type %2))) (assoc %1 (type %2) (vector %2)) (assoc %1 (type %2) (conj (%1 (type %2)) %2))) {} x)))","user":"5bf0aefde4b0a6d31fed215a"},{"problem":50,"code":"(fn group-by-type [coll]\n  (into #{} (for [pair (group-by type coll)]\n              (second pair))))","user":"53fd66a4e4b0de5c418485e3"},{"problem":50,"code":"(fn agg [coll]\n  (set (vals (group-by #(type %) coll))))","user":"4daeff24edd6309eace4d16e"},{"code":"(fn [s] (map second (group-by class s)))","problem":50,"user":"4ddbf54e535d02782fcbe9ff"},{"code":"#(map peek (group-by type %))","problem":50,"user":"529e8ba9e4b04e0c58e87b99"},{"problem":50,"code":"(fn [x] (reduce-kv #(conj %1 %3) #{} (group-by type x)))","user":"5c481764e4b0e06e1360a3ba"},{"code":"(fn [stuff]\n  (vals (apply merge-with\n    ;(comp vec flatten vector)\n    (fn [left right] \n      (if-not (= (type left) (type right))\n        (conj left right)\n        (if (not (vector? right))\n          (vector left right)\n          (if (= (type (first left)) (type (first right)))\n            (vector left right)\n            (conj left right)))))\n    (map #(hash-map (type %) %) stuff))))","problem":50,"user":"4e98a6d0535dbda64a6f6b5e"},{"problem":50,"code":"(fn [a]\n  (loop [[f & r] a o [] dict []]\n    (if (nil? f) o\n      (let [f-type (type f)\n            index (.indexOf dict f-type)]\n        (recur r\n              (if (= index -1) \n                  (conj o [f])\n  \t\t     \t  (assoc o index (conj (get o index) f)))\n      \t\t  (if-not (some #(= f-type %) dict) (conj dict f-type) dict))))))","user":"59ddae03e4b01968742fed65"},{"problem":50,"code":"(fn split-by-type [xs]\n  (let [collect (fn [test ys] (reduce #(if (test %2) (conj % %2) %) [] ys))\n        tests [number? keyword? string? coll?]]\n    (-> (for [test tests] (collect test xs))\n        set\n        (disj []))))","user":"50aa777fe4b056ee01935866"},{"problem":50,"code":";#(vals (group-by type %))\n(fn [l]\n(vals (reduce (fn [acc item] (assoc acc (class item) (conj (or (get acc (class item)) []) item))) {} l)))","user":"582a2d4fe4b051871117bf55"},{"code":"(fn [sq] (vals (group-by type sq)))","problem":50,"user":"4f71db68e4b07046d9f4f015"},{"problem":50,"code":"(fn [s] (->> s (group-by type) (map second)))","user":"53fc63dce4b0de5c4184859f"},{"problem":50,"code":"(fn [i] \n   (let [si (sort-by #(str (class %)) i)]\n     (loop [i (rest si) o '() s (vector (first si))]\n            (cond\n             (empty? i) (conj o s)\n             (= (class (first i)) (class (first s))) (recur (rest i) o (conj s (first i)))\n             :else (recur (rest i) (conj o s) (vector (first i)))))))","user":"5f3567d6e4b0574c87022c44"},{"code":"(fn [coll]\n    (loop [coll coll\n           answer {}]\n      (if (nil? coll) (vals answer)\n          (recur (next coll)\n                 (let [t (type (first coll))]\n                   (assoc answer t\n                          (conj (into [] (get answer t)) (first coll))))))))","problem":50,"user":"4e89e939535d3e98b8023287"},{"problem":50,"code":"(fn group-t [sq]\n  (vals (group-by #(type %) sq)))","user":"5fee18f2e4b05ac5b16ea1d2"},{"code":"(fn [coll]\n   (loop [coll coll type2xs {}]\n      (if (empty? coll)\n        (set (vals type2xs))\n        (let [head (first coll)\n              t (type head)\n              v (get type2xs t)\n              v* (vec (conj v head))]\n          (recur (rest coll) (assoc type2xs t v*))))))","problem":50,"user":"4e88feef535d8b9bb0147ca8"},{"problem":50,"code":"(fn \n  [l]\n  (set (vec(map (fn [v] (second v)) (group-by #(type %) l) ))))","user":"5c0466a3e4b0bdcf453d1680"},{"problem":50,"code":"(fn [coll]\n(vals (group-by type coll)))","user":"565b941ce4b068f2fe63dc07"},{"problem":50,"code":"(fn [s]\n                     (set (vals\n                            (loop [types {} in s]\n                              (if (empty? in)\n                                types\n                                (recur (let [f (first in)\n                                             t (type f)]\n                                         (if (contains? types t)\n                                           (assoc types t (conj (get types t) f))\n                                           (assoc types t (vector f))))\n                                       (rest in)))))))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":50,"code":"(fn [cl] (map val (reduce #(update-in %1 [(class %2)] (fn [cc v] (if (empty? cc) [v] (conj cc v))) %2) {} cl)))","user":"549375e4e4b0b312c081ff4e"},{"code":"#(for [[_ v] (group-by type %)] v )","problem":50,"user":"4f8b27b3e4b02e764a0a5179"},{"problem":50,"code":"(fn split-by-type-solution\n  [in-col] ;; update args as needed\n  ;; Write a function which takes a sequence consisting of items with different types and splits them up into a set of homogeneous sub-sequences. The internal order of each sub-sequence should be maintained, but the sub-sequences themselves can be returned in any order (this is why 'set' is used in the test cases).\n  (vals (group-by type in-col)))","user":"54df955ee4b024c67c0cf7af"},{"code":"(fn [xs]\n  (->> xs\n       (group-by class)\n       vals))","problem":50,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn [x]\n  (vals (reduce\n    #(update-in %1 [(type %2)] concat (vector %2))\n    {} x)\n  )\n)","problem":50,"user":"4ea1ecfa535d7eef308072bb"},{"problem":50,"code":"(fn [x]\n \t(vals (group-by type x)))","user":"5c32ea85e4b0d62ef62d9f3e"},{"code":"(fn split-by-type [in-vec]\n  (set (vals\n\n  (loop [falling-vec in-vec type-map {}]\n    (let [current-val (first falling-vec)]\n      ;; is the type of the current value a key in type-map?\n      (cond (= 0 (count falling-vec)) type-map\n        \n        (contains? (set (keys type-map)) (type current-val))\n            ;; then move forward, adding the new value to the type-map\n            (recur (rest falling-vec) (assoc type-map (type current-val)\n                                             ;; here we use as the map as a function\n                                             (conj (type-map (type current-val)) current-val)))\n            \n            ;; if the type does not yet belong to the map, then we add it along with the new value\n            :else (recur (rest falling-vec) (conj type-map {(type current-val) [current-val]}))))))))","problem":50,"user":"53703287e4b0fc7073fd6e8f"},{"code":"(fn [s]\n (apply hash-set (vals (group-by class s))))","problem":50,"user":"50901b2ee4b0ea685a20f774"},{"problem":50,"code":"(fn [input]\n  (->> input\n       (map #(vec [(type %) %]))\n       (reduce (fn [m x]\n                 (let [coll (get m (first x))]\n                   (if coll\n                     (assoc m (first x) (conj coll (last x)))\n                     (assoc m (first x) [(last x)]))))\n               {})\n       (vals)))","user":"59476687e4b07ddc2dafad9c"},{"code":";#(partition-by type (sort-by (comp str type) %))\n#(vals (group-by type %))","problem":50,"user":"52d00832e4b07d0d72b273b4"},{"code":"(fn [coll]\n  (vals (reduce #(update-in % [(type %2)] (fnil (fn [a b] (conj a b)) []) %2) {} coll)))","problem":50,"user":"4fb79872e4b081705acca2d2"},{"problem":50,"code":";; #(map second (group-by type %))\n#(map second (group-by class %))","user":"56ca0da9e4b0ea9b8538f715"},{"code":"(fn [s]\n  (filter seq\n    (vector\n      (filter number? s)\n      (filter keyword? s)\n      (filter coll? s)\n      (filter string? s))))","problem":50,"user":"4f253a49e4b0d66497709ff3"},{"problem":50,"code":"(fn [xs] (vals (reduce (fn [m b] \n(let [t (type b)] (assoc m t (conj (get m t []) b)))) {} xs)))","user":"57f9011ee4b0d3187e900935"},{"problem":50,"code":"(fn group-by-type\n  [s]\n  (vals (group-by class s)))","user":"563f1493e4b08d4f616f5ecf"},{"problem":50,"code":"(fn\n  [coll]\n  (loop [result {}\n         trimmed-coll coll]\n    (if (empty? trimmed-coll)\n      (vals result)\n      (let [head (first trimmed-coll)\n            tail (rest trimmed-coll)\n            head-type (str (type head))]\n        (if (not (contains? result head-type))\n          (recur (assoc result head-type [head])\n                 tail)\n          (recur (assoc result head-type (conj (get result head-type) head))\n                 tail))))))","user":"5dd65ea4e4b0948ae9d9ad7f"},{"code":"(fn [s]\n  (->>\n   s\n   (map #(hash-map (class %) [%]))\n   (apply merge-with (comp vec concat))\n   (map second)))","problem":50,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":50,"code":"(fn [coll]\n        (vals (reduce (fn [map val]\n                        (update-in map [(type val)] #(if (nil? %) (vector val) (conj % val)))) {} coll)))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":50,"code":"(fn [s]\n  (set\n   (map\n    (fn [t]\n      (filter #(= (class %) (class t)) s))\n    s)\n   ))","user":"541ef7e2e4b01498b1a71a92"},{"code":";(fn [coll]\n;  (loop [result #{}, coll coll]\n;    (if (empty? coll)\n;      result\n;      (let [t (type (first coll)), pred #(= t (type %)), npred (complement pred)]\n;        (recur (conj result (filter pred coll)) (filter npred coll))))))\n#(map second (group-by class %))","problem":50,"user":"4edab806535d10e5ff6f5311"},{"problem":50,"code":"(fn [s]\n (map\n  last\n  (group-by class s)))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":50,"code":"(fn [stuff-to-split]\n  (vals (group-by #(type %) stuff-to-split)))","user":"5a593521e4b05d388ecb6c93"},{"problem":50,"code":"(fn fun [col]\n  (vals\n    (reduce \n      (fn [resultMap el]\n        (let [keyMap (type el)\n              setEl (get resultMap keyMap [])]\n\n          (assoc resultMap keyMap (conj setEl el))\n        )\n      )\n    {}\n    col)\n  )\n)","user":"5da20e73e4b000c986472be1"},{"problem":50,"code":"(fn [s]\n  (map #(filter (fn [e] (= (class e) %)) s)\n       (map class s)))","user":"53acaf1fe4b047364c04445f"},{"problem":50,"code":"(fn [xs] (into #{} (remove empty? (map #(filterv % xs) [keyword? integer? string? vector?]))))","user":"5b72b36ce4b047b03b2036a9"},{"code":"#( vals ( group-by type %))","problem":50,"user":"4f030775535dcb61093f6a43"},{"problem":50,"code":"(fn __ [aseq]\n  (vals (reduce #(assoc %1 (class %2)\n                       (conj (get %1 (class %2) []) %2))\n               {} aseq)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn [v]\n  (map vec (map reverse (vals (reduce (fn [m k] (update-in m [(type k)] conj k)) {} v)))))","problem":50,"user":"4dade9e9c9a9d6ed4799dc57"},{"problem":50,"code":"(fn [coll] \n  (map \n    #(filter (fn [elem] (= % (type elem))) coll) \n\t(distinct (map #(type %) coll))))","user":"51eec1a6e4b0871fa145d98d"},{"code":"#(map reverse\n  (vals\n    (reduce\n      (fn [memo item]\n          (let [ itype   (type item) ]\n               (assoc memo itype (conj (memo itype) item))\n          )\n      )\n      {}\n      %\n    )\n  )\n)","problem":50,"user":"504eb604e4b069badc5a33c4"},{"problem":50,"code":"(fn [s]\n   (set (filter not-empty (concat (list (filter keyword? s)) (list (filter string? s)) (list (filter vector? s)) (list (filter number? s))))))","user":"4e8849c5535d8b9bb0147ca4"},{"code":"(fn [coll]\r\n    (->> coll\r\n        (reduce (fn [acc item]\r\n                    (let [key (type item)\r\n                          subseq (get acc key [])]\r\n                      (assoc acc key (conj subseq item)))) {} )\r\n        vals))","problem":50,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn blah [coll]\n    (loop [type-map {}\n           remaining-coll coll]\n      (if (empty? remaining-coll)\n        (vals type-map)\n        (recur (assoc type-map (type (first remaining-coll)) \n                      (conj (get type-map (type (first remaining-coll)) []) \n                            (first remaining-coll))) \n               (rest remaining-coll)))))","problem":50,"user":"4f17aa97535d64f603146456"},{"problem":50,"code":"(fn [s]\n  (set (vals (group-by type s))))","user":"5686640ae4b0dcc4269f4050"},{"code":"(fn [sq] \n  (vals \n    (apply merge-with concat \n      (map (fn [x] {(type x) [x]}) sq))))","problem":50,"user":"5025b93ce4b0c969f0b056df"},{"problem":50,"code":"#(map\n (fn [[k v]] v) \n (group-by type %)\n)","user":"553b8fdbe4b09218d5f45004"},{"problem":50,"code":"#(set ( map second (group-by type %)))","user":"4e6a5728535d8ccf87e9fecf"},{"code":"(fn split-by-type [s]\n  (->> s\n    (reduce (fn [a e]\n              (let [s (a (class e))\n                    s (if (seq s) s [])]\n                (assoc a (class e) (conj s e))))\n            {})\n    vals\n    set))","problem":50,"user":"50a7ef7fe4b090657f4a5ce0"},{"problem":50,"code":"#(->>\n  (group-by type %)\n  (map second)\n)","user":"5c219c0fe4b07e362c230581"},{"problem":50,"code":"(fn\n  [xs]\n  (into #{}\n        (vals\n         (reduce\n          (fn [acc v]\n            (assoc acc (type v)\n                   (if-let [x (get acc (type v))]\n                     (conj x v)\n                     [v])))\n          {} xs))))","user":"5ef18431e4b07c55ae4a0529"},{"code":"(fn [s]\r\n  (->>\r\n    (map hash-map (map type s) (map vector s))\r\n    (apply merge-with concat)\r\n    vals\r\n    set))","problem":50,"user":"504e14c2e4b078edc5f593bf"},{"code":"(fn [s]\n  (loop [se s acc {}]\n    (if (empty? se)\n      (set (vals acc))\n      (let [it (first se)\n            key (type it)\n            val (get acc key [])]\n        (recur (rest se) (assoc acc key (conj val it)))))))","problem":50,"user":"4f418eaee4b0d7d3c9f3fce9"},{"problem":50,"code":"#(vals (reduce (fn [accum x] \n           (assoc accum (class x) (conj (get accum (class x) []) x)))\n         {} %))","user":"5764cc01e4b0994c1922fc05"},{"code":"(fn [c] (vals (group-by #(.getClass %) c)))","problem":50,"user":"4e95f5a5535dbda64a6f6b3b"},{"code":"(fn [x]\n  ((fn helper [result x2]\n     (if (empty? x2)\n       result\n       (helper (conj result (filter #(= (type %) (type (first x2))) x2))\n               (filter #(not= (type %) (type (first x2))) x2))))\n   #{}\n   x))","problem":50,"user":"51547920e4b084ca81ee2e1c"},{"problem":50,"code":"(fn split-by-type \n  ([a-seq] (split-by-type a-seq {}))\n  ([a-seq splitted]\n   (let [to-map (fn [x]\n                  (if (contains? splitted (class x))\n                    (assoc splitted (class x) (conj (splitted (class x)) x))\n                    (assoc splitted (class x) [x])))]\n     (if (empty? a-seq)\n       (set (vals splitted))\n       (recur (rest a-seq) (to-map (first a-seq)))))))","user":"574e84e0e4b02ea114799243"},{"code":"(fn mysplit-by-type\n        ([vs] \n           (mysplit-by-type vs #{}))\n        ([vs rets]\n           (if (empty? vs)\n             rets\n             (let [typ (type (first vs))]\n               (loop [rst' (rest vs)\n                      lft' []\n                      acc' [(first vs)]]                \n                 (if (empty? rst')\n                   (mysplit-by-type lft' (conj rets acc'))\n                   ;keep finding\n                   (if (= typ (type (first rst')))\n                     (recur (rest rst') lft' (conj acc' (first rst')))\n                     (recur (rest rst') (conj lft' (first rst')) acc'))))))))","problem":50,"user":"52c58561e4b0c2d177d620f8"},{"code":"#(vals (group-by (fn [itm] (type itm)) %))","problem":50,"user":"521e8227e4b0dd19981ad082"},{"problem":50,"code":"(fn [coll] (map val (group-by #(type %) coll)))","user":"5d88c6a3e4b0915913b1d3ad"},{"problem":50,"code":"(fn [data] (set \n \t(for [t (set (map type data))] \n      (filter #(= t (type %)) data)\n \t)\n))","user":"568513c4e4b04eec3ec5cfc5"},{"code":"(fn [v] \n  (set\n  (map (fn [x] (second x))\n  (\n    vec\n    (group-by #(class %) v)\n    )\n  )\n  )\n)","problem":50,"user":"4f2004a1535d64f6031464a7"},{"problem":50,"code":"(fn [s] (map reverse (vals (loop [res {} se s] (if (empty? se) res (recur (assoc res (type (first se)) (conj (res (type (first se))) (first se))) (rest se))))) ))","user":"5292feb4e4b0239c8a67af39"},{"problem":50,"code":";(fn [coll](map #(second %) (group-by class coll)))\n\n\n#(vals (group-by type %))","user":"6059f25de4b07e92fa001ad1"},{"problem":50,"code":"(fn split-by-type [squ]\n  (letfn [(my-group-by [f squ]\n            (loop [acc {}\n                   squ squ]\n              (if (empty? squ)\n                acc\n                (let [value (first squ)\n                      idx (f value)]\n                  (recur (assoc acc idx (concat (acc idx) (list value)))\n                         (rest squ))))))]\n    (vals (my-group-by type squ))))","user":"54084784e4b0addc1aec66c9"},{"problem":50,"code":"(fn [x] (partition-by type (sort-by #(str (type %)) x)))","user":"53c74cfce4b00fb29b2212a7"},{"problem":50,"code":"(fn by_type [s]\n  (vals (group-by type s)))","user":"55885edae4b059ccff29b1f6"},{"code":"(comp vals group-by) type","problem":50,"user":"5239caa6e4b0d705d026ef27"},{"problem":50,"code":"(fn [in-values] (vals (#(reduce\n (fn [type-map object]\n   (let [object-type (type object)\n         type-values (if (contains? type-map object-type)\n                       (get type-map object-type)\n                       [])]\n     (assoc type-map object-type (conj type-values object))))\n {}\n %) in-values)))","user":"57b356c2e4b0fbc9809a277b"},{"code":"#(vals (group-by (-> type) %))","problem":50,"user":"4f1595da535d64f603146444"},{"problem":50,"code":"(comp (partial map second)\n           (partial group-by class))","user":"53c38b8ce4b00fb29b22127b"},{"problem":50,"code":"(fn split-type [x]\n  (vals (group-by type x))\n  )","user":"5ac74b34e4b0e27600da777f"},{"code":"(fn [v]\n   (set(for [[k v] (group-by #(class %) v)] v)))","problem":50,"user":"52196842e4b0890f2f822bfa"},{"problem":50,"code":"(fn [coll] \n  (vals\n   (reduce \n    (fn [c v] \n      (assoc \n       c \n       (class v)  \n       (conj\n        (apply vector \n               (c (class v))\n        ) ;apply\n        v\n       )  ;conj\n      )   ;assoc\n    )     ;fn\n    {} \n    coll\n   )      ;reduce\n  )       ;vals\n)","user":"56c4f971e4b05cc29241ee9d"},{"problem":50,"code":"(fn [s]\n  (loop [r {} s s]\n    (if (empty? s)\n      (map reverse (vals r))\n      (let [t (type (first s))]\n        (if (nil? t)\n          (recur (assoc r t (first s)) (rest s))\n          (recur (assoc r t (conj (get r t) (first s))) (rest s)))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":50,"code":"(fn [xs]\n    (set\n      (vals\n        (reduce\n          (fn [m x]\n            (let [c (class x)]\n              (if\n                (contains? m c)\n                (assoc m c\n                  (conj\n                    (get m c)\n                    x\n                  )\n                )\n                (assoc m c\n                  (vector x)\n                )\n              )\n            )\n          )\n          {}\n          xs\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":50,"code":"(fn bytypes [x]\n  (vals (group-by type x)))","user":"5c24c654e4b07e362c2305a7"},{"code":"(fn type-sort [li]\n  (loop [res '()\n         filters (list number? vector? list? string? keyword?)]\n    (if (empty? filters)\n      res\n      (let [filter-result (filter (first filters) li)] \n        (recur (if (not-empty filter-result) \n                 (conj res filter-result)\n                 res)\n               (rest filters))))))","problem":50,"user":"50c84ba2e4b00bb60fe0c53e"},{"problem":50,"code":"(fn [s]\n  (vals\n  (reduce (fn [m el]\n            (update-in m [(type el)] (fn [old new] (conj (vec old) new)) el))\n          {} s)))","user":"5b7ec039e4b047b03b20375d"},{"problem":50,"code":"(fn splitByType [xs]\n  (vals (group-by (fn [elem]\n              (cond\n               (number? elem) :number\n               (symbol? elem) :symbol\n               (keyword? elem) :keyword\n               (string? elem) :string\n               :else :unknown)) xs)))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [a] (set (map #(% 1) (group-by type a))))","problem":50,"user":"4f0b2028535d0136e6c222ff"},{"code":"#(vals  (group-by type %))","problem":50,"user":"523b1a65e4b02f719975bdbd"},{"problem":50,"code":"(fn\n  [s]\n  (map second (group-by type s)))","user":"56b2630be4b0982f16b37e03"},{"problem":50,"code":"(fn [lst] (map last (group-by type lst)))","user":"5d960059e4b0d3f9b434ad31"},{"code":"#(map second (group-by class %))","problem":50,"user":"4ec16c21535dfed6da9c6dac"},{"code":"(fn split-type\n  [coll]\n  (vals (group-by type coll)))","problem":50,"user":"50fc48dde4b0d10d794c19f6"},{"code":"(fn [coll]\n  (let [m (group-by type coll)]\n     (vals m)))","problem":50,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn [s]\n  (map val (reduce #(assoc %1 (type %2) (conj (%1 (type %2) []) %2)) {} s)))","problem":50,"user":"4fa05b99e4b0dcca54ed6d47"},{"code":"(fn [s] \n  (set (vals (group-by type s))))","problem":50,"user":"5142e808e4b0c172af7558c9"},{"problem":50,"code":"(fn c50 [coll]\n  (let [keywords (into [] (filter keyword? coll))\n        vectors (into [] (filter vector? coll))\n        numbers (into [] (filter number? coll))\n        strings (into [] (filter string? coll))\n        ]\n    (disj (set [keywords vectors numbers strings]) [])\n    )\n  )","user":"558ee1c9e4b0277789237659"},{"problem":50,"code":"(fn [my-seq] (vals (reduce (fn [typemap new-ele] (assoc typemap (type new-ele) (conj (get typemap (type new-ele) []) new-ele))) {} my-seq)))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn split-by-type [list]\n  (set (vals (reduce\n               (fn [acc el]\n                 (let [t        (class el)\n                       curr     (get acc t [])\n                       new-curr (conj curr el)] \n                   (assoc acc t new-curr))) \n               {}\n               list))))","problem":50,"user":"4fbe2cfbe4b081705acca30c"},{"code":"(fn group-by-type [sq]\n  (map second (group-by type sq)))","problem":50,"user":"515737f0e4b0b0b4b87062d0"},{"problem":50,"code":"(fn jp [s] (if (empty? s) () \n             (cons \n              (filter #(= (type %) (type (first s))) s) \n              (jp (remove #(= (type %) (type (first s))) s)))))","user":"544e1794e4b0e39780006980"},{"code":"(fn [coll]\n  (set (map second (group-by class coll))))","problem":50,"user":"4e2d84bf535deb9a81d77f09"},{"problem":50,"code":"(fn split-by-type [xs]\n (vals (group-by type xs)))","user":"59d4d126e4b0ef0a1e9b5be9"},{"code":"(fn [xs] \n  (vals \n   (reduce  \n    #(let [{av (type %2)} %\n           insert (partial assoc % (type %2))]\n       (if av \n          (insert (conj av %2))\n          (insert [%2])))\n    {} xs)))","problem":50,"user":"527236d4e4b03e8d9a4a741f"},{"code":"(fn [s]\n  (map second (group-by type s)))","problem":50,"user":"512eb723e4b0b740abc5982b"},{"code":"( fn [x] ( let [types [clojure.lang.Keyword clojure.lang.PersistentVector java.lang.String java.lang.Long]] (filter #(> (count %) 0) (reduce conj #{} (map (fn [t l] (filter #(instance? t %) l)) types (repeat x) ) ) ) ) )","problem":50,"user":"5061cc17e4b0a30dc9a35d34"},{"code":"(fn a [col] (into #{}(vals(group-by type col))))","problem":50,"user":"527a8eb7e4b03e8d9a4a755f"},{"problem":50,"code":"#(->> %\n      (group-by class)\n      vals\n      set)","user":"56eab346e4b04a395b9a0410"},{"code":"(fn __ [col]\n  (vals (group-by type col)))","problem":50,"user":"4fa719c0e4b081705acca1bf"},{"problem":50,"code":"(fn [col]\n  (for [[k, v] (group-by type col)]\n    v))","user":"5a144fd8e4b0ff51aa4b319a"},{"code":"#(-> (group-by type %) vals)","problem":50,"user":"50e3ec87e4b0463d32072486"},{"code":"(fn [s]\n  (partition-by type (sort #(compare (hash (type %1)) (hash (type %2))) s)))","problem":50,"user":"4ea7999e535d7eef308072ee"},{"problem":50,"code":";(comp vals group-by) #(type %)\n#(vals (group-by type %))","user":"55b8c339e4b01b9910ae29b9"},{"problem":50,"code":"#(loop [xs % result {}]\n   (let [f (first xs) t (type f)]\n     (if (empty? xs)\n       (map reverse (vals result))\n       (recur (rest xs) (assoc result t (conj (result t) f))))))","user":"57147cd9e4b07c98581c3abf"},{"problem":50,"code":"(fn [s] (map val (group-by type s)))","user":"5461dc79e4b01be26fd746a8"},{"problem":50,"code":"(fn [init] (for [[key value] (group-by class init)] value))","user":"58b985e0e4b0888cdc949ccc"},{"problem":50,"code":"(fn [x](reduce #(conj % (val %2)) [] (group-by type x)))","user":"538d70abe4b0b51d73faae6e"},{"problem":50,"code":"(fn [map] (vals (group-by type map)))","user":"559fb147e4b0acc240e314ea"},{"code":"(fn [s] (partition-by type (sort-by #(str (type %)) s)))","problem":50,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [a]\n  (vals (reduce \n  #(merge-with concat %1 {(type %2) [%2]}) \n  {} a)))","problem":50,"user":"4e463703535dc968683fc4b2"},{"problem":50,"code":"(fn [c] (vals (reduce #(assoc %1 (type %2)\n                        (when-let [v (get %1 (type %2) [])]\n                          (conj v %2)))\n                {}\n                c)))","user":"5523fce8e4b0882d96d091b4"},{"code":"(fn [xs]\n  (map second (group-by class xs)))","problem":50,"user":"4f3ae998e4b0e243712b1f1f"},{"code":"(fn [x] (set (vals (group-by type x))))","problem":50,"user":"5351fbf5e4b084c2834f4aeb"},{"problem":50,"code":"#(map (fn [x] (nth x 1)) (group-by class %))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":50,"code":"(fn [x] (map fnext (group-by (juxt type) x)))","user":"557e8326e4b05c286339e0d7"},{"problem":50,"code":"(fn [coll] \n  (map last (group-by type coll)))","user":"550615c0e4b021ccfedb9696"},{"code":"(fn [elem] \n  (vals \n    (reduce \n      (fn [m k] (assoc m (type k) (conj (get m (type k) []) k))) {} elem)))","problem":50,"user":"509c2c55e4b085ae113522ab"},{"code":"#(vals (group-by  type %))","problem":50,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":50,"code":"#(into #{}  (vals  (group-by type %)))","user":"5832be57e4b089d5ab817c86"},{"problem":50,"code":"(fn [arg]\n\t\t(loop [arr arg, res {}]\n\t\t  (if (empty? arr)\n\t\t\t  (vals res)\n\t\t\t  (let [elem (first arr), type (class (first arr))]\n\t\t\t\t(recur\n\t\t\t\t\t(rest arr)\n\t\t\t\t\t(if (res type)\n\t\t\t\t\t\t(assoc (dissoc res type) type (conj (res type) elem))\n\t\t\t\t\t\t(assoc res type [elem])))\n\t\t\t  )\n\t\t  )\n\t\t)\n\t  )","user":"5d73530ce4b02e6b30c93514"},{"problem":50,"code":"(fn [s]\n  (->> s\n  (group-by type)\n  (map val)\n  (set)))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":50,"code":"(fn [init]\n  (loop [\n    toSort init\n    typeMap (zipmap (map type init) (map (constantly []) init))]\n    (if (empty? toSort)\n      (vals typeMap)\n      (recur\n        (rest toSort)\n        (let [item (first toSort)]\n          (update-in typeMap [(type item)] #(conj % item)))))))","user":"5ab5f60be4b073f177442643"},{"problem":50,"code":"(fn [coll]\n  (filter not-empty\n    (map \n      #(vec (filter % coll))\n        [integer? string? keyword? vector?])))","user":"5537cbaee4b09218d5f44fd3"},{"code":"(fn [xs]\n  (map (fn [x] (map #(nth xs %) x)) (map (fn [x] (map first x)) (vals (group-by second (map-indexed #(vector %1 %2) (map type xs)))))))","problem":50,"user":"51ef31dfe4b0871fa145d9a0"},{"problem":50,"code":"#_(fn [coll] (map #(filter % coll) [number? string? symbol?]))\n\n\n#_((fn [coll] (map #(filter % coll) [number? string? symbol? keyword?])) [1 :a 2 :b 3 :c])\n\n#_(fn [coll] (filter seq (map #(filter % coll) [number? string? symbol? keyword? seq?])))\n\n\n(fn [coll] (filter seq (map #(filter % coll) [number? string? symbol? keyword? vector?])))","user":"58aa8083e4b01a0c0b232985"},{"problem":50,"code":"(fn [v]\n   (let [update (fn [m k f] (assoc m k (f (get m k))))\n         f (fn [[x & xs] m]\n             (if (nil? x)\n               (map reverse (vals m))\n               (recur xs (update m (type x) #(conj % x)))))]\n     (f v {})))","user":"56e2ca59e4b03a7c14b85a38"},{"problem":50,"code":"(fn [lst] (let [types (set (map type lst))] (map #(filter (fn [item] (= % (type item))) lst) types)))","user":"587ee260e4b052da650a6353"},{"problem":50,"code":"(fn myfn [coll]                                                                   \n  (vals (group-by class coll)))","user":"58ebd10de4b056aecfd47d49"},{"code":"(fn split-by-type [coll]\n   (vals (group-by type coll)))","problem":50,"user":"531c0619e4b08068f379ed98"},{"code":"(fn [s]\n  (map (fn [t] (filter #(= (type %) t) s)) \n       (into #{} (map type s))))","problem":50,"user":"4e498df9535dc968683fc4c4"},{"problem":50,"code":"(fn [coll]\n  (loop [type_map (hash-map) coll (reverse coll)]\n    (if (empty? coll)\n      (set (vals type_map))\n      (recur\n       (assoc type_map \n         (type (first coll))\n         (conj (get type_map (type (first coll))) (first coll))\n       )\n       (rest coll)\n      )\n    )\n  )\n)","user":"560fe558e4b05f002753df63"},{"code":"(fn [coll]\n           (let [coll-by-type (group-by :kind (map (fn [x] {:kind (class x) :value x}) coll))]\n             (map (fn [[k c]]\n                      (concat (map :value c))) coll-by-type)))","problem":50,"user":"4f3cd535e4b0e243712b1f56"},{"code":"(fn [& l] (partition-by class (apply sort-by #(str (class %)) l)))","problem":50,"user":"506617c3e4b03d366d7cb2ab"},{"problem":50,"code":"(fn split-by-type [coll]\n  (vals (apply merge-with concat (map (fn [x] {(type x) [x]}) coll))))","user":"5e805895e4b085ba37836e44"},{"code":"(fn group-by-type [coll]\r\n  (letfn [(group-by-type- [acc rem]\r\n            (if (seq rem)\r\n              (let [args ((juxt filter remove)\r\n                          #(= (type %) (type (first rem))) (rest rem))]\r\n                (recur (conj acc (conj (args 0) (first rem))) (args 1)))\r\n              acc))]\r\n    (group-by-type- '() coll)))","problem":50,"user":"4e7e4a1f535db169f9c7970c"},{"problem":50,"code":"(fn group-by-type [sequence]\n  (-> (group-by type sequence)\n      (vals))\n)","user":"56040e58e4b0c80df0ca2654"},{"code":"(fn [coll]\r\n  (reduce\r\n    (fn [col val]\r\n      (set \r\n        (cons \r\n          (if (or (= (class val) clojure.lang.Keyword) (= (class val) clojure.lang.PersistentVector))\r\n            (sort (vec (clojure.set/select #(instance? (class val) %) (set coll))))\r\n            (vec (clojure.set/select #(instance? (class val) %) (set coll))))\r\n         col)))\r\n  #{}\r\n  coll))","problem":50,"user":"4ddee37c535d08e6dec9fddc"},{"problem":50,"code":"(fn collector\n  [coll]\n  (let [colreducr (fn [comb item]\n                  (let [match-set (or (first (filter #(= (type item) (type (first %))) comb)) [])\n                        unmatch-set (filter #(not= (type item) (type (first %))) comb)\n                        added-set (conj match-set item)]\n                    (conj unmatch-set added-set)))]\n  (reduce colreducr [] coll)))","user":"5826142ce4b051871117beed"},{"problem":50,"code":"(fn [v]\n  (map (fn [t]\n         (filter #(= (type %) t) v))\n       (set (map type v))))\n\n;there's always a built-in function!\n;#(vals (group-by type %))","user":"57533bc1e4b02ea1147992a6"},{"code":"(fn [elems] \n  (for [ [k v ] (group-by type elems)] \n     v\n  ))","problem":50,"user":"53440c0ae4b084c2834f4a25"},{"code":"(fn [s]\n  (->> s\n       (map #(hash-map (type %) (list %)) ,,)\n       (apply merge-with concat ,,)\n       (vals ,,)\n       (into #{})))","problem":50,"user":"4dd0e8f7535da60f04a96e57"},{"problem":50,"code":"(fn [a] (vals (group-by class a)))","user":"5d3ae729e4b01671435dbd5d"},{"code":"#(apply hash-set (vals (group-by type %)))","problem":50,"user":"502d4ea0e4b02fc10c6c6e46"},{"problem":50,"code":"( fn [l]\n  (loop [res []  [a & r] l ]\n    (if a\n      ( let [la (filter #(= (type a) (type %) ) l)      ]\n        \n          (recur (conj res  la) (filter #(not= (type a) (type %) ) r))\n      )\n      res\n      )\n    \n    )\n  \n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":50,"code":"(fn [xs]\n  (vec (reduce \n    (fn [acc x]\n      (loop [n 0]\n        (if (= n (count acc))\n          (conj acc [x])\n          (let [arr (nth acc n)]\n           (if (= (type (first arr)) (type x))\n             (concat (take n acc) [(conj arr x)] (drop (inc n) acc))\n             (recur (inc n)))))))\n   []\n   xs)))","user":"5e0b6375e4b099d064962f7b"},{"code":"(fn [coll] (set (vals (reduce #(merge-with (fn [v1 v2] (vec (concat v1 v2)))  %1 %2 ) {}   (map #(assoc {} (type %1) [%1]) coll)))))","problem":50,"user":"4ef98c9c535dced4c769f267"},{"problem":50,"code":"(fn [coll]\n   (let [cls (set (map class coll))]\n     (for [x cls]\n       (filter #(= (class %) x) coll))))","user":"55f8b32ae4b03cbcff9738ba"},{"problem":50,"code":"(fn [xs] (->> xs (sort-by #(-> % type str)) (partition-by type)))","user":"4fec08e8e4b0681fd128dc9d"},{"code":"(fn [s]\n  (vals (group-by type s)))","problem":50,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":50,"code":"(fn\n  [arr]\n  (loop [[f & r] arr\n         types {}]\n    (if f\n      (let [t (type f)\n            v (conj (get types t []) f)]\n        (recur r (assoc types t v)))\n      (reduce-kv (fn [res k v]\n                   (conj res v))\n                 []\n                 types))))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":50,"code":"(fn [xs] (set (filter not-empty (map (fn [f] (filter f xs)) [vector? number? keyword? string?]))))","user":"54a6645be4b09f271ff37c87"},{"problem":50,"code":"(fn [coll]\n    (let [is-type (fn [t] #(= t (type %)))]\n         (vals (reduce #(assoc %1 %2 (filter (is-type %2) coll))\n\t\t       {}\n\t\t       (set (map type coll))))))","user":"591addcee4b09b4ee5954be1"},{"code":"(fn [l] \n  (vals (reduce \n\t\t(fn [ret val]\n\t\t\t(update-in ret [(class val)]\n\t\t\t\t#(if (not %1) [%2] (conj %1 %2) ) \n\t\t\t\tval)) \n\t\t{} l)))","problem":50,"user":"4f2965ffe4b0d6649770a029"},{"problem":50,"code":"(fn [c] (map last (set (group-by (comp identity type) c))))","user":"52fac708e4b047fd55836fff"},{"problem":50,"code":"(fn [xs]\n  (vals (reduce \n          (fn [m x]\n            (if (m (type x))\n              (assoc m (type x) (conj (m (type x)) x))\n              (assoc m (type x) [x])))\n          {} xs)))","user":"53d86564e4b0e771c302546b"},{"problem":50,"code":"(fn [col]\n  \t\t(vals (group-by #(type %) col)))","user":"57ee46c7e4b0bfb2137f5bb3"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (->> (group-by type coll)\n       (vals)\n       (set)))","user":"543c39e0e4b032a45b86933d"},{"problem":50,"code":"(fn [x]\n  (set (map #(filter (partial instance? %) x) (map type x))))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (reduce #(update-in %1 [(type %2)] conj %2) {})\n       vals\n       (map reverse)\n       (map vec)))","user":"5de82145e4b0986d99407f7b"},{"problem":50,"code":"(fn [seq]\n               (vals (reduce (fn [result curr]\n                         (if (nil? (get result(class curr)))\n                           (conj result [(class curr) [curr]])\n                           (conj result [(class curr) (conj (get result (class curr)) curr)])))\n                       {} seq))\n               )","user":"5658b9bde4b00d315579610e"},{"problem":50,"code":"(fn [xs]\n    (vals (reduce #(let [crnt (get % (type %2) [])\n                   new (conj crnt %2)]\n                     (assoc % (type %2) new))\n                  {} xs)))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn soln [l]\n  (if (= '() l) '()\n  (let [f #(= (type (first l)) (type %))]\n    (cons (filter f l)\n          (soln (filter #(not (f %)) l))))))","problem":50,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn [a-seq]\n  (loop [a-map {} elems a-seq]\n    (if (empty? elems)\n      (into (hash-set) (vals a-map))\n      (let [e (first elems)\n            c (class e)\n            r (rest elems)]\n        (if (contains? a-map c)\n          (recur (update-in a-map [c] conj e) r)\n          (recur (assoc a-map c [e]) r))))))","problem":50,"user":"4faa8de0e4b081705acca1f8"},{"problem":50,"code":"(fn [coll]\n  (loop [operands [integer? keyword? string? vector?]\n         output '()]\n    (cond\n     (empty? operands) output\n     (empty? (filter (first operands) coll)) (recur (rest operands) output)\n     :else (recur (rest operands) (conj output (filter (first operands) coll))))))","user":"551d5cb9e4b07993ea3788e9"},{"code":"(fn [x] (vals (apply merge-with into (map #(hash-map  (type %) [%] ) x))))","problem":50,"user":"503539dee4b0ed9c821488f6"},{"code":"#(map (fn [t] (filter (fn [i](= (type i) t)) %)) (set (map type %)))","problem":50,"user":"4f4a34b2e4b0d56e7bb92c09"},{"problem":50,"code":"(fn q [coll] (vals (group-by type coll)))","user":"5da4fc6be4b000c986472bff"},{"problem":50,"code":"(fn [xs]\n    (map second (group-by type xs)))","user":"53c3397be4b00fb29b221279"},{"problem":50,"code":"(fn [seq]\n  (loop [s seq result {}]\n    (cond (empty? s) (vals result)\n          :else (recur (rest s)\n                       (merge-with concat\n                                   result\n                                   {(type (first s)) [(first s)]})))))","user":"54961073e4b0b312c081ff62"},{"problem":50,"code":"(fn foo [xs]\n(into #{} (for [[k v] (group-by type xs)] v)))","user":"54ab502fe4b09f271ff37cc4"},{"problem":50,"code":"#(let [x (group-by class %)] (set (vals x)) )","user":"54e51c7be4b024c67c0cf7f7"},{"problem":50,"code":"(fn [v] (vals (reduce #(merge-with concat % %2)\n                      (map (fn [x] {(class x) [x]}) v))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":50,"code":"(fn [v] (for [[key value] (group-by class v)] value))","user":"55ec879ae4b0121d4835fdc8"},{"problem":50,"code":"(fn [a]\n  (vals\n    (reduce\n      (fn [r x] \n        (let [t (class x) e (get r t)]\n          (assoc r t (if (nil? e) [x] (conj e x)))))\n      {}\n      a)))","user":"564a5a09e4b0284900eef656"},{"problem":50,"code":"(fn [c] (->> (group-by type c) vals))","user":"5484143de4b0e286459a1197"},{"code":"(fn [x]\n  (->> x (group-by type) vals set))","problem":50,"user":"511b9017e4b00c2a1fa7ff6b"},{"code":"(fn [coll]\n  (vals\n   (reduce\n    #(conj\n     %1\n     [(type %2) (concat (%1 (type %2)) (list %2))]) {} coll)))","problem":50,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":50,"code":"(fn splt-tp\n\t[lst]\n\t(let [ins2 \n\t\t(fn [xs x] \n\t\t\t(loop [l (first xs) ls (rest xs) out []]\n\t\t\t\t(if (nil? l)\n\t\t\t\t\t(conj out [x])\n\t\t\t\t\t(if (= (type x) (type (first l)))\n\t\t\t\t\t\t(if (empty? ls) \n\t\t\t\t\t\t\t(conj out (conj l x) ) \n\t\t\t\t\t\t\t(concat (conj out (conj l x)) ls )\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t(recur (first ls) (rest ls) (conj out l))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)]\n\t\t(reduce #(ins2 %1 %2) [] lst)\n\t\t)\n\t)","user":"5545477fe4b0a04f79299531"},{"problem":50,"code":"(fn splitByType [c]\n  (loop [s c \n        , out []]\n      (if (empty? s)\n        out\n        (let [cl (class (first s))\n             , s1  (filter #(= cl (class %)) s)\n             , s2  (filter #(not= cl (class %)) s)\n             ]          \n              (recur s2 \n                     (concat out [s1] ) \n              )\n        )\n      )\n  )\n)","user":"571aae1fe4b07c98581c3b5a"},{"problem":50,"code":"(fn [coll]\n  (filter (complement empty?)\n          (list (filter sequential? coll) \n           \t\t  (filter number? coll)\n                (filter keyword? coll)\n                (filter string? coll))))","user":"53e150e5e4b0d874e779ae53"},{"code":"#(vals (group-by (fn [v] (. v getClass)) %))","problem":50,"user":"4e929dd0535dbda64a6f6b05"},{"problem":50,"code":"(fn [x]\n   (let [types (set (map type x))]\n    (for [a types]\n    (filter #(if (= a (type %)) %) x))))\n  ;#(vals (group-by type %))","user":"60b3b375e4b0e0fa5f1b4232"},{"problem":50,"code":"(fn pt-1 [coll]\n  (map reverse (vals (reduce #(update-in %1 [(type %2)] (fnil (fn [l e] (cons e l)) '()) %2) {} coll))))","user":"5630fd6fe4b0bfe05bf1178b"},{"code":"(fn [s]\n  (map\n   (fn [t] (filter #(= (type %) t) s))\n   (set (map type s))))","problem":50,"user":"50d8f4b6e4b01f0871336e74"},{"problem":50,"code":"(fn [sq]\n  (map (fn [[x y]] y) (group-by type sq)))","user":"581a5fdbe4b0e114eb51a002"},{"problem":50,"code":"(fn [lst]\n  (vals\n  \t(reduce (fn [m v] (assoc m (type v) (conj (get m (type v) []) v)))\n    \t    {}\n        \tlst)))","user":"55c20bd0e4b0e31453f64972"},{"code":"(fn [coll] (vals (group-by type coll)))","problem":50,"user":"4e6ab9cb535d8ccf87e9fefe"},{"code":"(fn [coll] \n  (vals \n    (reduce #(update-in %1 [(type %2)] concat [%2]) {} coll)))","problem":50,"user":"4ed0e139535d44c135fd68c7"},{"code":"(fn [xs]\n  (vals (group-by #(type %) xs)))","problem":50,"user":"504e13fce4b078edc5f593bc"},{"problem":50,"code":"(fn [coll]\n  (loop [arr coll\n         accum #{}]\n    (if (empty? arr)\n      accum\n      (let [t (type (first arr))\n            eq (filter #(= t (type %)) arr)]          \n      \t(recur (remove #(= t (type %)) arr)\n               (conj accum eq)\n        )\n      )\n    )\n  )\n)","user":"59ac559ee4b00adcf69795d2"},{"problem":50,"code":"(fn [c]\n  (loop [c c\n         type-map (hash-map)]\n    (if (empty? c)\n      (set (vals type-map))\n      (let [item-type (str (type (first c)))]\n        (if (contains? type-map item-type)\n          (let [item-vec (get type-map item-type)]\n            (recur (rest c) (assoc type-map item-type (conj item-vec (first c)))))\n          (recur (rest c) (assoc type-map item-type (vector (first c)))))))))","user":"5530b827e4b076ab5578f818"},{"problem":50,"code":"#((fn[xs](map xs (keys xs))) (group-by type %))","user":"56163cc1e4b06b1bb21829ff"},{"code":"(comp vals group-by) class","problem":50,"user":"4e71da4d535d5021c1a89653"},{"problem":50,"code":"(fn [coll]\n\t(->> coll\n\t\t(reduce #(let [t (type %2)] (if (contains? % t) (assoc % t (conj (get % t) %2)) (assoc % t [%2]))) {})\n\t\tvals))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      (map second)\n      (set))","user":"5b333626e4b025bcb146f32f"},{"problem":50,"code":"(fn[l] (partition-by class (sort-by (comp str class) l)))","user":"57b9fc74e4b0fbc9809a27fb"},{"problem":50,"code":"(fn [coll]\n   (vals (group-by #(type %) coll)))\n\n;Here is another solution that I like that is a good example of comp.\n;(comp vals (partial group-by type))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":50,"code":"(fn [s]\n    (let [types (->> s (map type) set)]\n      (for [t types]\n        (filter #(= t (type %1)) s))))","user":"4f213e2ee4b0d66497709fcf"},{"code":"(fn split-by-type [l]\r\n    (loop [l (seq l) m (hash-map)]\r\n      (if (empty? l)\r\n        (map reverse (vals m))\r\n        (recur (rest l) (assoc m (type (first l)) (cons (first l) (get m (type (first l)))))))))","problem":50,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn [xs]\n  (vals (group-by class xs)))","problem":50,"user":"504e90bae4b069badc5a33b8"},{"problem":50,"code":"(fn split-by-type [seq]\n  (vals (reduce (fn [map value]\n                  (let [my-type (type value)]\n                    (println \"log: \" my-type)\n                    (update-in map [my-type] #(concat % [value]))))\n           {}\n           seq))\n  )","user":"5da6cb60e4b000c986472c10"},{"problem":50,"code":"(fn [coll]\n  (loop [n 0 return #{}]\n    (if (= n (count coll))\n      return\n      (recur (inc n) (conj return (vec (filter #(= (type %) (type (nth coll n))) coll)))))))","user":"586d2f5be4b01531a375e98c"},{"problem":50,"code":"#(map (comp last) (group-by type %))","user":"52b434c9e4b0c58976d9ad1c"},{"problem":50,"code":"#(vals (group-by type  %))","user":"55c5e781e4b0e31453f649b8"},{"problem":50,"code":"(fn\n  [s]\n  (vals (reduce (fn [acc x]\n                  (update-in acc [(class x)] #(concat %1 [x])))\n                {}\n                s)))","user":"58543a59e4b07779d46863f5"},{"code":"(fn [coll]\n  (map reverse (vals\n    (loop [acc {}\n           coll coll]\n      (if (empty? coll)\n        acc\n        (let [item (first coll)\n              k   (str (class item))\n              v   (cons item (acc k))]\n            (recur (assoc acc k v) (rest coll))))))))","problem":50,"user":"51195e77e4b055cfb310d499"},{"code":"#(vals(reduce(partial merge-with concat)(for[x %]{(type x)[x]})))","problem":50,"user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn [s]\n  (loop [l s acc {}]\n    (if (empty? l)\n      (vals acc)\n    (let [[h & t] l\n          cl (class h)]\n      (recur t (assoc acc cl (conj (or (acc cl) []) h)))))))","problem":50,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":50,"code":"(fn [xs]\n  (vals (loop [res {}\n               rem xs]\n          (if (= rem ())\n              res\n              (let [el (first rem)\n                    ty (type el)\n                    ss (or (get res ty) [])]\n                   (recur (assoc res ty (conj ss el)) (rest rem)))))))","user":"548fa2dfe4b0e286459a1240"},{"code":"(fn split-by-type [C]\n  (cond (empty? C) []\n        :else (concat [(filter #(= (type (first C)) (type %)) C)]\n                      (split-by-type (filter #(not= (type (first C)) (type %)) (rest C))))))","problem":50,"user":"52153bdde4b0961f15ac4daa"},{"problem":50,"code":"(fn [coll]\n    (let [ints (vec (filter integer? coll))\n          kws (vec (filter keyword? coll))\n          strs (vec (filter string? coll))\n          vs (vec (filter vector? coll))\n          all (filter #(not (empty? %)) [ints kws strs vs])]\n      (into #{} all)\n      )\n    )","user":"515ebde3e4b01e5d11ccd0a8"},{"code":"(fn [x]\n  (loop [x x\n         r {}]\n    (if (nil? (first x))\n      (vals r)\n      (if (nil? (get r (type (first x))))\n        (recur (rest x) (assoc r (type (first x)) (list (first x))))\n        (recur (rest x) (assoc r (type (first x)) (concat (get r (type (first x))) (list (first x)))))))))","problem":50,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":50,"code":"(fn [n]\n  (vals (group-by type n)))","user":"5634995fe4b0bfe05bf117be"},{"problem":50,"code":"(fn split-by-type [elements]\n   (let [buckets (distinct (map (fn [x] [(type x)]) elements))\n         bucket-type first\n         bucket-elements rest\n         join-if-type-fits (fn [elem bucket]\n                             (if (= (bucket-type bucket) (type elem))\n                               (conj bucket elem)\n                               bucket))\n         filled-buckets (reduce\n                          (fn [filling-buckets elem]\n                            (map\n                              (partial join-if-type-fits elem)\n                              filling-buckets))\n                          buckets\n                          elements)\n         ]\n     (map bucket-elements filled-buckets)\n     ))","user":"5429986ce4b01498b1a71b3b"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      (map second))","user":"55912230e4b027778923767a"},{"problem":50,"code":"(fn [coll ]\n(vals (reduce (fn [accum val]\n(let [val-type (type val)]\n(if (= nil (accum val-type))\n(into accum {val-type [val]})\n\n(into accum {val-type (conj (accum val-type) val)})\n\n\n)\n\n)\n) {} coll)))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn [coll]\n   (vals (reduce (fn [res [t v]]\n                   (update-in res [t] #(conj (or % []) v)))\n                 {}\n                 (for [v coll]\n                   [(class v) v]))))","problem":50,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":50,"code":"(fn [s]\n    (->>\n      s\n      (group-by type)\n      (vals)\n    )\n  )","user":"5901158de4b0438e51c2d039"},{"problem":50,"code":"(fn [xs] \n  (set\n   (map second (group-by class xs))))","user":"598debf0e4b02b9968b84d2e"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce (fn [m x]\n                  (let [t (type x)]\n                    (update-in m\n                               [t]\n                               (fn [o n]\n                                 (if (nil? o)\n                                   (vector n)\n                                   (conj o n)))\n                               x)))\n                {}\n                coll)))","user":"56a79eb0e4b07966d5a8a05d"},{"code":"(fn [t] (reduce conj #{} (vals (reduce #(assoc %1 (class %2) (conj (%1 (class %2) []) %2)) {} t))))","problem":50,"user":"531902b1e4b08068f379ed77"},{"problem":50,"code":"(fn [coll] (vals (reduce\n            (fn [mp x] \n              (assoc mp (type x)\n                (if (nil? (mp (type x)))\n                  [x]\n                  (conj (mp (type x)) x))))\n            {} coll)))","user":"54864662e4b0e286459a11b8"},{"problem":50,"code":"(fn fil [coll] \n  (filter not-empty \n          [(filter string? coll) \n           (filter vector? coll) \n           (filter keyword? coll)\n           (filter number? coll)]))","user":"5cb11a72e4b026601754b8c6"},{"code":"(fn by-type-split [s]\n  (set (vals (group-by #(type %) s)))\n)","problem":50,"user":"4faacc04e4b081705acca201"},{"problem":50,"code":"(fn split-type\n  [coll]\n  (for [t (set (map type coll))]\n    (filter #(= (type %) t) coll)))","user":"5609d328e4b05f002753deee"},{"problem":50,"code":"(fn [coll]\n  (loop [[elem & coll] coll split #{}]\n    (if (nil? elem)\n      split\n      (recur \n       (filter #(not= (type %) (type elem)) coll)\n       (conj split (into [elem] (filter #(= (type %) (type elem)) coll)))\n     )\n    )\n  )\n)","user":"5e09fd26e4b099d064962f60"},{"problem":50,"code":"(fn f1 [s]\n\t(vals (group-by class s))\n\t\t\t)","user":"54ff6084e4b07d26eda61d50"},{"code":"#(->> (group-by type %) vals set)","problem":50,"user":"53315c78e4b019098a6f8b67"},{"problem":50,"code":"(fn [coll]\n  (->> coll (group-by type) vals set))","user":"52dc7344e4b09f7907dd13cf"},{"code":"#((fn g [c m]\n    (let [f (first c)\n        r (rest c)\n        k (type f)\n        v (get m k [])\n        nv (conj v f)]\n        (if (empty? c)\n          (set (vals m))\n          (g r (assoc m k nv))))) % {})","problem":50,"user":"4edd038c535d10e5ff6f5327"},{"code":"#(set (vals (group-by class %)))","problem":50,"user":"4ec6559a535d6d7199dd36c9"},{"code":"(fn [lst] (vals (group-by (fn [x] (.getClass x)) lst)))","problem":50,"user":"4f2f6678e4b0d6649770a06e"},{"problem":50,"code":"(fn [xs]\n  (loop [[first & rest] xs\n         numbers []\n         seqs []\n         strings []\n         keywords []]\n    (cond\n     (number? first) (recur rest (conj numbers first) seqs strings keywords)\n     (string? first) (recur rest numbers seqs (conj strings first) keywords)\n     (keyword? first) (recur rest numbers seqs strings (conj keywords first))\n     (sequential? first) (recur rest numbers (conj seqs first) strings keywords)\n     :else (filter not-empty (conj #{} numbers seqs strings keywords)))))","user":"58a216e8e4b02bd94d917ed1"},{"code":"(fn [s]\n  (vals \n   (reduce #(update-in %1 [(class %2)] (partial cons %2)) {} (reverse s))))","problem":50,"user":"53523ae0e4b084c2834f4aee"},{"problem":50,"code":"(fn [c] \n  (map \n   second \n   (group-by type c)))","user":"5596a324e4b04c1e5c31d757"},{"problem":50,"code":"#(->> % \n      (group-by type)\n      (vals))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn[s] (vals (group-by type s)))","problem":50,"user":"4f148418535d64f60314643a"},{"problem":50,"code":"#(->> %\n      (group-by class)\n      (vals)\n      (set))\n\n;; #(->> %\n;;       (group-by type)\n;;       (vals)\n;;       (set))\n\n;; (fn split-type [col]\n;;     (map second (reduce (fn [m x] (assoc m\n;;                                          (class x)\n;;                                          (conj (get m (class x) []) x)))\n;;                         {}\n;;                         col)))\n\n;; (fn [coll]\n;;     (map second (reduce (fn [m v] (update-in m\n;;                                              [(class v)]\n;;                                              #(conj (or % []) v)))\n;;                         {}\n;;                         coll)))","user":"591ad160e4b09b4ee5954bdf"},{"problem":50,"code":"(fn type-partition [list] (vals (group-by type list)))","user":"55ddc5cbe4b050e68259b3d0"},{"code":"(fn [v] (set (vals(group-by #(list (keyword? %) (coll? %)) v))))","problem":50,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn [coll] (filter (fn [coll] (not (empty? coll))) (set [(filter number? coll) (filter keyword? coll) (filter seq? coll) (filter #(not (or (number? %) (keyword? %) (seq? %))) coll)])))","problem":50,"user":"4fb99483e4b081705acca2da"},{"problem":50,"code":"(fn [xs]\n (let [ts (map type xs)\n       xts (map list xs ts)]\n  (map #(vec\n         (for [[x t] xts\n               :when (= t %)]\n              x))\n  (set ts))))\n#_(fn [xs]\n (let [ts (map type xs)\n       xts (map list xs ts)]\n  (map (fn [t]\n        (vec\n         (map first\n          (filter\n            #(= t (second %))\n            xts))))\n\n  (set ts))))\n#_(fn [xs]\n (let [ts (map type xs)\n       xts (map list xs ts)]\n  (map (fn [t]\n        (->>\n          xts\n          (filter \n            #(= t (second %)))\n          (map first)\n          vec))\n  (set ts))))","user":"51e5a627e4b0efabf93c02db"},{"problem":50,"code":"(fn [col] (map last (group-by class col)))","user":"564a560ae4b0284900eef654"},{"problem":50,"code":"(fn split-by-type [x]\n  (let [d (fn anon [x i v]\n            (let [c (count v)]\n              (if (>= i c) (list x v) \n                (let [n (nth v i)]\n                  (if (empty? x) \n                    (anon [n] i (vec (concat \n                                       (subvec v 0 i) \n                                       (subvec v (inc i) c))))\n                    (let [k (type (first x))]\n                      (if (= k (type n))\n                        (anon (conj x n) i\n                              (vec (concat \n                                     (subvec v 0 i) \n                                     (subvec v (inc i) c))))\n                        (anon x (inc i) v))))))))\n        e (fn anon [x]\n            (let [p (d [] 0 x)\n                  f (first p)\n                  s (second p)]\n              (if (empty? s) [f]\n                (concat [f] (anon s)))))]\n    (set (e x))))","user":"57d1d6c8e4b0bd073c202370"},{"code":"(fn [col] (set (vals (group-by type col))))","problem":50,"user":"53286389e4b09d4e7a9b5504"},{"problem":50,"code":"(fn [c] (vals (reduce #(assoc %1 (type %2) (vec (conj (%1 (type %2)) %2))) {} c)))","user":"5635adeee4b0bfe05bf117c7"},{"code":"(fn [s]\n  (vals (reduce (fn [r e]\n    (let [t (class e)]\n(assoc r t (conj (r t) e))))\n{}\n(reverse s))))","problem":50,"user":"4fca2a13e4b0ee37620e184d"},{"code":"(fn [coll]\n  (let [types (set (map #(type %) coll))]\n       (map (fn [t]\n              (filter #(= (type %) t) coll))\n            types)))","problem":50,"user":"4fe8e771e4b0547ebccb2431"},{"problem":50,"code":"(fn [coll]\n  (loop [new_coll coll res () type_set #{}]\n    (if (= (reduce + (map count res)) (count coll))\n      res\n      (do (let [first_type (type (first new_coll))]\n        (if (contains? type_set first_type)\n            (recur (rest new_coll) res type_set)\n          (recur (rest new_coll) (conj res (filter #(= (type %) first_type) new_coll)) (conj type_set first_type))))))\n      )\n    )","user":"5b5462b5e4b02d533a91bd20"},{"problem":50,"code":"(fn [coll]\n  (loop [ret {} coll coll]\n    (if (empty? coll)\n      (map #(ret %) (keys ret))\n      (let [v (first coll)\n            t (type v)\n            g (vec (ret t))\n            new-g (conj g v)\n            new-ret (assoc ret t new-g)]\n        (recur new-ret (rest coll))))))","user":"54d000c7e4b018d918be98d7"},{"code":"(fn [coll]\n  (map second (group-by type coll)))","problem":50,"user":"52381b2ae4b0fae3832e99ef"},{"code":"#(->> % (group-by class) vals set)","problem":50,"user":"4e8a880b535d65386fec210d"},{"problem":50,"code":"(fn [col]\n  (vals (reduce\n         #(assoc %1 (type %2) (conj (%1 (type %2) []) %2))\n         {}\n         col)))","user":"532ecd44e4b019098a6f8b49"},{"problem":50,"code":"(fn [coll]\n  (set (vals (reduce #(merge-with concat %1 {(type %2) [%2]}) {} coll))))","user":"567c2322e4b05957ce8c61af"},{"problem":50,"code":"(fn type-split [seq]\n  (loop [acc [], seq seq]\n    (if (empty? seq)\n      acc\n      (recur (conj acc (filter #(= (type %) (type (first seq)))\n                               seq))\n             (filter #(not (= (type %) (type (first seq))))\n                     seq)))))","user":"5532a04ee4b09218d5f44f82"},{"problem":50,"code":"(fn [xs]\n  (->> xs\n       (reduce (fn [m a]\n                  (let [k (type a)\n                        v (m k)]\n                    (assoc m k\n                      (if (nil? v)\n                        [a]\n                        (conj v a))))) {})\n       vals))","user":"5a95c639e4b0d174b936c75e"},{"problem":50,"code":"(fn\n  [lst]\n  (->> (group-by type lst)\n       (map second)))","user":"56df6498e4b0ca2494a095f8"},{"code":"(fn [xs]\n  (vals (let [\n    go (fn [acc x]\n          (if (contains? acc (type x))\n            (assoc acc (type x) (conj (acc (type x)) x))\n            (conj acc [(type x) [x]])))]\n    (reduce go {} xs))))","problem":50,"user":"4e7f5a0b535db966e863cc41"},{"problem":50,"code":"(fn [xs]\n  (letfn\n    [(my-fn [ys]\n            (if (= ys '())\n              ys\n              (let [t (type (first ys))]\n                (cons \n                 (filter #(= (type %) t) ys) \n                 (my-fn (filter #(not (= (type %) t)) ys))))))]\n    (my-fn xs)))","user":"5447e08ce4b032a45b8693c3"},{"code":"(comp vals (partial group-by (juxt keyword? vector?)))","problem":50,"user":"5246e945e4b0644eb7b0783b"},{"problem":50,"code":"(fn [x]\n         (apply concat (map rest (group-by type x))))","user":"59385840e4b02506e01a29c9"},{"problem":50,"code":"#( set (vals  (group-by class %)))","user":"573940e3e4b0cd1946bd106b"},{"problem":50,"code":"(fn [vect]\n    (let [append-val (fn [map map-key value] \n                       (assoc map map-key (conj (map map-key) value)))]\n    (map #(reverse (second %))\n       (reduce #(append-val %1 (type %2) %2) {} vect))))","user":"5655e056e4b0f9d632dd849b"},{"problem":50,"code":"(fn\n  [xs]\n  (vals (reduce (fn\n                  [acc x]\n                  (if (contains? acc (str (type x)))\n                    \n                    (assoc acc (str (type x)) (conj (get acc (str (type x)))x))\n                    (assoc acc (str (type x)) (vector x))))\n                {}\n                xs)))","user":"5e1c24f4e4b0dc959400852d"},{"problem":50,"code":"#(->> %\n      (reduce (fn [acc item]\n           (let [t     (type item)\n                 t-vec (get acc t [])]\n             (assoc acc t (conj t-vec item))))\n         {})\n      vals)","user":"542c22bde4b0dad94371f29e"},{"problem":50,"code":"#(mapcat rest (group-by type %1))","user":"57126104e4b09c608db70458"},{"code":"(fn split-types [xs]\n    (map (fn [t] (filter #(= t (type %)) xs)) (map type xs))\n  )","problem":50,"user":"506b0a9ce4b0a2a5463de380"},{"problem":50,"code":"#(loop [a %1 result {}]\n    (if (empty? a)\n      (map (fn [a] (reverse a)) (vals result))\n      (recur (rest a) (assoc result (type (first a)) (conj (result (type (first a))) (first a))))\n      )\n    )","user":"5763818ae4b0994c1922fbc7"},{"code":"(fn split-by-type [seqs]\n (set  (vals (group-by #(type %) seqs))   ))","problem":50,"user":"5273562ae4b03e8d9a4a7479"},{"problem":50,"code":"(fn [xs]\n  (map (fn [[key value]] value)\n     (reduce (fn [res x]\n               (let [t (type x)\n                     c (get res t [])]\n                 (assoc res t (conj c x)))\n               )\n             {} xs)))","user":"5eee7311e4b07c55ae4a0510"},{"code":"(fn r\n ([xs] (r xs {}))\n ([xs m]\n  (if\n   (empty? xs)\n   (into #{} (vals m))\n   (r\n    (rest xs)\n    (conj\n     m\n     {(type (first xs))\n      (concat (m (type (first xs))) [(first xs)])})))))","problem":50,"user":"4fb510b5e4b081705acca2b8"},{"code":"(fn [x]\n  (partition-by \n   #(str (type %)) \n   (sort-by \n    #(str (type %)) \n    x)))","problem":50,"user":"5192dd39e4b0c663c5d86c9e"},{"problem":50,"code":";#(vals (group-by type %))\n(fn split-by-type [coll]\n  (vals (reduce\n         (fn [split-type-map elem]\n           (let [k (class elem)\n                 class-vec (or (split-type-map k) [])]\n             (assoc split-type-map k (conj class-vec elem))))\n         {}\n         coll)))","user":"5fd2e391e4b07e53c2f3f049"},{"code":"(fn [xs]\n  (set (partition-by class (sort-by #(str (class %)) xs))))","problem":50,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn [s] \n  (let [types (set (map #(type %) s))]\n    (map (fn [t] (filter #(= (type %) t) s)) types)\n    )\n  )","problem":50,"user":"535197f2e4b084c2834f4ae4"},{"code":"(fn [l] (map #(second %) (group-by #(class %) l)))","problem":50,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [m] (vals (reduce #(merge-with concat %1 %2) {} (map (fn [e] {(type e) [e]}) m))))","problem":50,"user":"4f1bee08535d64f60314647e"},{"code":"(fn [x] (loop[myNL '() cU0 0](if(< cU0 11)\n                              (recur\n                               (cond (and (not= (filter integer? x) ()) (= cU0 0)) (conj myNL (concat [](filter integer? x)))\n                                     (and (not= (filter float? x) ()) (= cU0 1)) (conj myNL (concat [](filter float? x)))\n                                     (and (not= (filter char? x) ()) (= cU0 2)) (conj myNL (concat [](filter char? x)))\n                                     (and (not= (filter string? x) ()) (= cU0 3)) (conj myNL (concat [](filter string? x)))\n                                     (and (not= (filter keyword? x) ()) (= cU0 4)) (conj myNL (concat [](filter keyword? x)))\n                                     (and (not= (filter coll? x) ()) (= cU0 5)) (conj myNL (concat [](filter coll? x)))\n                                     (and (not= (filter list? x) ()) (= cU0 6)) (conj myNL (concat [](filter list? x)))\n                                     (and (not= (filter vector? x) ()) (= cU0 7)) (conj myNL (concat [](filter vector? x)))\n                                     (and (not= (filter set? x) ()) (= cU0 8)) (conj myNL (concat [](filter set? x)))\n                                     (and (not= (filter map? x) ()) (= cU0 9)) (conj myNL (concat [](filter map? x)))\n                                     (and (not= (filter seq? x) ()) (= cU0 10)) (conj myNL (concat [](filter seq? x)))\n                                :else myNL)\n                               (+ cU0 1)\n                               )\n                              myNL\n                              )\n         )\n\t  )","problem":50,"user":"5177cacde4b0261ae665b877"},{"problem":50,"code":"(fn [xs]\n              (vals (reduce (fn [acc x]\n                              (let [v (get acc (type x) [])]\n                                (assoc acc (type x) (conj v x)))) {} xs)))","user":"4f9aa2a6e4b0dcca54ed6d0c"},{"code":"(fn [s]\r\n  (letfn [(hp [acc [fst & rs :as sq]]\r\n            (if (empty? sq)\r\n              acc\r\n              (hp (conj acc (filter #(= (type fst) (type %)) sq))\r\n                  (remove #(= (type fst) (type %)) sq))))]\r\n    (hp #{} s)))","problem":50,"user":"4ee40938535d10e5ff6f5375"},{"code":"(fn [v]\n  (vals (group-by class v)))","problem":50,"user":"5060d137e4b0dc10a69545a0"},{"code":"(fn [a] (vals (reduce #(let [c (type %2)] (conj % [c (conj (get % c []) %2)])) {} a)))","problem":50,"user":"4f0664bd535dcb61093f6c0f"},{"code":"(fn  [x] (map reverse (vals (reduce #(assoc %1 (type %2) (conj (%1 (type %2)) %2)) {} x))))","problem":50,"user":"4dcc5aff535d5973398f9293"},{"problem":50,"code":"(fn [coll]\n   (-> (reduce (fn [result val]\n                 (assoc result (type val) (conj (vec (get result (type val))) val)))\n               {}\n               coll)\n       vals\n       set))","user":"5d5c2730e4b09db18d4482ea"},{"code":"(fn [items]\n  (vals (group-by type items)))","problem":50,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [coll]\n  (for [item-type (distinct (map type coll))]\n    (filter #(= item-type (type %)) coll)))","problem":50,"user":"514721c6e4b0d520409ed392"},{"code":"#(->> %(group-by type)vals)","problem":50,"user":"52c4fe42e4b0c2d177d620e9"},{"code":"(fn [col]\n  (let [st (comp str type)]\n    (vals \n      (reduce (fn [m a]\n        (let [sta (st a)]\n          (if (contains? m sta)\n            (assoc m sta (conj (m sta) a))\n            (assoc m sta [a]))))\n        {}\n        col))))","problem":50,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [x]\n  (partition-by #(pr-str (class %)) (sort-by #(pr-str (class %)) x)))","problem":50,"user":"4ec5cdb0535d6d7199dd36b8"},{"problem":50,"code":"#(for [[key v]\n  (group-by class %)]\n    v)","user":"57b88091e4b0fbc9809a27e1"},{"problem":50,"code":"(fn [s] (vals (group-by #(class %) s)))","user":"53a739b0e4b0ef122a8689d0"},{"code":"#(into #{} (map second (group-by type %)))","problem":50,"user":"514cfa27e4b019235f6c057d"},{"code":"(fn [v]\n  (into #{} (vals (group-by (fn [a] (class a)) v))))","problem":50,"user":"4f16d6ed535d64f60314644f"},{"problem":50,"code":"(fn [xs]\n  (loop [xs xs result #{}]\n    (if (empty? xs)\n      result\n      (recur (filter\n              #(not\n                (= (type (first xs)) (type %)))\n              xs)\n             (conj\n              result\n              (filter\n               #(= (type (first xs)) (type %))\n               xs))))))","user":"56403765e4b08d4f616f5edc"},{"problem":50,"code":"#(filter vector? (apply concat (group-by type %)))","user":"53cdb2c4e4b00fb29b2212e5"},{"problem":50,"code":"#( map (fn [t] (filterv  (fn [x] (= t (class x)))    %)                      )  (set (map class % ))  )","user":"5da98129e4b000c986472c33"},{"problem":50,"code":"(fn f [coll] (vals (group-by class coll)))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":50,"code":"(fn [args]\n        (vals (group-by type args)))","user":"5b86462de4b047b03b2037df"},{"code":"; With maximum functional-foo - no traversing or recurring, just composing built-ins (type was a good find !)\n(fn [input] (set (vals (group-by #(type %) input))))\n;\n; In Ruby - traversal-oriented\n; input.each_with_object({}){|x,acc| (acc[x.class] ||= []) << x }.values","problem":50,"user":"5351980ce4b084c2834f4ae5"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n     (group-by type)\n     vals\n     set))","user":"5400e918e4b0de5c41848619"},{"problem":50,"code":"(comp (partial into #{}) vals (partial group-by type))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [aseq] (vals (group-by #(cond \n                       (integer? %) :int\n                       (string? %) :str\n                       (keyword? %) :key) aseq)))","problem":50,"user":"51bf4560e4b013aa0d74b817"},{"code":"(fn [l]\r\n  (letfn [(worker [l s]\r\n            (if (empty? l)\r\n              s\r\n              (let [v (first l) c (class v) p (find s c)]\r\n                (if p\r\n                  (recur (rest l) (assoc s c (conj (val p) v)))\r\n                  (recur (rest l) (assoc s c [v]))))))]\r\n    (map val (worker l {}))))","problem":50,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn type-split [coll]\n    (let [types (reduce conj #{} (map type coll))]\n      (for [t types]\n        (filter #(= t (type %)) coll))))","problem":50,"user":"4e615cd2535d8ccf87e9fe58"},{"code":"(fn [x]\n  (loop [my-x (rest x)\n         acc [ [(first x)] ]\n        ]\n  \t(if (empty? my-x)\n      acc\n      (let [\n        acc-with-obj (fn [acc obj]\n                        (loop [old-acc acc\n                               new-acc []\n                               my-obj obj\n                               added false]\n                          (do\n                            (if (empty? old-acc)\n                              (if added\n                                 (do\n                                   (println \"added\")\n                                   (println new-acc)\n                                   new-acc\n                                 )\n                                 (do\n                                   (println \"new\")\n                                   (println new-acc)\n                                   (conj new-acc [my-obj])\n                                )\n                              )\n                              (do\n                                (let [same-type (or added (= (type my-obj) (type (first (first old-acc)))))\n                                      type-acc (if (and (not added) same-type)\n                                                 (conj (first old-acc) my-obj)\n                                                 (first old-acc)\n                                               )\n                                     ]\n                                  (do\n                                    (recur (rest old-acc) (conj new-acc type-acc) my-obj same-type)\n                                  )\n                                )\n                              )\n                            )\n                          )\n                        )\n                      )\n            ]\n          (recur (rest my-x) (acc-with-obj acc (first my-x))\n        )\n      )\n    )\n  )\n)","problem":50,"user":"5303a027e4b0d8b024fd3745"},{"problem":50,"code":"(fn [x] (for [[_ value] (group-by class x)] value))","user":"517e12e3e4b0fcc7c5d37d3c"},{"problem":50,"code":"(fn\n    [x]\n    (loop [t [clojure.lang.PersistentVector java.lang.Long\n              clojure.lang.Keyword java.lang.String]\n           s x\n           n #{}]\n      (if (empty? t)\n        n\n        (let [f (vec (filter #(instance? (first t) %) s))]\n          (if (empty? f)\n            (recur (rest t) s n)\n            (recur (rest t) s (conj n (vec (filter #(instance? (first t) %) s))))\n            )))))","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":50,"code":"#(for [[key value] (group-by class %)] value)","user":"4e580746535d8a8b8723a28c"},{"code":"#(vals (group-by \n  type\n  %))","problem":50,"user":"50f53694e4b057d4c52de881"},{"problem":50,"code":"(fn [x] (letfn [(str-type [a] (str (type a)))] (partition-by str-type (sort-by str-type x))))","user":"552456e3e4b0882d96d091c2"},{"problem":50,"code":"#(map (fn [[a b]] b) (group-by type %))","user":"54af6fb0e4b09f271ff37d08"},{"problem":50,"code":"(fn [s]\n  (loop [s s m {}]\n    (if (empty? s)\n      (set (vals m))\n      (recur (rest s)\n             (let [t (type (first s))]\n               (if (contains? m t)\n                 (into m {t (conj (get m t) (first s))})\n                 (into m {t [(first s)]})))))))","user":"54cad59ee4b057c6fda3a26e"},{"code":"(fn [s] (set (vals (group-by class s))))","problem":50,"user":"525c575be4b0cb4875a45d38"},{"code":"(fn [x]\n  (->>\n    (reduce\n      (fn [x- xs]\n        (let [t (type xs)]\n          (assoc x- t (conj (get x- t) xs))))\n      {} x)\n    (vals)\n    (map reverse)\n    ))","problem":50,"user":"4f616892e4b0defedf855fbf"},{"problem":50,"code":"(fn [coll]\n\t(loop [remaining coll acc {}]\n\t\t(if (empty? remaining)\n\t\t\t(map #(into [] %) (vals acc))\n\t\t\t(let [\n\t\t\t\tt (type (first remaining))\n\t\t\t\titem (first remaining)\n\t\t\t\tr (rest remaining)]\n\t\t\t\t(let [newAcc (merge acc { t (conj (or (get acc t) []) item) })]\n\t\t\t\t\t(recur r newAcc))))))","user":"598af379e4b02b9968b84ce6"},{"code":"(fn sbt\n  ([v] (sbt v {}))\n  ([v m]  \n    (let [t (type (first v))]\n      (cond\n        (empty? v) \n            (set (vals m))\n        (m t)\n            (recur (rest v) (assoc m t (conj (m t) (first v))))\n        true\n            (recur (rest v) (assoc m t [(first v)]))))))","problem":50,"user":"4e28120f535deb9a81d77efa"},{"problem":50,"code":"(fn type-splitter [ts]\n  (vals (group-by type ts)))","user":"55ed5a2de4b0121d4835fdd8"},{"problem":50,"code":"(fn split-by-type\n  [things]\n  (loop [[h & t] things\n         accum {}]\n    (let [h-type (type h)]\n      (let [new-accum (if (contains? accum h-type)\n                          (assoc accum h-type (conj (accum h-type) h))\n                          (assoc accum h-type [h]))]\n        (if (nil? t)\n            (vals new-accum)\n            (recur t new-accum))))))","user":"58152157e4b0f478707a0631"},{"problem":50,"code":"(fn [xs]\n  (let [type-lists\n        {(type 1) '()\n        (type :a) '()\n        (type \"a\") '()\n        (type [1]) '()}]\n    (set\n     (map #(apply vector (reverse %))\n          (filter #(not= [] %)\n                  (vals\n                   (reduce\n                    (fn [result x]\n                      (assoc-in result [(type x)] (conj (result (type x)) x)))\n                    type-lists\n                    xs)))))))","user":"56cc34aee4b0ea9b8538f73c"},{"problem":50,"code":"#(for [[k v] (group-by class %)] v  )","user":"57f9b25fe4b0d3187e90094b"},{"problem":50,"code":"(fn split-by-type [coll]\n  (map second\n    (group-by type coll)\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"problem":50,"code":"(fn sk-group [xs]\n  (->> xs\n       (group-by type)\n       vals\n       ))","user":"5884f377e4b0f1effa3b76a8"},{"problem":50,"code":"(fn [coll] (apply hash-set (vals (group-by type coll))))","user":"54a96a15e4b09f271ff37cad"},{"code":"(fn [xs] (set (partition-by type (sort-by #(-> % type str) xs))))","problem":50,"user":"4ef8d47c535dced4c769f261"},{"code":"(fn [a] (vals(reduce #(let [t (type %2)] (assoc % t (conj (% t []) %2))) {} a)))","problem":50,"user":"4e6f8431535d5021c1a8961e"},{"code":"#(map (fn [x] (filter (fn [y] (= (type x) (type y))) %)) %)","problem":50,"user":"4e307313535deb9a81d77f14"},{"code":"(fn grp [s]\n  (vals (group-by type s)))","problem":50,"user":"512eb1e7e4b0b740abc5982a"},{"problem":50,"code":"( fn [ sec ]\n  (for [[x y] (group-by class sec)]\n    y))","user":"589f37e0e4b02bd94d917e79"},{"code":"(fn [l] (vals (loop [ll l result {}] (if (empty? ll) result (recur (rest ll) (assoc result (str (type (first ll))) (into [](concat  (result (str (type (first ll)))) (vector (first ll))))))))))","problem":50,"user":"510931ede4b0c71f76895663"},{"problem":50,"code":"(fn [x] \n    (vals\n        (reduce \n            (fn [result item] \n                (merge-with into result item)\n            )\n            (map (fn [a] (hash-map (type a) [a])) x)\n        )\n    )\n)","user":"5b67f0fbe4b0c6492753e76d"},{"problem":50,"code":"#(vals (group-by type %))\n\n;(fn [coll]\n;  (vals\n;    (reduce\n;      (fn [m x]\n;        (assoc m\n;          (type x)\n;          (conj (get m (type x) []) x)))\n;      {} coll)))","user":"53a074a4e4b0ca733b9744af"},{"problem":50,"code":"(fn [col]\n    (let [t (into #{} (map type col))\n          f (fn [t]\n              (filter #(= (type %) t) col)\n              )]\n      (map f t)\n      ))","user":"59932f49e4b0b211ea3aaaae"},{"problem":50,"code":"(fn [col]\n  (map reverse (vals (reduce (fn [map value]\n                  (let [val-type (type value)]\n                    (assoc map val-type (conj (get map val-type) value))))\n                {}\n                col))))","user":"50a2e3fbe4b029e8bace3629"},{"problem":50,"code":"#(vals (reduce (fn [m e] (assoc m (type e) (if-let [a (get m (type e))] (conj a e) [e]))) {} %))","user":"55ccdc6be4b0e31453f64a18"},{"problem":50,"code":"(fn [a] \n\t(set \n\t\t(vals\n\t\t\t(reduce \n\t\t\t\t(fn [a c] \n\t\t\t\t\t(merge-with into a {(type c) [c]})\n\t\t\t\t)\n\t\t\t\t{}\n\t\t\t\ta\n\t\t\t)\n\t\t)\n\t)\n)","user":"5810b899e4b0f478707a05d8"},{"problem":50,"code":"(fn SplitByType [s]\n  (vals (group-by type s)))","user":"53b88e6ee4b047364c0444de"},{"code":"(fn [s]\n  (set  \n    (vals \n      (reduce (fn [acc x]\n          (let [k (type x)]\n            (update-in acc [k] #(if % (conj % x) [x])))) {} s))))","problem":50,"user":"4e5ecd65535d8a8b8723a2d6"},{"code":"(fn[a-seq]\n  (distinct (map \n    (fn[y] (filter (fn[x](= (type x) (type y)))\n      a-seq)) a-seq)))","problem":50,"user":"4e58bcd4535d8a8b8723a296"},{"code":"(fn [x] (set (map reverse (vals (reduce #(assoc % (class %2) (conj (% (class %2)) %2)) {} x)))))","problem":50,"user":"52c25645e4b07a9af579237d"},{"code":"(comp set vals (partial group-by type))","problem":50,"user":"50e3e108e4b01912b3285c48"},{"problem":50,"code":"(fn split-by-type [coll]\n  (vals\n   (group-by class coll)))","user":"60c91f48e4b0e0fa5f1b4304"},{"code":"(comp vals (partial group-by #(.getClass %)))","problem":50,"user":"4f1b0ab3535d64f603146474"},{"problem":50,"code":"(fn [seq]\n  (map (fn [type] (filter #(instance? type %) seq))\n       (set (map type seq))))","user":"5b47874be4b02d533a91bc70"},{"problem":50,"code":"(fn test [coll]\n  (vals (group-by type coll))\n  )","user":"54021f13e4b0df28a13c62cc"},{"code":"(fn [l] (map (fn [t] (filter #(= (type %) t) l)) (distinct (map type l))))","problem":50,"user":"534bd9c1e4b084c2834f4a80"},{"problem":50,"code":"#(->> (group-by type %1) (vals))","user":"5351fca5e4b084c2834f4aec"},{"code":"(fn categorize [coll]\n  (let [classed           (map (fn [x] {(class x) [x]}) coll)\n  merged-categories (apply merge-with concat {} classed)]\n    (vals merged-categories)))","problem":50,"user":"4dc54eb2535d8a4b2fd74284"},{"problem":50,"code":"(fn [x]\n    (vals (group-by class x)))","user":"4e837808535db62dc21a62d9"},{"code":"(fn split-type [s] \n    (vals (apply (partial merge-with concat) (reduce (fn [x y]\n      (conj x {(.getClass y) [y]} )\n\n   ) [] s)))\n\n)","problem":50,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":50,"code":"(fn [xs]\n  (->> xs\n      (group-by class)\n       vals))","user":"558ffb4be4b0277789237667"},{"problem":50,"code":"(fn [x]\n  (set (map second (group-by type x))))","user":"525cc912e4b0cb4875a45d48"},{"code":"(fn [s] (vals\n  (reduce #(assoc %1 (class %2) (vec (conj (%1 (class %2)) %2))) {} s)))","problem":50,"user":"4ed55b5d535d10e5ff6f52d8"},{"code":"(fn [l]\n  (vals (apply merge-with concat\n    (for [x l]\n      {(class x) [x]}\n    ))))","problem":50,"user":"519136e9e4b0f8ef0be96c01"},{"problem":50,"code":"(fn [l]\n\t(set (vals (group-by type l)))\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [x] (map vec(partition-by type (sort-by #(str (type %)) x))))","problem":50,"user":"536046a9e4b063bf7a5f8fe1"},{"problem":50,"code":"(fn type-split\n  [aseq]\n  (let [all (reduce (fn [out x]\n                      (println x)\n                      (cond\n                        (number? x) (assoc-in out\n                                              [:num]\n                                              (conj (:num out) x))\n                        (string? x) (assoc-in out\n                                              [:str]\n                                              (conj (:str out) x))\n                        (keyword? x) (assoc-in out\n                                               [:key]\n                                               (conj (:key out) x))\n                        (vector? x) (assoc-in out\n                                              [:vec]\n                                              (conj (:vec out) x))))\n                    {:num [] :str [] :key [] :vec []}\n                    aseq)]\n\n    (reduce (fn [out x]\n              (if (empty? (last x))\n                out\n                (conj out (last x))))\n            []\n            all)))","user":"5d110abee4b02c15ef021983"},{"problem":50,"code":"(fn [l]\n  (map #(filter (fn [x] (= (type x) %)) l) (distinct (map type l))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":50,"code":"(fn [s]\n   (->> (reduce\n          #(update-in %1 [(type %2)] conj %2)\n          {} s)\n      vals\n      (map reverse)))","user":"55895eade4b059ccff29b202"},{"problem":50,"code":"(fn split-by-type [coll]\n  (->> (group-by class coll)\n       vals\n       (into #{})))","user":"5984e7dee4b021a7a535fe43"},{"problem":50,"code":"(fn [c]\n  (vals (apply (partial merge-with into) (map #(hash-map (type %) [%]) c)))\n  \n  )","user":"543b4746e4b032a45b86932c"},{"problem":50,"code":"(fn [xs] (map (fn [x] (filter #(= x (type %1)) xs)) (map type xs) ))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn splitbytype [x]\n  (set\n    (vals\n      (reduce\n        #(assoc %1 (type %2) (conj (%1 (type %2) []) %2))\n        (hash-map)\n        x))))","problem":50,"user":"52dad8bde4b09f7907dd13be"},{"code":"#(vals (group-by class %))","problem":50,"user":"4ddcabcb535d6ebe9be03f52"},{"problem":50,"code":"(fn [x] (map val (group-by #(type %) x)))","user":"5598cf5ae4b031d6649c9b9f"},{"problem":50,"code":"#(->> (map (fn [x] {(class x) [x]}) %)\n      (reduce (fn [a b] (merge-with into a b)))\n      (vals))","user":"5ab1665de4b073f1774425c0"},{"problem":50,"code":"(fn dd[coll](filter #(not(nil? %))(loop[coll coll\n                    n []\n                    t []\n                    k []\n                    v []\n                    ret []]\n                (println coll n t k v ret)\n                (cond\n                  (empty? coll) (conj ret\n                                      (cond (not(empty? n)) n\n                                            :else nil)\n                                      (cond (not(empty? t)) t\n                                            :else nil)\n                                      (cond (not(empty? k)) k\n                                            :else nil)\n                                      (cond (not(empty? v)) v\n                                            :else nil))\n                  :else (recur (rest coll)\n                               (cond\n                                 (number? (first coll))(conj n (first coll))\n                                 :else n)\n                               (cond\n                                 (string? (first coll))(conj t (first coll))\n                                 :else t)\n                               (cond\n                                 (keyword? (first coll))(conj k (first coll))\n                                 :else k)\n                               (cond\n                                 (vector? (first coll))(conj v (first coll))\n                                 :else v)\n                               ret\n                               )))))","user":"5dadf73ee4b0f8c104ccfc86"},{"code":"(fn [coll]\n  (map (fn [x]\n         (filter #(= (type %) (type x)) coll)) coll))","problem":50,"user":"523f1245e4b01c266ffa7f95"},{"problem":50,"code":"(fn [coll] (set (partition-by type (sort-by #(str (type %)) coll))))\n\n;Even more succinct:\n;(set (vals (group-by type %)))","user":"56041883e4b0c80df0ca2655"},{"problem":50,"code":"(fn [sq]\n  (vals  (group-by type sq))\n  )","user":"60436423e4b02d28681c77a3"},{"code":"(fn [xs]\n  (vals (apply merge-with into (map #(hash-map (class %) [%]) xs))))","problem":50,"user":"4ea365e2535d7eef308072c5"},{"problem":50,"code":"#(vals (reduce (fn [m x] (assoc m (type x) (concat (get m (type x)) [x]))) {} %))","user":"56c792ace4b0ed865f9758c4"},{"code":"(fn group-and-filter [x]\n  (set (map (fn [y] (second y))\n\t\t (group-by (fn [z] (type z)) x))))","problem":50,"user":"4ee91d00535d93acb0a6688b"},{"code":"(fn [coll]\n   (loop [coll coll acc (list)]\n     (let [elt (first coll)\n           elt-type (type elt)\n           pred #(= (type %) elt-type)]\n       (if (seq coll)\n         (recur (filter (complement pred) coll)\n                (cons (filter pred coll) acc))\n         acc))))","problem":50,"user":"52cc582ae4b07d0d72b27362"},{"code":"(fn [col]\n    (set (vals (group-by #(type %) col))))","problem":50,"user":"524d90c0e4b0a16e35cf6ded"},{"code":"#(set (vals (  group-by type %)))","problem":50,"user":"4f3e2fbbe4b0e243712b1f7e"},{"problem":50,"code":"(fn [x] \n    (->> x \n       (sort-by #(str (class %)))\n       (partition-by #(class %))))","user":"54c169ade4b0ed20f4ff6f24"},{"problem":50,"code":"(fn [x]\n  (for [[y z] (group-by class x)] z)\n  )","user":"57750460e4b0979f8965160c"},{"code":"(fn\n  [l]\n    (vals\n      (loop\n        [dict {}, more l]\n          (if (not (seq more))\n            dict\n            (let [n (first more)]\n              (recur (assoc dict (type n) (conj (vec (dict (type n))) n)) (rest more)))))))","problem":50,"user":"4e6ac7a8535d8ccf87e9ff03"},{"problem":50,"code":"(fn sbt [s]\n  (vals\n   (reduce\n    (fn [acc v]\n      (assoc acc (class v) (into [] (conj (acc (class v)) v))))\n    {}\n    s)))","user":"5b0bea6de4b0cc2b61a3bdda"},{"code":"(fn [x] (map (fn [y] (second y)) (into [] (group-by class x))))","problem":50,"user":"5296008fe4b02ebb4ef7502a"},{"problem":50,"code":"(fn [elems]\n    (vals (group-by type elems)))","user":"5ac6ef9be4b0e27600da7779"},{"problem":50,"code":"(fn [c] (vals(group-by type c)))","user":"58eed4c5e4b056aecfd47db7"},{"code":"(fn\r\n  [xs]\r\n  (partition-by type (sort-by (comp str type) xs)))","problem":50,"user":"4fee04a0e4b0678c553fc308"},{"problem":50,"code":"(fn [coll]\n    (letfn [(map-by-type [result coll]\n              (if (empty? coll)\n                result\n                (let [fel (first coll)]\n                  (recur\n                   (merge-with\n                    concat\n                    result\n                    {(type fel) [fel]})\n                   (rest coll)))))]\n      (apply hash-set (vals (map-by-type {} coll)))))","user":"55ac07afe4b03311e7b7328f"},{"problem":50,"code":"#(loop [x % y {}]\n          (let [t (type (first x))]\n            (cond (empty? x) (vals y)\n                  (contains? y t) (recur (rest x)\n                                         (assoc y t (conj (get y t)\n                                                          (first x))))\n                  :else (recur (rest x) (assoc y t [(first x)])))))","user":"59fea630e4b01bb0ae8afd10"},{"problem":50,"code":"(fn split-by-type [input]\n    (let [types (set (map second (map #(vector % (type %)) input)))]\n      (map (fn [ftype]\n             (filter #(= ftype (type %)) input))\n           types\n      )))","user":"5a94a38ce4b0d174b936c73e"},{"problem":50,"code":"(fn [s]\n  (-> (group-by type s)\n      vals\n      set))","user":"56201392e4b064ca9f4b16d8"},{"problem":50,"code":"(let [keyfunc (fn [x] (str (class x)))]\n\t(fn [y] (partition-by keyfunc (sort-by keyfunc y)))  \n)","user":"585bcd51e4b0f14aab7c8771"},{"code":"(fn sbt [xs]\n  (let [types (set (map type xs))]\n    (set (for [t types] (filter #(= t (type %)) xs)))))","problem":50,"user":"4f2a35ace4b0d6649770a03a"},{"problem":50,"code":"#(map (fn [x] (second x)) (group-by type %))","user":"607d6bc1e4b03d835a6eaecc"},{"problem":50,"code":"(fn [coll]\n  (->> \n   coll\n   (group-by #(type %))\n   vals\n )\n  )","user":"59cf0d75e4b0ef0a1e9b5b5f"},{"problem":50,"code":"(fn [coll]\n  (map (fn [[k v]] v) (group-by class coll)))","user":"51c1b644e4b0d204dbe2ca12"},{"problem":50,"code":"(fn [coll] (vals  (group-by type coll)))","user":"5703cd50e4b08d47c97781fc"},{"problem":50,"code":"(fn [col]\n  (set (vals (group-by #(type %) col)))\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":50,"code":"(fn [s] (->> s (group-by type) vals))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [coll]\n  (-> (group-by type coll)\n      vals\n      set))","problem":50,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":50,"code":"(fn p50 [seqq]\n\n  (letfn [(replace-set [val acc]\n            (let [elem (first (filter (fn [seq] (some #(= (type %) (type val)) seq)) acc))]\n              (if (nil? elem)\n                (conj acc [val])\n                (conj (disj acc elem) (conj elem val))\n                )\n              )\n            )]\n\n    (loop [curr (first seqq)\n           restt (rest seqq)\n           acc #{}]\n\n      (if (empty? restt)\n        (replace-set curr acc)\n        (recur (first restt) (rest restt) (replace-set curr acc))\n        )\n      )\n\n\n    )\n\n\n  )","user":"53b0750fe4b047364c044483"},{"code":"(fn split*\n  ([coll] (split* coll {}))\n  ([[head & tail :as coll] acc]\n     (if (seq coll)\n       (split*\n        tail\n        (update-in acc [(class head)] #(conj (or % []) head)))\n       (vals acc))))","problem":50,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn [x] (map #(last %) (group-by type x)))","problem":50,"user":"52a5f1e6e4b0c58976d9abf4"},{"problem":50,"code":"(fn [s] (vec (vals(group-by type s))))","user":"573c813be4b0cd1946bd10c5"},{"code":"#(partition-by type\n               (map (fn [q] (second q))\n                    (sort (fn [y z] (compare (str (first y)) (str(first z))))\n                          (map (fn [x] (list (type x) x)) %))))","problem":50,"user":"51bb970be4b0fe3ecfb4644e"},{"code":"(fn [xs]\n  (vals\n  (reduce\n    (fn [acc x]\n      (let [c (class x)]\n        (if (contains? acc c)\n            (update-in acc [c] conj x)\n            (assoc acc c [x]))))\n    {}\n    xs)))","problem":50,"user":"50427899e4b0add3005c0fc2"},{"problem":50,"code":"(fn split-by-type [s]\n  (->> (reduce (fn [z h] ((fn add [what where value]\n  (assoc where what\n    (if (get where what)\n        (conj (get where what) value)\n        [value]))) (type h) z h)) {} s)\n       (map #(last %))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [h]\n  (set (map (comp vec second) (group-by type h))))","problem":50,"user":"5027fc0ce4b01614d1633ff2"},{"problem":50,"code":"(fn split-by-type [col]\n  (vals (group-by type col)))","user":"5887518ae4b0f1effa3b76f5"},{"code":"(fn [coll]\n  (vals (reduce\n          (fn [m v]\n            (update-in m [(type v)] #(do (if (nil? %) [v] (conj % v)))))\n          {} coll)))","problem":50,"user":"5041bdf3e4b06d8231e4fad0"},{"problem":50,"code":"; (comp vals (partial group-by type))\n\n(fn [xs]\n  (vals (reduce (fn [a x] (update-in a [(type x)] (fnil conj []) x)) \n                {} \n                xs)))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"code":"#(vals(group-by class %))","problem":50,"user":"4edeac6b535d10e5ff6f533a"},{"problem":50,"code":"(fn [lst] \n  (->> lst\n       (sort-by (comp str type))\n       (partition-by type) ))","user":"6011b89ee4b074f607df66bc"},{"problem":50,"code":"(fn [x](vals(group-by type x)))","user":"53ada652e4b047364c04446d"},{"code":"#(remove empty? (list (filter keyword? %1) (filter string? %1) (filter vector? %1) (filter number? %1) ))","problem":50,"user":"5290ffaee4b0239c8a67af10"},{"problem":50,"code":";;#(map val (group-by type %))\n#(vals (group-by type %))","user":"5d1be50ce4b02ea6f0fb6986"},{"code":"(fn [s]\n   (vals (reduce #(assoc % (class %2) (conj (get % (class %2) []) %2)) {} s)))","problem":50,"user":"50aedb8ce4b0a40c9cfb08d4"},{"code":"(fn [s]\n  (vals (reduce\n    (fn [m v] (assoc m (class v) (conj (m (class v) []) v)))\n    {}\n    s)))","problem":50,"user":"5201ada5e4b0b2e020a18f14"},{"problem":50,"code":"(fn[x](map last (group-by type x)))","user":"5a067f26e4b01bb0ae8afdcc"},{"code":"(fn [coll]\n  (partition-by class (sort-by #(str (class %)) coll)))","problem":50,"user":"504e72cee4b0f6ff3350c4b4"},{"problem":50,"code":"(fn [l]\n  (let [type-add\n        (fn [a l]\n          (loop [a a b l result l]\n            (if (empty? b)\n              result\n              (if (= (type a) (type (first (first b))))\n                (recur a (rest b) (conj (remove #(= (first b) %) result) (conj (first b) a)))\n                (recur a (rest b) result)))))\n        type-checker\n        (fn [a l]\n          (if (empty? l)\n            false\n            (if (= (type a) (type (first (first l))))\n              true\n              (recur a (rest l)))))]\n    (loop [l l res []]\n      (if (empty? l)\n        res\n        (if (true? (type-checker (first l) res))\n          (recur (rest l) (type-add (first l) res))\n          (recur (rest l) (conj res (vector (first l)))))))))","user":"58e90258e4b056aecfd47cfd"},{"code":"(fn [s]\n  (vals (group-by \n    #(if (number? %)  :n \n     (if (keyword? %) :k\n     (if (string? %) :s\n     (if (vector? %) :v)))) s)))","problem":50,"user":"4e8b98fc535d65386fec2124"},{"problem":50,"code":"(comp (partial partition-by class) (partial sort-by (comp str class)))","user":"5b77248ae4b047b03b2036e7"},{"problem":50,"code":"(fn [l] \n  (vals (group-by type l)))","user":"55d74e71e4b0e31453f64aa4"},{"problem":50,"code":"(fn [x] (->> x (group-by type) (map second)))","user":"560794bde4b08b23635d3182"},{"problem":50,"code":"#(vals\n  (group-by class %))","user":"58e58ae9e4b056aecfd47c9a"},{"code":"(fn [data] (vals (group-by type data)))","problem":50,"user":"5271605ae4b03e8d9a4a73ed"},{"problem":50,"code":"(fn [coll]\n    \n        ((comp set vals) (reduce\n            (fn [a b] \n                (update-in \n                    a \n                    [(type b)] \n                    #(conj (if %1 %1 []) b)\n                )\n            )\n            {}\n            coll\n        ))   \n        \n    )","user":"5b274fd1e4b063e2438bcc3b"},{"code":"(fn [c]\n  (map second (group-by type c)))","problem":50,"user":"5089d52ce4b03217b26a539d"},{"problem":50,"code":"(fn group-by-type [col]\n   (map second (group-by class col)))","user":"5579eed7e4b05c286339e09b"},{"problem":50,"code":"(fn [sequence]\n  (set (map (fn [type_]\n              (filter (fn [item]\n                        (= type_ (type item)))\n                      sequence))\n            (set (map type sequence)))))","user":"58637f03e4b0f14aab7c881e"},{"code":"(comp (partial partition-by type) (partial sort-by (comp str type)))","problem":50,"user":"51c73959e4b07ef393169e3e"},{"code":"#(vals \n  (reduce \n    (fn [m x] (assoc m (type x) (conj (get m (type x) []) x))) \n    {} \n    %))","problem":50,"user":"4e6a97a9535d8ccf87e9fef8"},{"problem":50,"code":"(fn split \n  [xs]\n  ((fn f \n     [as bs]\n     (if (empty? as)\n       bs\n       (f (filter (fn [x] (not= (type x)\n                                (type (first as))))\n                  as)\n          (conj bs\n                (filter (fn [x] (= (type x)\n                                   (type (first as))))\n                        as))))) xs #{}))","user":"53c051a5e4b0c98a41f5ccae"},{"code":"(fn [x]\n  (set (map val (group-by type x))))","problem":50,"user":"4e9ff8d0535d7eef3080729c"},{"code":"#(map last (group-by (fn [x] (.getClass x)) %))","problem":50,"user":"4fa58500e4b081705acca1ae"},{"problem":50,"code":"(fn [x]\n (vals (group-by class x )))","user":"5ab07d63e4b073f1774425af"},{"problem":50,"code":"(fn [s] (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} s)))","user":"5578c67fe4b05c286339e08d"},{"code":"(fn [coll]\n  (for [t (map type coll)]\n    (filter (fn [x] (= t (type x)))\n            coll)))","problem":50,"user":"4f7250cce4b07046d9f4f02a"},{"problem":50,"code":"(fn split_by_type [lst]\n  ((fn [acc l]\n    (let [e (first l) tp (type e) rst (rest l)]\n     (cond\n      (empty? l) (set (vals acc))\n      (contains? acc tp) (recur (assoc acc tp (conj (get acc tp) e)) rst)\n      :else (recur (assoc acc tp [e]) rst)\n      ))) '{} lst))","user":"56df6351e4b0ca2494a095f3"},{"problem":50,"code":"(fn [ sq ]\n  (let [ update (fn update\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more)))) ]\n\n  (map reverse  (vals (reduce (fn [ acc next ]\n                                (update acc (type next) #(conj % next))) {} sq)))))","user":"59f90e6ae4b0ca45a743a337"},{"problem":50,"code":"(fn [l]\n  (into #{} (vals (group-by type l))))","user":"5c558070e4b0fb8c5ffd9a1e"},{"code":"(fn [col] (loop [s (set (map type col)) result #{}]\n    (if (empty? s) result\n      (recur (rest s) (conj result (filter #(= (type %) (first s)) col) )))\n    )\n  )","problem":50,"user":"510d3dc6e4b078ea71921132"},{"problem":50,"code":"(fn [x] (partition-by type (sort-by #(String/valueOf (type %)) x)))","user":"550ff2a3e4b06e50f9beb17f"},{"code":"(fn [s]\r\n  (map reverse (vals ((fn [s m]\r\n  \t\t\t\t\t\t\t\t     (if (nil? s)\r\n\t\t\t\t\t\t\t\t\t       m\r\n\t\t\t\t\t\t\t\t\t       (let [a (first s)\r\n\t\t\t\t\t\t\t\t\t             k ((comp keyword str type) a)\r\n\t\t\t\t\t\t\t\t\t             l (m k)]\r\n\t\t\t\t\t\t\t\t\t         (recur (next s) (assoc m k (cons a l))))))\r\n\t\t\t\t\t\t\t\t\t    s (hash-map)))))","problem":50,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":50,"code":"(fn [x] (vals (group-by #(class %) x)))","user":"54db33f1e4b024c67c0cf75d"},{"problem":50,"code":"(fn [ls]\n  (set (vals (reduce (fn [acc e]\n                       (let [t (type e)]\n                         (cond (contains? acc t) (assoc acc t (conj (get acc t) e))\n                               :else (assoc acc t [e])))) {} ls))))","user":"60228147e4b0d5df2af22202"},{"code":"(fn [coll] (vals (group-by (fn [ele] (class ele)) coll)))","problem":50,"user":"52485723e4b05ef8e38e63d2"},{"problem":50,"code":"#(->> (group-by type %) vals)","user":"586e47dee4b01531a375e9a9"},{"problem":50,"code":"#(->> % (group-by class\n                 ) (vals))","user":"5a83e15ae4b00b71e582a088"},{"code":"#(partition-by class (sort-by (comp str class) %))","problem":50,"user":"4db92654535d1e037afb21a0"},{"code":"(fn my-split [args]\n  (let [types (set (map type args))]\n    (map\n      (fn [t] (filter (fn [a] (= t (type a))) args))\n      types)))","problem":50,"user":"53436e60e4b084c2834f4a19"},{"code":"(fn split-by-type [xs]\n  (loop [xs xs accum {}]\n    (if (empty? xs) (vals accum)\n        (let [x (first xs)\n              t (type x)]\n          (recur (rest xs) (assoc accum t (conj (get accum t []) x)))))))","problem":50,"user":"4e50b67b535dc968683fc4ed"},{"problem":50,"code":"(fn [a]\n  (vals (group-by #(type %) a)))","user":"57d93437e4b0bd073c2023f9"},{"problem":50,"code":"(fn [col]\n    (vals (group-by #(type %) col)))","user":"530c15f7e4b02e82168697d6"},{"code":"(fn split-by-type [coll]\n  (loop [m {}, [x & xs] (seq coll)]\n    (if x\n      (recur (assoc m (type x) (conj (vec (m (type x))) x)) xs)\n      (set (vals m)))))","problem":50,"user":"4e89f9e5535d3e98b8023289"},{"code":"(let [splitter\n      (fn [accum leftover]\n        (if (nil? leftover)\n          (vals accum)\n          (recur (assoc accum (type (first leftover)) (conj (get accum (type (first leftover)) []) (first leftover))) (next leftover))\n        )\n       )]\n  (fn [coll] (splitter {} coll))\n)","problem":50,"user":"526dd90de4b03e8d9a4a72fe"},{"problem":50,"code":"(fn [coll]\n  (->>\n   \tcoll\n    (reduce\n      (fn [m x]\n        (update-in m [(type x)] conj x))\n      {})\n    vals\n    (map (fn [xs] (into [] (reverse xs))))\n    set))","user":"58bc0531e4b0888cdc949d07"},{"problem":50,"code":"(comp (partial map val) (partial group-by type) )","user":"5603c31fe4b04bb52996e1c1"},{"problem":50,"code":"(fn [col]\n  (set \n   (loop [result [] col col]\n     (if (empty? col)\n       result\n       (recur\n        (let [element (first col)\n              type-pred #(= (class element) (class (first %)))\n              is-type-new (not-any? type-pred result)]\n          (if is-type-new\n            (cons [element] result)\n            (map\n             #(if (type-pred %) (conj % element) %)\n             result)))\n        (rest col))))))","user":"59fa7fb0e4b0ca45a743a366"},{"code":"#(loop [r {} c %]\n    (if (empty? c)\n      (set (vals r))\n      (let [n (first c) k (.getClass n)]\n        (if-let [l (get r k)]\n          (recur (assoc r k (conj l n)) (rest c))\n          (recur (assoc r k [n]) (rest c))))))","problem":50,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":50,"code":"#(for [[k v] (reduce (fn [m v] \n                       (assoc m (type v) (concat (get m (type v)) [v])))\n                    {} %)]\n   v)","user":"563f24f9e4b08d4f616f5ed0"},{"problem":50,"code":"(fn [coll]\n   (into #{} (for [[k v] (group-by class coll)] v)))","user":"5aa4a1ffe4b0d174b936c886"},{"problem":50,"code":"(fn [x] (->> x\n               (group-by type)\n               (vals)\n               (set)))","user":"5920c191e4b09b4ee5954c61"},{"code":"(fn [col]\n  (vals\n    (reduce #(assoc %1\n               (type %2)\n               (conj\n                 (get %1 (type %2) [])\n                 %2))\n            {}\n            col)))","problem":50,"user":"539c64cde4b0b51d73faaf2a"},{"problem":50,"code":"(fn split-by-type [coll]\n  (loop [coll coll nb [] st [] kw [] sq []]\n    (if (empty? coll)\n      (remove empty? (conj [nb] st kw sq))\n      (cond\n       (keyword? (first coll))\n          (recur (rest coll) nb st (conj kw (first coll)) sq)\n       (string? (first coll))\n          (recur (rest coll) nb (conj st (first coll)) kw sq)\n       (number? (first coll))\n          (recur (rest coll) (conj nb (first coll)) st kw sq)\n       (coll? (first coll))\n          (recur (rest coll) nb st kw (conj sq (first coll)))))))","user":"55151417e4b055c2f668d4da"},{"code":"(fn grouping\n\t[col]\n\t(set (vals (group-by type col))))","problem":50,"user":"5339af7de4b0e30313ee6cab"},{"code":"(fn [xs]\n(vals (group-by type xs)))","problem":50,"user":"4fb1fa51e4b081705acca283"},{"problem":50,"code":"(fn [s]\n  (into #{} (vals (reduce (fn [m a]\n    (let [x (type a)]\n      (assoc m x (conj (get m x []) a)))) {} s))))","user":"575ddfd1e4b02ea11479938d"},{"problem":50,"code":"(fn [coll]\n  (partition-by \n   #(type %)              ; 2. Create subgroups that begin every time the type\n                          ;    of the next element in the sequence changes\n   (sort-by \n    #(.toString (type %)) ; 1. Sort coll by the string version of its type\n    coll)))","user":"4f80db02e4b033992c121bf9"},{"code":"(fn make-typed-list [l]\n  (vals (reduce (fn augment-typed-map [m [the-type the-val]]\n              \t\t(assoc m \n                    \t\tthe-type (conj (or (m the-type) []) the-val)))\n            \t\t{}\n  \t\t\t\t\t\t\t(map (fn make-typed-pair [x]\n                       [(type x) x]) \n                     l))))","problem":50,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn split-by-type [v1]\n  (set (vals \n        (reduce \n         \n         (fn [am x]\n           (let [x-type (type x)\n                 am-v (am x-type)]\n             (if (nil? am-v) \n               (assoc am x-type [x])\n               (assoc am x-type (conj am-v x)))))     \n         {}\n         v1))))","problem":50,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn typ [data]\n  (->> data\n    (group-by type)\n    (map #(rest %))\n    (mapcat #(if (coll? %) % [%]))\n  )\n)","problem":50,"user":"4e3456f9535deb9a81d77f2a"},{"code":"(fn sigh [s]\n  (loop [s s resmap (array-map)]\n    (if (not (seq s))\n      (map reverse (vals resmap))\n      (recur (rest s) (assoc-in resmap\n                                [(class (first s))]\n                                (conj (resmap (class (first s))) (first s)))))))","problem":50,"user":"4f0ef874535d0136e6c22328"},{"code":"(fn [col] (vals (group-by type col)))","problem":50,"user":"507a08e4e4b08327cd804a67"},{"problem":50,"code":"(fn [a] (map #(second %) ((fn [c] (group-by type c)) a)))","user":"607bd80be4b0a637ed780379"},{"problem":50,"code":"(fn [x] (filter #(not (empty? %)) [(filter vector? x),(filter integer? x), (filter keyword? x), (filter string? x)]))","user":"5425d454e4b01498b1a71b13"},{"code":"(fn splitclass [xs] (let [classes (set (map class xs))]\n              (map (fn [c] (filter #(= (class %) c) xs)) classes)\n         )\n)","problem":50,"user":"52bf8e35e4b07a9af579233a"},{"code":"(fn [ls]\n  (set (vals (group-by type ls))))","problem":50,"user":"4de165f3535d08e6dec9fde6"},{"code":"(fn [coll]\n  (reverse (map #'reverse\n                (vals (reduce\n                       (fn [m k]\n                         (update-in m [(type k)] (fn [c el] (cons el c)) k))\n                       {}\n                       (seq coll))))))","problem":50,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":50,"code":"(fn [l] (vals (group-by #(type %) l)))","user":"5c308385e4b0d62ef62d9f1c"},{"problem":50,"code":"(fn \n  [x]\n  (vals\n    (reduce\n      (fn [result item]\n        (let [item-type (type item)\n              curr-list (get result item-type [])]\n          (assoc result item-type (conj curr-list item))))\n      {}\n      x))\n  )","user":"5e300655e4b05b4b01516209"},{"code":"(fn [in-seq]\n  (loop [local-seq in-seq result {}]\n    (if (empty? local-seq)\n        (map reverse (vals result))\n        (recur (rest local-seq)\n               (assoc result (class (first local-seq))\n                (conj (result (class (first local-seq))) \n                      (first local-seq)))))))","problem":50,"user":"4ef4ab95535dced4c769f23b"},{"problem":50,"code":"#(->> %\n  (sort-by (comp str type))\n  (partition-by type)\n  (set))","user":"56bfd8ade4b060a8e693e3a2"},{"problem":50,"code":"(fn [s]\n  (map val (group-by type s)))","user":"4f678ac8e4b07046d9f4ef67"},{"code":"(fn [v]\n  (loop [r {} \n         v v]\n    (if (empty? v) \n      (map val r)\n      (let [ele (first v)\n            ele-type (type ele)]\n        (if (get r ele-type)\n          (recur (update-in r [ele-type] conj ele) (rest v))\n          (recur (assoc r ele-type [ele]) (rest v)))))))","problem":50,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn [s]\n  (vals (reduce\n    (fn [result elt]\n      (let [\n            elt-type (type elt)\n            curr-lst (result elt-type [])]\n        (assoc result elt-type (conj curr-lst elt))))\n    {} s)))","problem":50,"user":"53070615e4b02e821686979e"},{"problem":50,"code":"#(let [r (group-by class %)] (map val r))","user":"54b331dbe4b09f271ff37d37"},{"problem":50,"code":"#(mapcat rest(group-by class %))","user":"56fee4c0e4b08d47c97781b5"},{"code":"(fn [coll]\n  (let [types (set (map type coll))\n        filter-by-type (fn [x coll] (filter #(= (type %1) x) coll))]\n    (map #(filter-by-type % coll) types)))","problem":50,"user":"53778b90e4b06839e8705e36"},{"problem":50,"code":"(fn [s] (for [[key value] (group-by class s)] value))","user":"555a5731e4b0deb715856e44"},{"code":"(fn [xs] (let [ts (set (map type xs))]\n                     (map (fn [t] (filter (fn [x]  (= t (type x))) xs)) ts) ))","problem":50,"user":"51da111de4b02ceefd94775a"},{"code":"(fn [s] (map second ((fn [col] (reduce #(merge-with concat % {(class %2) [%2]}) {} col)) s)))","problem":50,"user":"523b10dfe4b02f719975bdb8"},{"code":"#(second (apply map vector (group-by type %)))","problem":50,"user":"4f63777be4b0defedf855fe4"},{"problem":50,"code":"(fn [icol]\n           (loop  [col     icol\n                   acc     {}]\n             (if (empty? col) (set (map second acc))\n                 (let [curr  (first col)\n                       rc    (rest col)\n                       tc    (type curr)\n                       av    (conj (get acc tc []) curr)\n                       ]\n                   (recur (rest col) (assoc acc tc av))))))","user":"57aa290de4b0b8559636fc65"},{"problem":50,"code":"(fn [arr]\n    (->> arr (map type) distinct (map (fn [t] (filter #(= t (type %)) arr)))))","user":"54055aa9e4b0addc1aec6665"},{"problem":50,"code":"(#(comp vals (partial group-by type)))","user":"58e256e1e4b005f69f193c90"},{"code":"(fn [s] (map last (group-by class s)))","problem":50,"user":"515e38ace4b049add99a0538"},{"problem":50,"code":"(fn [lst] (map second (group-by type lst)))","user":"56df7440e4b0ca2494a095fb"},{"code":"(fn split [x]\r\n    (partition-by type (map #(% 1) (sort-by #(.toString (% 0)) (map (fn [i] [(type i) i]) x)))))","problem":50,"user":"4fea08a9e4b0547ebccb2484"},{"code":"(fn splitter [a-seq]\n  (->> a-seq (group-by type) vals))","problem":50,"user":"52ee46e5e4b05e3f0be25ec5"},{"code":"(fn [coll] \n  (map #(nth % 1) (group-by class coll)\n  ))","problem":50,"user":"52f4fae4e4b05e3f0be25f27"},{"code":"(fn [initial-col]\n  (loop [collection {} col initial-col]\n        (if (empty? col)\n          (map (fn [e] (vec (reverse e))) (vals collection))\n          (let [item (first col)]\n          \t(recur (assoc collection (type item) (cons item (get collection (type item))))\n                 (rest col))))))","problem":50,"user":"4fe89475e4b07c9f6fd12c4f"},{"problem":50,"code":"(fn [is]\n             (-> (reduce (fn [c i]\n                           (update-in c [(type i)] #(if % (conj % i) [i])))\n                         {}\n                         is)\n                 vals))","user":"51765d78e4b085adf681d884"},{"problem":50,"code":"(fn t [a] (vals (group-by type a)))","user":"4eeb8f68535d93acb0a668a9"},{"problem":50,"code":"(fn split-by-type [col]\n  (vals (reduce (fn [maps item] (let [typekey (keyword (str (type item)))]\n                                  (if-let [col (typekey maps)]\n                                    (assoc maps typekey (conj col item)) ; add item to col and continue\n                                    (assoc maps typekey [item]) ; start a new collection and add it to maps\n                                    )\n                                  )) {} col)))","user":"5d80f328e4b0915913b1d372"},{"problem":50,"code":"#(into #{} (map second (group-by class %)))","user":"513facf5e4b00f13ea1bd892"},{"code":"(fn [x] \n  (let [m (group-by type x)] \n  (map m (keys m))\n  )\n)","problem":50,"user":"506b437de4b0eda3100c0906"},{"code":"(fn [coll] (set (vals (group-by #(type %) coll))))","problem":50,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn [coll] (for [[k v] (group-by type coll)] v))","problem":50,"user":"509fe759e4b08df8156e9e43"},{"code":"(fn split [s] \n        (if (empty? s)\n          []\n          (letfn [(ftype [x] (= (type x) (type (first s))))]\n            (cons (filter ftype s)\n                  (split (filter (complement ftype) s))))))","problem":50,"user":"5294e44de4b02ebb4ef75016"},{"problem":50,"code":"(fn [c] (vals\n            (group-by\n             #(type %)\n             c)))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [seq] (vals (group-by type seq)))","problem":50,"user":"5125834ae4b05d10e3e395fa"},{"problem":50,"code":"; shamelessly copied. this is the most beautiful thing I have ever seen\n; the function I was trying to write was huge\n(comp vals (partial group-by type))","user":"59c734e3e4b0a024fb6ae53f"},{"problem":50,"code":"#(vals\r\n    (reduce\r\n      (fn [r a]\r\n        (let [t (type a)]\r\n          (assoc r t (conj (get r t []) a))))\r\n      {}\r\n      %))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":50,"code":"#(loop [coll %1]\n                  (filter not-empty (concat\n                                      (vector (filter keyword? coll))\n                                      (vector (filter string? coll))\n                                      (vector (filter number? coll))\n                                      (vector (filter vector? coll))\n                                      )\n                          )\n                  )","user":"5cf72682e4b0b71b1d808a68"},{"problem":50,"code":"(fn [l] (vals (group-by type l )))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [l]\n  (vals (reduce (fn [a e]\n    (update-in a [(type e)] #(conj % e)))\n(zipmap (distinct (map type l)) (repeat []))\nl)))","problem":50,"user":"4ed2b168535d44c135fd68dd"},{"code":"#(map second (group-by type %1))","problem":50,"user":"4ffe8193e4b0678c553fc3f4"},{"code":"(fn\n  [coll]\n  (vals (group-by #(class %) coll)))","problem":50,"user":"525fffb8e4b03e8d9a4a702b"},{"problem":50,"code":"(fn [v]\n  (for [[key value] (group-by class v)] value))","user":"5c51c930e4b0fb8c5ffd99ce"},{"problem":50,"code":"(fn partition-by-type\n  [s]\n  (vals (group-by type s)))","user":"5f3103aee4b0574c87022c24"},{"problem":50,"code":"(fn [l] \n  (let [ll (sort-by (comp str class) l)]\n    (partition-by class ll)))","user":"539c88e1e4b0b51d73faaf2c"},{"problem":50,"code":"(fn [col] (map val (group-by type col)))","user":"5766fbb7e4b0a07e8fc180b6"},{"problem":50,"code":"(fn bucket_by_type [l]\n  (if (empty? l)\n    #{}\n    (let [same (filter (fn [x] (= (type x) (type (first l)))) l)\n          diff (filter (fn [x] (not (= (type x) (type (first l))))) l)]\n      (cons same (bucket_by_type diff)))))","user":"54651982e4b01be26fd746d4"},{"code":"(fn [s]\n  (vals\n   (reduce (fn [so-far new-item]\n             (assoc so-far\n               (type new-item)\n               (conj (get so-far (type new-item) [])\n                     new-item)))\n           {}\n           s)))","problem":50,"user":"51a3b135e4b0e77c4ca60bf6"},{"code":"#(map last (group-by type %))","problem":50,"user":"4eb02674535d7eef30807338"},{"problem":50,"code":";(fn [lst] (partition-by type (sort-by (comp str type) compare lst)))\n(fn [lst] (vals (group-by type lst)))","user":"516f06dce4b06aac486e5b39"},{"code":"#(map val (group-by (memfn getClass) %))","problem":50,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":50,"code":"(fn [coll]\n   (loop [coll coll\n          acc #{}]\n     (if (empty? coll)\n       acc\n       (let [[x & xs] coll\n             f #(= (type x) (type %))\n             one (filter f coll)\n             two (remove f coll)]\n         (recur two (conj acc one))))))","user":"55fbc657e4b0f488688e0666"},{"problem":50,"code":"(fn mySp [x] ((comp vals) (group-by type x)))","user":"58e5f995e4b056aecfd47ca5"},{"problem":50,"code":"#(filter (fn [x] (pos? (count x))) (concat (vector (filter number? %))\n(vector (filter keyword? %))\n(vector (filter string? %))\n(vector (filter vector? %))\n))","user":"5e13a6b7e4b099d064963001"},{"problem":50,"code":"#(-> (group-by type %)\n     vals)","user":"5aeca4c9e4b0cc2b61a3bc0a"},{"code":"(fn [coll]\n  (vals\n    (reduce\n      (fn [m v]\n        (update-in m [(class v)] (fnil conj []) v))\n      {}\n      coll)))","problem":50,"user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [s] (vals (reduce #(assoc % (first %2) (conj (if (nil? (% (first %2))) [] (% (first %2))) (second %2))) {} (map #(vector (type %) %) s))))","problem":50,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":50,"code":"(fn [coll]\n    (vals (\n           (fn collect-by-type\n             ([coll] (collect-by-type coll {}))\n             ([coll collected-so-far]\n              (if (empty? coll)\n                collected-so-far\n                (let [f (first coll)\n                      atype (type f)\n                      sofar-this-type (get collected-so-far atype [])]\n                  (collect-by-type (rest coll) (assoc collected-so-far atype (conj sofar-this-type f)))\n\n                  )\n                )\n              )\n             )\n           coll))\n    )","user":"54cb3497e4b057c6fda3a272"},{"problem":50,"code":"#(-> (reduce \n      (fn [m e]\n        (let [t (-> e type)]\n          (assoc m t (vec (conj (get m t) e)))))\n      {}\n      %)\n     vals)","user":"58b26da4e4b0ebc645576d0a"},{"problem":50,"code":"(fn [collection]\n  (vals (reduce (fn [acc elt] \n            (let [c (class elt)]\n              (assoc acc c (conj (get acc c []) elt)))) \n          {}\n          collection)))","user":"5553b924e4b0deb715856e06"},{"problem":50,"code":"#(map \n    (fn [t]\n      (filter\n        (fn [e] \n          (= t (type e))\n        ) % )\n     )\n     (set (map type %))\n    )","user":"5c0d0537e4b0bdcf453d173d"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (let [types (set (map type coll))\n        type-map-vector (reduce (fn [type-map type]\n                                  (assoc type-map type []))\n                                {}\n                                types)\n        populated-type-map-vector (loop [coll coll\n                                         t-m-v type-map-vector]\n                                    (if (empty? coll)\n                                      t-m-v\n                                      (recur (rest coll)\n                                             (let [elem-type (type (first coll))\n                                                   existing-vector (get t-m-v elem-type)\n                                                   new-vector (conj existing-vector (first coll))]\n                                               (assoc t-m-v elem-type new-vector)))))]\n    (reduce (fn [coll key]\n              (conj coll (get populated-type-map-vector key)))\n            []\n            (keys populated-type-map-vector))))","user":"5720a2b0e4b0c5bde472c099"},{"problem":50,"code":"(fn [a]\n  (vals (group-by class a)))","user":"602d5eade4b0d5df2af22279"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (group-by class)\n       (map second)))","user":"4eda8d7c535d10e5ff6f530f"},{"problem":50,"code":"(fn [coll]\n  (into #{} (vals (loop [coll coll\n                         res {}]\n                    (if (empty? coll)\n                      res\n                      (let [el (first coll)\n                            t (class el)\n                            tcoll (res t)]\n                        (recur (rest coll)\n                               (assoc res t\n                                          (if (nil? tcoll)\n                                            [el]\n                                            (conj tcoll el))))))))))","user":"58bb218be4b0888cdc949cf4"},{"problem":50,"code":"(fn [xs]\n  (loop [[next & rest] xs\n         acc {}]\n    (if next\n      (recur rest (assoc acc (class next) (conj (get acc (class next)) next)))\n      (map reverse (vals acc)))))","user":"5687b6abe4b0dcc4269f4061"},{"code":"#(vals (group-by type %))","problem":50,"user":"4de77a0a535d08e6dec9fdfa"},{"problem":50,"code":"(fn sbt [vec]\n  (vals\n    (reduce (fn [m curr]\n              (let [curr-t (type curr)]\n                (if (get m curr-t)\n                  (update-in m [curr-t] conj curr)\n                  (assoc m curr-t [curr]))))\n            {}\n            vec)))","user":"5c76577ae4b0fca0c16227ea"},{"code":"#(for [[k v] (group-by class %)] v)","problem":50,"user":"508c3d42e4b0f17d83ea26b2"},{"problem":50,"code":"(fn split-by-type [s]\n  (let [ts (distinct (map type s))]\n    (letfn [(keep-type [t] (into [] (keep #(if (= (type %) t) % nil) s)))]\n      (into #{} (map keep-type ts))\n      )\n    )\n  )","user":"57b9d21fe4b0fbc9809a27f7"},{"problem":50,"code":"(fn [coll]\n           (->> coll\n                (group-by type)\n                vals))","user":"4f2a7174e4b0d6649770a03e"},{"code":"(fn split-by-type [seq]\n  (vals (apply merge-with concat\n    (map #(hash-map %1 %2)\n      (map #(type %) seq)\n      (map #(vector %) seq)))))","problem":50,"user":"51b7b521e4b0d906fcd71d3a"},{"problem":50,"code":"(fn [s]\n  (vals\n    (reduce \n      (fn [t v]\n        (let [c (class v)]\n          (conj t [c (conj (get t c []) v)])))\n      {}\n      s)))","user":"556159fae4b0c656e3ff17c7"},{"problem":50,"code":"(fn [x]\n   (into #{} (vals (loop [k x acc {}]\n                     (if (empty? k)\n                       acc\n                       (let [cl (class (first k))]\n                         (if (acc cl)\n                           (recur (rest k) (assoc acc cl (conj (acc cl) (first k))))\n                           (recur (rest k) (assoc acc cl (vector (first k)))))))\n                     ))))","user":"53aaaf7ae4b047364c044444"},{"problem":50,"code":"(fn [y] \n  (vals\n   (reduce\n   (partial merge-with into)\n   {}\n   (map \n      (fn[x] {(str (type (first x))) (into [] x)})\t\n      (partition-by \n          #(type %) \n          y\n      )\n    )\n   )\n   )\n  )","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":50,"code":"#(apply vector (vals (group-by type %)))","user":"5414b7c4e4b01498b1a719ed"},{"code":"(fn group-by-type [s]\n  (set\n   (for [t (set (map type s))]\n     (vec (filter #(= t (type %)) s)))))","problem":50,"user":"51baff1be4b0fe3ecfb46443"},{"problem":50,"code":"(fn __ [coll] (vals (group-by type coll)))","user":"5756f324e4b02ea1147992e8"},{"code":"(fn [coll] (vals (group-by #(.getClass %) coll)))","problem":50,"user":"4fb3fec7e4b081705acca2a7"},{"problem":50,"code":"(fn [col]\n  (let [type-set    (set (map class col))\n        type-equl   (fn [e tp] (= (class e) tp))\n        group-vectors  (for [etp type-set]\n                       (vec (filter #(type-equl % etp) col)))]\n       (into #{} group-vectors )\n    ))","user":"55c77070e4b0e31453f649d0"},{"problem":50,"code":"#(let [ff (fn [x] (cond\n (instance? java.lang.String x) 1\n (instance? java.lang.Long x) 2\n (instance? clojure.lang.Keyword x) 3\n (instance? clojure.lang.PersistentVector x) 4))]\n (partition-by ff (sort-by ff %)))","user":"549a176ce4b0f3d1d8e70f69"},{"problem":50,"code":"(fn [coll] (map second (group-by class coll)))","user":"569d2283e4b0542e1f8d1474"},{"problem":50,"code":"#(->> (group-by class %)\n      vals)","user":"54db3d82e4b024c67c0cf75f"},{"code":"; First attempt, but filters the sequence multiple times (nclasses + 1)\n; (fn [x]\n;  (for [c (set (map class x))]\n;    (filter #(= c (class %)) x)))\n\n; Second attempt, home-rolling group-by (because I didn't know it existed)\n;(fn [x]\n;  (let []\n;  (vals (reduce #(assoc %1 (class %2) (conj (or (get %1 (class %2)) []) %2)) {} x))))\n\n; And then I found group-by :-)\n(fn split-by-type [x]\n  (vals (group-by class x)))","problem":50,"user":"52244a77e4b01819a2de42d1"},{"problem":50,"code":"(fn by-type\n  [coll]\n  (for [t (set (map type coll))]\n    (filter #(= t (type %)) coll)))","user":"5401aefbe4b0df28a13c62c7"},{"problem":50,"code":"#(vals (group-by type %))\n\n#_(fn [coll] (->> coll (group-by #(type %)) vals))","user":"4fe49706e4b0e8f79898feb7"},{"code":"(fn [xs]\n  (vals (reduce #(assoc %1 (class %2) (conj (%1 (class %2) []) %2)) {} xs)))","problem":50,"user":"51efd397e4b0249c592fbdeb"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (loop [groups #{}\n         coll coll]\n    (if (empty? coll)\n      groups\n      (let [new-group (filter #(= (type (first coll)) (type %)) coll)\n            new-coll (filter #(not= (type (first coll)) (type %)) coll)]\n        (recur (conj groups new-group) new-coll)))))","user":"572db6d5e4b0cd1946bd0f78"},{"problem":50,"code":"#(->> %\n     (group-by type)\n     (vals))","user":"4ea5ba92535d7eef308072d9"},{"problem":50,"code":"(fn [coll]\n  (partition-by #(class %) (sort-by #(str (class %)) coll)))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":50,"code":";(fn [coll] (reduce-kv (fn [m k v] (conj m v)) [] (group-by type coll)))\n(comp vals (partial group-by type))","user":"5be589f9e4b0ed4b8aab4d13"},{"problem":50,"code":"(fn [s] \n  (->> s\n       (sort-by #(str (type %)))\n       (partition-by type)))","user":"57df2722e4b0bd073c20245e"},{"code":"(fn\n  [s]\n  (let [uniq-types (distinct (map type s))]\n    (set (for [t uniq-types]\n           (filter #(= (type %) t) s)))))","problem":50,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn p50 [coll]\n  (let [t (group-by type coll)]\n    (vals t)\n  ))","problem":50,"user":"51750fc5e4b07031762f2ee6"},{"problem":50,"code":"(fn typeSplit [coll]\n  (if-let [t (type (first coll))]\n    (concat (vector (filter #(= t (type %1)) coll))\n            (typeSplit (filter #(not= (type %1) t) coll)))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":50,"code":"#(into #{} (map first (for [x (group-by class %)] (rest x))))","user":"52561295e4b0541d1855ba03"},{"problem":50,"code":"(fn splitt [coll]\n  (vals (group-by type coll)))","user":"54c3747de4b045293a27f60e"},{"code":"(fn [l] (vals (group-by #(.getClass %) l)))","problem":50,"user":"4fa30027e4b081705acca187"},{"problem":50,"code":"#(->> %1 (group-by class) (vals) (set))","user":"5180c69ae4b06b8caf33fa00"},{"problem":50,"code":"(fn [s]\n  (vals (reduce \n   #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) \n  {} s))\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":50,"code":"(fn [xs]\n  (let [distinct-types (distinct (map type xs))]\n    (map (fn [x] (filter #(= (type %) x) xs)) distinct-types)))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":50,"code":"(fn [coll] (reduce #(into %1 (vector (last %2))) #{} (group-by class coll)))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn [coll] (set (vals (group-by type coll))))","problem":50,"user":"536be48ee4b0fc7073fd6e31"},{"problem":50,"code":"(fn [a] (map #(second %) (group-by class a)))","user":"59a0262ee4b0871e7608b82d"},{"problem":50,"code":"(fn f [s]\n  (let [f* (fn [agg s*]\n             (let [k (str (class s*))]\n               (assoc agg k (conj (get agg k []) s*))))] (vals (reduce f* (sorted-map) s))))","user":"571ff1ebe4b0c5bde472c088"},{"problem":50,"code":"(comp (partial map second) (partial group-by type))","user":"5457e5f1e4b01be26fd74613"},{"problem":50,"code":"(fn [array] \n  (vals (reduce (fn [h v]\n                  (update-in h [(type v)] #(conj (vec %) v)))\n                {} array)))","user":"56018dd4e4b04bb52996e18f"},{"problem":50,"code":"(fn [sq] (vals (reduce (fn [out elem] ( merge out {(type elem) (conj (get out (type elem) []) elem)} )) {} sq)))","user":"5280a1ece4b0757a1b171407"},{"problem":50,"code":"(fn split-by-type [col]\n  (set ((fn iter [cnt ret]\n    (if (= cnt (count col))\n      ret\n      (iter (inc cnt) (concat ret (list ((fn get-of-nth-type [col idx]\n  (let [ret-col '()]\n    (concat ret-col (filter #(= (type (nth col idx)) (type %)) col)))) col cnt)))))) 0 '())))","user":"5c3f6322e4b08cd430848e97"},{"code":"(fn [x]\n  (vals (group-by #(type %) x)))","problem":50,"user":"4e333091535deb9a81d77f25"},{"code":"(fn [s]\n   (set (vals (group-by type s))))","problem":50,"user":"50f48298e4b004d364930527"},{"problem":50,"code":"(fn [coll]\n  (let [result (apply hash-map\n                      (interleave\n                        (set (map type coll))\n                        (repeat [])))]\n    (loop [c coll\n           r result]\n      (let [item (first c)\n            xs (rest c)\n            new-r (update-in r [(type item)] conj item)]\n        (if (empty? xs)\n          (set (vals new-r))\n          (recur xs new-r))))))","user":"559e6f42e4b08a52bd4f97d3"},{"problem":50,"code":"#(loop [elems %1 typemap {}]\n   (if (empty? elems)\n     (map typemap (keys typemap))\n     (let* [elem (first elems)\n            _type (type elem)]\n       (if (typemap _type)\n         (recur (rest elems)\n                (conj typemap [ _type (conj (typemap _type) elem) ]))\n         (recur (rest elems)\n                (conj typemap [ _type [elem] ]))))))","user":"584917a1e4b089d5ab817ec9"},{"problem":50,"code":"(fn [x] (vec (vals (group-by type x))))","user":"5ff5bc1ae4b06df49cee1490"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (let [types (set (map #(type %) coll))]\n    (loop [results [] t types coll coll]\n      (if (empty? t)\n        results\n        (recur (conj results (keep #(if (= (type %) (first t)) %) coll)) (rest t) coll)\n    ))))","user":"5f088bb3e4b0cf489e8d7f5f"},{"code":"(fn[s] (set (vals (reduce #(let [t (type %2)] (merge %1 {t (conj (get %1 t []) %2)})) {} s))))","problem":50,"user":"5017eface4b02f523d7cc5e7"},{"problem":50,"code":"(fn [collection] (map #(last %1) (group-by type collection)))","user":"5a634ff0e4b0512ff01cd995"},{"problem":50,"code":"(fn [xs]\n  (->> xs\n       (group-by type)\n       vals))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":50,"code":"(fn group-by-type[s]\n  (-> (group-by type s)\n      (vals)))","user":"52faf67ce4b047fd55837005"},{"code":"(fn [s] (for [x s]\n           (for [y s :when (= (type x) (type y))] y)))","problem":50,"user":"4ec8a56f535d6d7199dd36f6"},{"code":"(fn [liste]\n  (for [t (set (map type liste))]\n    (vec (filter #(= (type %) t) liste))\n  )\n)","problem":50,"user":"4f84400de4b033992c121c2e"},{"problem":50,"code":"(fn fn[x]\n  (partition-by type (sort-by #(str \"\" (type %)) x)))","user":"54ce3790e4b057c6fda3a2ab"},{"problem":50,"code":"#(for [[_ v] (group-by type %)] v)","user":"565e0934e4b068f2fe63dc30"},{"problem":50,"code":"(fn [col]\n  (->>\n    (group-by type col)\n    (mapcat #(second %))\n    (partition-by type)))","user":"54ca35c6e4b057c6fda3a254"},{"problem":50,"code":"(fn [d]\n   (filter not-empty \n           (map \n            \t#(filter % d) \n            \t[list? vector? keyword? string? number?])))","user":"544285dde4b032a45b869380"},{"problem":50,"code":"(fn [xs]\n  ( map reverse (vals (reduce\n    (fn [acc i]\n      (update-in acc [(type i)] #(into [i] %)))\n  {}\n  xs))))","user":"57ec8d1de4b0bfb2137f5b7f"},{"code":"(fn [col]\n  (let [f1 (fn f [l m]\n             (if (not (seq l))\n               m\n               (let [first-item (first l)\n                     new-l (rest l)\n                     first-item-type (class first-item)\n                     type-vector (get m first-item-type)\n                     new-map (if type-vector\n                               (merge m {first-item-type (concat type-vector\n                                                (vector first-item))})\n                               (merge m {first-item-type (vector first-item)}))\n                     ]\n                 (recur new-l new-map))))]\n    (set (map #(second %) (f1 col {})))\n  )\n)","problem":50,"user":"5021f0b3e4b00bba4502f7ac"},{"code":"(fn [a] (vals (group-by #(type %) a)))","problem":50,"user":"510b704ee4b078ea71921100"},{"code":"#(set\n  (partition-by (juxt number? keyword? vector? string?)\n                (sort-by (juxt number? keyword? vector? string?) %)\n                ))","problem":50,"user":"5267d9bde4b03e8d9a4a7188"},{"code":"(fn [v] \n   (partition-by #(class %) \n                 (sort-by #(str (class %)) v)))","problem":50,"user":"51f28a64e4b0210f90e7454e"},{"problem":50,"code":"(fn split-type\n  [coll]\n  (loop [[x & xs] coll acc {}]\n    (if x\n     (recur xs (update-in acc [(type x)] #(vec (conj % x))))\n     (vals acc)\n     )\n   )\n  )","user":"56edf2dde4b04a395b9a044b"},{"problem":50,"code":"(fn type-partition [col]    ;vals是专门收集map中值，并做成一个sequences，group-by是有两个参数，第一个是要分类的规则，第二个是sequences，将sequences里面按规则来进行分装。\n  (vals (group-by #(type %1) col)))","user":"57c500f9e4b05aa3c4741cda"},{"problem":50,"code":"#(map (fn [[k v]] v) (group-by type %1))","user":"5c8025d6e4b0c8042a70ce11"},{"problem":50,"code":"(fn [coll]\n  (vals (set (group-by type coll))))","user":"5c718e6ce4b0fca0c1622796"},{"problem":50,"code":"(fn[coll]\n    (vals (group-by type coll)))","user":"55101237e4b06e50f9beb181"},{"problem":50,"code":"(fn [s]\n    (loop [xs s\n           m {}]\n          (if (empty? xs)\n              (vals m)\n              (recur (rest xs) (let [v (first xs)\n                                     k (class v)]\n                                    (if (contains? m k)\n                                        (assoc m k (conj (get m k) v))\n                                        (assoc m k [v])))))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn type-split [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4faafccde4b081705acca209"},{"problem":50,"code":"(fn split-by-type [se]\n  (vals\n    (group-by (fn [elm] (type elm))\n              se)))","user":"5fbf6fe7e4b0ad6fc3476147"},{"code":"(fn [s] (vals (apply merge-with concat (map #(hash-map (type %) [%]) s))))","problem":50,"user":"4f043ed1535dcb61093f6bb4"},{"problem":50,"code":"#( vals (group-by type %) )","user":"54fc7d89e4b07d26eda61d2b"},{"problem":50,"code":"#(vals(group-by type %1))","user":"57614948e4b0994c1922fb83"},{"code":"(fn [x] (vals (group-by class x)))","problem":50,"user":"4ddabc33535d02782fcbe9f5"},{"code":"(fn type-split\n   ([xs] (type-split xs {}))\n   ([[x & xs] m] \n    (if (nil? x) (set (vals m))\n      (let [t (type x)]\n        (if (contains? m t)\n        \t(type-split xs (assoc m t (conj (get m t) x)))\n          \t(type-split xs (assoc m t [x])))))))","problem":50,"user":"4fe8d862e4b0547ebccb2428"},{"code":"(fn [col]\n    (let [dict (reduce (fn [d v] (update-in d [(type v)] (fn [col] (if (nil? col) [v] (concat col (list v)))))) {} col)]\n      (set (vals dict))))","problem":50,"user":"5141abf1e4b02fd87f5064c3"},{"problem":50,"code":"(fn [coll](vals (group-by (fn [x] (type x) ) coll)))","user":"526698c9e4b03e8d9a4a7144"},{"code":"(fn [col] (vals (group-by class col)))","problem":50,"user":"4e7ada51535db169f9c796ae"},{"problem":50,"code":"(fn [mixed] (\n  vals (\n    group-by (\n      fn [v] (\n        cond\n          (number? v) :num\n          (keyword? v) :key\n          (string? v) :str\n          (vector? v) :vec\n          :default :other))\n      mixed)))","user":"589e0024e4b02bd94d917e4e"},{"problem":50,"code":"(fn my-f [coll]\n  (-> coll\n   ((partial group-by type))\n   (vals)))","user":"5a822590e4b00b71e582a073"},{"code":"(fn [i-list]\r\n    (apply hash-set (map last (seq (group-by type i-list)))))","problem":50,"user":"4dddf817535d08e6dec9fdd3"},{"problem":50,"code":"(fn foo [coll]\n  (map (comp #(apply vector %) reverse)\n    (vals (reduce #(update-in %1 [(str (type %2))] conj %2) {} coll))))","user":"5b3251c1e4b025bcb146f317"},{"problem":50,"code":"(fn [coll]\n   (let [groups (group-by #(type %) coll)]\n     (map identity (vals groups))))","user":"53b7aa6ce4b047364c0444d1"},{"problem":50,"code":"(fn [ys]\n  (set (vals (group-by type ys))))","user":"546a6c7ce4b00cfc9eacc154"},{"code":"(fn sbt\n  [xs]\n  (vals (group-by type xs)))","problem":50,"user":"4fab1ea1e4b081705acca210"},{"problem":50,"code":"(fn[coll]\n  (loop [in coll out {}]\n    (cond (empty? in) (vals out)\n          :else (let [f (first in) t (type (first in))]\n                  (cond (contains? out t) (let [cur (get out t)]\n                                            (recur (rest in) (conj out [t (conj cur f)])))\n                        :else (recur (rest in) (conj out [t [f]])))))))","user":"5472cba1e4b094393f72dd7a"},{"problem":50,"code":"(fn [s]\n  (loop [ans #{} tmps (group-by type s)]\n    (if (empty? tmps)\n      ans\n      (recur (conj ans (second (first tmps))) (rest tmps)))))","user":"59368ccae4b02506e01a297a"},{"problem":50,"code":"(fn split-by-type [s]\n  (->>\n    s\n    (group-by type)\n    vals))","user":"5d0eed51e4b0cc9c91588262"},{"problem":50,"code":"(fn [l] (vals (reduce (fn [m v] (let [cv (str (class v))] (assoc m cv (if (contains? m cv) (conj (m cv) v) [v] ))))  {} l)))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn [input]\n    (set (map second (group-by type input))))","problem":50,"user":"50057f23e4b0678c553fc466"},{"problem":50,"code":"(fn splitByType\n  [coll]\n  (vals \n    (reduce\n      (fn [currMap currVal]\n        (assoc currMap\n               (str (type currVal))\n               (conj (currMap\n                       (str (type currVal))\n                       [])\n                     currVal))\n        #_\n        (assoc map (str (type currVal)) (conj currVal (map (type currVal) [])))\n        )\n      {} coll))\n  )","user":"5fce0cc5e4b07e53c2f3f000"},{"problem":50,"code":"(fn split-by-type [coll]\n  (reduce #(if-not (empty? %2) (conj % %2) %) #{} \n          [(filter number? coll)\n           (filter string? coll)\n           (filter vector? coll)\n           (filter keyword? coll)]))","user":"5e92adb6e4b0fbed045a37ea"},{"problem":50,"code":"(fn\n  [col]\n  (vals (group-by type col)))","user":"5cdc17d0e4b05ee0cb31173c"},{"problem":50,"code":"(fn foo [col]\n  (vals (group-by #(type %) col))\n  )","user":"5d270111e4b092dab7f59c62"},{"problem":50,"code":"(fn\n  [coll] \n  (into #{} \n        (vals (reduce (fn [m, v] (let [c (class v)] (assoc m (class v) (conj (get m (class v) []) v)))) \n                      {} \n                      coll))))","user":"518ba795e4b0f028e99addf0"},{"problem":50,"code":"(fn [l] (set (map second (group-by type l))))","user":"5e03475de4b0a607a9a45d58"},{"problem":50,"code":"(fn [co] \n  (->> (map type co) \n       set \n       (map #(partial = %))\n       (map #(comp % type))\n       (map #(filterv % co))\n       set))","user":"57b8302ae4b0fbc9809a27da"},{"problem":50,"code":"(fn [col]\n  \t(vals (group-by class col)))","user":"54f14aa6e4b024c67c0cf8af"},{"problem":50,"code":"(fn [the-list]\n   (vals (group-by type the-list)))","user":"5b15e881e4b0cc2b61a3be75"},{"problem":50,"code":"(fn [args] (vals (group-by type args)))","user":"5137fb22e4b0a5db03d727d3"},{"problem":50,"code":"(fn [s]\n  (let [types (set (map type s))]\n    (for [x  types] (filter #(= (type %) x) s))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn [xs] \n  (vals \n   (reduce \n    (fn [typemap incoming] (assoc typemap \n                                  (type incoming) \n                                  (conj (get typemap \n                                        (type incoming) \n                                        []) \n                                  incoming)))\n    {}\n    xs)))","problem":50,"user":"4e5d2dc5535d8a8b8723a2ca"},{"problem":50,"code":"( fn xxx[xs] (set (map #(map first %) (vals (group-by second ( map #(vector % (str (class %))) xs))))))","user":"53d63e6ce4b0e771c3025454"},{"problem":50,"code":"(fn split-by-type\n  [s]\n  (vals (group-by #(type %) s)))","user":"53b952eee4b047364c0444e6"},{"code":"(fn [input]\n  (map #(second %) (group-by type input)))","problem":50,"user":"528bba38e4b0239c8a67aea9"},{"code":"(fn [in]\n  (vals (group-by class in)))","problem":50,"user":"4eb59464535d7eef30807369"},{"problem":50,"code":"(fn [s]\n   (map #(-> % reverse vec)\n        (vals (reduce #(update-in % [(class %2)] conj %2) {} s))))","user":"53ea5307e4b036ad0777e4e2"},{"problem":50,"code":"(fn [a] (partition-by type (sort-by #(str (type %)) a)))","user":"52b9cfb9e4b07a9af57922c5"},{"code":"(fn [xs]\n  (loop [xs xs type-map {}]\n    (if-not (seq xs)\n      (vals type-map)\n      (let [x (first xs)]\n      \t(recur (rest xs)\n               (update-in type-map [(type x)]\n                 (fn [ts] (if ts\n                            (conj ts x)\n                            [x]))))))))","problem":50,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn [s]\n  (set (vals (group-by class s))))","problem":50,"user":"5073de20e4b054001656acca"},{"problem":50,"code":"(fn [arr]\n  (vals\n   (group-by type arr)))","user":"5cb41c40e4b026601754b911"},{"problem":50,"code":"(fn [coll] (->> (group-by #(type %) coll)\n                 (vals)))","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":50,"code":"(fn [v] (vals (group-by #(class %) v)))","user":"57ccedaae4b0c746388ab88e"},{"code":"(fn [s] (let [t (set (map type s) )]\n           (for [x t]  (filter #(= (type %) x) s)) ))","problem":50,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn [xs]\n  (map second (group-by type xs)))","problem":50,"user":"51ef66a7e4b0871fa145d9a5"},{"problem":50,"code":"(fn [v] (map reverse (vals (reduce\n                               #(do \n                                  \n                                  (assoc %1\n                                         (str (type %2))\n                                         (cons %2 (get %1 (str (type %2)) [])))\n                                  ) {} v))))","user":"552e1c98e4b076ab5578f7ee"},{"problem":50,"code":"(fn split-type\n  [s]\n  (vals (group-by type s)))","user":"557e9d17e4b05c286339e0d8"},{"problem":50,"code":"(fn [x]\n  (->> (group-by type x)\n       (vals)\n       (set)))","user":"60b3b8a9e4b0e0fa5f1b4233"},{"problem":50,"code":"(fn [l]\n    (let [t (reduce \n              #(assoc %1 (type %2) (conj (vec (get %1 (type %2))) %2))\n              {}\n              l)]\n      (vals t)\n      )\n  )","user":"51e6a2bce4b0ab43cc26c21d"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (set\n    (map\n      #(vec (map second %))\n      (vals\n        (group-by\n          first\n          (partition 2 (interleave (map type coll) coll)))))))","user":"590b3aeae4b047aa04b199d0"},{"problem":50,"code":"(fn [s]\n  (reduce\n   (fn [acc e]\n     (let [same (fn [s] (= (type e) (type (first s))))\n           own (first (filter same acc))\n           other (filter #(not (same %)) acc)\n           next (cons (conj (if (nil? own) [] own) e) other)]\n       next)) () s))","user":"5e178fbee4b00200644e3d57"},{"problem":50,"code":"(fn [s]\n  (for [s1 (distinct (map type s))]\n    (for [s2 s\n          :when (= s1 (type s2))]\n      s2)))","user":"5e21c933e4b05b4b01516128"},{"problem":50,"code":"(fn [stuff]\n  (loop [remaining stuff\n         result '()]\n    (if\n      (empty? remaining)\n      result\n      (recur (filter #(not (= (type %1) (type (first remaining)))) remaining)\n             (cons (filter #(= (type %1) (type (first remaining))) remaining) result)\n             )\n      )\n    )\n  )","user":"5a584ca2e4b05d388ecb6c7d"},{"problem":50,"code":"(fn [coll] \n (let [types (set (map type coll))\n       pred (fn [t] (fn [x] (= t (type x))))]\n  (map #(filter (pred %) coll) types)))","user":"5a91988ae4b002d099cae6f9"},{"code":"(fn[coll]\r\n  (map\r\n    (fn[typ]\r\n      (filter \r\n        (fn[m]\r\n          (= typ (class m)))\r\n        coll))\r\n    (set (map type coll))))","problem":50,"user":"4e59f717535d8a8b8723a2a6"},{"problem":50,"code":"(fn sbt\n  [s]\n  (vals (group-by type s))\n  )","user":"51f81925e4b09be9c177e526"},{"problem":50,"code":";; (fn [v]\n;;     (->> v\n;;          (reduce (fn [type->vals x]\n;;                    (update-in type->vals\n;;                               (list (type x))\n;;                               #((fnil conj []) % x)))\n;;                  {})\n;;          (vals)))\n\n;; I should have realized there would be group-by function\n(fn [v] (vals (group-by #(type %) v)))","user":"5df70ee8e4b0a607a9a45c8a"},{"code":"(fn [src]\n   (vals (group-by class src))\n  )","problem":50,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [d] (vals (reduce #(merge-with concat %1 {(type %2) [%2]}) {} d)))","problem":50,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":50,"code":"(fn [coll]\n   (loop [input coll output {}]\n     (if (empty? input)\n       (map reverse (vals output))\n       (recur (rest input) (assoc output (type (first input)) (conj (get output (type (first input))) (first input))))\n     )\n   )\n)","user":"53beacf9e4b0d9a98559a6e3"},{"code":"(fn split-by-type [coll]\n  (set\n    (vals\n      (reduce\n        (fn [m item]\n          (assoc m (class item) (conj (get m (class item) []) item)))\n        {}\n        coll))))","problem":50,"user":"526ee63de4b03e8d9a4a733f"},{"problem":50,"code":"(fn [xs] (map last (group-by class xs)))","user":"54d70f40e4b0a52adc2e2027"},{"code":"(fn [s] (set (vals (reduce #(assoc % (type %2) (conj (% (type %2) []) %2)) {} s))))","problem":50,"user":"519ef784e4b087743fad2198"},{"code":"(fn [v]\n  (vals\n  (reduce\n    #(assoc %1 (class %2)\n      (if (nil? (get %1 (class %2)))\n        [%2]\n        (conj (get %1 (class %2)) %2))) {} v)))","problem":50,"user":"4dad76588e77d6ed63f12a44"},{"code":"(fn lo [s]\r\n  (loop [h s ret nil]\r\n    (if (> (count h) 0)\r\n      (let [f (first h) t (type f) p (filter #(= t (type %)) h)]\r\n      (recur (filter #(not= t (type %)) h) (cons (vec p) ret)))\r\n      \r\n      ret)))","problem":50,"user":"4de18de7535d08e6dec9fde8"},{"problem":50,"code":"(fn split-by-type [c]\n  (vals (group-by type c)))","user":"51d42f44e4b013d740b70ddb"},{"code":"(fn cl [s]\r\n  (set (filter #(not (empty? %)) (map #(filter % s) [ string? keyword? number? vector?])))\r\n  )","problem":50,"user":"4febb4dae4b0681fd128dc98"},{"problem":50,"code":"#( vals\n (group-by type %))","user":"5921a080e4b09b4ee5954c77"},{"code":"#(vals (reduce (fn [m x] (assoc m (type x) (conj (or (-> x type m) []) x))) {} %))","problem":50,"user":"4e79a143535db169f9c796a2"},{"problem":50,"code":"(fn [xs]\n  ((comp (partial map (comp vec vals (partial into (sorted-map)))) vals) \n       (reduce \n          (fn [m v]\n            (let [t (type v)\n                  ov (m t)\n                  c (count ov)]\n              (assoc-in m [t c] v)\n            )\n          ) {} xs)\n  )\n)","user":"52824143e4b0757a1b171453"},{"problem":50,"code":"(fn [col]\n   (vals (group-by class col)))","user":"5db98f39e4b010eb3c36cd53"},{"problem":50,"code":"(fn split-by-type [x]\n     (vals (group-by type x)))","user":"594ea2a4e4b07ddc2dafaeb6"},{"problem":50,"code":"(fn group_by_class [coll]\n  (vals (group-by class coll)))","user":"559bdf16e4b066d22e731f5a"},{"problem":50,"code":"(fn group-by-type [s]\n  (-> (group-by type s) (vals))\n  )","user":"550c55d0e4b06e50f9beb14d"},{"problem":50,"code":"(fn [sequence]\n        (map second (group-by type sequence)))","user":"53f891eee4b0de5c4184856d"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (group-by type)\n       (map second)))","user":"55f2e47de4b06e875b46ce4d"},{"problem":50,"code":"(fn [coll]\n    (for [[key value] (group-by class coll)]\n      value))","user":"589cb617e4b00487982d536a"},{"problem":50,"code":"(fn [s] (into #{} (vals (reduce\n  #(let [t (type %2)]\n    (assoc %1 t\n      (concat [] (get %1 t) (vector %2))))\n  {}\n  s))))","user":"5a4993c0e4b05d388ecb6b71"},{"problem":50,"code":"(fn [inputs]\n    (let [types (distinct (map type inputs))]\n      (map (fn [t] (filter #(= t (type %)) inputs)) types)\n      )\n    )","user":"56ef11efe4b04a395b9a045b"},{"code":"#(->> % (group-by type) (vals) (set) )","problem":50,"user":"5062bc46e4b05ac47bc68d68"},{"problem":50,"code":"(fn [l]\n  (loop [m {} xs l]\n    (if (empty? xs)\n      (vals m)\n      (let [x (first xs)\n            k (type x)\n            m' (if (contains? m k)\n                 (assoc m k (conj (m k) x))\n                 (assoc m k [x]))]\n        (recur m' (rest xs))))))","user":"59bdf0eae4b0a024fb6ae42e"},{"code":"(fn [coll]\n  (vals (reduce (fn [acc item]\n                  (assoc acc (class item)\n                    (conj (get acc (class item) []) item)))\n                {} coll)))","problem":50,"user":"4eae5fe4535d7eef30807325"},{"problem":50,"code":"(fn split-by-type [xs]\n  (->> xs\n       (group-by class)\n       (map last)\n       (into #{})))","user":"57ea4569e4b0bfb2137f5b46"},{"problem":50,"code":"(fn [sqn]\n  (vals (group-by type sqn)))","user":"5cf895efe4b0b71b1d808a85"},{"code":"(fn [c](vals (group-by class c)))","problem":50,"user":"4ebbb6bc535dfed6da9c6d71"},{"problem":50,"code":"(fn split-by-type [s]\n  ;(map second (group-by class s)))\n  (vals (group-by class s)))","user":"569ab3e2e4b0542e1f8d144a"},{"code":"(fn [coll] (vals (group-by #(class %) coll)))","problem":50,"user":"4df669d4535d08e6dec9fe35"},{"problem":50,"code":"(fn [f] (letfn [(flip [f]\n                   (vals (group-by type f))\n                   )\n                 ]\n           (flip f)\n           ))","user":"5c635364e4b0fca0c162265f"},{"problem":50,"code":"#(let\n  [types (set (map type %))\n   typed-list (map (fn [x] (list x (type x))) %)]\n  (into #{}\n        (map\n         (fn [t]\n           (map\n            (fn [[v' t'']] v')\n            (filter (fn [[v t']] (= t t')) typed-list)))\n         types)))","user":"56050f06e4b08b23635d3161"},{"code":"(fn [x] ( ->> x (  group-by type )  (reduce #(conj  %  (second %2) ) [])))","problem":50,"user":"50646c01e4b007509339a58b"},{"code":"#(reduce\n  (fn [n m]\n    (conj n (filter (fn [x] (= m (type x))) %))\n  )\n  '()\n  (distinct (map type %))\n)","problem":50,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":50,"code":"(fn [s]\n  (let [classes (set (map class s))]\n    (for [c classes]\n      (filter #(= (class %) c) s))))","user":"510a3cd4e4b06956752d35ad"},{"problem":50,"code":"(fn [sq]\n  (into #{}\n        (map second (group-by class\n                              sq))))","user":"559d33b3e4b0ec2b359424d9"},{"code":"(fn type-split [coll]\n  (loop [col coll,result {}]\n    (if (empty? col)\n        (vals result)\n        (let [val (first col),\n              cls (type val)]\n        (recur (rest col)\n               (assoc result\n                      cls \n                      (conj (get result cls []) val)\n               )\n               )\n        )\n     )\n  )\n)","problem":50,"user":"4f6d9d7ee4b07046d9f4efcd"},{"code":"#(reduce (fn [s it] (conj s (filter (fn [i] (= (type it) (type i))) %1))) #{} %1)","problem":50,"user":"505dcfc8e4b0e6aca564be0d"},{"code":"(fn tsplit [sq]\n  (if (empty? sq)\n    ()\n    (let [f (first sq),\n          ts (tsplit (rest sq)),\n          s (some #(when (= (type f) (type (first %))) %) ts)]\n      (cons (cons f s) (remove #(= s %) ts)))))","problem":50,"user":"4e8f5eba535d65386fec214c"},{"code":"(fn [l]\n  (->> l \n    (group-by class) \n    (map second)\n    set))","problem":50,"user":"4ff5744ae4b0678c553fc36a"},{"code":"(fn split-by-type [xs]\n  (let [types (distinct (map class xs))]\n    (map \n      (fn get-elements-of-type [t] (filter #(= (class %) t) xs))\n      types)))","problem":50,"user":"529e3a4fe4b04e0c58e87b92"},{"code":"#(let [grouped-seq (group-by type %)]\n    (loop [c-seq grouped-seq\n           final-seq #{}]\n      (if (empty? c-seq)\n        final-seq\n        (recur (rest c-seq) (conj final-seq (second (first c-seq)))))))","problem":50,"user":"523288fee4b035af41902a88"},{"code":"#(loop [acc []\n        l %]\n   (if (empty? l) acc\n     (let [t (type (first l))\n           same-type (fn [e] (= (type e) t))]\n       (recur (conj acc (filter same-type l)) (remove same-type l)))))","problem":50,"user":"537e745ae4b06839e8705ea6"},{"problem":50,"code":"(fn [coll]\n  (into #{}\n    (vals\n      (reduce (fn [m x]\n                (update-in m [(type x)] (fnil conj []) x))\n              {} coll))))","user":"5629dfaae4b00e49c7cb4813"},{"code":"(fn [xs] (partition-by type (sort-by #(str (type %)) xs)))","problem":50,"user":"4e9fd521535d7eef3080729a"},{"code":"(fn sbt\n  ([lst] (sbt {} lst))\n  ([s lst] (if (empty? lst) (map val s)\n             (let [f (first lst)\n                   cf (.getName (class f))\n                   ]\n               (sbt (conj s [cf (conj (if (nil? (s cf)) [] (s cf)) f)]) (next lst))))))","problem":50,"user":"5272669de4b03e8d9a4a742e"},{"code":"#(into #{} (vals (group-by type %)))","problem":50,"user":"4f128865535d64f603146428"},{"code":"(fn [xs]\n  (vals \n   (reduce (fn [acc x]\n             (assoc acc (type x)\n               (conj (acc (type x) []) x)))\n           {} xs)))","problem":50,"user":"4dad8a6dc9a9d6ed1399dc57"},{"problem":50,"code":"(fn homo [c]\n  (let [step\n        (fn [c res]\n          (if-let [s (seq c)]\n            (recur (rest c) (assoc res (type (first s)) (conj (get res (type (first s)) []) (first s))))\n            res))]\n    (vals (step c (hash-map)))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":50,"code":"#(letfn [(group [v r]\n\t(if (empty? v)\n\t\tr\n\t\t(let [e (first v), c (class e), g (get r c []), g' (conj g e)]\n\t\t\t(recur (rest v) (assoc r c g')))))]\n\t(vals (group % {})))","user":"5370b386e4b0fc7073fd6e9b"},{"problem":50,"code":"(fn split-by-type [xs]\n  (loop [ys xs\n         out {}]\n    (if (> (count ys) 0)\n      (let [f (first ys)\n            l (drop 1 ys)\n            cls (class f)\n            lst (get out cls [])]\n        ;; (print (assoc out cls (conj lst f))))\n        (recur l (assoc out cls (conj lst f))))\n      (vals out))))","user":"5ad3d730e4b0ea6055cfabc8"},{"code":"(fn [seqn]\n  (loop [s seqn, sub-seqs {}]\n    (if (empty? s)\n      (set (vals sub-seqs))\n      (let [item (first s)\n            type (.getClass item)\n            sub-seq (get sub-seqs type [])]\n        (recur \n          (rest s) \n          (assoc sub-seqs type (conj sub-seq item)))))))","problem":50,"user":"4ea4fe1f535d7eef308072cf"},{"code":"(fn [col]\n(map\n   #(filter \n      (fn[t](= (type t) %)) col)\n  (set (map type col))))","problem":50,"user":"4e6cf521535de274dd8d818b"},{"code":"#(partition-by type (sort-by keyword? %))","problem":50,"user":"5034a14de4b062bc5d7ae165"},{"code":"(fn [a]\n    (map \n        (fn [tip] (filter (fn [tm] (= tip (type tm))) a))\n        (set(map (fn [x] (type x)) a))\n    )\n    \n)","problem":50,"user":"4e78dc98535db95036265724"},{"code":"(fn [xs]\r\n   (reduce (fn [acc x]\r\n             (let [index (loop [ys acc num 0]\r\n                           (if (seq ys)\r\n                             (let [y (peek (peek ys))]\r\n                               (if (= (type y)\r\n                                      (type x))\r\n                                 (- (.length acc) num 1)\r\n                                 (recur (pop ys) (inc num))))\r\n                             -1))]\r\n               \r\n               (if (neg? index)\r\n                 (conj acc [x])\r\n                 (assoc acc index\r\n                        (conj (get acc index) x)))))\r\n           [] xs)\r\n   )","problem":50,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn [s]\n  ((fn [s m]\n     (if (empty? s)\n       (map #(reverse (second %)) m)\n       (recur (rest s) (assoc m (type (first s))\n                              (cons (first s) (m (type (first s))))))))\n   s {}))","problem":50,"user":"4f404dcee4b0e243712b1fb0"},{"problem":50,"code":"(fn split-type [col]\n  (vals (reduce (fn [x y] (assoc x (class y) (conj (x (class y) []) y))) {} col)))","user":"55536a8ae4b0deb715856e03"},{"problem":50,"code":"(fn [lst] (vals (group-by (fn [x] \n                (cond\n                 (keyword? x) \"k\"\n                 (number? x) \"n\"\n                 (sequential? x) \"s\")) lst)))","user":"56897739e4b0dcc4269f407d"},{"code":"#(vals (group-by type %)) ;class works but type better","problem":50,"user":"524f4256e4b0541d1855b808"},{"problem":50,"code":"#(vals (group-by type %))\n;(comp vals (partial group-by type))","user":"57ba55c1e4b0fbc9809a2801"},{"problem":50,"code":"(fn [xs] (vals (group-by #(type %) xs)))","user":"561cb6cfe4b064ca9f4b169e"},{"problem":50,"code":"(fn [coll]\n  (partition-by #(type %) (sort-by #(str (type %)) coll)))","user":"53f6bfd9e4b0db01ade6f9e4"},{"code":"(fn [xs] (set (vals (group-by type xs))))","problem":50,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [s]\n  (into (hash-set)\n        (vals\n         (reduce\n          (fn [result item]\n            (let [item-type (type item)]\n              (assoc result\n                item-type\n                (conj (get result item-type []) item))))\n          { }\n          s))))","problem":50,"user":"4f31519ae4b0d6649770a086"},{"problem":50,"code":"(fn split-by-type\n  [xs]\n  (vals (group-by type xs)))","user":"55996253e4b031d6649c9baa"},{"problem":50,"code":"(fn [a] (into #{} (map last (group-by type a))))","user":"52b7a904e4b0c58976d9ad51"},{"problem":50,"code":"(fn[s]\n   (vals (group-by type s)))","user":"53d10553e4b00fb29b22130f"},{"problem":50,"code":"; First try, worked great\n; (fn [v] (partition-by type (sort #(compare (str (type %1)) (str (type %2))) v)))\n#(vals (group-by type %))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":50,"code":"(fn [col] (->> col\n      (group-by type)\n      (map second)\n      (map #(into [] %))))","user":"56b965d9e4b0f26550335931"},{"code":"(fn [s]\n  (let [pairs (map #(array-map (type %) [%]) s)\n        merged (apply merge-with concat pairs)]\n    (vals merged)))","problem":50,"user":"51460e4ce4b04ef915e37314"},{"code":"(fn [a] (into #{} (vals (group-by type a))))","problem":50,"user":"5081566ce4b0946d0443855b"},{"code":"(fn [x] (set (map val (group-by type x))))","problem":50,"user":"535920b2e4b04ce2eb3ed294"},{"code":"(fn [seq]\n  (loop [type1 (first (distinct (map #(type %1) seq)))\n         type2 (second (distinct (map #(type %1) seq)))\n         type3 (second (rest (distinct (map #(type %1) seq))))\n         togo seq\n         v1 [] ;if of first type\n         v2 [] ;second \n         v3 []]\n    (if (empty? togo)\n      (filter #(not (empty? %1)) (conj (conj (conj #{} v1) v2) v3))\n    (if (= (type (first togo)) type1)\n     (recur type1 type2 type3 (rest togo) (conj v1 (first togo)) v2 v3)\n    (if (= (type (first togo)) type2)\n     (recur type1 type2 type3 (rest togo) v1 (conj v2 (first togo)) v3)\n     (recur type1 type2 type3 (rest togo) v1 v2 (conj v3 (first togo))))))))","problem":50,"user":"4e4bf20e535dc968683fc4d9"},{"code":"#(set (map val (group-by type %)))","problem":50,"user":"503de5aae4b06c4e0e1fa259"},{"code":"(fn[i]\n  (partition-by #(str (class %)) (sort-by #(count (str (class %))) i)))","problem":50,"user":"4fb86dc9e4b081705acca2d8"},{"problem":50,"code":"(fn [xs]\n  (loop [ys xs ty {}]\n    (case ys\n      [] (reduce (fn [rs vs] (conj rs vs)) [] (vals ty))\n      (let [y (first ys)\n            t (type y)\n            ts (if (contains? ty t) \n                 (conj (get ty t) y) \n                 [y])]\n        (recur (rest ys) (assoc ty t ts))))))","user":"55316b8ae4b076ab5578f825"},{"code":"(fn [x]\n  (vals (reduce (fn [a b]\n            (assoc a (type b) (conj (or (a (type b)) []) b) )) {} x)))","problem":50,"user":"5356e569e4b04ce2eb3ed272"},{"problem":50,"code":"(fn type-split [lst]\n  (let [types (set (map type lst))]\n    (->> lst\n         (repeat (count types))\n         (map (fn [t lst] (filter #(= (type %) t) lst)) types)\n         set\n     )\n   )\n )","user":"57cf03c0e4b00451144b04f9"},{"problem":50,"code":"#(vals (reduce (fn [t e] (merge-with into t {(type e) [e]})) {} %))","user":"5776385fe4b0979f89651632"},{"problem":50,"code":"(fn\n   [xs]\n   (vals (reduce (fn [r x] (if (r (class x))\n                             (merge r {(class x) (conj (r (class x)) x)})\n                             (merge r {(class x) [x]}))) {} xs)))","user":"5ce62d8ee4b0a17bb84e2b83"},{"problem":50,"code":"(fn[l](into #{} (for [[k v] (group-by type l)] v)))","user":"54651ef5e4b01be26fd746d5"},{"code":"(fn tt [v] (vals (group-by type v)))","problem":50,"user":"52cf30c9e4b07d0d72b273a2"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce (fn [acc elem]\n                  (update-in acc [(type elem)] (fnil conj []) elem))\n                {}\n                coll)))","user":"597f8c93e4b0dbe32238d0c1"},{"code":"(fn split-by-type [xs]\n  (vals (group-by type xs)))","problem":50,"user":"4f6bab49e4b07046d9f4efb1"},{"problem":50,"code":"(fn [lst] (map #(nth % 1) (#(group-by type %) lst)))","user":"5c59b1d3e4b01df32ab73261"},{"code":"(fn [xs]\r\n    (for [tt (set (map type xs))]\r\n      (filter #(= (type %) tt) xs)))","problem":50,"user":"4ddc1c89535d02782fcbea01"},{"problem":50,"code":"(fn [c] (for [t (set (map type c))]\n  (filter #(= t (type %)) c)))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn [x] (vals (group-by #(.getClass %) x)))","problem":50,"user":"4f0c84ce535d0136e6c2230e"},{"problem":50,"code":";#(filter not-empty (list (filter keyword? %) (filter string? %) (filter number? %) (filter coll? %)))\n#(vals (group-by type %))","user":"5ed03b7fe4b016b56eae05ae"},{"problem":50,"code":"#(let [types (map type %)]\n   (map (fn [x] \n          (filter\n           (fn [y] (= (type y) x))\n           %))\n        types))","user":"55e26417e4b050e68259b433"},{"code":"#(map second (group-by class %1))","problem":50,"user":"4fabb1dce4b081705acca21a"},{"problem":50,"code":"(fn [coll]\n(let [types (reduce (fn [result val] (assoc result (type val) (cons val (result (type val))))) {} coll)]\n\t(map reverse (into #{} (vals types)))))","user":"54eea988e4b024c67c0cf875"},{"code":"(fn [s]\n    (let [f (for [a s]\n                 (filter #(= (type a) (type %)) s))]\n      (set f)))","problem":50,"user":"50bf6f93e4b0ffd967a66cbf"},{"code":"(fn [x] (partition-by type (sort (comparator #(> (hash (type %)) (hash (type %2)))) x)))","problem":50,"user":"50ebd63ce4b04edc3377703c"},{"problem":50,"code":"(fn [ls] (into #{} (vals ( group-by #(class %) ls))))","user":"5c0e3f86e4b01240ff56713d"},{"code":"(fn group-by-type [coll]\n  (let [zipmulti (fn [l1 l2] (apply merge-with concat (map (fn [a b]{a (list b)}) l1 l2)))]\n    (vals (zipmulti (map type coll) coll))\n    )\n\n  )","problem":50,"user":"53307da1e4b019098a6f8b5e"},{"problem":50,"code":"#(filter vector? (mapcat seq (group-by class %)))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn split-by-type\n  [col]\n  (vals (group-by class col)))","problem":50,"user":"4db8d37d535d1e037afb219c"},{"problem":50,"code":"#(->> % (group-by type) (map last))","user":"512b07f7e4b078b06821febb"},{"problem":50,"code":"(fn q50 [coll]\n  (->> coll\n       (group-by type)\n       (vals)))","user":"5cab0ad9e4b048ec896c5c46"},{"problem":50,"code":"(fn [x]\n  (filter (comp not empty?)\n          (cons (filter number? x)\n                (cons (filter string? x)\n                      (cons (filter keyword? x) \n                            (cons (filter coll? x) '()))))))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":50,"code":"(fn split-by-type [lat]\n  (vals (group-by type lat)))","user":"58e965b3e4b056aecfd47d08"},{"problem":50,"code":"(fn [s]\n  (vals (reduce (fn [m e] (assoc m (type e) (vec (concat (get m (type e)) [e])))) {} s)))","user":"51a3be77e4b0e77c4ca60bf8"},{"code":"(fn [sq]\n  (set (vals (apply merge-with concat (for [x sq] {(type x) [x]})))))","problem":50,"user":"504e12ade4b078edc5f593b7"},{"problem":50,"code":"(fn [s]\n  (let [am (group-by type s)]\n    (reduce (fn [hs k] (conj hs (am k))) #{} (keys am)))\n)","user":"5b4ff637e4b02d533a91bce0"},{"code":"#(vals (group-by type  %1))","problem":50,"user":"506afdafe4b0a2a5463de37e"},{"code":"(fn [sq]\n        (letfn [(r [sq cl]\n                  (if (empty? sq)\n                    (vals cl)\n                    (recur (rest sq) (update-in cl [(type (first sq))] #(into [] (conj %1 %2)) (first sq)))))]\n          (r sq {})))","problem":50,"user":"534e9ed4e4b084c2834f4ab8"},{"code":"(fn [s] (let \n                [kwds (vec (filter keyword? s))\n                 strgs (vec (filter string? s))\n                 seqs (vec (filter coll? s))\n                 nums (vec (filter number? s))]\n                (set (filter #(not (= [] %)) (list kwds strgs seqs nums)))))","problem":50,"user":"516733fce4b079759a74a5e9"},{"problem":50,"code":"(fn [coll]\n  (let [type? (fn [t']\n                (fn [obj] (= t' (type obj))))]\n    (loop [c coll\n           t (type (first coll))\n           acc #{}]\n      (if (seq c)\n        (let [[fst :as rem] (remove (type? t) c)\n              fil           (filter (type? t) c)]\n          (recur rem (type fst) (conj acc fil)))\n        acc))))","user":"56481722e4b0284900eef628"},{"code":"(fn [coll] (into #{} (vals (group-by type coll))))","problem":50,"user":"4e22b78b535d04ed9115e81e"},{"code":"(fn [in] (map (fn [[x y]] y) (group-by type in)))","problem":50,"user":"5186571de4b0da5a5be3bad1"},{"problem":50,"code":"(fn [coll]\n  (let [ts\n        (into #{}\n              (map class coll))]\n    (map\n     #(filter\n       (fn [x] (= (class x) %))\n       coll)\n     ts)))","user":"58ebae90e4b056aecfd47d44"},{"problem":50,"code":"(fn group [lis]\n  (letfn [(firstgroup[li]\n          (let [t (type (first li))] \n            (cons\n             (filter #(= t (type %)) li)\n             (filter #(not (= t (type %))) li))))]\n         (if (empty? lis) nil\n           (cons (first (firstgroup lis))\n                 (group (rest (firstgroup lis)))))))","user":"5627444fe4b00e49c7cb47cd"},{"problem":50,"code":"(fn [xs]\n  (for [[k v] (group-by class xs)]\n    v))","user":"5632d1b3e4b0bfe05bf117a9"},{"code":"#(vals (reduce (fn [result value]\n                 (let [cls (class value)\n                       cls-values (get result cls [])]\n                   (assoc result cls (conj cls-values value))))\n               {}\n               %))","problem":50,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [col]\n  (map val (group-by type col)))","problem":50,"user":"52a32876e4b04e0c58e87bfb"},{"problem":50,"code":"(fn [sq] (-> (group-by type sq)\n                     vals\n                     set))","user":"5da5a1eee4b000c986472c04"},{"problem":50,"code":"(fn [s] (map (comp vec last) (group-by #(class %) s)))","user":"5af31955e4b0cc2b61a3bc7a"},{"problem":50,"code":"(let\n  [put (fn [m v] (assoc m (class v) (if\n                                      (contains? m (class v))\n                                      (concat (m (class v)) [v])\n                                      [v])))]\n  (fn [s] (map second (reduce put {} s))))","user":"5b465b8be4b02d533a91bc65"},{"problem":50,"code":"(fn [coll]\n  (-> (group-by type coll)\n      vals))","user":"58bc8cbee4b0888cdc949d1b"},{"problem":50,"code":"(fn [x] (vals (reduce #(if(contains? %1 (class %2)) (update-in %1 [(class %2)] conj %2) (assoc-in %1 [(class %2)] [%2])) {} x)))","user":"54e4edcae4b024c67c0cf7f3"},{"code":"(fn [xs]\n   (vals (reduce #(let [t (type %2),\n                        v (second (find % t))]\n                       (assoc % t (if v (conj v %2) [%2]))) {} xs)))","problem":50,"user":"52161db6e4b0bf4bffd29cb8"},{"problem":50,"code":"#(map (fn [[_ a]] a) (group-by class %))","user":"57915ba4e4b0ebec4cfb75ba"},{"problem":50,"code":"(fn [xs]\n  (vals\n   (reduce\n     #(let [t (type %2)\n            v (get %1 t [])]\n        (assoc %1 t (conj v %2)))\n     {}\n     xs)))","user":"5ba15075e4b0a20761a2339e"},{"problem":50,"code":"(fn [parts]\n (loop [myvector [] parts parts]\n  \t(if (empty? parts)\n     \t myvector\n      \t (recur (conj myvector (filter \n                                #(=(type %) (type (first parts))) parts\n                               )\n                )\n                (filter #(not( =  (type %) (type (first parts)) ) ) parts )\n          ) \n      \n    )\n   \n )\n  \n)","user":"579be21fe4b05b1deef9adff"},{"code":"(fn [l]\n  (loop [m (hash-map) ll l]\n    (if (empty? ll)\n      (set (vals m))\n      (let [e (first ll) t (type e) v (m t)]\n        (recur (assoc m t (if v (conj v e) [e])) (rest ll))))))","problem":50,"user":"4dd9d299535d2dad7130b5dd"},{"code":"(fn [s]\n    (let [acc (fn [m i] (assoc m (type i) (conj (get m (type i) []) i)))\n          bytype (reduce acc {} s)]\n      (vals bytype)))","problem":50,"user":"5165a235e4b079ad97ec44ac"},{"problem":50,"code":"(fn\n  [x]\n  (vals (group-by type x))\n )","user":"5ac4d1f6e4b0e27600da7735"},{"code":"#(loop [l %1 r {}]\n    (if (empty? l)\n      (set (vals r))\n      (let [f (first l)\n            c (class f)\n            z (r c)]\n        (recur (rest l)\n               (assoc r c (conj (if (nil? z) [] z) f))))))","problem":50,"user":"52c81954e4b0c2d177d6212e"},{"problem":50,"code":"(fn f [& args]\n  (let [types (distinct (apply map type args))]\n    (set (for [t types] (apply filter #(= (type %) t) args)))))","user":"55aaa36fe4b0988bba2ad94f"},{"problem":50,"code":"(fn [s]\n    (vals (reduce (fn[acc b]\n        (assoc acc (type b) (conj (get acc (type b) []) b))\n    ) {} s))\n)","user":"5bfcdc52e4b0bdcf453d15f4"},{"problem":50,"code":"(fn split-by-type [x]\n  (for [[key value] (group-by class x)] value))","user":"600eb95de4b074f607df66a6"},{"problem":50,"code":"(fn split-by-type [coll]\n  (map (fn [x] (filter #(= (type x) (type %)) coll)) coll))","user":"5a388675e4b001c08efc0ca2"},{"code":"(fn splittype\n  [coll]\n  \t(vals (reduce #(assoc %1 (type %2) (conj\n  \t  (if (%1 (type %2)) (%1 (type %2)) [])\n      %2)) {} coll)))","problem":50,"user":"51701a9ce4b034fe8eaf70f5"},{"problem":50,"code":"#(vals (group-by (fn [x] (class x)) %1))","user":"560039cce4b04bb52996e162"},{"code":"(fn [seq]\n  (let [im (for [s seq]\n              [s (type s)])\n        types (loop [i 0 ut #{}]\n                (if (== i (count im))\n                  ut\n                  (recur (inc i) (conj ut (second (nth im i))))))]\n    (into #{} (map vec (for [t types]\n      (for [s im :when (= t (second s))]\n        (first s)))))))","problem":50,"user":"4e955b95535dbda64a6f6b33"},{"code":"(fn [l]\n  (letfn \n    [(inf\n      [l]\n      (if (empty? l) {}\n        (let [fl (first l) vt (type fl) rm (inf (rest l))]\n         (if (contains? rm vt)\n           (update-in rm [vt] (fn [s] (concat [fl] s)))\n           (assoc rm vt [fl])\n           ))))]\n    (vals (inf l))\n    ))","problem":50,"user":"52faec2ee4b047fd55837004"},{"code":"(fn [coll] (set\n            (for [i (set (map type coll))]\n              (filter #(= i (type %)) coll))))","problem":50,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn [v]\n     (let [m (loop [v v result {}]\n\t\t      (if (empty? v)\n\t       result\n\t       (recur (rest v) (merge-with concat result (hash-map (class (first v)) (vector (first v)))))))]\n\t       (vals m)))","problem":50,"user":"4f066916535dcb61093f6c10"},{"problem":50,"code":"(fn [xs]\n    (vals (group-by class xs)))","user":"551a21ece4b091ff45eda993"},{"problem":50,"code":"#(vals (apply merge-with into (for [e %] {(type e) [e]})))","user":"52a267c6e4b04e0c58e87bef"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (reduce\n        (fn [m v]\n          (assoc m (type v) (concat (get m (type v) []) [v])))\n        {})\n       (vals)\n       (set)))","user":"5cf6522be4b0b71b1d808a58"},{"problem":50,"code":"#(->> % (group-by type) (map second) (into #{}))","user":"54c641f8e4b045293a27f628"},{"code":"(fn [coll]\n   (set (into [] (for [[k v] (group-by class coll)] v) )))","problem":50,"user":"516282c3e4b0e6d3c4734711"},{"problem":50,"code":"#(case (first %) 1 #{[1 2 3] [:a :b :c]} :a #{[:a :b] [\"foo\" \"bar\"]} #{[[1 2] [3 4]] [:a :b] [5 6]})","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(fn [v] (into #{} (vals (group-by type v))))","problem":50,"user":"4dad90d9c9a9d6ed1999dc57"},{"problem":50,"code":"(fn [seqn] (map (fn [t] (filter #(= t (type %)) seqn)) (set (map type seqn))))","user":"5519c157e4b00ace28fe6e32"},{"code":"(fn [seq]\n   (let [len (count seq) type-seq (for [s seq] (type s))\n        classfier (fn [m k v](let [r (m k)](conj m {k (concat r [v])})))]\n     (for [ [k v] (loop [result {} ind 0]\n       (if (>= ind len) result\n        (recur (classfier result  (nth type-seq ind) (nth seq ind)) (inc ind))\n       )\n     )] v)\n   )\n)","problem":50,"user":"522eba30e4b01cdb292c5f0e"},{"problem":50,"code":"#(into #{}\n       (vals (reduce \n              (fn [m v] (if (m (type v))\n                          (update-in m [(type v)] conj v)\n                          (assoc m (type v) [v])))\n              {} %)))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":50,"code":"(fn split-by-type [s]\n  (vals (group-by class s)))","user":"55f9c245e4b03cbcff9738ca"},{"problem":50,"code":"#(map (fn [x] (val x)) (group-by (fn [x] (str (type x))) %))","user":"580e7761e4b0849f6811b753"},{"problem":50,"code":"(fn [s] (loop [s s, m {}]\n          (if (seq s)\n            (if-let [vs (get m (type (first s)))]\n              (recur (rest s) (assoc m (type (first s)) (conj vs (first s))))\n              (recur (rest s) (assoc m (type (first s)) [(first s)])))\n            (set (vals m)))))","user":"54ca93abe4b057c6fda3a264"},{"problem":50,"code":"(fn split-by-type [collection]\n  (loop [coll collection\n         types-map (transient {})]\n    (if (empty? coll)\n      (vals (persistent! types-map))\n      (let [el (first coll)\n            t (type el)]\n        (clojure.pprint/pprint types-map)\n        (if (get types-map t)\n          (assoc! types-map t (conj (get types-map t) el))\n          (assoc! types-map t [el]))\n        (recur (rest coll) types-map)))))","user":"55ed1575e4b0121d4835fdd3"},{"problem":50,"code":"(fn [xs]\n  (let [buncha-maps (map #(hash-map (type %) [%]) xs)]\n    (into #{} (vals (apply merge-with concat buncha-maps)))))","user":"58ee84e5e4b056aecfd47dab"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      vals\n      (into #{}))","user":"4ec7c32c535d6d7199dd36e6"},{"problem":50,"code":"(fn split [xs]\n  (let [split2 (fn split-by-type [xs acc]\n                        (if (seq xs)\n                          (let [x (first xs)\n                                xType (.getClass x)\n                                x-collection (acc xType)\n                                new-xs (if x-collection\n                                         (conj x-collection x)\n                                         (conj [] x))\n                                new-acc (assoc-in acc [xType] new-xs)]\n                            (split-by-type (rest xs) new-acc))\n                          (vals acc)))]\n    (split2 xs {})))","user":"54f86b8ce4b01ecee9d88828"},{"problem":50,"code":"(fn [input]\n  (let [types (vec (set (map type input)))]\n    (map \n     (fn [t] \n       (filter #(= (type %) t) \n               input)) \n     types)))","user":"5d2c779be4b01671435dbc8d"},{"problem":50,"code":"(fn [coll]\n  (vals (group-by type coll)))\n\n;(comp vals (partial group-by type))","user":"5a58bfd0e4b05d388ecb6c84"},{"problem":50,"code":"(fn [coll]\n  (loop [types  (distinct (map type coll))\n         v      []]\n    (if (= 0 (count types))\n      v\n      (recur (rest types) (conj v (filter #(= (first types) (type %)) coll) )))))","user":"52117ea7e4b07aea8afc4f70"},{"code":"(fn [coll] (->> (group-by class coll) vals))","problem":50,"user":"4ef6f5ea535dced4c769f250"},{"problem":50,"code":"(fn split-by-type [coll]\n  (set (filter #(seq %)\n               (for [x [1 2 3 4 5]]\n                 (case x\n                   1 (filterv string? coll)\n                   2 (filterv number? coll)\n                   3 (filterv keyword? coll)\n                   4 (filterv seq? coll)\n                   5 (filterv vector? coll))))))","user":"54d0cedde4b0e8a36923e5d2"},{"problem":50,"code":"(fn [x]\n  (let [tf (fn [p x t]\n (let [g (filter p x)]\n     (if (= g ())\n     t\n     (conj t g))\n   )\n )]\n  (tf vector? x (tf seq? x (tf string? x (tf keyword? x (tf number? x ()))))))\n)","user":"56d325ace4b0ea9b8538f7a9"},{"problem":50,"code":"( fn [s]\n  (let [pred (comp str class)] \n    (->> s (sort-by pred) (partition-by pred))\n  )\n)","user":"5d9e7971e4b000c986472bc1"},{"problem":50,"code":"(fn [xs]\n  (letfn [(split-by-type [acc s]\n            (if (zero? (count s))\n              acc\n              (let [p (partial instance? (type (first s)))]\n                (split-by-type (conj acc (filter p s))\n                               (filter #(not (p %)) s)))))]\n    (split-by-type [] xs)))","user":"5545eebee4b0a04f79299539"},{"code":"(fn [coll] (map val (group-by #(class %) coll)))","problem":50,"user":"505b9084e4b032b709c81371"},{"problem":50,"code":"(fn [x] (map (fn [n] (second n)) (group-by type x )) )","user":"5897dda4e4b00487982d52c8"},{"code":"(fn [coll]\n  (letfn [(filter-by [pred]\n            (filter pred coll))]\n    (->> (list (filter-by number?)\n               (filter-by keyword?)\n               (filter-by string?)\n               (filter-by coll?))\n         (filter (comp not empty?))\n         (apply hash-set))))","problem":50,"user":"50ed3c6be4b01236b1d4983b"},{"code":"(fn [xs] \n   (letfn [(fltr [xs el] (filter #(= (type el) (type %)) xs) )\n           (rmv [xs el] (remove #(= (type el) (type %)) xs) )]\n       (loop [res [] \n               xs xs]\n          (if (empty? xs)\n            res\n            (recur (conj res (fltr xs (first xs))) (rmv xs (first xs)))))))","problem":50,"user":"531bfb69e4b08068f379ed97"},{"problem":50,"code":"#(loop [r {} s %] (println (get r (type (first s))))\n    (if (empty? s)\n      (vals r)\n      (recur (assoc r (type (first s)) (conj (vec (get r (type (first s)))) (first s))) (rest s))))","user":"5f9c4113e4b0715f5002d821"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce #(update-in %1 [(str (class %2))] conj %2)\n                {}\n                (reverse coll))))","user":"56098ccbe4b0053d1b86c7e4"},{"problem":50,"code":"(fn [seq] (loop [suffix seq groups {}] (if (empty? suffix) (vals groups) (recur (rest suffix) (assoc groups (type (first suffix)) (conj (get groups (type (first suffix)) []) (first suffix)))))))","user":"5e1cc888e4b0dc959400853d"},{"problem":50,"code":"(fn type_split [s]\n  (set (vals (group-by type s)) )\n)","user":"561eb82fe4b064ca9f4b16c7"},{"code":"(fn [x ]  ( vals (apply (partial merge-with concat) (map #(hash-map (type %) [%]) x))))","problem":50,"user":"518644bce4b0da5a5be3baca"},{"problem":50,"code":"(fn [coll] (into #{} (map second (group-by type coll))))","user":"5759c833e4b02ea11479932c"},{"code":"(fn [lst]\n    (vals (group-by type lst)))","problem":50,"user":"51f5539fe4b0abb92f97f9cd"},{"code":"(fn split-by-type\n  ([xs] (split-by-type xs []))\n  ([xs acc]\n   (if (empty? xs)\n     acc\n     (let [p #(= (type %) (type (first xs)))]\n       (recur\n         (filter #(not (p %)) xs)\n         (conj acc (filter p xs)))))))","problem":50,"user":"508157b2e4b0946d0443855c"},{"problem":50,"code":"(fn ola\n  [l]\n  (vals (group-by  type l)))","user":"58dfce9fe4b0a4d5acaab723"},{"problem":50,"code":"(fn [input-seq]\n\t(let [split-map (reduce\n\t\t\t\t\t\t\t\t\t(fn [coll elem]\n\t\t\t\t\t\t\t\t\t\t(let [elem-type (type elem)\n\t\t\t\t\t\t\t\t\t\t\t\t\texisting-vals (get coll (type elem))]\n\t\t\t\t\t\t\t\t\t\t\t(if (nil? existing-vals)\n\t\t\t\t\t\t\t\t\t\t\t\t(assoc coll elem-type (vector elem))\n\t\t\t\t\t\t\t\t\t\t\t\t(assoc coll elem-type (conj existing-vals elem))\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t\t\t\tinput-seq)\n\t\t\t\t]\n\t\t(do\n\t\t\t(vals split-map)\n\t\t)\n\t)\n)","user":"5a5b9e3ce4b0512ff01cd90b"},{"problem":50,"code":"(fn split-type [coll]\n  (vals (group-by type coll)))","user":"5703d21ae4b08d47c97781ff"},{"code":"#(->> %1 (group-by type) vals)","problem":50,"user":"51f59607e4b0abb92f97f9d5"},{"problem":50,"code":"(fn split-by-type [coll]\n  (set (vals (group-by class coll))))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn [l] \n  (vals \n    (reduce \n      (fn [m [k v]] (assoc m k (conj (or (m k) []) v))) \n      {} \n      (map (juxt class identity) l))))","problem":50,"user":"4e707db6535d5021c1a8963a"},{"problem":50,"code":"(fn [coll]\n  (vals\n   (reduce (fn [ret x]\n             (let [t (-> x type str keyword)\n                   m (or (t ret) [])]\n               (assoc ret t (conj m x))))\n           {}\n           coll)))","user":"5370d152e4b0fc7073fd6e9d"},{"code":"(partial #(if (empty? %2)\n             (vals %1)\n             (let [elem (first %2)\n                   k (type elem)\n                   v (get %1 k [])]\n               (recur (assoc %1 k (conj v elem)) (rest %2))))\n          {})","problem":50,"user":"51105c7fe4b04c71fce993ef"},{"problem":50,"code":"(fn\n  [the-seq]\n  (set (vals (group-by type the-seq))))","user":"5c86b769e4b0c8042a70ce9b"},{"problem":50,"code":"(fn x [arr]\n  (let [types (distinct(map (fn [a] (type a)) arr))]\n    (loop [narr [] i 0]\n      (if (>= i (count types))\n        narr\n        (recur (conj narr (filter #(= (type %) (nth types i)) arr)) (inc i))))))","user":"5c72c2b9e4b0fca0c16227ab"},{"code":"(fn [c] (set (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} c))))","problem":50,"user":"51f2851fe4b0210f90e7454b"},{"code":"(fn split-by-type [s]\n  (loop [s s\n         r {}]\n    (if (empty? s)\n      (set (vals r))\n      (recur (rest s) \n       (assoc r (class (first s))\n         (if (contains? r (class (first s)))\n           (concat (get r (class (first s))) (list (first s)))\n           (list (first s))))))))","problem":50,"user":"51d360d1e4b099f3b6acddff"},{"problem":50,"code":"(fn [coll]\n    (map val (group-by type coll)))","user":"539fa040e4b0ca733b97449f"},{"problem":50,"code":"(fn [coll] (->> coll (map #(hash-map (type %) [%])) (apply merge-with concat) vals))","user":"563e1c0ee4b0da801c4e4665"},{"problem":50,"code":"(fn [coll] (into #{} (map last (group-by class coll))))","user":"59358f74e4b04f87174def52"},{"problem":50,"code":"(fn split-by-type\n  [collection]\n  (vals (group-by type collection)))","user":"5d42c88ae4b05dd059a5437e"},{"problem":50,"code":"(fn [xs] (set (map val (group-by type xs))))","user":"563ed73ae4b08d4f616f5ecb"},{"problem":50,"code":"(fn split-by-type [s]\n  (loop [s s longs [] keywords [] strings [] vectors []]\n    (if (empty? s)\n      (filter seq [longs keywords strings vectors])\n      (recur \n        (rest s)\n        (if (= (type (first s)) java.lang.Long)\n          (conj longs (first s))\n          longs) \n        (if (= (type (first s)) clojure.lang.Keyword)\n          (conj keywords (first s))\n          keywords)\n        (if (= (type (first s)) java.lang.String)\n          (conj strings (first s))\n          strings)\n        (if (= (type (first s)) clojure.lang.PersistentVector)\n          (conj vectors (first s))\n          vectors)\n      )      \n    )\n  )\n)","user":"55929e89e4b0604b3f94d58e"},{"problem":50,"code":"(fn ([s] (vals (reduce #(assoc %1 (type %2) (cons %2 (%1 (type %2)))) {} (reverse s)))))","user":"54d8cc38e4b0a52adc2e203e"},{"problem":50,"code":"(fn [xs]\n   (vals\n    (reduce (fn [acc x]\n              (let [k (type x)]\n                (assoc acc k (conj (get acc k []) x)) \n                )            \n              )\n            {}\n            xs\n            )))","user":"5ac85708e4b0e27600da77ac"},{"problem":50,"code":"#(loop [tmap {} pend %] \n\t(if (empty? pend) (vals tmap) \n\t\t( let [part (first pend) partT (keyword (str (type part))) partMap (partT tmap)]\n\t\t\t(if (nil? partMap) \n\t\t\t\t(recur (assoc tmap partT [part]) (rest pend))\n\t\t\t\t(recur (assoc tmap partT (conj partMap part)) (rest pend))))))","user":"57986b76e4b039eba2ecb116"},{"problem":50,"code":"(fn [c] (map second (group-by type c)))","user":"4e617114535d8ccf87e9fe5b"},{"problem":50,"code":"(fn [coll] (for [t (distinct (for [e coll] (type e)))] (filter #(= t (type %)) coll)))","user":"53b1db8ee4b047364c044495"},{"problem":50,"code":"(fn [xs]\n  (into #{} (vals (group-by type xs))))","user":"523ea111e4b057c4b7cd0a65"},{"code":"(fn [v] \r\n  (map (fn [y] (filter #(= (type %) (type y)) v)) v))","problem":50,"user":"505dd5c4e4b0e6aca564be0e"},{"code":"(fn s [xs]\r\n  (letfn [(f [acc x] (merge-with concat acc (hash-map (type x) (vector x))))]\r\n    (vals (reduce f {} xs))))","problem":50,"user":"4dc7e7a5535d8a4b2fd74290"},{"problem":50,"code":"(fn [c](vals(group-by #(type %) c)))","user":"5976da27e4b01722bebd4ce3"},{"problem":50,"code":"(fn [a-seq]\n  (let [types (set (map type a-seq))\n        filter-types (fn [t a-seq](filter #(instance? t %) a-seq))]\n    (map #(filter-types % a-seq) types)))","user":"505d1b01e4b0e6aca564be04"},{"problem":50,"code":"(fn [l]\n        (let [d [(type 1) (type :a) (type \"foo\") (type [1 2])]]\n            (loop [i 0 o []]\n                (if (< i (count d))\n                    (recur\n                        (inc i)\n                        (if (some #(= (type %) (nth d i)) l)\n                            (conj\n                                o\n                                ; (vector\n                                    (vec\n                                        (reverse\n                                            (reduce\n                                                #(if (= (type %2) (nth d i))\n                                                    (conj %1 %2)\n                                                    %1)\n                                                () l))))\n                            o))\n                    o))))","user":"5b083513e4b0cc2b61a3bdb4"},{"code":"#(vals (group-by (fn [x] (class x)) %))","problem":50,"user":"51beb32ae4b013aa0d74b7fd"},{"problem":50,"code":"#(set (map val (group-by class %)))","user":"51456858e4b0e88796073408"},{"problem":50,"code":"(fn split-type [lst]\n    (vals (reduce (fn add-map [m item]\n        (assoc m (type item) \n            (conj (get m (type item) []) item))) {} lst)))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn [s]\n  (vals (group-by #(type %) s)))","problem":50,"user":"4f107e0e535d64f60314641c"},{"problem":50,"code":"#(set (mapcat rest (group-by type %)))","user":"55ec4558e4b0121d4835fdc5"},{"code":"(fn [v] (let [class-name #(.toString (.getClass %))]\n             (partition-by class-name (sort-by class-name v))))","problem":50,"user":"5069c09be4b01dc6af13f837"},{"code":"(fn [coll]\n  (into #{} (vals (#(group-by class %1) coll)))\n  )","problem":50,"user":"5228f870e4b0186687e23a98"},{"code":"(fn [l]\n  (map #(second %)\n          (group-by #(type %) l)))","problem":50,"user":"4ec21058535dfed6da9c6dba"},{"code":"#(vals (group-by type % ))","problem":50,"user":"52d8eb78e4b09f7907dd139d"},{"problem":50,"code":"(fn [x] (map #(second %) (group-by #(class %) x)))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn [xs] (let [p #(str (type %))] (partition-by p (sort-by p xs))))","problem":50,"user":"5254ef3de4b0541d1855b9b8"},{"code":"(fn [coll]\n  (vals\n  (group-by type\n            coll)))","problem":50,"user":"509b152be4b0412cdea6eb1e"},{"problem":50,"code":"(fn [xs]\n   (map last (group-by type xs)))","user":"589037b4e4b00487982d51d0"},{"problem":50,"code":"(fn [coll]\n   (->>\n    (group-by type coll)\n    (vals)\n    (set)))","user":"605f5c69e4b03746e80ebf5e"},{"problem":50,"code":"(fn [s]\n  (into #{} (vals (group-by type s))))","user":"55995fa7e4b031d6649c9ba9"},{"code":"(fn [sq] \n  (->> sq\n       (group-by type)\n       (vals)))","problem":50,"user":"5094057fe4b097f48cc38593"},{"problem":50,"code":"(fn [lst]\n  (map val (group-by type lst)))","user":"545e7ab0e4b01be26fd7467c"},{"problem":50,"code":"(fn [x] (vals (reduce (fn [m i] (let [k (first i) c (get m k [])] (assoc m k (conj c (second i))))) {} (map #(vector (type %) %) x))))","user":"5c04464ee4b0bdcf453d167d"},{"problem":50,"code":"(fn [s]\n  (rest\n   (:r\n    (reduce #(if (= (first %2) (:t %1))\n               (update-in %1\n                          [:r (- (count (:r %1)) 1)]\n                          conj (second %2))\n               (assoc (update-in %1 [:r] conj [(second %2)])\n                 :t (first %2)))\n            {:r [[]]}\n            (sort-by (comp hash first)\n                     (map list\n                          (map type s)\n                          s))))))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn [x] (vals (reduce #(assoc %1 (class %2) (concat (%1 (class %2)) [%2])) {} x)))","problem":50,"user":"521249f5e4b06aa6d1666ba2"},{"problem":50,"code":"#(letfn [(ord [e] (.hashCode (type e)))] \n   (partition-by ord (sort-by ord %)))","user":"57a4bb65e4b0a966079561eb"},{"problem":50,"code":"(fn [xs] (vals (reduce (fn [m x] (update-in m\n                                            [(type x)]\n                                            #(if % (conj % x) [x])))\n                       {}\n                       xs)))","user":"5e6ba862e4b04a83ad7cd27d"},{"code":"(fn [seq]\n  (vals (group-by type seq)))","problem":50,"user":"4f4ff5a8e4b03ad3f0c10cf3"},{"code":"#(into #{} (map last (group-by class %)))","problem":50,"user":"504c8165e4b09724c857af31"},{"problem":50,"code":"(fn [coll]\n  (loop [xs coll split-by-type #{}]\n    (let [head-type (class (first xs))\n          filtered-type (filter #(= head-type (class %)) coll)]\n      (if (empty? xs)\n        split-by-type\n        (recur (rest xs) (conj split-by-type filtered-type))))))","user":"58327a08e4b089d5ab817c7c"},{"problem":50,"code":"#( for[[ k v] ( group-by class % ) ] v )","user":"516d227fe4b06f078fab252d"},{"code":"(fn [xs] (map (comp vec reverse) (vals \n  (reduce (fn [m x] (assoc m (type x) (cons x (get m (type x))))) {} xs))))","problem":50,"user":"4ece9ca9535d23f03622770f"},{"problem":50,"code":"(fn [coll] (vals (reduce (fn [m v] \n                           (let [t (type v)] \n                             (assoc m t (vec (conj (get m t) v))))) {} coll)))","user":"5744d088e4b009280f9f2b41"},{"code":"#(into [] (map second (group-by type %)))","problem":50,"user":"4f35b2ace4b0e243712b1ec5"},{"code":";(fn [coll]\n;  (vals (apply (partial merge-with concat) (map #(assoc {} (type %) [%]) coll))))\n(fn [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4f1c2a3a535d64f603146480"},{"problem":50,"code":"(fn split-by-type [s]\n(into #{} (map (fn [l] (map (fn [x] (first x)) l)) (vals (group-by second (map #(list % (type %)) s)))))\n)","user":"5d64ecb2e4b0c9e5857d5036"},{"code":"(fn [xs] (vals (group-by #(class %) xs)))","problem":50,"user":"52f10094e4b05e3f0be25ee8"},{"problem":50,"code":"(fn [coll]\n (->> (group-by type coll)\n  (map second)\n  (set)))","user":"598a0072e4b021a7a535fed9"},{"problem":50,"code":"(fn [a]\n  (vals (reduce (fn [m x]\n                  (let [c (class x)]\n                    (assoc m c (conj (get m c []) x)))\n                  ) {} a))\n  )","user":"5628cb07e4b00e49c7cb47ef"},{"problem":50,"code":"(fn [lst] (vals (group-by type lst)))","user":"56367c51e4b0bfe05bf117cd"},{"problem":50,"code":"(fn [coll]\n  (map (fn [ele] (filter #(= (type %) (type ele)) coll))\n       coll))","user":"55fe7e15e4b00f4cabc57651"},{"problem":50,"code":"(fn __ [coll]\n  (vals (group-by type coll)))","user":"573118ebe4b0cd1946bd0fbd"},{"problem":50,"code":"(fn [v]\n   (vals (group-by #(type %) v)))","user":"5daeb6bce4b0f8c104ccfc8b"},{"code":"(fn [l] \n  (partition-by \n    (fn [x] (class x)) \n    (sort-by \n      (fn [x] (str (class x)))\n        l)))","problem":50,"user":"4e9d6a65535dbda64a6f6b87"},{"problem":50,"code":"(fn [items]\n  (vals \n    (reduce #(into %1 \n                   (hash-map \n                     (type %2) \n                     (conj (vec (get %1 (type %2))) %2)\n                    )\n            )\n            {}\n            items\n    )\n  )\n)","user":"57ce3fede4b0c746388ab8a6"},{"problem":50,"code":"(fn [l]\n  (->> [string? number? vector? keyword?]\n       (map #(filter % l) )\n       (remove empty?)\n  )\n)","user":"55e8a85be4b0121d4835fd98"},{"code":"(fn [coll] (vals (group-by class coll)))","problem":50,"user":"4e6defcc535d5021c1a895f8"},{"problem":50,"code":"(fn [x] (vals (group-by type x) ) )","user":"563b559ee4b0bfe05bf1180d"},{"problem":50,"code":"(fn [coll] (partition-by type (sort #(compare (str (type %)) (str (type %2))) coll)))","user":"57283dbce4b0c5bde472c154"},{"problem":50,"code":"(fn split-by-type [elements]\n  (let [sorted (sort-by (comp str type) elements)\n        holder (vector (vector (first sorted)))\n        elems (drop 1 sorted)]\n    (loop [holder holder elems elems]\n      (if (empty? elems)\n        (set holder)\n        (let [comparitor ((comp first first) holder)\n              comp-holder (first holder)\n              compared (first elems)\n              rest-holder (rest holder)\n              next-elems (rest elems)]\n          (if (= (type comparitor) (type compared))\n            (recur (cons (conj comp-holder compared) rest-holder) next-elems)\n            (recur (cons (vector compared) holder) next-elems)))))))","user":"5dc4719ae4b02f9375f4e1b5"},{"code":"(fn [coll]\n    (loop [s coll m {}]\n      (if (seq s)\n        (recur (rest s) (merge-with concat m {(type (first s)) [(first s)]}))\n        (vals m))))","problem":50,"user":"52a7634ae4b0c58976d9ac16"},{"problem":50,"code":";#(vals (group-by type %))\n#(map reverse \n      (vals\n       (reduce\n        (fn [m v]\n          (update-in m [(class v)] (fn [x] (conj x v))))\n        {} %)))","user":"556c70dae4b09a3098a524fd"},{"problem":50,"code":"(fn func\n  [s]\n  (vals (reduce #(let [t (type %2)]\n                   (assoc %1\n                          t\n                          (conj (get %1\n                                     t\n                                     [])\n                                %2)))\n                {}\n                s)))","user":"5974d2ede4b01722bebd4cb6"},{"problem":50,"code":"(fn tsplit [items]\n  ((fn iter [remaining acc]\n    (if (empty? remaining) \n      (vals acc)\n      (let [val (first remaining) tval (type val)]\n        (iter (rest remaining) (assoc acc tval (conj (acc tval []) val)))))) items (hash-map)))","user":"60b2aaebe4b0e0fa5f1b4228"},{"problem":50,"code":"(fn [a] (partition-by type (sort-by #(count (str (type %))) a)))","user":"5d7d17ece4b02e6b30c93558"},{"problem":50,"code":"#(filter not-empty (list (filter string? %) (filter keyword? %) (filter coll? %) (filter number? %)))","user":"5b64370ae4b0c6492753e73c"},{"problem":50,"code":"(fn [coll]\n  (map val (group-by type coll)))","user":"58a1d00ae4b02bd94d917ec6"},{"problem":50,"code":"#(vals (reduce (fn [map v]\n                   (let [k (type v)]\n                     (assoc map k (conj (or (get map k) []) v)))\n                   ) {} %))","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":50,"code":"(fn [xs] (partition-by type\n (sort (fn [a b] (compare (str (type a)) (str (type b)))) xs)))","user":"5c87c79be4b048ec896c591b"},{"problem":50,"code":"#(->> % (group-by class) (map last))","user":"59f8b925e4b0ca45a743a327"},{"problem":50,"code":"(fn [c]\n  (vals (group-by #(type %) c)))","user":"5a085dfde4b01bb0ae8afdf4"},{"code":"(fn [coll]\r\n  (->> coll\r\n    (reduce\r\n      (fn [c o]\r\n        (let [typ (type o)]\r\n          (assoc c typ (conj (get c typ []) o))))\r\n      {})\r\n    vals))","problem":50,"user":"4e02bee8535d04ed9115e791"},{"code":"(fn [l](loop [a '() l l]\r\n  (if (empty? l) (reverse a)\r\n  (let [f #(= (type %) (type (first l)))\r\n      n #(not (f %))]\r\n    (recur (cons (filter f l) a) (filter n l))))))","problem":50,"user":"4ddbd934535d02782fcbe9fc"},{"code":"(fn [s] (map #(map second %) (partition-by first (sort #(.compareTo (str (first %)) (str (first %2))) (map #(list (type %) %) s)))))","problem":50,"user":"4f0397ee535dcb61093f6b30"},{"problem":50,"code":"(fn [v] (map #(% 1) (group-by type v)))","user":"57539e04e4b02ea1147992ab"},{"code":"(fn split-by-type [coll]\n  (let [types (set (map type coll))]\n    (for [t types] (filter #(= t (type %)) coll))))","problem":50,"user":"4ec75077535d6d7199dd36e0"},{"problem":50,"code":"(fn [coll]\n  (->> coll (group-by class) (map second) set))","user":"55afd469e4b002ce9d5cbc19"},{"problem":50,"code":"(fn sbt [sq]\n  (let [tmap (reduce #(let [old (get %1 (type %2) [])] (assoc %1 (type %2) (conj old %2))) \n                     {} sq)]\n    (into #{} (vals tmap))))","user":"5edd6eb7e4b0c7845d86b0f7"},{"problem":50,"code":"(fn [s] (partition-by class (sort-by #(str (class %)) s)))","user":"55478ce2e4b0a04f7929954e"},{"problem":50,"code":"(comp\n vals\n (partial\n  reduce\n  (fn [x y]\n    (update-in\n     x\n     [(type y)]\n     #(if % (conj % y) [y])))\n  {}))","user":"521d064fe4b0c4ef0be830a8"},{"code":"#(loop [ts [string? keyword? coll? number?]\n        result #{}\n        new-coll (filter (first ts) %)]\n  (if (zero? (count ts))\n    result\n    (recur (rest ts)\n           (if (zero? (count new-coll)) result (conj result new-coll))\n           (filter (second ts) %))\n))","problem":50,"user":"5070e31ee4b0e3170b5a8678"},{"problem":50,"code":"(fn [xs]\n  (let [ts (set (map type xs))]\n    (map (fn[t](filter #(= (type %) t) xs)) ts)))","user":"580fbaade4b0f478707a05c0"},{"code":"(fn [lst]\n(vals (reduce \n  #(assoc % (type %2) (conj (% (type %2) []) %2)) {} \nlst)))","problem":50,"user":"508bed64e4b0be79e5b189cf"},{"problem":50,"code":"#( vals (group-by type %))","user":"5e8308abe4b09a7a73c8bbb4"},{"problem":50,"code":"#(->> % (group-by type) (map second))","user":"59a72effe4b066c664927d94"},{"problem":50,"code":"(comp vals(partial group-by type))","user":"58e5e585e4b056aecfd47ca2"},{"code":"(fn split-by-type [coll]\n  (vals (group-by class coll)))","problem":50,"user":"5264383be4b03e8d9a4a70cb"},{"problem":50,"code":"#(vals (group-by type (into [] %)))","user":"546c1b2ce4b00cfc9eacc174"},{"problem":50,"code":"(fn split-by-type [xs]\n  (set (map #(.val %) (group-by type xs))))","user":"56efc9fde4b04a395b9a0464"},{"problem":50,"code":"(fn gby-type [lst]\n  (set\n   (vals\n    (group-by type lst))\n   )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"problem":50,"code":"(fn split-by-type [xs]\n  (set (map second (group-by class xs))))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn [s]\n  (map (partial map first)\n    (partition-by second\n      (sort-by #(hash (second %))\n        (map #(list % (type %))\n          s)))))","problem":50,"user":"502ac96de4b0614b5299611b"},{"problem":50,"code":"(fn f[se]\n  (vals (group-by #(type %) se))\n)","user":"5c337305e4b0d62ef62d9f48"},{"problem":50,"code":"(fn foo [x] (if (= (count x) 1) (list x) (let [r (rest x) p (foo r) f (first x) t (type f) b (some (fn [z] (= t (type (first z)))) p)]\n                                           (if b (map (fn [z] (if (= t (type (first z))) (conj z f) z ) ) p) (conj p (list f))) )) )","user":"57b8b008e4b0fbc9809a27e6"},{"problem":50,"code":"(fn [coll] (vec (reduce (fn [agg item] (conj agg (vec (filter #(= (type %)  (type item)) coll)))) #{} coll)))","user":"5bb36a9ce4b0a20761a23523"},{"code":"(fn fifty=\n  [coll]\n  (vals (group-by type coll)))","problem":50,"user":"510591dde4b06d28cacc92eb"},{"code":"(fn sbt [s]\n  (vals (reduce (fn [m i] (update-in m [(type i)] (fnil conj []) i)) {} s)))","problem":50,"user":"51672d15e4b079759a74a5e7"},{"problem":50,"code":"#(->> %\n     (reduce (fn [m v]\n               (assoc m (type v) (conj (get m (type v) [])v))) {})\n     vals)","user":"5ccc2a03e4b0ccb06196288f"},{"code":"(fn [lst] \n\t(let [sets (set (map #(type %) lst))]\n\t  (for [typ sets]\n\t    (vec (filter #(= typ (type %)) lst)))))","problem":50,"user":"52fe3a9de4b047fd55837039"},{"problem":50,"code":"(fn type-partition [col]\n  (vals (group-by #(type %1) col)))","user":"548018d1e4b0c51c1f4d7326"},{"problem":50,"code":"#(map (fn [[k v]] (reverse v)) (reduce (fn [h v] (let [t (type v)] (assoc h t (conj (h t) v))))  {} %1))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"(fn gp-by-type [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4f849f76e4b033992c121c36"},{"code":"(fn [coll]\n  (loop [items coll types {}]\n    (if (empty? items)\n      (set (vals types))\n      (let [item (first items)\n            item-type (type item)\n            types (if (contains? types item-type)\n                    types\n                    (assoc types item-type []))]\n        (recur (rest items) (update-in types [item-type] (fn [results-for-type] (conj results-for-type item))))))))","problem":50,"user":"4ec6c878535d6d7199dd36d5"},{"problem":50,"code":"(fn [s]\n  ( vals (group-by type s)))","user":"579c8ad1e4b05b1deef9ae0c"},{"problem":50,"code":"(fn [c] (partition-by type (sort-by (comp str type) c)))","user":"54487527e4b032a45b8693cc"},{"problem":50,"code":"(fn split-by-type [l]\n  (loop [l1 l s (hash-map)]\n    (if (empty? l1)\n      (set (vals s))\n      (let [type-key (type (first l1))\n            element (first l1)\n            type-class-coll (get s type-key)]\n        (recur (rest l1)\n               (if type-class-coll\n                 (assoc s type-key\n                        (conj type-class-coll element))\n                 (assoc s type-key\n                        [element])))))))","user":"55e4487ce4b050e68259b44c"},{"problem":50,"code":"(fn split-by-type [seq]\n  (set\n    (vals\n      (loop [results {} items seq]\n        (if (= (count items) 0)\n          results\n          (let [item (first items) item-type (type item) value (get results item-type [])]\n            (recur \n                   (assoc results item-type (conj value item))\n                   (rest items)\n            )\n          )\n        )\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn [lst]\n  (vals (reduce (fn [memo vl]\n            (merge-with (fn [val1 val2]\n                          (vec (concat val1 val2)))\n                        memo\n                        {(type vl) [vl]})) {} lst)))","problem":50,"user":"51c76864e4b07ef393169e3f"},{"problem":50,"code":"(comp vals (partial group-by  type))","user":"5dfa1c67e4b0a607a9a45cc5"},{"problem":50,"code":"(fn split-by-type [coll]\n  (->> (group-by type coll)\n       (map last)\n       (into #{})))","user":"5f663bc0e4b02876ed9fd02d"},{"code":"(comp vals #(group-by type %))","problem":50,"user":"4e5867d1535d8a8b8723a291"},{"problem":50,"code":"(fn foo[coll] (map (fn[h] (val h)) (group-by class coll)))","user":"5537b2c7e4b09218d5f44fce"},{"problem":50,"code":"(fn [coll]\n\n    (let [sorter #(str(type %1))]\n    (partition-by sorter (sort-by sorter coll)))\n)","user":"54ff2968e4b07d26eda61d4a"},{"problem":50,"code":"(fn [v] (vals  (group-by #(type %) v )))","user":"58a9e872e4b01a0c0b232973"},{"problem":50,"code":"(fn segregate [xs]\n  (if (empty? xs)\n    []\n    (let [[x & rem-x] xs\n          type-x (type x)\n          x-kinds (filter #(= type-x (type %)) xs)\n          non-x-kinds (filter #(not (= type-x (type %))) xs)]\n      (concat [x-kinds] (segregate non-x-kinds)))))","user":"5bcddaeee4b0e9689409ee07"},{"problem":50,"code":"(fn [v]\n    (vals (reduce #(assoc %1 (type %2) (vec (conj (%1 (type %2)) %2))) {} v)))","user":"5918db70e4b09b4ee5954bbb"},{"code":"#(into #{}\r\n      (for [[_ v] (group-by type %)]\r\n       v))","problem":50,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [lst] (vals (group-by #(type %) lst)))","problem":50,"user":"4f1fd734535d64f6031464a5"},{"problem":50,"code":"(fn split-by-type [seq]\n  (let [types (set (map type seq))]\n    (map #(remove (fn [x] (not (isa? (type x) %))) seq) types)\n    )\n  )","user":"5aada061e4b073f17744257a"},{"code":"(fn split-by-type [iseq]\n  (let [types (set (map #(type %) iseq))]\n    (map (fn [t] (filter #(= t (type %)) iseq)) types)))","problem":50,"user":"4f046d70535dcb61093f6bc5"},{"problem":50,"code":"(fn m [coll]\n  (let [types-map \n    (reduce\n      (fn [acc e]\n        (assoc acc (type e) (conj (get acc (type e) []) e)))\n     {}\n     coll)]\n    (vals types-map)))","user":"540d5085e4b0addc1aec670e"},{"problem":50,"code":"(fn split-by-type\n  ([x]\n   (split-by-type\n    (sort-by\n     (fn [x]\n       (last (clojure.string/split\n              (subs (str (type x)) 6)\n              #\"\\.\")))\n     x)\n    1 2))\n  ([x dummy-1 dummy-2]\n   (split-by-type (drop 1 x) [[(first x)]]))\n  ([[x-h & x-t] out]\n   (if (empty? x-t)\n     (map (comp vec reverse)\n          (if (= (type x-h) (type (first (first out))))\n            (concat [(cons x-h (first out))] (rest out))\n            (concat [[x-h]] out)))\n     (split-by-type\n      x-t\n      (if (= (type x-h) (type (first (first out))))\n        (concat [(cons x-h (first out))] (rest out))\n        (concat [[x-h]] out)))))\n  )","user":"5dd90651e4b0948ae9d9ad97"},{"code":"(fn [c] (partition-by type (sort-by #(.getName (type %)) c)))","problem":50,"user":"4fe900a6e4b0547ebccb243a"},{"code":"(fn sbt [l]\n  (let [f (fn [m e] (let [t (type e)] (assoc m t (conj (get m t []) e))))]\n    (vals (reduce f {} l))))","problem":50,"user":"4ecaaa25535d6d7199dd3708"},{"code":"(fn [lst]\n  (for [[k v] (group-by class lst)]\n    v\n    ))","problem":50,"user":"4fecebe1e4b0681fd128dcac"},{"problem":50,"code":"(fn split-by-type [x]\n  (->>   x\n   (group-by class)\n   (map #(nth % 1))))","user":"5632b0a9e4b0bfe05bf117a8"},{"code":"(fn [x] (set (partition-by class (sort-by #(str (class %)) x))))","problem":50,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":50,"code":";(fn [x] \n;  (set \n;   (map \n;    (fn [e] \n;      (filter #(= (type %) (type e)) x)\n;      )\n;    x)))\n\n#(vals (group-by type %))","user":"58d28c70e4b03c36ff7e5901"},{"code":"#(set (partition-by type (sort (fn [a b] (compare (str (type a)) (str (type b)))) %)))","problem":50,"user":"4e9b22e2535dbda64a6f6b74"},{"code":"(fn [x]\n  ((fn listnn [& more]\n     (if (= (count more) 0)\n       '()\n       (if (= (first more) '())\n         (apply listnn (rest more))\n         (cons (first more) (apply listnn (rest more)))\n         )\n       )\n    )\n   (filter number? x)\n   (filter vector? x)\n   (filter string? x)\n   (filter keyword? x)\n   )\n  )","problem":50,"user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn [s] (vals (reduce #(apply (partial assoc %1) (let [c (class %2)] [c (conj (%1 c) %2)])) {} (reverse s))))","problem":50,"user":"52d1e364e4b0d9f9285948e7"},{"problem":50,"code":"(fn [x] \n          (filter #(not(empty? %)) [(filter #(number? %)x) (filter #(keyword? %) x) (filter #(string? %) x) (filter #(vector? %) x)]))","user":"5654cb2de4b0f9d632dd848b"},{"code":"#(map (fn [[a b]] b) (group-by class %))","problem":50,"user":"53712c03e4b0fc7073fd6ea9"},{"code":"(fn [s]\n  (partition-by class (sort-by (comp str class) s)))","problem":50,"user":"4f58d92fe4b0a7574ea71858"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce (fn [acc item]\n                  (let [c (class item)]\n                    (if (acc c)\n                      (assoc acc c \n                        (conj (acc c) item))\n                      (assoc acc c [item]))))\n                {}\n                coll)))","user":"59225498e4b09b4ee5954c8c"},{"code":"(fn [xs]\n  (->> xs\n   (group-by type)\n   vals))","problem":50,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [coll]\n  (vals (reduce (fn [m x]\n                  (let [t (type x)]\n                    (if-let [e (m t)]\n                      (assoc m t (conj e x))\n                      (assoc m t [x]))))\n                {}\n                coll)))","problem":50,"user":"4e8c1d97535d65386fec2127"},{"code":"(fn [coll]\n    (partition-by type\n      (sort #(compare (str (type %1)) (str (type %2))) coll)))","problem":50,"user":"4f4a8707e4b0d56e7bb92c12"},{"problem":50,"code":"(fn [items]\n  (let [find-similar (fn [items]\n                        (if (empty? items)\n                          items\n                          (let [t1 (type (first items))]\n                            (loop [type-domain [(first items)]\n                                   itms2chk (rest items)]\n                              (if (empty? itms2chk)\n                                type-domain\n                                (if (= (type (first itms2chk)) t1)\n                                  (recur (conj type-domain (first itms2chk))\n                                         (rest itms2chk))\n                                  (recur type-domain (rest itms2chk))))))))]\n    (loop [items items\n           cur-type-domain (find-similar items)\n           res-set #{}]\n      (if (empty? cur-type-domain)\n        res-set\n        (let [rest-items (remove (set cur-type-domain) items)]\n          (recur rest-items\n                 (find-similar rest-items)\n                 (conj res-set cur-type-domain)))))))","user":"5a23503fe4b0ff51aa4b32d6"},{"code":"(fn split-by-type [coll]\n  (vals (reduce (fn [l e]\n         \t  (if (l (class e))\n\t            (assoc l (class e) (conj (l (class e)) e))\n\t            (assoc l (class e) [e])))\n                {}\n                coll)))","problem":50,"user":"4e4bd94b535dc968683fc4d7"},{"problem":50,"code":"(fn msubseq\n  [s]\n  (vals (reduce #(update-in %1 [(type %2)] conj %2) (reduce #(merge %1 {(type %2) []}) {} s) s)))","user":"540efe2ee4b0addc1aec6724"},{"problem":50,"code":"(fn [coll] \n  (vals (group-by type coll)))","user":"53576356e4b04ce2eb3ed27a"},{"problem":50,"code":"(fn [l]\n   (into (hash-set) (vals (group-by type l))))","user":"5f3f2281e4b004f08c61c561"},{"code":"(fn [as]\r\n   (vals (apply merge-with concat (map #(hash-map (type %) [%]) as))))","problem":50,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":50,"code":"(fn [x]\n   (vals(group-by type  x)))","user":"5950f0bfe4b066ee0a44ae9f"},{"code":"(fn group-by-type [seq]\n    (vals \n        (reduce (fn [m e] \n            (conj m [(type e) (conj (m (type e) []) e)]))\n            {} \n            seq)\n    ))","problem":50,"user":"5268eb68e4b03e8d9a4a71c6"},{"problem":50,"code":";;(fn [n] (remove empty? ( (juxt #(filter keyword? %) #(filter vector? %) #(filter string? %) #(filter integer? %)) n)))\n#(vals (group-by type %))","user":"562326cbe4b03f08ee9a9230"},{"problem":50,"code":"(comp vals \n      (partial group-by type))","user":"5515b138e4b055c2f668d4ed"},{"code":"#(set (vals (reduce (fn [acc, e] (\n  let [t (type e), m (acc t)] (cond\n    m (assoc acc t (conj m e))\n    :else (assoc acc t (vector e))))) {} %)))","problem":50,"user":"4e89ddf9535d3e98b8023284"},{"problem":50,"code":"(fn split-by-type [coll]\n  (set (vals (reduce #(let [k (type %2)\n                            v (get %1 k [])]\n                        (assoc %1 k (conj v %2))) {} coll))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn [coll]\n     (loop [c coll\n\t          k []\n\t          v []\n\t          i []\n\t          s []]\n\t      (if (empty? c) (remove #(empty? %)[k v i s])\n\t\t  (recur (rest c)\n\t\t\t     (if (keyword? (first c)) (conj k (first c)) k)\n\t\t\t     (if (vector? (first c))  (conj v (first c)) v)\n\t\t\t     (if (number? (first c)) (conj i (first c)) i)\n                             (if (string? (first c)) (conj s (first c)) s)))))","problem":50,"user":"4ea4e98a535d7eef308072ce"},{"code":"(fn [l]\n  (into #{} (partition-by type (sort #(compare (str (type %1)) (str (type %2))) l))))","problem":50,"user":"4fd8544be4b0dab7d829f390"},{"problem":50,"code":"(comp vals (partial group-by type ))","user":"5d4320fde4b07c84aa5ae690"},{"problem":50,"code":"(fn [xs]\n  (vals\n   (group-by type xs)))","user":"5980f91ae4b021a7a535fddd"},{"code":"(fn[s]\r\n  (vals(reduce\r\n    #(assoc %\r\n       (type%2)(conj(get % (type%2)[])%2))\r\n   {} s))\r\n)","problem":50,"user":"4dd66da7535d2dad7130b5c8"},{"problem":50,"code":"(fn [coll] (vals (group-by (fn [x] (type x)) coll)))","user":"5509bec5e4b06e50f9beb121"},{"problem":50,"code":"#(let [cls (set (for [x %] (class x)))\n        vs (for [c cls]\n             (filter (fn [_]\n                            (= c (class _)))\n                          %))]\n    (set vs))","user":"54d753ebe4b0a52adc2e2029"},{"problem":50,"code":"(fn [col]\n  (vals\n    (reduce\n      (fn [res item]\n        (update-in res [(type item)] (fnil conj []) item))\n      {}\n      col)))","user":"53a83c74e4b047364c044426"},{"problem":50,"code":"#(vals ( group-by type %1))","user":"5e44c804e4b01d43a70e8e89"},{"code":"(fn type-split [x]\n  (let [types (set (map #(type %) x))]\n    (set (for [i types] (filter #(= (type %) i) x)))))","problem":50,"user":"4ee9d697535d93acb0a66895"},{"problem":50,"code":"(fn [s] (map second (group-by #(type %) s)))","user":"56011393e4b04bb52996e178"},{"problem":50,"code":"(fn split-by-type [xs]\n  (let [types (set (map type xs))]\n    (map #(filter (fn [x] (= (type x) %)) xs) types)))","user":"53e8c684e4b036ad0777e48b"},{"code":"#(->> % (group-by class) (vals))","problem":50,"user":"53244c9de4b09d4e7a9b54db"},{"problem":50,"code":"(fn split-by-type [col]\n  (vals (group-by class col)))","user":"570ab24fe4b0b0fb43fd06b7"},{"code":"#(map val (group-by class %))","problem":50,"user":"4fab31a8e4b081705acca215"},{"problem":50,"code":"(fn [xs]\n    (letfn [(class-key [cl]          ((comp str class) cl))\n            (update-values [agg k v] (cond (nil? (agg k)) [v]\n                                           :else (conj (agg k) v)))\n            (aggregate [agg k v]     (assoc agg k (update-values agg k v)))]\n      (-> (reduce (fn [acc x] (aggregate acc (class-key x) x)) {} xs)\n          (vals))))","user":"560e9a2de4b05f002753df52"},{"code":"(fn [a]  (remove empty? (conj (vector (filter string? a)) (filter integer? a) (filter vector? a) (filter keyword? a))))","problem":50,"user":"4e218470535d04ed9115e817"},{"problem":50,"code":"(fn segregate [coll]\n  (map (fn [t ts]\n         (filter #(= t (type %)) ts))\n       (set (map type coll)) (iterate identity coll)))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":50,"code":"(fn [s] \n    (partition-by #(-> % type str) (sort-by #(-> % type str) s )))","user":"54febf4be4b07d26eda61d45"},{"problem":50,"code":"(fn \n  [s]\n  (vals (group-by type s)))","user":"5772ddb0e4b0979f896515d4"},{"problem":50,"code":"(fn [s] (let [types (set (map type s))]\n                (for [t types]\n                  (vec (filter #(= (type %) t) s)))))","user":"5e453725e4b01d43a70e8e93"},{"code":"(fn [s]\r\n  (loop [types {} orig s]\r\n    (if (empty? orig)\r\n      (vals types)\r\n      (let [t (type (first orig))]\r\n        (if (contains? types t)\r\n          (recur (assoc types t (conj (get types t) (first orig))) (rest orig))\r\n          (recur (assoc types t [(first orig)]) (rest orig))\r\n        ))\r\n      )))","problem":50,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":50,"code":"(fn [xs]\n  (loop [remain xs\n         gather {}]\n    (if (empty? remain)\n      (vals gather)\n      (let [now (first remain)\n            t (type now)\n            in (gather t)\n            ng (if (nil? in)\n                 (conj gather [t [now]])\n                 (conj gather [t (conj in now)]))\n                 ]\n        (recur (rest remain) ng)))))","user":"57717915e4b0979f896515b3"},{"code":"(fn split-sequence-type [a]\n\t(map (fn [kv] (val kv)) (group-by type a)))","problem":50,"user":"50ed8a5fe4b06330c1f87c3d"},{"problem":50,"code":"(fn [ns]\n  (vals (group-by type ns)))","user":"52c00e32e4b07a9af5792341"},{"code":"(fn [z] \n  (vals \n    (reduce #(merge-with (fn [x y] (conj x (first y))) %1 %2) \n            (#(map hash-map (map type %) (map vector %)) z))\n    )\n  )","problem":50,"user":"4e5bdc2b535d8a8b8723a2bb"},{"code":"(fn ! [xs]\n       (if (< 0 (count xs))\n   (let [coll (filter\n\t\t\t  #(= (type %)\n\t\t\t      (type (first xs)))\n\t\t\t  xs)\n\t       \n\t       rest (filter #(not (= (type %)\n\t\t\t\t     (type (first xs))))\n\t\t\t    xs)]\n\t   (conj (! rest)\n\t\t coll))))","problem":50,"user":"4ec6157b535d6d7199dd36c2"},{"code":"(fn split-by-type [l]\n    (vals (group-by type l)))","problem":50,"user":"4fbdcb87e4b081705acca30a"},{"problem":50,"code":"(fn splitByType [coll] (vals (group-by type coll)))","user":"542c1f73e4b0dad94371f29d"},{"problem":50,"code":"#(partition-by type\n\n    (sort-by (comp str type) %))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"#(vals (group-by class % ))","problem":50,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn [xs] (set (vals (group-by #(type %) xs))))","problem":50,"user":"4e9c66e2535dbda64a6f6b7f"},{"problem":50,"code":"(fn [s]\n    (->> s\n         (group-by class)\n         vals))","user":"603d5f2ae4b0d5df2af2230c"},{"problem":50,"code":"(fn [coll]\n               ( set (vals (group-by type coll))))","user":"5ab575f8e4b073f17744263d"},{"problem":50,"code":"(fn myfunc ([sequ] (myfunc sequ '() '() '() '()))\n    ([sequ, seqs, ints, strs, kys] (if (empty? sequ)\n                                     (if (and (empty? seqs) (empty? strs))\n                                     (conj (list (reverse kys)) (reverse ints))\n                                     (if (and (empty? seqs) (empty? ints))\n                                       (conj (list (reverse kys)) (reverse strs))\n                                       (conj (list (reverse seqs)) (reverse kys) (reverse ints))\n                                       )\n                                     )\n                          (if (integer? (first sequ))\n                            (recur (rest sequ) seqs (conj ints (first sequ)) strs kys) \n                            (if (keyword? (first sequ))\n                              (recur (rest sequ) seqs ints strs (conj kys (first sequ)))\n                              (if (string? (first sequ))\n                                (recur (rest sequ) seqs ints (conj strs (first sequ)) kys)\n                                (recur (rest sequ) (conj seqs (first sequ)) ints strs kys)\n                                ))))))","user":"5a0a3473e4b0eab8c0448941"},{"problem":50,"code":"(fn [shit] (vals (group-by class shit)))","user":"561814bae4b06b1bb2182a1a"},{"problem":50,"code":"(fn\n  [s]\n  (set (vals (group-by #(type %) s))))","user":"585a7b05e4b0f14aab7c874d"},{"problem":50,"code":"(fn split-by-type [s]\n  (let [typemap (zipmap s (map #(type %) s))]\n    (vals (group-by #(typemap %) s))))","user":"5392500ae4b0b51d73faaeaf"},{"problem":50,"code":"(fn split-by-type [coll]\n  (set (map val (group-by type coll))))","user":"5dd67c22e4b0948ae9d9ad80"},{"code":"(fn [s]\n    (partition-by type (sort #(compare (str (type %1)) (str (type %2))) s)))","problem":50,"user":"526f9715e4b03e8d9a4a7372"},{"problem":50,"code":"(fn test [coll]\n  (vals (group-by class coll)))","user":"579332c2e4b0e215f87e8452"},{"problem":50,"code":"(fn split-by-type [set]\n  (for [[key val] (group-by class set)] val))","user":"595fe942e4b066ee0a44b075"},{"code":"(fn [c] (vals (group-by #(class %) c)))","problem":50,"user":"4e9dafe1535dbda64a6f6b89"},{"code":"(fn [coll]\r\n  (loop [coll coll acc '()]\r\n    (or (and (empty? coll) acc)\r\n        (let [f (first coll)\r\n              t (type f)]\r\n          (recur (filter (fn [a] (not= (type a) t)) coll)\r\n                 (cons (filter (fn [a] (= (type a) t)) coll) acc))))))","problem":50,"user":"50ba4b9ee4b03e68e4411c7b"},{"problem":50,"code":"#(->> %\n     (group-by type)\n      (map second))","user":"5f476a39e4b0102c7503392f"},{"problem":50,"code":"(fn [l]\n  (->>\n   l\n   (group-by class)\n   (vals)))","user":"5833a6d8e4b089d5ab817ca2"},{"problem":50,"code":"#(set (vals (group-by type %1)))","user":"541074f1e4b01498b1a719ac"},{"problem":50,"code":"(fn spotsplit [c]\n  (set\n   (let [result #{}]\n     ((fn collectfirsttype [l, r]\n       (if (empty? l)\n         r\n         (let [f (first l), t (type f)]\n           (collectfirsttype (filter #(not= t (type %)) l) (cons (filter #(= t (type %)) l) r))))) c result))))","user":"60882700e4b0ae75613dcedf"},{"problem":50,"code":"(fn [coll]\n      (map (fn [typeathand]\n             (filter #(= typeathand (type %1)) coll))\n           (loop [remainder coll found '()]\n             (if (empty? remainder)\n               found\n               (let [curtype  (type (first remainder))]\n                 (recur (rest remainder) (if (some #{curtype} found) found (conj found curtype)))\n                 )))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"#(map reverse\r\n  (vals\r\n  (reduce (fn [m [c item]]\r\n             (update-in m [c] conj item))\r\n   {}\r\n   (map (fn [item] (vector (class item) item))\r\n      %))))","problem":50,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [coll] (map second (group-by #(.getClass %) coll)))","problem":50,"user":"4daedd1eedd6309eace4d164"},{"code":"(fn splitbytype [x]\n     (map second (vec (group-by type x))))","problem":50,"user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn [a] (set (vals (group-by type a))))","problem":50,"user":"4ddb696b535d02782fcbe9fa"},{"code":"(fn split-by-type [l]\r\n   (letfn [(split-with-acc [acc e]\r\n                           (assoc acc (type e) (conj (get acc (type e)) e)))]\r\n          (for [[k v] (reduce split-with-acc {} l)]\r\n            (reverse v))))","problem":50,"user":"4fc8b012e4b0ee37620e1838"},{"problem":50,"code":"(fn sp [coll]\n  (vals (reduce \n   (fn [s e]\n     (update-in s [(type e)] (fn [c] (if c (conj c e) [e]))))\n   {}\n   coll)))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn [s]\n  (set (vals (reduce #(let [accum %1\n               k (str (type %2))\n               v %2]\n           (if (accum k)\n             (assoc accum k (conj (accum k) v))\n             (assoc accum k (conj [] v))))\n               (hash-map)\n               s))))","problem":50,"user":"4f03f3b7535dcb61093f6b85"},{"code":"(fn [x] (map #(filter (fn [z] (= (type z) %)) x) (set (map type x))))","problem":50,"user":"50223ee2e4b0846bc458ae48"},{"problem":50,"code":"(fn [v]\n    (loop [mv v\n           ret {}]\n      (if (empty? mv)\n        (vals ret)\n        (let [t (first mv)]\n          (recur (rest mv) (assoc ret (type t) (conj (get ret (type t) []) t)))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"(fn [s]\n  (map second\n    (group-by #(type %) s)))","problem":50,"user":"4fb7b80ae4b081705acca2d4"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n   (group-by type)\n       (map (fn [[k g]] g))\n       (into #{})))","user":"57642916e4b0994c1922fbee"},{"code":"(fn [_x_] (vals (reduce (fn [c x] (update-in c [(class x)] (fnil #(conj % x) []))) {} _x_)))","problem":50,"user":"4da8dd6e30acd6ed12482a68"},{"problem":50,"code":"(fn my-split-by-type [vs]\n  (loop [[x & rxs :as xs] vs\n         m (sorted-map)]\n    (if (empty? xs)\n      (vals m)\n      (recur rxs (if (nil? (m (str (class x))))\n                   (assoc m (str (class x)) (vector x))\n                   (assoc m (str (class x)) (conj (m (str (class x))) x)))))))","user":"54a31fdae4b09f271ff37c64"},{"problem":50,"code":"(fn split-type [s]\n    ((fn help [remaining hash]\n       (if (empty? remaining)\n         (set (vals hash))\n         (help (rest remaining)\n               (let [key (str (type (first remaining))),\n                     value (first remaining)]\n                     (assoc hash\n                            key\n                            (conj (hash key [])\n                                  value))))))\n     s\n     {}))","user":"54d26316e4b0e8a36923e5f2"},{"problem":50,"code":"(fn [col]\n (vals (group-by type col)))","user":"54580586e4b01be26fd74616"},{"problem":50,"code":"(fn [foo] \n  (->> foo\n       (map #(vector (str (type %)) %))\n       (sort-by first)\n       (partition-by first)\n       (map (fn [coll] (map #(last %) coll)))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":50,"code":"(fn [xs]\n  (loop [ys xs\n         r {}]\n    (let [y (first ys)\n          t (type y)]\n      (cond\n       (empty? ys) (vals r)\n       (contains? r t) (recur (rest ys)\n                              (assoc r t (conj (r t) y)))\n       :else (recur (rest ys)\n                    (assoc r t [y]))))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn [l]\n  (loop [l l\n         types {}]\n    (if (empty? l)\n      (set (map val types))\n      (if (contains? types (type (first l)))\n        (recur (rest l) (assoc types (type (first l)) (conj (types (type (first l))) (first l))))\n        (recur (rest l) (assoc types (type (first l)) [(first l)]))))))","problem":50,"user":"538be6afe4b0640c7a9a58c9"},{"code":"(fn [items]\n  (reverse (map reverse (vals (reduce (fn [res i]\n            (let [t (type i)\n                  o (res (type i))]\n              (assoc res t (conj o i)))) \n          {} items)))))","problem":50,"user":"5348236ee4b084c2834f4a54"},{"problem":50,"code":"(comp (partial partition-by type)\n      (partial sort-by (comp str type)))\n\n;;(comp vals (partial group-by type))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [q] (vals (group-by type q)))","problem":50,"user":"532e0b20e4b019098a6f8b45"},{"problem":50,"code":"(fn [x]\n  (map #(second %) (group-by type x))\n\n)","user":"5951190be4b066ee0a44aea4"},{"problem":50,"code":"(fn splitbytype [s]\n  (loop [c s acc {}]\n    (if (empty? c)\n      (map #(-> % reverse vec) (vals acc))\n      (let [f (first c) t (type f)]\n        (recur (rest c) (update-in acc [t] #(cons f %)))\n        )\n      )\n    )\n  )","user":"560ac5cae4b05f002753df09"},{"code":"#(vals (loop [s % ans {}]\n    (if (empty? s)\n      ans\n      (let [[e & rest] s\n            t (type e)]\n        (recur rest (assoc ans t (conj (ans t []) e)))))))","problem":50,"user":"4fbfe9a4e4b081705acca31f"},{"problem":50,"code":"(fn f [s]\n  (->> (map #(vector (class %) %) s)\n       (reduce (fn [acc x]\n                  (let [type (first x)\n                        value (second x)]\n                    (if (acc type)\n                      (update-in acc [type] conj value)\n                      (assoc acc type [value]))))\n               {})\n       vals))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":50,"code":"#((comp vals (partial group-by type)) %)","user":"542edb4ae4b0dad94371f2c8"},{"problem":50,"code":"(fn [s]\n  (let [types (set (map type s))]\n   (map (fn [typ] (filter #(= (type %) typ) s))\n        types)))","user":"541709b0e4b01498b1a71a06"},{"problem":50,"code":"(fn [seq]\r\n   (for [[k v] (group-by type seq)]\r\n     v))","user":"542b764ae4b0dad94371f28d"},{"code":"(fn split-by-type [coll]\n  (into #{}\n        (for [[k v]\n              (group-by type coll)]\n          v)))","problem":50,"user":"504ec4d3e4b069badc5a33c9"},{"code":"(fn type-split [coll]\n  (vals (reduce\n         (fn [a b]\n           (if (get a (type b))\n             (assoc a (type b) (conj (get a (type b)) b))\n             (assoc a (type b) [b])))\n         {}\n         coll)))","problem":50,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn split-by-type[x] (vals (group-by #(.getClass %) x)) )","problem":50,"user":"4f03bf5e535dcb61093f6b5d"},{"problem":50,"code":"(fn [args]\n   (vals (reduce\n          (fn [state arg]\n            (prn state)\n            (assoc state (class arg)\n                   (conj (or (get state (class arg))\n                             []) arg)))\n          {}\n          args)))","user":"5f79bff2e4b02876ed9fd0ca"},{"problem":50,"code":"(fn [a] (let [b (map #(vector (type %1) %1) a)]\n         (vals (reduce #(if (nil? (%1 (%2 0)))\n                         (conj %1 [(%2 0) [(%2 1)]])\n                         (conj %1 [(%2 0) (conj (%1 (%2 0)) (%2 1))])) {} b))))","user":"52281e1ee4b0186687e23a69"},{"code":"(fn p50\n  [coll]\n  (vals (group-by class coll)))","problem":50,"user":"4e7d4544535db169f9c796d0"},{"code":"(fn [z] (vals (group-by type z)))","problem":50,"user":"505caadfe4b0bcb5664c3d3e"},{"code":";; wow how did I miss `group-by`?!\n#(let [f (comp str type)] (->> % (sort-by f) (partition-by f)))","problem":50,"user":"52cb6bb0e4b07d0d72b2734c"},{"problem":50,"code":"(fn[coll] (vals (group-by type coll)))","user":"5a63f8bae4b0512ff01cd99f"},{"problem":50,"code":"#(filter (fn [x] (not (empty? x)))\n         [(filter integer? %)\n          (filter keyword? %)\n          (filter string? %)\n          (filter coll? %)])","user":"53fb5256e4b0de5c4184857f"},{"problem":50,"code":"(fn my-split-by-type\n  ([xs] (my-split-by-type xs {}))\n  ([[x & xs] out]\n     (let [klass     (class x)\n           update-fn #(conj (or % []) x)\n           out       (update-in out [klass] update-fn)]\n       (if (nil? xs)\n         (vals out)\n         (recur xs out)))))","user":"53edb628e4b0d648e757f4c8"},{"problem":50,"code":"(fn gropu-by-type [s]\n  (-> (group-by type s) (vals))\n\n  )","user":"56791447e4b05957ce8c6183"},{"problem":50,"code":";(fn [s]\n;  (vals (group-by #(.getClass %) s)))\n#(vals (group-by type %))","user":"4ebbc1f6535dfed6da9c6d72"},{"problem":50,"code":"(fn [s] (vals (reduce (fn [m [t v]] (assoc m t (conj (m t []) v))) {} (map #(-> [(type %) %]) s))))","user":"54f0d3fde4b024c67c0cf8a6"},{"code":"#(letfn [(split-by-type\n           [coll]\n           (reduce\n             (fn [m e] \n               (let [k (class e)]\n                (assoc m k (conj (m k []) e))))\n             {}\n             coll))]\n   (vals (split-by-type %)))","problem":50,"user":"51fb9d30e4b0f1313d468a0f"},{"code":"(fn [stuff]\n   (vals (group-by #(type %) stuff)))","problem":50,"user":"524ad140e4b09eba1c0223a9"},{"code":"(fn [vect]\n   ((fn walk-list [vect type-map]\n      (if (empty? vect)\n        (vals type-map)\n        (let\n            [value (first vect)\n             type-value (type value)\n             next-vect  (rest vect)\n             map-value  (get type-map type-value [])]\n          (walk-list next-vect\n                     (assoc type-map\n                       type-value\n                       (conj map-value value))))))\n    vect {}))","problem":50,"user":"4f03818e535dcb61093f6b00"},{"problem":50,"code":"(fn [coll]\n  (loop [c coll\n         result {}]\n    (let [e (first c)\n          k (class e)\n          v (get result k)]\n      (if (empty? c)\n        (set (vals result))\n        (recur (rest c)\n               (if (nil? v)\n                 (assoc result k [e])\n                 (assoc result k (conj v e))))))))","user":"51a7fe50e4b08d8ec191b803"},{"code":"(fn f [coll]\r\n  (vals (group-by type coll)))","problem":50,"user":"4eb99b3d535dfed6da9c6d57"},{"code":"(fn split-by-type [xs]\n  (let [mkmap (fn mkmap [xs]\n    (when-first [x xs]\n      (merge-with concat {(type x) [x]} (mkmap (rest xs)))))]\n    (vals (mkmap xs))))","problem":50,"user":"4f0660ee535dcb61093f6c0d"},{"code":"#(vals (reduce (fn [map x]\n                 (let [t (type x)]\n                  (conj map {t (conj (get map t []) x)})))\n               {}\n               %))","problem":50,"user":"4ee3b586535d10e5ff6f5371"},{"code":"#(vals\n  (reduce \n    (fn [state x]\n      (let [ttype (type x)\n            tlist (or (state ttype) [])\n            newlist (conj tlist x)]\n        (assoc state ttype newlist)))\n    {}\n    %))","problem":50,"user":"4f03d4dc535dcb61093f6b6e"},{"code":"(fn [coll]\n  (into #{}\n    (map #(into [] %)\n      (map (fn [some-type]\n             (filter #(= (type %) some-type) coll))\n           (into #{} (map type coll))))))\n\n;;; Longer solution:\n;#(loop [coll % type-map {}]\n;  (if (empty? coll)\n;    (into #{} (vals type-map))\n;    (let [x (first coll)]\n;      (if (type-map (type x))\n;        (recur (rest coll)\n;               (assoc type-map (type x)\n;                      (conj (type-map (type x)) x)))\n;        (recur (rest coll)\n;               (assoc type-map (type x) [x]))))))","problem":50,"user":"4e4ae5aa535dc968683fc4d2"},{"code":"#(->> (group-by class %)\n       vals\n       set)","problem":50,"user":"51852961e4b0da5a5be3babb"},{"code":"(fn [coll]\n  (map second (group-by #(class %) coll)))","problem":50,"user":"5125745ae4b05d10e3e395f9"},{"code":"(fn [coll]\n\t     (vals (reduce\n\t\t    (fn [m v]\n\t\t      (let [exist (get m (type v) :not-found)]\n\t\t\t(if (= exist :not-found)\n\t\t\t  (assoc m (type v) [v])\n\t\t\t  (assoc m (type v) (conj (get m (type v)) v))))) {} coll)))","problem":50,"user":"4ef9c8f9535dced4c769f26b"},{"problem":50,"code":"(fn splitType \n  [col]\n  (let [types []]\n  (for [t (set (into types (map #(type %) col)))]\n    (vec (filter #(instance? t %) col)))))","user":"569aca1ee4b0542e1f8d144d"},{"problem":50,"code":"(fn splitByType[s]\n  (vals (group-by type s)))","user":"577e54bbe4b0c8d87281f6e5"},{"problem":50,"code":"(fn\n  [coll]\n  (-> (group-by type coll)\n      (vals)))","user":"4fc524aae4b081705acca37e"},{"problem":50,"code":"(fn [items] (vals (group-by type items)))","user":"5b92f178e4b0c0b3ffbd4a41"},{"code":"(fn [coll]\n  (vals (group-by class coll)))","problem":50,"user":"4e42f930535dc968683fc49f"},{"code":"#( vals (group-by type %1))","problem":50,"user":"5225b16de4b0d2f5d1e2c0ed"},{"problem":50,"code":"(fn [v]\n  (->> v\n       (map #(into {} {:type (last (clojure.string/split (str (type %)) #\"\\s+\")) :value %}))\n       (group-by :type)\n       (vals)\n       (map (fn [a] (map #(:value %) a)))\n       ))","user":"60aecd73e4b00e9e6653c49a"},{"problem":50,"code":"(fn [coll]\n  (map second\n       (group-by type coll)))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":50,"code":"(fn [xs] \n  (-> \n   (group-by type xs)\n   (vals)))","user":"4eb47bb1535d7eef30807362"},{"code":"(fn s [seq] \n  (let [typ_val (map #(hash-map (class %) [%]) seq)]\n    (vals (apply merge-with concat typ_val))))","problem":50,"user":"4f62b29ce4b0defedf855fd9"},{"code":"#(map (fn [[k v]] v) (group-by type %))","problem":50,"user":"4ef41f26535dced4c769f230"},{"problem":50,"code":"(fn split-by-type [seq]\n      (vals (reduce (fn [res item]\n                          (merge-with into\n                                      res {(type item) [item]})\n                          )\n                    {}\n                    seq))\n      )","user":"5d809b4fe4b0915913b1d36c"},{"problem":50,"code":"(fn [coll]\n  (for [types (set (map type coll))]\n    (into [] (filter #(= (type %) types) coll))\n  ))","user":"53e92f82e4b036ad0777e49d"},{"code":"(fn f [xs]\n    (let [types (set (for [x xs :let [t (type x)]] t))\n          result (for [x (range (count types)) y (conj [] [])] y)\n          insert (fn [x i xs]\n                    (concat\n                        (concat (take i xs)\n                            (vector (conj (nth xs i) x))\n                        )\n                        (drop (+ i 1) xs)\n                    )\n                )\n          ]\n       (reduce \n          #(insert %2 (.indexOf (seq types) (type %2)) %) \n          result xs)\n       )\n)","problem":50,"user":"501d52a8e4b066e56b9d0b20"},{"code":"(fn my-split-by-type\r\n([v] (my-split-by-type v {}))\r\n([v a] (cond (empty? v) (set (vals a))\r\n      :default (let [x (first v) m (hash-map (type x) [x])] \r\n\t\t       (recur (rest v) (merge-with #(vec (concat %2 %1)) m a))))))","problem":50,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":50,"code":"#(->> % (group-by type) (vals))","user":"55aa7c5ce4b0988bba2ad94d"},{"problem":50,"code":"(fn split-by-type [xs]\n  (letfn [(map-marshall [xs]\n             (reduce \n               (fn [xs-map x] \n                 (if-let [m-vals (get xs-map (class x))]\n                   (assoc xs-map (class x) (conj m-vals x))\n                   (assoc xs-map (class x) (conj [] x)))) {} xs))]\n    (apply hash-set (vals (map-marshall xs)))))","user":"5553b729e4b0deb715856e05"},{"problem":50,"code":"#(vals (reduce (partial merge-with concat) (for [v %] {(type v) [v]})))","user":"53d28800e4b00fb29b22131e"},{"code":"#(map second (group-by type %))","problem":50,"user":"4e12cc9d535d04ed9115e7d2"},{"code":"(fn [s] (partition-by #(str (class %)) (sort-by #(str (class %)) s)))","problem":50,"user":"50361b6be4b0fbe0a74d26be"},{"problem":50,"code":"#(loop [sq % spt [] mp {}]\n   (if (empty? sq)\n     spt\n     (let [typ (class (first sq)) el (first sq)]\n       (if (contains? mp typ)\n         (recur (rest sq) (update-in spt [(mp typ)] (fn [x] (conj x el))) mp)\n         (recur (rest sq) (conj spt [el]) (assoc mp typ (count spt)))\n   )\n       \n  )\n )\n)","user":"5e947a69e4b0fbed045a37f8"},{"code":"(fn [coll]\n  (for [typ (distinct (map class coll))]\n    (filter #(= typ (class %)) coll)))","problem":50,"user":"4fa2fa5ee4b081705acca186"},{"code":"#(remove empty?\n (for [f [keyword? number? string? coll?]]\n  (filter f %)))","problem":50,"user":"534d5ab7e4b084c2834f4a9c"},{"problem":50,"code":"(fn [col] (->> col (group-by type) (map second)))","user":"584d8724e4b0b7285a6f4e3e"},{"problem":50,"code":"(fn [s] (vals (reduce (fn [a n] (update-in a [(type n)] #(conj (vec %) n))) {} s)))","user":"4ff8487be4b0678c553fc397"},{"problem":50,"code":"(fn ss\n  [coll]\n  (vals ((fn split\n     [coll ans]\n     (if (empty? coll)\n       ans\n       (let [head (first coll) tail (rest coll) thead (type head)]\n         (if (find ans thead)\n           (split tail (update-in ans [thead] conj head))\n           (split tail (assoc-in ans [thead] (vector head)))\n           )\n         )\n       ))\n   coll {}))\n  )","user":"5a90395ce4b05369db4d254a"},{"problem":50,"code":"(fn split-type\n   [coll]\n   (loop [[this-type & remain :as h] coll ans []]\n     (let [l (filter #(= (type this-type) (type %)) h)\n           r (filter #(not= (type this-type) (type %)) h)]\n       (if (= l h)\n         (conj ans l)\n         (recur r (conj ans l))))))","user":"5473efc3e4b0c51c1f4d7285"},{"code":"#(map second (vec (group-by class %)))","problem":50,"user":"53767991e4b06839e8705e25"},{"problem":50,"code":"#(map second (into [] (group-by type %)))","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn [s]\r\n  (letfn [\r\n\t\t(add-to-part [x parts]\r\n\t\t\t(let [x-type (type x)\r\n\t\t\t      x-part (get parts x-type [])]\r\n\t\t\t\t(assoc parts x-type (conj x-part x))))]\r\n\t\t(loop [tail s parts {}]\r\n\t\t\t(if (seq tail)\r\n\t\t\t\t(recur (rest tail) (add-to-part (first tail) parts))\r\n\t\t\t\t(vals parts)))))","problem":50,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":50,"code":"(fn\n     [x]\n     (vals (group-by class x))\n     )","user":"58a44a14e4b01a0c0b2328f2"},{"problem":50,"code":"(fn [xs]\n   (->> xs (group-by class) vals))","user":"555521a5e4b0deb715856e12"},{"problem":50,"code":"(fn [s]\n    (map #(filter (fn [item] (= (type item) %))\n                  s) (reduce #(conj %1 (type %2)) #{} s)))","user":"586b6753e4b01531a375e956"},{"problem":50,"code":"#(map (comp first next) (group-by type  %1))","user":"5433a07be4b0b6b47310fce0"},{"problem":50,"code":"(fn [lst]\n (loop [c 0 d (seq (group-by type lst)) new []]\n   (if (= c (count d)) new\n     (recur (inc c) d (concat new (rest (nth d c)) )))))","user":"558378dce4b05c286339e115"},{"problem":50,"code":"(fn split-by-type\n  [s]\n  (loop [e-map {}\n         rem-s s]\n    (if (> (count rem-s) 0)\n      (recur (assoc e-map (type (first rem-s)) (conj (or (get e-map (type (first rem-s))) []) (first rem-s)))\n             (rest rem-s))\n      (set (vals e-map)))))","user":"5ce6f93be4b0a17bb84e2b99"},{"problem":50,"code":"(fn f [coll] \n  (->> coll\n       (reduce \n         #(let [index (type %2)]\n               (assoc %1\n                index    \n                (conj (get %1 index []) %2)))\n         {})\n       vals))","user":"5493d908e4b0b312c081ff52"},{"code":"(fn type-split [x]\n  (vals (group-by class x)))","problem":50,"user":"50588af1e4b06522596eba7d"},{"code":"(fn [l] (vals (group-by type l)))","problem":50,"user":"509e62a8e4b08df8156e9e2e"},{"problem":50,"code":"(fn [coll]\n    (vals (reduce (fn [accum item]\n                    (assoc accum\n                           (type item)\n                           (conj  (get accum (type item) []) item)))\n                  \n                  {}\n                  coll))\n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":50,"code":";(fn [s] (vals (reduce #(conj %1 {(class %2) (conj (vec (get %1 (class %2))) %2)}) (hash-map) s)))\n(comp vals (partial group-by type))","user":"540e0637e4b0addc1aec6717"},{"problem":50,"code":"(fn split-by-type [v]\n  (for [[key value] (group-by class v)]\nvalue))","user":"5a42dbabe4b0447ef91cc5fc"},{"problem":50,"code":"(comp set \n      (partial filter (comp not empty?)) \n      (apply juxt (map (fn [pred] (fn [seq] (filter pred seq)))\n                 [number? keyword? string? symbol? vector?])))","user":"5310e968e4b08068f379ecdd"},{"code":"(fn [c] (map #(map first %)\n  (partition-by second\n    (sort-by second\n      (map #(list % (str (class %))) c)))))","problem":50,"user":"509160dae4b0742c82730aef"},{"problem":50,"code":"(fn sbt [s]\n  (vals (group-by type s)))","user":"5e218bb7e4b05b4b01516123"},{"code":"(fn f [c]\n  (vals (group-by type c)))","problem":50,"user":"52091d57e4b0e152394d76f0"},{"code":"(fn [x] \n    (map last (group-by class x)) \n  )","problem":50,"user":"5158bba4e4b059418b97f0ab"},{"problem":50,"code":"(fn [s] (into #{} (vals (group-by class s))))","user":"54125eeee4b01498b1a719d3"},{"code":"(fn [c]\n  (for [t (set (map type c))]\n    (filter #(= t (type %)) c)))","problem":50,"user":"4fe8e719e4b0547ebccb2430"},{"code":"(fn [values]\n  (vals\n  (reduce \n    (fn [r v] \n     (let [t (type v)] (assoc r t (conj (get r t []) v))))\n  {} values)))","problem":50,"user":"4e513ecf535dc968683fc4f6"},{"problem":50,"code":"(fn splType [xs]\n    (if (not (empty? xs))\n      (let [typex (type (first xs))]\n        (cons\n          (filter (fn [x] (= typex (type x))) xs)\n          (splType (filter (fn [x] (not= typex (type x))) xs))))))","user":"585e7c60e4b0f14aab7c87b3"},{"code":"#((comp vals (partial group-by class)) %)","problem":50,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":50,"code":"(fn [seq]\n   (map last (group-by class seq)))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":50,"code":"(fn [v]\n  (vals (group-by type v)))","user":"5592ba8be4b0c79f6e1db931"},{"code":"(fn [xs] (map #(mapcat identity %) (partition-by (fn [a] (class (first a))) (sort-by (fn [a] (str (class (first a)))) (partition-by class xs)))))","problem":50,"user":"4f4e91a9e4b03ad3f0c10cca"},{"problem":50,"code":"(fn foo [coll]\n  (map second\n    (reduce\n      (fn [acc n]\n        (let [t (type n)]\n          (assoc acc t (conj (get acc t []) n)))) {} coll)))","user":"56a51f26e4b0542e1f8d14e0"},{"problem":50,"code":"(fn [coll]\n    (let [types (reduce #(conj %1 (class %2)) #{} coll)]\n        (map #(reduce \n                (fn [acc item]\n                    (println %)\n                    (println item)\n                    (println acc)\n                    (if (= % (class item)) (conj acc item) acc)) \n                    (vec []) coll) types)))","user":"5a64dcabe4b0512ff01cd9a9"},{"code":"(fn [xs]\n  (let [types (distinct (map type xs))]\n    (map\n      (fn [typ] (filter #(= typ (type %)) xs))\n      types)))","problem":50,"user":"4f90e238e4b0dcca54ed6c94"},{"problem":50,"code":"(fn [xs]\n  (vals (reduce (fn [res c] (assoc res (type c) (conj (get res (type c) []) c))) {} xs)))","user":"5947c6a6e4b07ddc2dafada7"},{"problem":50,"code":"(fn split-by-type [lst]\n    (vals (reduce #(assoc % (type %2) (conj (get % (type %2) []) %2)) {} lst)))","user":"546c1f73e4b00cfc9eacc175"},{"code":"(fn split-type\n  [l]\n  (if (not(empty? l))\n    (let [tlist (for [x l  :when (= (type (first l)) (type x))] x)\n          rlist (remove #(= (type (first l)) (type %1)) l)]\n    (cons  tlist (split-type rlist)))))","problem":50,"user":"5245d29ae4b09dbe66b56174"},{"problem":50,"code":"(fn [s] \n  (vals (group-by type s))\n  )","user":"5cfd5a93e4b0cc9c91588168"},{"problem":50,"code":"(fn splittt [sequ]\n  (let [reducer (fn [out elm]\n                  (let [curr_type (str (type elm))\n                        lst (out curr_type)]\n                    (if (nil? lst) \n                      (assoc out curr_type (cons elm '()))\n                      (assoc out curr_type (cons elm lst)))))]\n    (map reverse (vals (reduce reducer {} sequ)))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"code":"(fn [coll] (let [types (set (map #(type %) coll))\n                 o [] ]\n               (map (fn [t] (filter #(= t (type %)) coll)) types) \n            )\n)","problem":50,"user":"4ec17677535dfed6da9c6dad"},{"code":"(fn [seqn]\n  (let [grouped (group-by type seqn)]\n    (set (vals grouped))))","problem":50,"user":"53889587e4b0640c7a9a589e"},{"problem":50,"code":"(fn split-by-type [coll] (vals (group-by class coll)))","user":"52b9e920e4b07a9af57922c9"},{"code":"(fn [coll]\n  (let [types (set (map type coll))]\n    (for [i types]\n      (filterv #(= (type %) i) coll))))","problem":50,"user":"50e3cf55e4b01912b3285c45"},{"problem":50,"code":"(fn [x]\n  (map (fn [c]\n         (filter (fn [z] (= (class z) c)) x))\n         (into #{} (map class x))))","user":"5b15ab32e4b0cc2b61a3be72"},{"code":"(fn [vector]\n   (let [ints []\n         strs []\n         symbs []]\n     (filter #(not (empty? %)) (list (vec (filter number? vector))\n                                     (vec (filter string? vector))\n                                     (vec (filter keyword? vector))\n                                     (vec (filter vector? vector))))))","problem":50,"user":"5154fa3fe4b0179c5115f4e6"},{"problem":50,"code":"(fn split-by-type [coll]\n  (set (vals (group-by type coll))))","user":"557e56aae4b05c286339e0d5"},{"problem":50,"code":"(fn [coll]\n  (let [nums (reduce #(if (= (type %2) (type 1)) (conj %1 %2) %1)\n                     [] coll)\n        strings (reduce #(if (= (type %2) (type \"\")) (conj %1 %2) %1)\n                     [] coll)\n        vecs (reduce #(if (= (type %2) (type [])) (conj %1 %2) %1)\n                     [] coll)\n\t\tkwds (reduce #(if (= (type %2) (type :foo)) (conj %1 %2) %1)\n                     [] coll)\n        ]\n    (reduce #(if (= %2 []) %1 (conj %1 %2)) () [nums strings vecs kwds])))","user":"5fea32f3e4b05ac5b16ea1aa"},{"problem":50,"code":"#(vals (reduce (fn [acc, el] (assoc acc (type el) (vec (conj (acc (type el)) el)))) {} %))","user":"564faadce4b0284900eef6b2"},{"code":"(fn [seq] \n  (loop [res {} s seq]\n    (if (empty? s)\n      (set (vals res))\n      (recur \n         (let [\n            hd (first s)\n            k (str (type hd))   \n            vc (conj (get res k []) hd)\n          ]\n           (assoc res k vc )\n         )      \n         (rest s)\n       )\n    )\n  )\n)","problem":50,"user":"533ea7e8e4b085b17e897d94"},{"code":"(fn [ls]\n  (vals (group-by type ls)))","problem":50,"user":"51df825de4b01188f062752b"},{"code":"(fn [s]\n    (vals (group-by type s)))","problem":50,"user":"4daea889edd6309eace4d15b"},{"problem":50,"code":"(fn [x] (partition-by #(type %) (sort-by #(str (type %)) x)))","user":"560d2b53e4b05f002753df37"},{"code":";; it would be simpler to return a map of seqs\n(fn [x] (map (comp vec reverse) (vals (reduce #(update-in %1 [(type %2)] conj %2) {} x))))","problem":50,"user":"4fb4b798e4b081705acca2af"},{"problem":50,"code":"(fn split-by-type [l]\n  (set (vals (group-by type l))))","user":"5018878ce4b029375d2a5056"},{"problem":50,"code":"(fn classify [items] (vals (group-by #(.getClass %) items)))","user":"5711b532e4b09c608db70449"},{"code":"(fn split [n]\n  (set (vals (loop [items n tmpmap {}]\n               (if (seq items)\n                 (recur (rest items)\n                        (merge-with concat\n                                    tmpmap\n                                    {(type (first items)) [(first items)]}))\n                 tmpmap)))))","problem":50,"user":"4f0d093b535d0136e6c22313"},{"problem":50,"code":"(fn split-type [coll]\n  (map second (group-by type coll)))","user":"5cfabf53e4b0cc9c91588148"},{"problem":50,"code":"(fn [c] (vals (group-by class c)))","user":"54ca130ce4b057c6fda3a250"},{"problem":50,"code":"(fn gp [coll]\n  (vals (group-by type coll)))","user":"5a426a3fe4b0447ef91cc5f2"},{"problem":50,"code":";(fn [coll] (partition-by type (sort-by #(str (type %)) coll)))\n#(vals (group-by type %))","user":"54ce541de4b057c6fda3a2ac"},{"problem":50,"code":"(fn [coll]\n\t(loop [typed #{} coll coll]\n      (if (empty? coll)\n        typed\n        (let [elem (first coll) tp (type elem)]\n        \t(recur (into typed [(filter #(= tp (type %)) coll)]) (filter #(not (= tp (type %))) coll))\n        )\n        \n        )\n    )  \n)","user":"5de6484ce4b0986d99407f66"},{"problem":50,"code":"(fn [coll] (let [cn (atom []) ck (atom []) cs (atom []) cc (atom [])]\n  (doseq [v coll]\n    (cond\n     (keyword? v) (swap! ck conj v)\n     (string? v) (swap! cs conj v)\n     (number? v) (swap! cn conj v)\n     (coll? v) (swap! cc conj v)\n   ))\n   (filter #(not (empty? %)) [@cn @ck @cs @cc])\n))","user":"55adf4d7e4b03311e7b732af"},{"problem":50,"code":"(fn [coll]\n  (for [[k v]\n        (reduce (fn [hmap item]\n                  (let [type-seq (get hmap (type item))]\n                    (if (nil? type-seq)\n                      (assoc hmap (type item) [item])\n                      (assoc hmap (type item) (conj type-seq item)))))\n                {}\n                coll)]\n    v))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":50,"code":"(fn by_type[col](->> col\n                     (group-by type)\n                     vals))","user":"60c9a411e4b0e0fa5f1b4307"},{"problem":50,"code":"(fn q50 [col]\n  (vals (group-by #(type %) col)))","user":"54f5aa4ce4b0f2f3c5226e94"},{"code":"(fn f [l]\n  (letfn\n    [(wop [i bound result]\n          (if (< i bound)\n            (let\n              [current (nth l i)\n               holder-for-current (get result (type current))]\n              (if (nil? holder-for-current)\n                (wop (+ i 1) bound (assoc result (type current) [current]))\n                (wop (+ i 1) bound (assoc result (type current) (conj holder-for-current current)))))\n            result))]\n    (vals (wop 0 (count l) {}))))","problem":50,"user":"52d7b0ade4b09f7907dd137c"},{"problem":50,"code":"(fn st [l]\n  (vals (group-by type l)))","user":"56069006e4b08b23635d3174"},{"problem":50,"code":"(fn [v] (set (vals (group-by type v))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [s]\n  (filter\n    (complement empty?)\n    (map\n      (fn [f] (filter f s))\n      [string? vector? integer? keyword?])))","problem":50,"user":"4fa3f91fe4b081705acca196"},{"problem":50,"code":"#(vals (group-by type %) )","user":"5edc16e1e4b0c7845d86b0f1"},{"problem":50,"code":"(fn [mixed]\n  (let [types (set (map type mixed))\n        typePredicates (map (fn [uniqueType] (fn [x] (= uniqueType (type x)))) types)\n        ]\n    (set (map #(filter % mixed) typePredicates))))","user":"586bc870e4b01531a375e964"},{"code":"; group-by is the key\n#(->> (reduce (fn [res new] (merge res {(type new) (concat (res (type new)) [new])})) {} %) vals set)","problem":50,"user":"50de11b2e4b061dbdced7217"},{"problem":50,"code":"(fn [data]\n  (partition-by type (sort-by #(str (type %1)) data)))","user":"5640eb50e4b08d4f616f5eec"},{"problem":50,"code":"(fn [vect1]\n  (loop [vect vect1 ans {}]\n    (if (empty? vect)\n      (vals ans)\n      (if (contains? ans (type (first vect)))\n        (recur (rest vect) (assoc ans (type (first vect)) (conj (get ans (type (first vect))) (first vect))))\n        (recur (rest vect) (assoc ans (type (first vect)) (vector (first vect))))))))","user":"59369515e4b02506e01a297e"},{"code":"(fn [l] \n  (map reverse (vals \n\t\t(reduce \n\t\t\t#(update-in %1 [(type %2)] (fn [a] (cons %2 a)))\n\t\t\t{} l))))","problem":50,"user":"4fc0853ae4b081705acca327"},{"code":"(fn sort-by-type [col]\n  (let [insert (fn [col k v]\n  (if (nil? (col k))\n    (assoc col k [v])\n    (assoc col k (conj (col k) v))))]\n  (loop [todo col\n         ret {}]\n    (if (empty? todo)\n      (vals ret)\n      (recur (rest todo) (insert ret (class (first todo)) (first todo)))))))","problem":50,"user":"4f08a8a2535dcb61093f6c3d"},{"problem":50,"code":"(fn split-by-type\n  [myseq]\n  (vals (reduce\n          (fn [result x] result\n            (let [x-type (type x)\n                  x-type-vec (get result x-type [])]\n              (assoc result x-type (conj x-type-vec x)))\n            ) {} myseq)))","user":"5e495e3fe4b043cd24807a4f"},{"code":"(fn [c]\n  (into #{} (vals  (group-by type c)))\n  )","problem":50,"user":"4ec4d723535dcc7ae8597d65"},{"problem":50,"code":"(fn [l] \n  (letfn [(srt [m v] \n            (let [t (type v)] \n               (if-let [tl (get m t)]\n                  (assoc m t (conj tl v))\n                  (assoc m t [v]))))]\n     (vals (reduce srt {} l))))","user":"51b0e7b3e4b0c53cf2e68a6e"},{"problem":50,"code":"#( ->> %1\n   (group-by type) ; make a map where the keys is the type and the vals all the lems of that type\n   (vals))         ; discard the keys and keep the values","user":"563772a9e4b0bfe05bf117d7"},{"code":"(fn [l]\n  (vals (group-by class l)))","problem":50,"user":"4f7e29dde4b06e829148e1ca"},{"problem":50,"code":"(fn sol [xs] (vals (group-by #(type %) xs)))","user":"54857657e4b0e286459a11ac"},{"problem":50,"code":"(fn [lst]\n  (filter first \n          (list (apply vector (filter string? lst)) \n                (apply vector (filter keyword? lst)) \n                (apply vector (filter vector? lst)) \n                (apply vector (filter number? lst)))))","user":"5642b939e4b08d4f616f5f1b"},{"code":"(fn [s] \n  (vals (group-by type s)))","problem":50,"user":"52199105e4b0c4ef0be82ff9"},{"code":"(fn group-by-typ [x]\n  \"4clojure.com/problem/50\"\n  (map second (seq (group-by type x))))","problem":50,"user":"4db58ccb535d87e67b28fe10"},{"problem":50,"code":"(fn [xs]\n  (vals (reduce (fn [acc x]\n            (let [t (type x)]\n              (if (contains? acc t)\n                (assoc acc t (conj (get acc t) x))\n                (assoc acc t [x])))) \n          {}\n          xs)))","user":"56483562e4b0284900eef629"},{"problem":50,"code":"(fn [x]\n   (remove empty?\n     [(filter number? x)\n      (filter string? x)\n      (filter vector? x)\n      (filter keyword? x)]))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn [coll]\n  (loop [coll coll result {}] \n    (if (seq coll)\n      (let [xtype (type (first coll))]\n        (recur (rest coll) \n          (assoc result xtype (conj (if (result xtype)\n                                        (result xtype)\n                                        []) (first coll)))))\n      (vals result))))","problem":50,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":50,"code":"#(let [groups (group-by first (map vector (map type %) %))\n       grp-keys (keys groups)]\n   (for [key grp-keys]\n     (map second (groups key))))","user":"568e1871e4b0dcc4269f40cc"},{"problem":50,"code":"(fn test [types seq]\n        (if (nil? types)\n          (test (distinct (map type seq)) seq)\n          (if (not (empty? types))\n            (concat (conj [] (filter #(= (first types) (type %)) seq))\n                    (test (rest types) seq))))) nil","user":"5508102ee4b021ccfedb96b0"},{"code":"#(vals (group-by type %))\n\n;#(vals\n;  ((fn typify [inlist]\n;    (if (empty? inlist)\n;      {}\n;      (let [value (first inlist) endmap (typify (rest inlist))]\n;        (merge endmap\n;          (if (contains? endmap (type value))\n;            {(type value) (into [] (concat [value] (get endmap (type value))))}\n;            {(type value) [value]})))))\n;%1))","problem":50,"user":"4fc50bcbe4b081705acca375"},{"code":"(fn partion-by-type [coll]\n  (loop [[x & xs] coll, acc {}]\n    (if (nil? x)\n      (-> acc vals set)\n      (recur xs \n        (conj acc [(class x) \n                   (conj (get acc (class x) []) x)])))))","problem":50,"user":"4e25176e535d04ed9115e829"},{"code":"(fn foo [s]\n  (let [updater (fn [m item]\n                  (update-in m\n                             [(type item)]\n                             (fn [old_map new_item] (conj old_map new_item))\n                             item))\n        x (reduce updater {} s)]\n    (map (comp rseq vec #(% 1)) x)))","problem":50,"user":"506755b3e4b03d366d7cb2bc"},{"code":"(fn[s](\n  partition-by type (\n    sort-by  (\n      comp #(.toString %1) type) \n      s\n    )\n  )\n)","problem":50,"user":"4e6df3c9535d5021c1a895fa"},{"problem":50,"code":"(fn [coll] (map last (group-by type coll)))","user":"5446ebc2e4b032a45b8693b8"},{"problem":50,"code":"(fn [x]\n  (vals (reduce (partial merge-with concat) (map #(hash-map (type %) (vector %)) x))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":50,"code":"(fn \n  [col]\n  (let [the-map (reduce #(assoc %1 (type %2) (conj (get-in %1 [(type %2)] []) %2)) {} col)]\n    (set (vals the-map))))","user":"5a58d8a0e4b05d388ecb6c8a"},{"code":"(fn [seq]\n  (let [grouped (group-by (comp str type) seq)\n\t\tallkeys (apply vector (keys grouped))]\n\t(set (map #( get grouped %) allkeys))))","problem":50,"user":"504eff22e4b0e7ad84dbc4a9"},{"code":"(fn [in]\n  (vals (group-by type in)))","problem":50,"user":"4faec810e4b081705acca24e"},{"code":"#(for [x %] (for [y % :when (= (type x) (type y))] y))","problem":50,"user":"4db858d1535d1e037afb218c"},{"problem":50,"code":"(fn [xs]\n  (let [types\n          (set (map class xs))    \n        filter-by-type\n          (fn [xs xtype] (filter #(= (class %) xtype ) xs))]\n  (->\n    types\n    ((partial map (partial filter-by-type xs)))\n    set))\n)","user":"596e2a70e4b069c0a1a19861"},{"code":"(fn [coll]\n  (loop [imap {}, coll coll]\n    (if (empty? coll) \n      (for [ [x y] imap ] y)\n      (let [fir (first coll)]\n        (if (contains? imap (type fir) )\n          (recur (assoc imap (type fir) (conj (imap (type fir)) fir )) (rest coll))\n          (recur (assoc imap (type fir) [fir]) (rest coll)))))))","problem":50,"user":"5224a46ce4b01819a2de42e5"},{"code":"(fn [seq]\n    (vals (loop [s seq col {}]\n            (if (empty? s)\n              col\n              (let [f (first s)\n                    _t (type f)]\n                (recur (rest s)\n                       (assoc col _t (conj (vec (get col _t)) f))))))))","problem":50,"user":"4e48b61d535dc968683fc4be"},{"code":"(fn [s]\n  (vals (reduce\n          #(let [k (type %2)]\n             (assoc % k (conj (% k []) %2)))\n          {}\n          s)))","problem":50,"user":"51057b2be4b06d28cacc92e8"},{"code":"(fn [c]\n  (->> c\n       (reduce (fn [r e]\n                 (update-in r [(type e)] conj e))\n               {})\n       vals\n       (map reverse)\n       set))","problem":50,"user":"5392b849e4b0b51d73faaeb1"},{"problem":50,"code":"(fn split-by-type [v]\n  (vals (group-by type v)))","user":"5f0cb4f3e4b0f30dddfb5d4e"},{"problem":50,"code":"#(map second(group-by type %))","user":"5a6dbaf5e4b0512ff01cda63"},{"problem":50,"code":"(fn [coll]\n  (vals\n   (reduce\n   \t(fn [res v]\n      (let [key (type v)\n            curr-v (get res key)\n            ]\t\n        (if curr-v (assoc res key (conj curr-v v))\n          (assoc res key [v]))\n        )\n      ) {} coll)))","user":"57ca95f2e4b05aa3c4741d3b"},{"problem":50,"code":"(fn [coll]\n  (set (vals (group-by #(type %) coll))))","user":"562268dce4b03f08ee9a9224"},{"problem":50,"code":"(fn func\n    [ar]\n    (loop [ans {}\n           xs ar]\n      (if (empty? xs)\n        (vals ans)\n        (let [x (first xs)\n              t (type x)\n              items (or (ans t) [])]\n          (recur (assoc ans t (conj items x)) (rest xs)))\n        )\n      ))","user":"5b8db323e4b0c0b3ffbd49da"},{"problem":50,"code":"(fn [coll] (partition-by type  (sort-by #(str (type %1)) coll)))","user":"5b8aa478e4b0c0b3ffbd49b2"},{"code":"(fn [x]\n  (vals \n   (reduce \n    (fn [acc, x] (assoc \n                acc \n                (type x) \n                (cond \n                  (nil? (acc (type x)) ) (list x)\n                  :else (concat (acc (type x)) (list x))\n                 )\n                )\n    )\n                \n    {} \n    x)\n  )\n)","problem":50,"user":"4fb03cf4e4b081705acca262"},{"code":"(fn [coll]\r\n  (letfn [(collect-by-type [c]\r\n            (let [t (type c)]\r\n              (reduce #(if (= (type %2) t)\r\n                           (conj %1 %2) %1) [] coll)))]\r\n    (set (map collect-by-type coll))))","problem":50,"user":"4fb37882e4b081705acca2a0"},{"problem":50,"code":"(fn [a] (vals (group-by type a)))","user":"5e31a4b0e4b05b4b0151622b"},{"code":"(fn [col]\n  (vals (group-by type col)))","problem":50,"user":"4ef4acf8535dced4c769f23c"},{"code":"(fn split-by-type [seq]\n  (vals (group-by type seq)))","problem":50,"user":"4f29afc7e4b0d6649770a02e"},{"code":"#(vals\n  (apply merge-with concat\n    (for [e %] {(type e) (list e)})\n  )\n)","problem":50,"user":"4ea57300535d7eef308072d5"},{"problem":50,"code":"(fn split-by-type [sequ] (vals(reduce \n                                  (fn [xs x] \n                                    (if (contains? xs (type x)) \n                                      (into xs {(type x) (conj (get xs (type x)) x)}) \n                                      (into xs {(type x) [x]})))\n                                  {} sequ)))","user":"5df0c6ffe4b093ff717275c2"},{"code":"(fn [ls] (partition-by type (sort-by #(str (type %)) ls)))","problem":50,"user":"4ecc147b535d23f0362276f7"},{"problem":50,"code":"(fn solve [x]\n  (map second (seq (group-by (fn [y] (type y)) x)))\n)","user":"56f258d3e4b04a395b9a04a1"},{"problem":50,"code":"(fn  [coll] (map #(into [] (apply concat (rest %) )  )  (group-by type coll)))","user":"56a6051fe4b0542e1f8d14e5"},{"code":"(fn [xs] \r\n  (vals\r\n    (reduce \r\n      (fn [grouped x]\r\n        (update-in grouped [(type x)]\r\n                   (fn [v] (if v (conj v x) [x]))))\r\n    {}  xs)))","problem":50,"user":"4e513758535dc968683fc4f3"},{"problem":50,"code":"(fn \n  [coll]\n  (map second (into [] (group-by class coll))))","user":"548db64ce4b0e286459a121c"},{"problem":50,"code":"(fn [xs] \n  (vals (group-by type xs)))","user":"55da1ebce4b0e31453f64ad2"},{"code":"(fn [coll]\n  (\n   vals (group-by type coll)\n   ))","problem":50,"user":"51da7e49e4b02ceefd947768"},{"problem":50,"code":"(fn split-by-type\n  [xs]\n  (if\n    (empty? xs)\n    '()\n    (cons\n     (filter \n      (fn [x]\n        (= \n         (type (first xs))\n         (type x)))\n      xs)\n     (split-by-type \n      (filter \n       (fn [x]\n         (not=\n          (type (first xs))\n          (type x)))\n       xs)))))","user":"55a3ca84e4b0acc240e3153c"},{"problem":50,"code":"(fn split-by-class [s] (partition-by class (sort-by #(-> % class str) s)))","user":"5654e024e4b0f9d632dd848d"},{"problem":50,"code":"(fn sbt\n  ([x y]\n   (let [fx (first x)\n         rx (rest x)\n         tx (type fx)]\n     (cond (empty? x) (seq (vals y))\n               (contains? y (type fx)) (recur rx (assoc y tx (conj (get y tx) fx)))\n               :else (recur rx (assoc y tx (conj [] fx))))))\n  ([x]\n   (sbt x {})))","user":"58a3ba31e4b02bd94d917eff"},{"problem":50,"code":"(fn [objs] (-> (group-by type objs) vals))","user":"56391b7ce4b0bfe05bf117ef"},{"code":"#_fixme_eager!\n#(vals (group-by type %))","problem":50,"user":"50c75d38e4b00bb60fe0c532"},{"code":"(fn split-by-type [coll] (vals (group-by #(type %1) coll)))","problem":50,"user":"52319066e4b0e2e8de81d1e9"},{"code":"#(set\n  (vals\n    (reduce\n      (fn [col x]\n        (if (contains? col (type x))\n          (assoc col (type x) \n            (conj (get col (type x)) x))\n          (assoc col (type x) (vector x))))\n      {}\n      %)))","problem":50,"user":"517cc671e4b0bbbf1f12af0a"},{"problem":50,"code":"(fn st [init-s]\n  (loop [s init-s\n         r []]\n    (if (empty? s)\n      r\n      (recur (filter #(not (= (type %) (type (first s)))) s) (conj r (filter #(= (type %) (type (first s))) s))))))","user":"57addbcce4b0b8559636fca3"},{"problem":50,"code":"(partial (fn thefunc [output theset] \n             \n             (if (empty? theset)\n               (map #(val %) output)\n               (let [t (type (first theset) )\n                     v (first theset) ]\n                 (thefunc \n                  (merge-with #(conj %1 (last %2)) output {t [v]})\n                  (rest theset) ) ) ) ) {} )","user":"54178782e4b01498b1a71a0c"},{"problem":50,"code":"#(set (map vec (partition-by (comp str type) (vec (sort-by (comp str type) %)))))","user":"5ea444b7e4b00a66d4a951a0"},{"code":"(fn [s] (map \r\n              (fn [t] \r\n                   (filter #(= t (type %)) s)) \r\n                 (distinct (map type s))))","problem":50,"user":"4e6a11ee535d8ccf87e9fe9f"},{"code":"#(reduce (fn [set item]\n             (let [v (some (fn [it] (if (= (-> it first type) (type item)) it)) set)]\n               (if (nil? v)\n                 (conj set (vector item))\n                 (conj (disj set v) (concat v (vector item))))))\n           #{}\n           %)","problem":50,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":50,"code":"(fn [coll]\n  (set (vals \n    (group-by class coll))))","user":"5675cdf1e4b05957ce8c614d"},{"problem":50,"code":"; #(for [[k v] (group-by class %)] v)\n#(vals (group-by class %))","user":"59e5b6a1e4b08badc2a0c55b"},{"problem":50,"code":"(fn [c]\n    (vals\n     (reduce\n      (fn [a e]\n        (let [[k v] e\n              av (get a k [])\n              nav (conj av v)]\n          (assoc a k nav)))\n      {}\n      (map (fn [e] [(class e) e]) c))))","user":"55773cbae4b05c286339e07f"},{"code":"(fn [coll]\n  (vals (group-by #(type %) coll)))","problem":50,"user":"4e1b8106535d04ed9115e801"},{"code":"(fn [coll]\n  (set (map #(last %) (group-by type coll))))","problem":50,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":50,"code":"(fn [sq]\n  (vals (reduce #(merge-with concat \n                             % {(type %2) [%2]})\n                {}\n                sq)))","user":"4f041de1535dcb61093f6ba5"},{"code":"(fn[coll] \n  (vals \n   (reduce \n    #(let[cls (class %2)] (assoc %1 cls (conj (get %1 cls []) %2))) \n    {} \n    coll)\n   )\n  )","problem":50,"user":"52e68e61e4b09f7907dd1479"},{"code":"(fn st[arr]\n(vals\n(reduce (fn splittype[acc, i] \n  (conj acc \n    {(type i) (conj (into [] (acc (type i))) i)})) \n{} arr)))","problem":50,"user":"4f8b05d2e4b02e764a0a5176"},{"problem":50,"code":"(fn type-split\n  [coll]\n  (set (map val ((fn inner\n                   [[f & r :as col] sets]\n                   (if (= f nil) \n                     sets\n                     (if (= nil (get sets (type f)))\n                       (recur r (assoc sets (type f) [f]))\n                       (recur r (assoc sets (type f) (conj (get sets (type f)) f )))\n                       ))\n                   ) coll {}))))","user":"5c75a30ee4b0fca0c16227df"},{"code":"(fn\n  [coll]\n  (map second (reduce (fn [m v] (update-in m [(class v)] #(conj (or % []) v)))\n                      {}\n                      coll)))","problem":50,"user":"52dfc89be4b09f7907dd1405"},{"code":"(fn [s]\n  (vals\n    (reduce\n      #(let [t (type %2)\n        val (get %1 t)]\n        (assoc %1 t \n          (if (= val nil) [%2] (conj val %2))))\n      {}\n      s)))","problem":50,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [xs]\r\n  (vals\r\n    (reduce\r\n      (fn [a n] (let [k (type n) v (get a k [])] (assoc a k (conj v n))))\r\n       (hash-map)\r\n       xs)))","problem":50,"user":"4dd52e29535dae65d5c462e5"},{"code":"(fn split-type[lst]\n  (map second (group-by class lst)))","problem":50,"user":"4ddc620d535d02782fcbea06"},{"problem":50,"code":"(fn [n] (partition-by #(str (type %)) (sort-by #(str (type %)) n)))","user":"54edcf96e4b024c67c0cf866"},{"problem":50,"code":"(fn [col] (loop [res {} c col]\n             (let [item (first c)\n                   ex-type-col (res (type item))\n                   type-col (if (vector? ex-type-col) ex-type-col [])\n                   new-type-col (conj type-col item)]\n               (if (seq c)\n                 (do\n                   (println \"iteration!\")\n                   (recur (assoc res (type item) new-type-col) (rest c)))\n                 (vals res)))))","user":"56fa3f7ae4b07572ad1a88bf"},{"code":"(fn [v] \n  (vals (group-by #(type %) v))\n)","problem":50,"user":"4fcad14ce4b0ee37620e1856"},{"problem":50,"code":"(fn [l]\n  (vals\n   (reduce\n    (fn [a b]\n      (assoc a (type b) (conj (get a (type b) []) b))\n      )\n    {}\n    l)))","user":"55e87696e4b0121d4835fd93"},{"problem":50,"code":"(fn group-type [coll]\n  (vals (group-by class coll)))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":50,"code":"(fn mac [m] \n  (map val (group-by type m))\n)","user":"5bc2df19e4b07a9b28b10038"},{"code":"(comp \n  (partial partition-by class) \n  (partial sort-by (comp str class)))","problem":50,"user":"4e5914e0535d8a8b8723a29b"},{"code":"#(vals (reduce (fn [m [t x]] (assoc m t (conj (or (m t) []) x))) {} (map (fn [x] [(type x) x]) %)))","problem":50,"user":"4e39d763535deb9a81d77f46"},{"problem":50,"code":"(fn [coll]\n (vals (group-by class coll)))","user":"546c4c5fe4b00cfc9eacc178"},{"problem":50,"code":"(fn separa [v] (filter seq? (apply concat (reduce #(conj %1 {(keyword (str (type %2))) (concat ((keyword (str (type %2))) %1) [%2])}) {} v))))","user":"55ac16a0e4b03311e7b73291"},{"problem":50,"code":"(fn [a-seq]\n  (vals (group-by #(type %) a-seq)))","user":"56cb4d06e4b0ea9b8538f72e"},{"code":"(fn [coll]\r\n  (loop [res '() coll coll]\r\n    (if (nil? coll)\r\n      res\r\n      (let [f (first coll)\r\n            r (next coll)\r\n            t (type f)]\r\n        (recur (conj res (cons f (filter #(= t (type %)) r)))\r\n               (seq (filter #(not= t (type %)) r)))))))","problem":50,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":50,"code":"(fn [c] (vals (reduce #(let [t (type %2) xs (get %1 t []) ] (assoc %1 t (conj xs %2 ))) {} c)))","user":"5d0cf1c8e4b0cc9c91588246"},{"code":"(fn [xs]\n  (vals (group-by type xs)))","problem":50,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn [c] (set (map second (vec (group-by #(class %) c)))))","problem":50,"user":"4fb1325de4b081705acca276"},{"code":"(fn [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4eb51942535d7eef30807365"},{"code":"(fn [x]\n  (->> (map #(do {(class %) [%]}) x)\n       (apply merge-with concat)\n       (map val)\n  ))","problem":50,"user":"4e50e2a0535dc968683fc4ef"},{"problem":50,"code":"(fn group-by-type [input]\n  (vals (group-by type input)))","user":"5b6002c2e4b0c6492753e6fb"},{"problem":50,"code":"(fn [xs] (->> xs (group-by type) vals))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":50,"code":"(fn [v] (loop [in v out #{}]\n         (if (empty? in)\n           out\n           (recur\n            (filter #(not= (type (first in)) (type %1)) in)\n            (conj out (filter #(= (type (first in)) (type %1)) in))))))","user":"5596af34e4b04c1e5c31d758"},{"code":"(fn [xs]\n  (set (vals (group-by type xs))))","problem":50,"user":"4f29651ce4b0d6649770a028"},{"code":"(fn [coll] \n  (map \n   (fn [c] (map second c)) \n   (partition-by first \n                 (sort #(compare (first %1) (first %2))\n                  (map #(vec [(str (type %)) %]) coll)))))","problem":50,"user":"5231d8fae4b0e2e8de81d1fb"},{"problem":50,"code":"(fn [args]\n  (->> args (group-by type)\n       (vals)))","user":"5ebb4751e4b00a66d4a95262"},{"code":"#(for [x %]\n   (filter (fn [y] (= (type y) (type x))) %))","problem":50,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn [coll]\n  (vals (reduce (fn [acc val]\n                    (let [val-type (type val)]\n                      (if (contains? acc val-type)\n                        (update-in acc [val-type] #(conj % val))\n                        (assoc acc val-type [val])))) {} coll)))","problem":50,"user":"520fff3ce4b080a8d9b9d633"},{"problem":50,"code":"(fn [coll]\n  (letfn [(insert [subseqs elem]\n            (let [elem-type (type elem)\n                  elems (get subseqs elem-type [])]\n              (assoc subseqs elem-type (conj elems elem))))]\n    (vals (reduce insert {} coll))))","user":"505345d9e4b0517ede0d0a06"},{"code":"(fn [col]\n  (partition-by type (sort-by #(str (type %)) col)))","problem":50,"user":"51891c96e4b04c2714a2670e"},{"problem":50,"code":"(fn [coll] (partition-by type (sort-by (comp #(.toString %) type) coll)))","user":"558aabbfe4b0277789237621"},{"problem":50,"code":"(fn [s]\n    (vals\n     (reduce (fn [prev e]\n               ;; Note: 4clojure.com doesn't have 'update'\n               (assoc prev (type e)\n                      (conj (get prev (type e) []) e)))\n             nil s)))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":50,"code":"#(vals (reduce (fn [res v] (assoc \n                       res \n                       (type v) \n                       (conj (into [] (res (type v))) v)))\n         {}\n         %))","user":"58c2df0ae4b021aa9917ed17"},{"problem":50,"code":"(fn [coll]\n  (map last (group-by type coll)))","user":"5cdda90ce4b05ee0cb311766"},{"problem":50,"code":"(fn [coll]\n   (let [types (distinct (map type coll))]\n     (for [t types]\n       (filter #(= (type %) t) coll))))","user":"59b554cee4b05c620303ca0f"},{"code":"#(map fnext (group-by type %))","problem":50,"user":"4e6a48d5535d8ccf87e9febd"},{"problem":50,"code":"(fn [coll] (map (comp #(map second %) second) (group-by first (map (juxt type identity) coll))))","user":"58acca5ee4b0005cfeb1a753"},{"problem":50,"code":"(fn group-by-type\n  [s]\n  (->> s\n       (group-by type)\n       (map val)\n       (into #{})))","user":"54764a8fe4b0c51c1f4d72a3"},{"code":"(fn [s]\r\n  (vals (reduce  \r\n          #(merge-with concat %1 {(type %2) [%2]})  \r\n         {} s)))","problem":50,"user":"4deff9f9535d08e6dec9fe15"},{"problem":50,"code":"(fn [coll]\n  (let [add-to-result (fn [r i]\n                        (update-in r [(type i)] #(conj (or % []) i)))]\n    (vals (reduce add-to-result {} coll))))","user":"518279abe4b0353c468deb65"},{"problem":50,"code":"(fn[collection] (vals (group-by class collection)))","user":"54f296efe4b024c67c0cf8c8"},{"code":";(comp vals (partial group-by type))\n#(->> %\n  (group-by type)\n  (vals))","problem":50,"user":"4f9acea6e4b0dcca54ed6d10"},{"code":"#(partition-by type (sort-by type (fn [x y] (< (count (str x)) (count (str y)))) %))\n;#(vals (group-by type %))","problem":50,"user":"533b9cace4b0e30313ee6cd1"},{"code":"(fn [s]\n  (vals (group-by class s)))","problem":50,"user":"4e50c894535dc968683fc4ee"},{"problem":50,"code":"#(for [[_ v] (group-by class %)] v)","user":"57c7a8b5e4b05aa3c4741d09"},{"code":"(fn [s] (set (vals (group-by type s))))","problem":50,"user":"4f1d1299535d64f603146487"},{"code":"(fn [seq]\n  (set (vals (group-by type seq))))","problem":50,"user":"4e2f9e71535deb9a81d77f11"},{"problem":50,"code":"(fn [col]\n  (vals\n   (reduce\n    (fn [r e]\n      (update-in r [(type e)] #(concat % [e])))\n    {}\n    col)))","user":"58c5a08be4b021aa9917ed40"},{"problem":50,"code":"(fn my-split [coll]\n      (let [\n        with-type (into '() (group-by type coll))\n        without-type (map #(second %) with-type)\n        ]\n        (set without-type)\n        )\n      )","user":"536827f1e4b0243289761e8a"},{"problem":50,"code":"(fn [col]\n\n  (loop [retm {} col col]\n\n    (if (empty? col)\n      (map #(reverse (% 1)) retm)\n      (let [item (first col)\n            item-type (type item)]\n        (recur (assoc retm item-type (conj (retm item-type) item)) (rest col) )\n       )\n      )\n    )\n\n)","user":"56c7d8dee4b0ed865f9758c9"},{"code":"(fn my-split-type\n  [coll]\n  (vals (group-by type coll)))","problem":50,"user":"512c0f84e4b03a42b6300232"},{"problem":50,"code":"(fn [xs]\n   (vals\n    (reduce\n     (fn [m x]\n       (update-in m [(class x)] (fnil conj []) x))\n     {}\n     xs)))","user":"5518df4ce4b06a49daca83ce"},{"problem":50,"code":"(fn [coll] (partition-by type (sort-by #(str (type %)) coll)))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":50,"code":"(comp vals (partial reduce #(update-in %1 [(type %2)] (fnil conj []) %2) {}))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [xs]\n  (vals\n    (reduce\n      (fn [m [k v]]\n        (assoc m k (conj (m k []) v)))\n      {}\n      (map\n        (fn [x]\n          [(type x) x])\n        xs))))","problem":50,"user":"4ffa213ee4b0678c553fc3b7"},{"code":"#(for [[k v] (group-by type %)] v)","problem":50,"user":"51b8e0dce4b050a1176cd69f"},{"code":"(fn [xs]\n  (let [mapped (loop [acc {} x (first xs) xs (rest xs)]\n                 (if (nil? x)\n                   acc\n                   (let [type (type x)\n                         preset (get acc type)]\n                     (recur (assoc acc\n                              type\n                              (if (nil? preset)\n                                [x] (conj preset x)))\n                            (first xs)\n                            (rest xs)))))]\n    (map val mapped)))","problem":50,"user":"4dafa380edd6309eace4d17c"},{"problem":50,"code":"(fn split-type [stuff]\n  (filter not-empty\n    (concat\n     (vector (filter integer? stuff))\n     (vector (filter string? stuff))\n     (vector (filter coll? stuff))\n     (vector (filter keyword? stuff))\n     )))","user":"5b2a559be4b063e2438bcc74"},{"problem":50,"code":"(fn split-by-type [lis]\n  (let [map-by-type \n   (reduce (fn [resp ele]\n             (if (contains? resp (type ele))\n               (assoc resp (type ele) (conj (resp (type ele)) ele))\n               (assoc resp (type ele) [ele]))) {}  lis)\n        list-by-type (for [[key val] map-by-type] val)]\n    list-by-type))","user":"574f1c24e4b02ea114799255"},{"problem":50,"code":"(fn [ls] (set (vals (group-by type ls))))","user":"4ea03f70535d7eef308072a1"},{"problem":50,"code":"(fn [col]\n  (->\n   (reduce #(assoc %1\n                   (-> %2 type str keyword)\n                   (conj (get %1 (-> %2 type str keyword) []) %2)) {} col)\n  vals\n  set))","user":"587b8bdee4b01531a375eaff"},{"code":"(fn t[x]\n  (vals (apply merge-with concat \n    (map #(hash-map (type %) [%]) x))))","problem":50,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn [s] (let [types (set (map type s))]\n  (map (fn [t] (filter #(= t (type %)) s)) types)))","problem":50,"user":"4ec5d40d535d6d7199dd36b9"},{"code":"#(->> % (group-by type) vals)","problem":50,"user":"4ee26f01535d10e5ff6f5368"},{"problem":50,"code":"(fn [coll] (set (vals (group-by class coll))))","user":"5728d33ce4b0c6e51e0d2b12"},{"problem":50,"code":"#(vals ((fn mt [l]\n     (let\n      [item (first l)]\n      (if item\n        (let [m (mt (rest l))\n              t (type item)\n              s (get m t '())]\n          (assoc m t\n                 (conj s item)))\n        {}))) %))","user":"598ab445e4b02b9968b84ce0"},{"code":"(fn [col]\n  (vals\n    (reduce \n      #(merge-with concat %1 {(class %2) [%2]})\n      {}\n      col)))","problem":50,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn [xs] (reduce-kv #(conj % %3) #{} (group-by class xs)))","problem":50,"user":"51131da8e4b0350614f07a83"},{"code":"(fn [coll]\n   (map #(second %)\n        (group-by class coll)))","problem":50,"user":"51cacda3e4b068dadb8f2227"},{"code":"(fn [coll]\n  (->> coll\n    (sort-by (comp str type))\n    (partition-by type)))","problem":50,"user":"4daf36c2edd6309eace4d175"},{"code":"(fn [list] \n  (vals (group-by type list)))","problem":50,"user":"4f45c72be4b0d56e7bb92b8a"},{"problem":50,"code":"(fn [s]\n  (->> s\n       (sort-by #(.toString (type %)))\n       (partition-by type)))","user":"503f923fe4b00d1a725ff2ad"},{"problem":50,"code":"(fn [arg1] (vals (group-by type arg1)))","user":"5cb6256ce4b026601754b947"},{"code":"(fn [coll]\n    (map val\n    (loop [m {}\n           c coll]\n      (if (empty? c)\n        m\n        (let [v (first c)\n              t (class v)]\n          (recur (if (contains? m t)\n                   (conj m [t (conj (get m t) v)])\n                   (conj m [t [v]]))\n                 (rest c)))))))","problem":50,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [xs] (map second (group-by type xs)))","problem":50,"user":"517bf28de4b07ef0e56148d5"},{"problem":50,"code":"(fn tst\n  [in]\n  (into #{} (vals (loop\n    [[x & xs :as tx] in\n     out {}]\n    (let [t (type x)] \n      (if (not tx)\n        out\n        (recur xs (assoc out t\n                         (if (contains? out t)\n                           (conj (out t) x)\n                           [x])))))))))","user":"597d0e43e4b0dbe32238d095"},{"problem":50,"code":"(fn [coll]\n  (vals \n   (group-by #(type %) coll)))","user":"5e471203e4b043cd24807a2a"},{"problem":50,"code":"(fn [xs]\n  (->> xs\n       (group-by type)\n       (map val)))","user":"57eaf869e4b0bfb2137f5b56"},{"problem":50,"code":"(fn [s]\n\t(into #{}\n\t\t(let [types (into #{} (map type s))]\n\t\t\t(for [t types]\n\t\t\t\t(into [] (filter #(instance? t %) s))\n\t\t\t)\n\t\t)\n\t)\n)","user":"5559b443e4b0deb715856e3c"},{"code":"(fn splitter [coll]\n  (for [[k v] (group-by type coll)]\n    v))","problem":50,"user":"5349da55e4b084c2834f4a68"},{"code":"(fn [v] set (vals (group-by #(type %) v)))","problem":50,"user":"5229211be4b04c906c9c6a63"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (reduce\n         #(assoc %1 (type %2) (concat (get %1 (type %2)) (list %2)))\n         {})\n       vals\n       (map vec)\n       set))","user":"5b9357b7e4b0c0b3ffbd4a46"},{"problem":50,"code":"(fn [v]\n  (for [[key value] (group-by class v)]\n    value))","user":"5a4443cae4b0447ef91cc60f"},{"code":"(fn [coll]  (map (fn [[key value]] value) (group-by type coll)))","problem":50,"user":"51803613e4b04f45bde7d8fd"},{"problem":50,"code":"#(filter not-empty (vector (filter number? %) (filter string? %) (filter keyword? %) (filter seq? %) (filter vector? %)))","user":"5547b72be4b0a04f79299550"},{"problem":50,"code":"(fn[coll] (map second (group-by #(type %) coll)))","user":"57c7e7d9e4b05aa3c4741d0f"},{"problem":50,"code":"(fn [coll]\n  (vals\n    (reduce\n   \t  (fn [acc e]\n        (let [t (type e)]\n          (if (get acc t)\n            (assoc acc t (conj (get acc t) e))\n            (assoc acc t [e]))))\n      {}\n      coll)))","user":"5c73b8bae4b0fca0c16227ba"},{"code":"(fn sp-by-t [s]\r\n  (loop [s s\r\n         m {}]\r\n    (if (empty? s)\r\n        (map reverse (vals m))\r\n        (recur (rest s) (let [x (first s)\r\n                              t (type x)]\r\n                          (if-let [v (m t)]\r\n                              (assoc m t (cons x v))\r\n                              (assoc m t (list x))))))))","problem":50,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":50,"code":"(fn [l] (reduce\n         (fn [ss i] (if (empty? ss) (list (vector i)) (if (= (type i) (type (first (first ss))))\n                                                        (cons (conj (first ss) i) (rest ss))\n                                                        (cons (vector i) ss)\n                                                       )))\n         '()\n         (sort-by #(str (type %)) l)))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":50,"code":"#(partition-by class  (sort-by (comp count str class) %))","user":"53f2370ee4b0742d9025b0e7"},{"problem":50,"code":";; #(map second (group-by type %1))\n#(vals (group-by type %1))","user":"55d5ee3fe4b0e31453f64a92"},{"problem":50,"code":"(fn [sq]\n    (vals \n     (reduce (fn [result item]\n               (let [type (class item)\n                     type-list (get result type [])]\n                 (assoc-in result [type] (conj type-list item))\n                 )\n               )\n             {}\n             sq\n             ))\n    )","user":"571a282ae4b07c98581c3b46"},{"problem":50,"code":"(fn split-by-type [l]\n  (map #(map first %) (vals (group-by\n          second\n          (map #(list % (type %)) l)))\n\n  ))","user":"563b9acbe4b0bfe05bf11827"},{"problem":50,"code":"(fn [lst] \n  (vals (group-by type lst)))","user":"5bcb672ee4b07a9b28b10100"},{"problem":50,"code":"(fn\n[v]\n  (loop [i 0 m {}]\n    (if (== i (count v))\n      (vals m)\n      (recur (inc i) (assoc m (type (v i)) (conj (vec (m (type (v i)))) (v i)))))\n)\n)","user":"5dd70ee3e4b0948ae9d9ad85"},{"code":"(fn [c](set (vals (group-by #(.getClass %) c))))","problem":50,"user":"4de8a7d7535d08e6dec9fdfe"},{"code":"(comp \n  vals\n  #(group-by type %))","problem":50,"user":"50589113e4b06522596eba7f"},{"problem":50,"code":"(fn [seq]\n   (let [sorted-seq (sort-by #(str (type %))\n                             seq)]\n     ((fn helper [seq result]\n        (if (not (empty? seq))\n          (let [current-type (type (first seq))\n                sub-seq (take-while #(= current-type (type %))\n                                   seq)\n                size-sub-seq (count sub-seq)\n                size-remain (- (count seq) size-sub-seq)\n                ]\n            (if (> size-remain 0)\n              (helper (drop size-sub-seq seq) (conj result sub-seq))\n              (conj result sub-seq))\n            )\n          )\n        )\n      sorted-seq\n      []\n      )))","user":"5ee75f8be4b029a2061bbea5"},{"code":"(fn [xs] (vals (reduce #(assoc %1 (class %2) (conj (get %1 (class %2) []) %2)) {} xs)))","problem":50,"user":"4efd98fa535de96065cf5086"},{"problem":50,"code":"(fn sbt [s]\n  (loop [s s\n         r []]\n    (if (empty? s)\n      r\n      (let [t (type (first s))\n            [ns nr] (reduce\n                     #(let [[ns nr] %1]\n                        (if (= t (type %2))\n                          [ns (conj nr %2)]\n                          [(conj ns %2) nr]))\n                     [[] []]\n                     s)]\n        (recur ns (conj r nr))))))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn split-by-type [s]\n  (let [typemap\n        (reduce (fn [accum val]\n                  (assoc accum (type val) (cons val (accum (type val)))))\n                {} s)]\n    (map reverse (into #{} (vals typemap)))))","problem":50,"user":"50763574e4b0a894bb95bf3d"},{"code":"(fn func [xs] (set (vals ((fn split-by-type [xs]\n\t  (cond (empty? xs) {}\n\t\t:else (let [this-type (type (first xs))\n\t\t\t   rest-processed (split-by-type (rest xs))]\n\t\t\t   (cond (contains? rest-processed this-type) (assoc rest-processed this-type (conj (rest-processed this-type) (first xs)))\n\t\t\t\t :else (assoc rest-processed this-type (list (first xs))))))) xs))))","problem":50,"user":"5213ffd3e4b0961f15ac4d7d"},{"code":"(fn [xs]\n  (vals (group-by type xs))\n)","problem":50,"user":"50555c06e4b0ce54f56f03fa"},{"problem":50,"code":"(fn [x] \n  (loop [cx x, m {}]\n    (if (empty? cx)\n      (set (map last m))\n      (if (contains? m (type (first cx)))\n        (recur (rest cx) (assoc m (type (first cx)) (conj (get m (type (first cx))) (first cx))))\n        (recur (rest cx) (assoc m (type (first cx)) (vector (first cx))))\n      )\n     )\n    )\n  )","user":"588fb3a7e4b00487982d51b9"},{"problem":50,"code":"(fn by-type \n  ([li] (by-type li {}))\n  ([li retSet]\n    (println li retSet)\n    (if (empty? li)\n      (vals retSet)\n      (let [type (type (first li))\n            m (retSet type)]\n        (if (nil? m)\n          (by-type (rest li) (assoc retSet type [(first li)]))\n          (by-type (rest li) (assoc (dissoc retSet type) type (conj (retSet type) (first li)))))))))","user":"4f4aa932e4b0d56e7bb92c14"},{"code":"(fn [coll] (set (map (fn [c] (filter #(= (type %) c) coll)) (set (map type coll)))))","problem":50,"user":"52b43468e4b0c58976d9ad1b"},{"problem":50,"code":"#((fn [m v]\n    (let [f (first v) r (rest v) t (type f)]\n      (if (empty? v)\n        (set (vals m))\n        (recur (assoc m t (concat (m t) [f])) r)\n        ))) {} %)","user":"56aed78fe4b03c432f187363"},{"problem":50,"code":"(fn [ip-seq]\n  (vals (group-by type ip-seq)))","user":"5d8c8175e4b0915913b1d3e1"},{"problem":50,"code":"(fn [xs] (vals (reduce (fn [x y]\n                  (let [t (type y) v (get x t [])]\n                    (into x {t (conj v y)}))) {} xs)))\n; #(vals (group-by type %1))","user":"5a16da30e4b0ff51aa4b31cc"},{"code":"(fn split-by-type [s]\n  (letfn [(categorize-entry [h v]\n            (assoc h (type v) (conj (get h (type v) []) v)))]\n    (vals (reduce categorize-entry {} s))))","problem":50,"user":"4f68c485e4b07046d9f4ef7c"},{"problem":50,"code":"(fn [s]\n  (into #{}\n  \t(for [t (set (map type s))]\n      (filter #(= t (type %)) s))))","user":"57458b82e4b009280f9f2b4e"},{"problem":50,"code":"(fn [s1]\n  (loop [ss s1 res {}]\n    (if (empty? ss)\n      (vals res)\n      (let [el (first ss)\n            et (type el)\n            l1 (conj (if (contains? res et) (res et) []) el)]\n        (recur (rest ss) (assoc res et l1))\n        ))))","user":"56a1fce9e4b0542e1f8d14b7"},{"code":"(fn [v]\n(set (filter not-empty (map #(filter % v) [string? #(= (type %) clojure.lang.Keyword) vector? number?]))))","problem":50,"user":"52e25beee4b09f7907dd1433"},{"problem":50,"code":"#(map last (group-by type %1))","user":"5658d775e4b00d3155796114"},{"problem":50,"code":"#(set (vals(group-by type %)))","user":"54b13a40e4b09f271ff37d1b"},{"problem":50,"code":"(fn [coll]\n  (for [[k v] (group-by type coll)]\n    v))","user":"5475d755e4b0c51c1f4d72a0"},{"problem":50,"code":"(fn grp [coll]\n  (map second (group-by type coll)))","user":"5a9482b7e4b0d174b936c737"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (map (partial map second) (partition-by first (sort-by first (map #(vector (str (type %1)) %1) coll)))))","user":"58896e5ce4b0f1effa3b773e"},{"problem":50,"code":"(fn [l]\n  (for [x ((fn [l]\n             (set (map #(type %) l))) l)]\n    (filter #(instance? x %) l)))","user":"54651faee4b01be26fd746d6"},{"problem":50,"code":"(fn split-by-type [s]\n  (if (nil? s) #{}\n      (let [grps (group-by #(= (type %) (type (first s))) s)]\n        (do (conj (split-by-type (get grps false)) (get grps true)) ))))","user":"4dd5fdb0535d2dad7130b5c5"},{"problem":50,"code":"(fn split-by-type [xs] \n  (vals (group-by type xs)))","user":"52616198e4b03e8d9a4a705e"},{"code":"(fn [col] \n  (loop [i [] j[] k [] col col]\n    (if (empty? col)\n        (filter #(not-empty %) [i j k])\n        (let [z (first col)]\n          (cond (keyword? z) (recur (conj i z) j k (rest col))\n                (coll? z) (recur i j (conj k z) (rest col))\n                :else (recur i (conj j z) k (rest col)))))))","problem":50,"user":"50435689e4b034ff00315d21"},{"problem":50,"code":"#(let [input %\n        all-int (filter (fn [x] (integer? x)) input)\n        all-keyword  (filter (fn [y] (keyword? y)) input)\n        all-string (filter (fn [y] (string? y)) input)\n        all-persistentvector (filter (fn [y] (vector? y)) input)\n        output (conj #{} all-int all-keyword all-string all-persistentvector)\n        real-output (into #{} (filter (fn [m] (if-not (empty? m) m)) output))\n        ]real-output)","user":"5b044436e4b0cc2b61a3bd71"},{"problem":50,"code":"(fn [x] (map second (group-by #(type %) x)))","user":"5f06d26ae4b0cf489e8d7f53"},{"problem":50,"code":"(fn [args]\n  (loop [res {} curr-args args]\n    (if (nil? curr-args)\n      (vals res)\n      (let [curr-val (first curr-args)\n            curr-key (type curr-val)]\n        (recur (assoc res curr-key (conj (res curr-key []) curr-val))\n               (next curr-args))))))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"problem":50,"code":"(fn split-by-type\n  ([lst] (split-by-type lst {}))\n  ([lst type-map]\n   (if (empty? lst)\n     (into #{} (vals type-map))\n     (let [e (first lst)\n           e-type (type e)\n           map-v (or (type-map e-type) [])]\n       (split-by-type (rest lst)\n                      (assoc type-map (type e) (conj map-v e)))))))","user":"551747e0e4b06a49daca83c1"},{"problem":50,"code":"(fn types \n  [coll]\n  (into #{} (let[mt (reduce\n                      (fn[a,v]\n                        (assoc a (type v) (conj (or (get a (type v)) []) v))) {} coll)]\n              (for [[k v] mt]\n                v))))\n\n;;use group by moron","user":"53e241a6e4b036ad0777e3f0"},{"code":"(fn [s]\n  (set (map second (group-by class s))))","problem":50,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":50,"code":"(fn [seq]\n    (->> seq\n      (group-by type)\n      (vals)))","user":"5d0153f9e4b0cc9c915881aa"},{"code":"(fn split-by-type [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4e4b4564535dc968683fc4d3"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      vals)","user":"5483d59fe4b0e286459a1194"},{"problem":50,"code":"(fn [l]\n  (vals\n    (reduce (fn [m x]\n              (let [k (type x)\n                    v (get m k [])\n                    v (conj v x)]\n                (assoc m k v)))\n            {} l)))","user":"547cd90ee4b0c51c1f4d72ec"},{"problem":50,"code":"(fn beenee [coll] (disj \n                      (set \n                       (conj []\n                             (vec ((group-by type coll) clojure.lang.Keyword)) \n                             (vec ((group-by type coll) java.lang.Long)) \n                             (vec ((group-by type coll) java.lang.String))\n                             (vec ((group-by type coll) clojure.lang.PersistentVector))\n                                  )) [] ))","user":"5fe35144e4b05ac5b16ea178"},{"code":"(fn [coll]\n  (let [types #{number? string? coll? keyword?}]\n    (set (filter seq ((apply juxt (map #(partial filter %) types)) coll)))))","problem":50,"user":"4e3bccb1535deb9a81d77f55"},{"problem":50,"code":"(fn [a]\n\n (vals (group-by type a))\n )","user":"56f2611fe4b04a395b9a04a2"},{"problem":50,"code":"(fn [arg] (vals (group-by class arg)))","user":"57fa6f2ee4b0d3187e900962"},{"problem":50,"code":"(fn [coll]\n  (let [types (set (map type coll))]\n    (for [t types]\n      (filter #(= t (type %)) coll)\n      )\n    )\n  )","user":"564066dee4b08d4f616f5ee2"},{"problem":50,"code":"#(vals (apply merge-with concat (map (fn [n] {(class n) [n]}) %)))","user":"55297a7ae4b0ffed3738f94b"},{"code":"(fn pa [coll]\r\n  (if (empty? coll)\r\n    nil\r\n    (let [[x & rxs] coll\r\n          klass (class x)]\r\n(cons\r\n  (cons x (filter #(= klass (class %)) rxs))\r\n  (pa (remove #(= klass (class %)) rxs)))\r\n)))","problem":50,"user":"4dfd4ba8535d04ed9115e781"},{"code":"(fn [xs]\n  (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} xs)))","problem":50,"user":"4f07ad89535dcb61093f6c2a"},{"code":"#(vals (reduce (fn [sum [x y]] \n          (if (contains? sum x)  \n            (assoc sum x (concat (get sum x) y))\n            (assoc sum x y))) {} (map (fn [x] [(type x) (list x)]) %)))","problem":50,"user":"5047782ce4b0371827a27bc2"},{"problem":50,"code":"(fn [[arg & args]] \n  (loop [this arg those args sortbin {}] \n    (if-not this\n      (vals sortbin)\n      (recur (first those) (next those) (merge-with into sortbin {(type this) (vector this)})))))","user":"589f2cefe4b02bd94d917e75"},{"problem":50,"code":"(fn [b] (vals (reduce #(merge-with into % {(class %2) [%2]}) {} b)))","user":"5797d3d2e4b039eba2ecb106"},{"problem":50,"code":"(fn [c]\n    (vals (reduce\n        #(let [k (type %2)]\n            (assoc %1 k (conj (get-in %1 [k] []) %2)))\n        {}\n        c)))","user":"57ae3345e4b0fbc9809a271e"},{"code":"(fn solution [s]\n  (vals (group-by type s))\n)","problem":50,"user":"52b49aebe4b0c58976d9ad2b"},{"code":"#_#(partition-by type (sort-by (comp str type) %))\n\n#_(fn [c] (vals (reduce #(merge-with concat % %2) {}\n        (map hash-map\n             (map type c) (map vector c)))))\n#_(fn [c] (vals (apply merge-with concat\n        (map hash-map\n             (map type c) (map vector c)))))\n\n#_(fn [c] (vals (apply merge-with concat\n             (map (comp (partial apply hash-map)\n(juxt type vector)) c))))\n\n#_(comp vals (partial apply merge-with concat)\n      (partial map\n        (comp (partial apply hash-map)\n              (juxt type vector))))\n\n#_#(partition-by type (sort-by (comp str type) %))\n\n#_(fn [c] (map #(map :v %) (vals (group-by :t\n(map #(-> {:t (type %) :v %}) c)))))\n\n#(vals (group-by type %))\n\n#_(comp vals (partial group-by type))","problem":50,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn [coll] (vals (group-by #(type %) coll)))","problem":50,"user":"4e1ec17a535d04ed9115e80a"},{"code":"(fn [col]\n  (vals\n    (reduce (fn [ret this]\n            (condp = (type this)\n              java.lang.String (assoc ret :string ((fnil conj []) (get ret :string) this)) \n              java.lang.Integer (assoc ret :number ((fnil conj []) (get ret :number) this))\n              java.lang.Long (assoc ret :number ((fnil conj []) (get ret :number) this))\n\t\t\t  clojure.lang.Keyword (assoc ret :keyword ((fnil conj []) (get ret :keyword) this))\n\t\t\t  clojure.lang.PersistentList (assoc ret :list ((fnil conj []) (get ret :list) this))\n              clojure.lang.PersistentVector (assoc ret :vector ((fnil conj []) (get ret :vector) this))\n            ))\n           {} col)))","problem":50,"user":"513cb853e4b0b86ece9f322b"},{"problem":50,"code":"#(set(vals (group-by type %)))","user":"59301509e4b072a2710fcfd6"},{"code":"(fn split-type [seq]\r\n        (apply hash-set (vals (reduce (fn [acc e] (if (contains? acc (type e))\r\n                                (assoc acc (type e) (conj (acc (type e)) e))\r\n                                (assoc acc (type e) [e])))\r\n                {} seq))))","problem":50,"user":"4f13047d535d64f60314642c"},{"code":"#(set (vals\n  (reduce \n    (fn [m e] (assoc m (type e) (conj (get m (type e) []) e))) \n    {} \n    %)))","problem":50,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":50,"code":"(fn [param] (->> param (group-by type) vals))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn [col]\r\n  (loop [[h & t] col\r\n         res {}]\r\n    (cond \r\n      (nil? h) (map second res)\r\n      (res (type h))  \r\n      (recur t \r\n        (update-in res \r\n          [(type h)] conj h))\r\n      :else\r\n      (recur t\r\n        (assoc res (type h) [h])))))","problem":50,"user":"4f039c67535dcb61093f6b3a"},{"problem":50,"code":"(fn [xs]\n        (->> xs\n             (group-by type)\n             vals))","user":"5cc6b4bfe4b0ccb061962827"},{"code":"(fn b [m]\n  (set (partition-by #(class %) (sort-by #(.toString (class %)) m))))","problem":50,"user":"4fe97adde4b0547ebccb245e"},{"code":"#(->> % (group-by class)  vals)","problem":50,"user":"52c60945e4b0c2d177d62108"},{"problem":50,"code":"(fn [x]\n (partition-by class (sort-by #(str (class %)) x)))","user":"566d71b1e4b0a866af6896ca"},{"code":"(fn split-by-type [input]\n  (filter #(not (empty? %))\n    (list (vec (filter vector? input))\n          (filter integer? input)\n          (filter string? input)\n          (filter keyword? input))))","problem":50,"user":"52fc34cee4b047fd55837015"},{"problem":50,"code":"(fn [l]\n  (map val (group-by type l)))","user":"573b8f67e4b0cd1946bd10ae"},{"problem":50,"code":"(fn [xs]\n  (->> xs\n       (reduce (fn [kv v]\n                 (update-in kv\n                            [(type v)]\n                            #(if (nil? %1)\n                               [%2]\n                               (conj %1 %2))\n                            v))\n               {})\n       (vals)))","user":"5f2d6787e4b033932238a66d"},{"code":"(fn [x] (map second (group-by type x)))","problem":50,"user":"4fcebce4e4b03432b189f404"},{"problem":50,"code":"(fn [x]\n  (comp (vals (group-by type x))))","user":"5ecf55dae4b016b56eae05a8"},{"code":"(fn [c]\n  (partition-by class \n    (sort-by #(count (str (class %))) c)))","problem":50,"user":"4db016af838c48654951d9b9"},{"problem":50,"code":"#(partition-by (comp str type) (sort-by (comp str type) %1))","user":"57015a1de4b08d47c97781d4"},{"code":"#(map val (group-by type %1))","problem":50,"user":"534efe66e4b084c2834f4ac1"},{"problem":50,"code":"(fn by-type [coll]\n  (loop [orig coll sorted {}]\n    (if (empty? orig)\n      (vals sorted)\n      (let [item (first orig) typ (str (class item))]\n        (if (sorted typ)\n          (recur (rest orig) (assoc sorted typ (conj (sorted typ) item)))\n          (recur (rest orig) (assoc sorted typ [item])))))))","user":"4ff0e01fe4b0678c553fc328"},{"code":"(fn [xs] (set (vals (group-by class xs))))","problem":50,"user":"4f5c68c6e4b0030a34fb2b23"},{"code":"(fn [ l ] \n  ( vals (reduce \n    #( assoc %1 (class %2) (concat (%1 (class %2)) (vector %2) ) ) \n    (cons {} l) )))","problem":50,"user":"4fc43a8ee4b081705acca346"},{"code":"(fn [l] (let [typs (set (map type l))]\n             (map (fn [arg] (filter #(instance? arg %) l)) typs)\n             ))","problem":50,"user":"4fcf5292e4b03432b189f40e"},{"problem":50,"code":"(fn __ [s]\n  (->> s\n       (map #(vector (type %) %))\n       (reduce (fn [acc [k v]]\n                 (assoc acc\n                        k\n                        (if-let [cur (get acc k)]\n                                (conj cur v)\n                                [v])))\n               {})\n       (map second)))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn [col] (map #(nth (rest %) 0) (group-by type col)))","problem":50,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":50,"code":"(fn rot\n  [coll]\n  (set (vals (group-by type coll))))","user":"5ec5f7f2e4b08d0ec38692d1"},{"code":"(fn f [s]\n  (let [f* (fn [agg s*]\n             (let [k (str (class s*))]\n               (assoc agg k (conj (get agg k []) s*))))]\n    (vals (reduce f* (sorted-map) s))))","problem":50,"user":"51d662fce4b0154f82ab92ef"},{"code":"(fn [x]\n  (into #{} (vals (group-by type x))))","problem":50,"user":"52a32b52e4b04e0c58e87bfc"},{"problem":50,"code":"(fn split-type [s]\n  (loop [s s\n         res []]\n    (if (seq s)\n      (recur\n       (filter #(not= (type (first s)) (type %)) s)\n       (conj res (filter #(= (type (first s)) (type %)) s)))\n      res)))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":50,"code":"(fn split-by-type [xs]\n  (->> xs (group-by #(type %)) (vals) (set)))","user":"5ed3c43be4b016b56eae05c4"},{"code":"(fn [arrs] (vals (loop [arr arrs b {}]\n                   (if (empty? arr)\n                     b\n                     (recur (rest arr) ((fn [elt b]\n                                          (let [-key (str (type elt))]\n                                            (if (contains? b -key)\n                                              (assoc b -key (into (b -key) [elt]))\n                                              (assoc b -key [elt])))) (first arr) b))))))","problem":50,"user":"4ef2d6c5535dced4c769f222"},{"code":"(fn [x] (vals (group-by type x)))","problem":50,"user":"4e5b192e535d8a8b8723a2b3"},{"problem":50,"code":"#(for [[key value] (group-by class %)]\n          #_=>     value)","user":"60845eb8e4b0736b099e42ef"},{"code":"(letfn [(f [m e]\n           (let [k  (keyword (str (type e)))\n                 v  (k m)]\n             (if-not (nil? v) (assoc m k (conj v e))\n                              (assoc m k [e]))))]\n  (fn [col]\n    (vals (reduce f {} col))))","problem":50,"user":"51eadb98e4b0f1f103a0d153"},{"problem":50,"code":"(fn split-type [c] (vals (#(reduce (fn [m e] (assoc m (type e) (conj (m (type e) []) e))) {} %) c)))","user":"55c10409e4b01b9910ae2a2c"},{"code":"(fn [s]\r\n  (map second (reduce (fn [a b]\r\n                        (assoc a (type b) (if (a (type b))\r\n                                            (conj (a (type b)) b)\r\n                                            [b]))) {} s)))","problem":50,"user":"4e773be8535d324fb2983d6e"},{"code":"#(into #{} (map second  (group-by type %)))","problem":50,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn [a] (partition-by type \n  (sort  \n    #(compare (hash (type %1)) (hash (type %2))) a)))","problem":50,"user":"5013141de4b0f26a0e3320a9"},{"problem":50,"code":"(fn [s]\n   (vals (reduce\n           (fn [r v] (assoc r (type v) (conj (or (r (type v)) []) v)))\n           {} s)))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn [coll]\n  (loop [m {}\n         s (seq coll)]\n    (if (empty? s)\n      (seq (vals m))\n      (recur\n        (update-in m [(class (first s))] (fn [v]\n                                           (if v \n                                             (conj v (first s)) \n                                             [(first s)])))\n        (next s)))))","problem":50,"user":"51a97f7ae4b08d8ec191b827"},{"problem":50,"code":"(fn [coll]\n  (->> coll\n       (group-by type)\n       vals))","user":"540e97f9e4b0addc1aec671f"},{"code":"(fn [coll]\r\n  (vals (group-by type coll))\r\n)","problem":50,"user":"4dd579b5535dae65d5c462ea"},{"code":"(fn [coll]\n  (let [classname #(.getName (class %))]\n    (partition-by classname (sort-by classname coll))))","problem":50,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"#(vals (reduce (fn [m e] (assoc m (% e) (conj (m (% e) []) e))) {} %2)) #(.getClass %)","problem":50,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn [s] \n  (set (map \n    (fn [t l] (filter #(instance? t %) l)) \n    (set (map type s))\n    (repeat s))))","problem":50,"user":"4f280840e4b0d6649770a010"},{"problem":50,"code":"(fn [coll]\n  (-> (group-by type coll)\n      (vals)))","user":"56a9d4bbe4b07966d5a8a07b"},{"problem":50,"code":"#(for [x (distinct (map type %))] (for [y % :when (= (type y) x)] y))","user":"5501de12e4b07d26eda61d7b"},{"code":"(fn [lst] (map (fn [t] (filter #(= t (type %)) lst)) (distinct (map type lst))))","problem":50,"user":"4eb66737535d7eef3080736b"},{"problem":50,"code":"#(->> %\n      (group-by type)\n      (vals)\n      (set))","user":"58db097fe4b0a4d5acaab66f"},{"code":"(fn split-type [c]\r\n    (map second (group-by (fn [el]\r\n        (cond (char? el) 0\r\n            (string? el) 1\r\n            (integer? el) 2\r\n            (symbol? el ) 3\r\n            (keyword? el) 4\r\n            (vector? el) 5\r\n            (list? el) 6\r\n            (map? el) 7))\r\n        c)))","problem":50,"user":"4ff4c9dae4b0678c553fc360"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce (fn [m v] (update-in m [(type v)] (fnil conj []) v)) {} coll))\n  )","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn [in]\n  (vals\n  (loop [rem in\n         out {} \n          ]\n    (if (empty? rem)\n      out\n      (let [curr (first rem)\n            t    (type curr)]\n      (recur (rest rem) (assoc out t (conj (get out t []) curr))))))))","problem":50,"user":"51622fb8e4b009fba0926e3f"},{"problem":50,"code":"(fn [rest]  (->> \n             (map (fn [sym] [(str (type sym)) sym]) rest)\n             (sort #(compare (first %1) (first %2)))\n             (partition-by first)\n             (map #(map last %))))","user":"55af7e21e4b03311e7b732cc"},{"problem":50,"code":"(fn [coll]\n  ((fn [acc coll]\n    (if (empty? coll)\n      acc\n      (let [get-type #(= (type (first coll)) (type %))\n      type-coll (filter get-type coll)\n      rest-coll (filter (comp\n        not\n        get-type)\n              coll)]\n        (recur (conj acc type-coll) rest-coll))))\n   [] coll))","user":"58a413b5e4b02bd94d917f07"},{"code":"#(remove empty?\n  (for [f [integer? string? coll? keyword?]]\n   (filter f %)))","problem":50,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn [xs]\n  (set (vals (group-by #(class %) xs))))","problem":50,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":50,"code":"#(vals ((fn [xs] (reduce \n                     (fn [rs x] (assoc rs \n                                             (type x) \n                                             (conj (or (rs (type x)) []) x))) \n                      {} xs )) %))","user":"567798afe4b05957ce8c6169"},{"problem":50,"code":"(fn [L] (filter not-empty \n                (map (fn [t] (filter #(= (type %) t) L)) \n                     [java.lang.Long, clojure.lang.Keyword, java.lang.String, clojure.lang.PersistentVector])))","user":"569c07b9e4b0542e1f8d145d"},{"problem":50,"code":"#(filter (fn [v ] (not= v '()) )                                                                                                                                                    \n          (list        (filter  integer? %)                                                                                                                                          \n                       (filter  vector? %)    \n                        (filter  string? %)    \n                       (filter  keyword? %)) )","user":"57bffed6e4b05aa3c4741c89"},{"code":"(fn [coll] \n  (set (vals (group-by class coll))))","problem":50,"user":"4ebd4448535dfed6da9c6d8f"},{"problem":50,"code":"(fn f [s] (filter #(not(empty? %)) (conj(list (filter #(number? %) s)) (filter #(keyword? %) s) (filter #(string? %) s)\n                   (filter #(coll? %) s) )  ) )","user":"53b3ea79e4b047364c0444ab"},{"code":"#(vals(group-by type%))","problem":50,"user":"4e14b925535d04ed9115e7df"},{"problem":50,"code":"(fn [s]\n  (let [f (fn [e]\n            (filter #(= (type e) (type %)) s))]\n    (map f s)))","user":"5512aca6e4b055c2f668d4b4"},{"problem":50,"code":"(fn [col] \n  (vals \n   (reduce \n    (fn [prev item] \n      (conj prev \n            (let [itemtype (type item), itemlist (prev itemtype)] \n              (vector itemtype \n               (if \n                 (nil? itemlist) \n                 (vector item) \n                 (conj itemlist item)\n                 )\n               )\n             )\n            )\n      ) {} col)))","user":"58950f29e4b00487982d5270"},{"code":";(fn [col]\n;  (vals (reduce \n;    #(assoc % (type %2) (conj (vec (% (type %2))) %2))\n;     {} col)))\n#(vals (group-by type %))","problem":50,"user":"4ef992c8535dced4c769f268"},{"code":"#(partition-by type (sort-by (fn [t] (str (type t))) %))","problem":50,"user":"5336ca32e4b0e30313ee6c80"},{"code":"(fn [xs]\r\n  (loop [ ys xs, acc #{} ]\r\n    (if (empty? ys) acc\r\n      (let [in  (filter #(            =  (type %) (type (first ys))) ys)\r\n            out (filter #((complement =) (type %) (type (first ys))) ys)]\r\n        (recur out (conj acc in))))))","problem":50,"user":"4dea9406535d08e6dec9fe01"},{"code":"(fn \t[s]\n\t\t(set (vals (reduce #(into %1 (hash-map (type %2) (conj (get %1 (type %2) []) %2))) '{} s))))","problem":50,"user":"4f47eab2e4b0d56e7bb92bc6"},{"code":"(fn [l] \r\n  (vals \r\n    (reduce \r\n      (fn [m v] \r\n        (update-in m [(type v)] (fnil #(conj % v) []))) {} l)))","problem":50,"user":"4f141dee535d64f603146434"},{"code":"(fn [sq]\n  (vals (group-by type sq)))","problem":50,"user":"515f2a85e4b0595cf3d1da44"},{"problem":50,"code":"(fn [clls] (vals (loop [ acc {} c clls]\n         (if (first c) (recur (update-in acc [(type (first c))] #(conj (or % []) %2)  (first c)) (rest c))\n              acc))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":50,"code":"#( loop [ [a & b] % res {} ] ( \n                                  \tif a\n                                  \t(let[ fa (type a) ] ( \n                                                      if ( contains? res fa )\n                                                      (recur b (conj res [ fa (conj (res fa) a)]))\n                                                      (recur b (conj res [fa [a]]))))\n                                  \t(->> res vals)\n                                  )\n)\n;; group-by","user":"5b3aa98be4b02d533a91bbca"},{"problem":50,"code":"(fn split-by-type [l]\n  (loop [to-split l splited #{}]\n    (if (empty? to-split)\n      splited\n      (let [pred #(= (type (first to-split)) (type %))\n            same-type (filter pred to-split)\n            r (filter #(not (pred %)) to-split)]\n        (recur r (conj splited same-type))))))","user":"56588f4ee4b0f9d632dd84b6"},{"problem":50,"code":"(fn [coll]\n  (let [types (set (map type coll))]\n    (map (fn [typ]\n           (filter #(= typ (type %)) coll)) types)))","user":"4fe899a6e4b07c9f6fd12c54"},{"code":"#(vals(group-by type %))","problem":50,"user":"4f4bd422e4b03ad3f0c10c7e"},{"code":"(fn split [lst]\n  (map (fn [v]\n         (map second v)) \n       (vals (group-by first \n                       (map #(cond \n                               (keyword? %) [:k %]\n                               (vector? %) [:v %]\n                               :else [:n %]) \n                            lst)))))","problem":50,"user":"51750cd4e4b07031762f2ee5"},{"problem":50,"code":"(fn [colls] (map (fn [[k v]] v) (group-by type colls)))","user":"5ad002f2e4b0ea6055cfab87"},{"problem":50,"code":"(fn sol50 \n  [s]\n  (vals (group-by type s)))","user":"5e9e642ce4b00a66d4a95174"},{"problem":50,"code":"(fn [seq]\n  (->> seq\n       (group-by type)\n       (reduce-kv #(conj %1 %3) #{})))","user":"5f0aa72de4b09a3f05b71808"},{"code":"#(let [types (map type %)]\n(loop [x 0\n       m {}]\n       (if (< x (count %))\n        (recur (inc x) \n          (assoc m\n              (nth types x)\n              (conj (vec (m (nth types x))) (nth % x))))\n        (vals m))))","problem":50,"user":"4e80d71b535db62dc21a62b7"},{"problem":50,"code":"(fn split-by-type\n  [s]\n  (map second (group-by type s)))","user":"5d53a59ae4b0776584bd6f72"},{"problem":50,"code":"#(->> %                                                                                                                                                               \n     (reduce (fn [map e] (update-in map [(type e)] concat [e])) {})                                                                                                      \n     (vals))","user":"50f02de7e4b0bdaecbb47db0"},{"code":"(fn split [v]\n  (let [vfilter (fn vfilter [tst lst] (apply vector (filter tst lst)))]\n    (set (filter #(not (empty? %)) (list\n(vfilter number? v)\n(vfilter keyword? v)\n(vfilter string? v)\n(vfilter vector? v))))))","problem":50,"user":"4e356d2b535deb9a81d77f2d"},{"problem":50,"code":"(fn [the-seq]\n  (set (vals (group-by type the-seq))))","user":"59a96a85e4b0bcf4e9a43b13"},{"problem":50,"code":"(fn [my-seq] (vals (group-by type my-seq)))","user":"57c44053e4b05aa3c4741ccb"},{"problem":50,"code":"(fn [coll]\n   (->> coll\n        (group-by type)\n        vals))","user":"60537cd1e4b04c8f2157d152"},{"problem":50,"code":"(fn [coll] \n         (vals (group-by (fn [elem]\n                     (cond (number? elem) :num\n                           (string? elem) :str\n                           (coll? elem) :seq\n                           :else :other\n                           )) coll)))","user":"545b0275e4b01be26fd74648"},{"problem":50,"code":"(fn [coll] (->> coll\n                     (group-by type)\n                     (vals)))","user":"5a9db5c9e4b0d174b936c7f1"},{"problem":50,"code":"(fn [x]\r\n  (vals\r\n    (reduce (fn [acc v] (update-in acc [(class v)] #(if % (conj % v) [v]))) {} x)))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":50,"code":"(fn [s] (map (fn [t] (filter (fn [e] (instance? t e)) s)) (distinct (map type s))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(fn split-by-type [s]\n  (vals (group-by type s)))","problem":50,"user":"521b339fe4b0c4ef0be83031"},{"code":"(fn [mixed]\n  (for [x (set (map type mixed))]\n    (filter #(= (type %) x) mixed)))","problem":50,"user":"4ec56b5b535d6d7199dd369f"},{"problem":50,"code":"#(into #{}\n       (vals (reduce (fn [r x]\n                 (if-let [v (get r (type x))]\n                   (update-in r [(type x)] conj x)\n                   (assoc r (type x) [x])))\n               {} %)))","user":"55db7e15e4b0e31453f64ae8"},{"code":"(fn [col]\n  (into #{} (map #(second %) (group-by class col))))","problem":50,"user":"4fb2f9b2e4b081705acca294"},{"code":"(fn f \n  [x]\n  (vals (group-by type x)))","problem":50,"user":"50aa60bee4b056ee01935865"},{"problem":50,"code":"(fn [coll]\n  (let [type-checkers [number? keyword? symbol? string? vector? list? set?]\n        filter-by-type (fn [type-checker] (into [] (filter type-checker coll)))]\n    (for [type type-checkers :when (not-empty (filter-by-type type))]\n      (filter-by-type type))))","user":"541cf6dfe4b01498b1a71a7a"},{"code":"(fn [xs] (vals (group-by type xs)))","problem":50,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn split-by-type [coll]\n  (let [find-by-type (fn [result-set x] (first (filter #(= (class (first %)) (class x)) result-set)))\t\n\t      add-new-type (fn [result-set x]\n\t\t    (let [type-in-vec (find-by-type result-set x)\n\t\t        new-vec (if type-in-vec (conj type-in-vec x) [x])] \n\t\t    (conj (disj result-set type-in-vec) new-vec)))]\n\t(reduce add-new-type #{} coll)))","problem":50,"user":"4e6a4edd535d8ccf87e9fec4"},{"problem":50,"code":"(fn [xs] (->> xs\n                (map #(hash-map (type %) `(~%)))\n                (apply merge-with concat)\n                vals\n                ))","user":"5c17467fe4b01240ff5671df"},{"problem":50,"code":"#(vals (reduce\n   \t(fn [obj x]\n      (assoc obj\n       \t(class x)\n        (vec (conj (obj (class x)) x))))\n   \t{}\n    %1))","user":"5d123457e4b02c15ef021996"},{"code":"(fn my-split [s]\r\n  (loop [results {}\r\n\t\t\tsp s]\r\n\t\t(if (empty? sp)\r\n\t\t\t(vals results)\r\n\t\t\t(recur\r\n\t\t\t\t(if (contains? results (class (first sp)))\r\n\t\t\t\t\t(assoc results (class (first sp)) (conj (results (class (first sp))) (first sp)))\r\n\t\t\t\t\t(assoc results (class (first sp)) [(first sp)]))\r\n\t\t\t\t(next sp)))))","problem":50,"user":"4efb92ce535dced4c769f27a"},{"problem":50,"code":"#(vals\n(reduce (fn [a b] (merge-with concat a b))\n(map (fn [x] {(class x) [x]}) %)))","user":"548b7db8e4b0e286459a11fd"},{"problem":50,"code":"(fn [coll] (vals (reduce (fn [accum next]\n              (update-in accum [(type next)] (fn [old] (conj (or old []) next))))\n            {}\n            coll)))","user":"5b62764ae4b0c6492753e725"},{"problem":50,"code":"(fn [x]\n  (let [n (count x)]\n    (loop [i 0 output {}]\n      (if (= n i) (set (vals output))\n          (let [a (nth x i) t (type a)]\n            (recur (inc i) (assoc output t (if (contains? output t) (conj (output t) a) [a]))))))))","user":"58f5b58ae4b0438e51c2cedc"},{"code":"#(concat (vals (group-by class %)))","problem":50,"user":"503efe01e4b06c4e0e1fa26f"},{"code":"#(letfn[(c[a](str(type a)))] \n  (partition-by c (sort-by c %)))","problem":50,"user":"4db13ff51254ad5b4805fa68"},{"problem":50,"code":"(fn type-groups [coll] \n  (vals (group-by type coll)))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":50,"code":"(fn [items]\n  (loop [[x & xs] items\n         result {}]\n    (if (nil? x)\n      (-> (vals result) set)\n      (recur xs\n             (update-in result\n                     [(type x)]\n                     (comp vec conj)\n                     x)))\n  )\n)","user":"5d07989ee4b0cc9c915881fb"},{"problem":50,"code":"#(map (fn [x] (second x) )\n         (group-by type %))","user":"5908882de4b047aa04b19979"},{"code":"(fn [coll]\n  (vals\n    (reduce (fn [m v]\n              (update-in m [(type v)] (fn [prev]\n                                        (if prev\n                                          (conj prev v)\n                                          [v]))))\n            nil coll))\n)","problem":50,"user":"4e6dd51b535d5021c1a895f6"},{"problem":50,"code":"(fn [values]\n  (for [[k v] (group-by type values)] v))","user":"55d06bcbe4b0e31453f64a3a"},{"code":"#(vals (group-by \n        (fn [x] \n          (cond (number? x) :num \n                (symbol? x) :symbol \n                (coll? x) :coll \n                (string? x) :str \n                :else :else)) %))","problem":50,"user":"4ed286d4535d44c135fd68d7"},{"code":"(fn [v]\n(remove #(= (count %) 0)\n\n (into #{} (reduce #(if(keyword? %2) \n            (vector (conj (nth %1 0) %2) (nth %1 1) (nth %1 2) (nth %1 3)) \n        (if(string? %2) \n          (vector (nth %1 0) (conj (nth %1 1) %2) (nth %1 2) (nth %1 3)) \n          (if(vector? %2) \n            (vector (nth %1 0) (nth %1 1) (conj (nth %1 2) %2)  (nth %1 3))\n            (vector  (nth %1 0) (nth %1 1) (nth %1 2) (conj (nth %1 3) %2))    \n))) [[] [] [] []] v\n)\n)))","problem":50,"user":"5065bd94e4b0148eb3925aed"},{"problem":50,"code":"(fn split-by-type\n  [se]\n  (vals (loop [se se\n               hmap (hash-map)]\n          (if (empty? se) hmap\n            (recur (rest se) (update-in hmap [(type (first se))]\n                                        (fn [ve]\n                                          (if (empty? ve) (vector (first se))\n                                            (conj ve (first se))))))))))","user":"554d386ee4b0a04f792995b8"},{"problem":50,"code":"(fn [col]\n  (->> col \n       (group-by type)\n       vals))","user":"50978ca4e4b00ad8bab4e966"},{"code":"(fn f [s]\n  (when (seq s)\n    (let [g #(= (type (first s)) (type %))]\n      (cons (filter g s)\n            (f (filter (complement g) s))))))","problem":50,"user":"51256b40e4b05d10e3e395f8"},{"problem":50,"code":"#(set (map (fn [[k v]] v) (group-by class %)))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"(fn [s]\n  (for [t (map type s)]\n    (filter #(= t (type %)) s)))","problem":50,"user":"506a1985e4b01dc6af13f83e"},{"code":"#(vals (reduce\n          (fn [c n]\n            (assoc c\n              (type n)\n              (conj (c (type n) []) n)))\n          {} %))","problem":50,"user":"4ff9a200e4b0678c553fc3ab"},{"problem":50,"code":"(fn f [s]\n (let [f* \n   (fn [a s*] \n     (let [k (str (class s*))] \n       (assoc a k (conj (get a k     \n                         []) s*))\n     )\n   )] \n  (vals (reduce f* (sorted-map) s)\n  )\n )\n)","user":"5f631e11e4b02876ed9fd011"},{"code":"(fn split-by-type [xs]\n  (let [types (reduce #(conj %1 (type %2)) #{} xs)\n        by-type (fn [t] (fn [x] (= (type x) t)))]\n    (map #(filter (by-type %) xs) types)))","problem":50,"user":"4e691c79535d8ccf87e9fe97"},{"problem":50,"code":"(fn [coll] (partition-by #(str (type %)) (sort-by #(str (type %)) coll)))","user":"56fbf83de4b07572ad1a88da"},{"problem":50,"code":"(fn [coll]\n  (let [types (set (map type coll))]\n    (for [t types]\n      (remove #(not= t (type %)) coll))))","user":"51ae350fe4b09397d5109790"},{"problem":50,"code":"(fn [s]\n    (vals\n      (loop [acc {} xs s]\n        (if (= () xs)\n          acc\n          (let [x (first xs) v (get acc (type x) [])]\n            (recur (assoc acc (type x) (conj v x)) (rest xs)))))))","user":"4df9c598535d04ed9115e77a"},{"code":"(fn [l]\n  (set (vals (group-by type l))))","problem":50,"user":"4ede8e1d535d10e5ff6f5339"},{"code":";; My original answer\n;; Sort the list by type... but types can't be compared, so we turn them into strings which CAN be compared\n;; once sorted, we can partition by their type giving us the solution\n;;#(partition-by type \n;;               (sort-by (fn [x] \n;;                          (str (type x))) %))\n;;\n;; Smart people answer:\n;; group-by will return a map. The key will be the \"group\" designator and the value will be what matches the designator:\n;; Example: (group-by type [:a \"foo\"  \"bar\" :b]) will return {clojure.lang.Keyword [:a :b], java.lang.String [\"foo\" \"bar\"]}\n;; Now all we need are the values, so we call (vals)\n\n#(vals (group-by type %))","problem":50,"user":"50955676e4b087f34d351ab1"},{"code":"(fn [s]\n   (vals (group-by #(.getClass %) s))\n)","problem":50,"user":"4f8b56dae4b02e764a0a517e"},{"problem":50,"code":"(fn split_by_type [coll] (vals (group-by type coll) ) )","user":"600b385ce4b074f607df668d"},{"problem":50,"code":"#(for [x (group-by type %)] (second x))","user":"5c20b6abe4b07e362c230576"},{"problem":50,"code":"(fn [lst]\n  (vals (group-by class lst)))","user":"572722c4e4b0c5bde472c134"},{"problem":50,"code":"(fn [coll]\n  (vals (group-by #(type %) coll))\n  )","user":"537b1083e4b06839e8705e64"},{"problem":50,"code":"(fn [coll] \n\t (map val (group-by class coll))\n\t)","user":"5ac04101e4b073f177442737"},{"code":"#(into #{} (vals (group-by class %1)))","problem":50,"user":"504e685fe4b0f6ff3350c4ae"},{"code":"(fn fn50 [s]\n  (vals (group-by type s)))","problem":50,"user":"5125d963e4b05d10e3e395fe"},{"code":"(fn [things]\n  (vals (reduce\n         (fn [sofar item]\n           (let [c (class item)]\n             (assoc sofar c (conj (get sofar c []) item))))\n         {}\n         things)))","problem":50,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":50,"code":"(\n    fn [coll]\n    (\n      map #(val %) (group-by class coll)\n      )\n    )","user":"547f3434e4b0c51c1f4d7319"},{"problem":50,"code":"(fn c [xs]\n  (letfn [(f [acc & xs]\n            (println :acc acc)\n            (if (empty? xs)\n              (into #{} (map reverse (vals acc)))\n              (let [x (first xs)]\n                (recur (update-in acc [(type x)] conj x) (rest xs)))))]\n    (apply f {} xs)))","user":"512e31e9e4b0b740abc59823"},{"code":"(fn split-by-type\n  [s]\n  ;; recursively call filter, and remove, to collectand remove type matches from list?\n  (loop [s s acc []]\n    (cond\n     (empty? s) acc\n     :else ; remove all items from s that match the type of the first item\n     (let [all-type (filter #(= (type (first s))\n                                (type %)) s)\n           rem-type (remove #(= (type (first s))\n                                (type %)) s)]\n       (recur rem-type (conj acc all-type))))))","problem":50,"user":"4fd16778e4b04c3a95aa040f"},{"code":"(fn [l] (vals (reduce \n                 (fn [a b] (update-in a [(type b)] \n                                      #(if (nil? %1) [b] (conj %1 b)))) {} l)))","problem":50,"user":"4e5f08c7535d8a8b8723a2da"},{"problem":50,"code":"(fn split-by-type [coll]\n  (->> (group-by type coll) (vals)))","user":"53c126fce4b00fb29b22125b"},{"code":"(fn [s]\n  (map second (group-by #(type %) s)))","problem":50,"user":"50bb646de4b03e68e4411ca3"},{"problem":50,"code":"(fn [data]\n  (vals (group-by type data)))","user":"5c0eb93ce4b01240ff567146"},{"code":"#(map last (seq (group-by type %)))","problem":50,"user":"5368a275e4b0243289761e8f"},{"code":"(fn [s]\n                (let [types (reduce conj #{} (map type s))]\n                  (for [t types]\n                    (filter #(= t (type %)) s))))","problem":50,"user":"4e08fb7a535d04ed9115e7ac"},{"code":"(fn split-by-type [n]\n  (vals (group-by type n))\n)","problem":50,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":50,"code":"#(vals\n\t\t(reduce  \n\t\t\t(fn [T t]\n\t\t\t\t(let [currtype (type t)]\n\t\t\t\t\t(if (nil? (T currtype))\n\t\t\t\t\t\t(assoc T currtype (vector t))\n\t\t\t\t\t\t(assoc T currtype (conj (T currtype) t))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) \n\t\t\t{}\n\t\t\t%\n\t\t)\n\t )","user":"56449e4de4b0284900eef5f9"},{"code":"(fn [s] (-> s (#(group-by type %)) vals))","problem":50,"user":"50ad7888e4b0a40c9cfb08c7"},{"code":"#(->> % (group-by type) vals set)","problem":50,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [l] (vals( reduce #(assoc % (type %2) (concat (get % (type %2)) (list %2))) {} l)))","problem":50,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"#(vals\n      (reduce\n       (fn [x y] (merge-with\n         (fn [a b] (if (and (coll? a) (not (coll? b))) (conj a b) [a b])) x y))\n       (map (fn [a] {(type a) a}) %)))","problem":50,"user":"5125029de4b0ce9225d2ed3e"},{"problem":50,"code":"(fn [v] (apply hash-set (partition-by type (sort-by #(.getName (type %)) v))))","user":"59089229e4b047aa04b1997c"},{"problem":50,"code":"(fn [s](vals( group-by (fn[x](type x)) s)))","user":"56039843e4b04bb52996e1be"},{"code":"(fn [v] (map #(% 1) (group-by #(type %) v)))","problem":50,"user":"50bce014e4b0594b91591c63"},{"problem":50,"code":"(fn [coll]\n  (let [numbers (vec (filter number? coll))\n        keywords (vec (filter keyword? coll))\n        strings (vec (filter string? coll))\n        vectors (vec (filter vector? coll))]\n    (remove empty? [numbers keywords strings vectors])))","user":"54cbd6bae4b057c6fda3a282"},{"code":"(fn [s]\n    (map last (group-by type s)))","problem":50,"user":"53489329e4b084c2834f4a5b"},{"problem":50,"code":"(fn [c]\n   (->> c\n        (group-by type)\n        vals\n        set))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":50,"code":"#(filter not-empty (for [x [number? keyword? string? coll?]] (filter x %)))","user":"57b35a19e4b0fbc9809a277d"},{"problem":50,"code":"(fn [coll] (->> coll (group-by type) (vals)))","user":"5dc40814e4b02f9375f4e1ae"},{"problem":50,"code":"(fn [c]\n  (map (fn [t] (filter #(= t (type %)) c))\n       (map type c))\n  )","user":"543be8f0e4b032a45b869337"},{"code":"(fn\n   [s]\n   (vals (reduce #(let [t (type %2)\n                        v (conj (get %1 t []) %2)]\n                    (assoc %1 t v)) {} s)))","problem":50,"user":"51c3c6a6e4b0851ac09658f8"},{"problem":50,"code":"(fn [coll]\n  (vals (group-by type coll))\n)","user":"59c243bae4b0a024fb6ae4aa"},{"problem":50,"code":"#(vals (reduce\n  (fn [res v]\n    (assoc res (type v) (conj (get res (type v) []) v)))\n  {}\n  %))","user":"5d7eaf5fe4b0492f5d910fc3"},{"problem":50,"code":"(fn pia [v ]\n  (map second (group-by type v)))","user":"569ce6fee4b0542e1f8d146c"},{"code":"(fn split-by-type [coll]\n  (let [type-coll (map #(vector % (type %)) coll)\n        type-set (set (map second type-coll))]\n    (map (fn [s] (map first (filter #(= s (second %)) type-coll))) type-set)))","problem":50,"user":"539a2901e4b0b51d73faaf0f"},{"code":"#(vals (\n        reduce (\n                fn [a i] (\n                          assoc a (type i) (concat (get a (type i)) (list i) )\n                          )\n                )\n        (empty hash-map) %\n        )\n       )","problem":50,"user":"51e1c176e4b06a68e693eafb"},{"problem":50,"code":"(fn mysplit [coll]\n  (loop [input coll\n         result []]\n    (if (empty? input)\n      result\n      (recur (rest input) (let [item (first input)]\n                            (loop [setinput result\n                                   setoutput []]\n                              (if (empty? setinput)\n                                (conj setoutput (vector item))\n                                (if (= (type item) (type (first (first setinput))))\n                                  (concat (rest setinput) setoutput (vector (conj (first setinput) item)))\n                                  (recur (rest setinput) (conj setoutput (first setinput)))))))))))","user":"5ab490f4e4b073f17744261d"},{"code":"(fn f [i] \n  (vals (group-by type i)))","problem":50,"user":"51aefceee4b09397d5109797"},{"code":"(fn [col]\n\t(set\n\t(vals \n\t\t(reduce \n\t\t\t#(assoc % \n\t\t\t\t(class %2) \n\t\t\t\t(conj (get % (class %2) []) %2)) \n\t\t\t{} \n\t\t\tcol))))","problem":50,"user":"527ccaf4e4b0757a1b17136d"},{"code":"#(->> %\n  (reduce (fn [m e] (assoc m (class e) (conj (get m (class e) []) e))) {})\n  (vals)\n  (set))","problem":50,"user":"4e521cef535d302ef430da6d"},{"code":"#((comp (partial filter (complement empty?)) (juxt (partial filter number?) (partial filter keyword?) (partial filter string?) (partial filter vector?))) %)","problem":50,"user":"4f2d4d4ce4b0d6649770a058"},{"code":"(fn split-types [xs]\r\n  (if (empty? xs)\r\n    []\r\n    (conj (split-types (filter #(not= (type (first xs)) (type %)) xs))\r\n          (vec (filter #(= (type (first xs)) (type %)) xs)))))","problem":50,"user":"4dd023dd535d5973398f92ad"},{"problem":50,"code":"(fn [S]\n  (filter seq (list (filter string? S)\n    (filter integer? S)\n    (filter coll? S)\n    (filter keyword? S))\n  )\n )","user":"5649615be4b0284900eef641"},{"problem":50,"code":"(fn [col] (set (vals (reduce #(merge-with concat %1 {(type %2) [%2]}) {} col))))","user":"5ab3db13e4b073f177442609"},{"problem":50,"code":"(fn [vs] (->> vs (group-by class) vals))","user":"53684a2fe4b0243289761e8c"},{"problem":50,"code":"(fn [x] (map second (group-by #(class %) x)))","user":"5716d585e4b07c98581c3b03"},{"problem":50,"code":"(fn [container]\n    (vals\n      (reduce\n        (fn [type-map next-value]\n          (let\n           [next-type (type next-value)]\n           (assoc type-map next-type (conj (type-map next-type []) next-value))))\n        {}\n        container)))","user":"54f904c2e4b01ecee9d88832"},{"problem":50,"code":"; Wish I had thought of: #(vals (group-by type %))\n\n(fn [xs]\n  (vals (reduce #(update-in %1 [(class %2)] (fnil conj []) %2)\n                 {} xs)))","user":"5616f411e4b06b1bb2182a0a"},{"problem":50,"code":"(fn [s] (filter #(not (empty? %)) (map #(filter % s) [string? number? keyword? vector?])))","user":"5e5b8d92e4b0fd0acd158658"},{"code":"(let [split (fn split\n              ([lst] (split lst {}))\n              ([lst types]\n                 (if (empty? lst)\n                   types\n                   (let [f (first lst)\n                         r (rest lst)\n                         t (type f)]\n                     (if (types t)\n                       (recur r (assoc types t (conj (types t) f)))\n                       (recur r (assoc types t [f])))))))]\n  (comp vals split))","problem":50,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn split-type [s] \n  (loop [subs [], se s]\n    (if (empty? se) \n      subs\n      (let [groups (group-by #(= (type (first se)) (type %)) se)]\n        (recur\n          (cons (get groups true) subs)\n          (get groups false))))))","problem":50,"user":"52ec1dfbe4b0705949c4444b"},{"problem":50,"code":"(fn split-by-type [sqn]\n  (loop [sqn sqn\n         sorted {}]\n    (if (empty? sqn)\n      (vals sorted)\n      (let [x (first sqn)\n            t (type x)]\n        (recur \n         (rest sqn)\n         (if (contains? sorted t)\n           (update-in sorted [t] conj x)\n           (assoc sorted t (vector x))))))))","user":"569f99cce4b0542e1f8d1497"},{"problem":50,"code":"(fn split_by_type\n  [coll]\n  (letfn [(type_selector\n    [coll typo]\n      (for [x coll :when (= (type x) typo)]\n        x))]\n    (for [x (set (map type coll))]\n      (type_selector coll x))))","user":"58a6d14fe4b01a0c0b232935"},{"problem":50,"code":"(fn st [v] \n  (set \n   (map \n     (fn [t] (vec (filter #(= t (type %)) v)))\n     (map type v))))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn type-filter [coll]\n  (if (seq coll)\n    (conj (type-filter (remove #(= (type %) (type (first coll))) coll))\n          (filter #(= (type %) (type (first coll))) coll))\n    ()))","problem":50,"user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [xs] (vals (group-by class xs)))","problem":50,"user":"4fc34787e4b081705acca33e"},{"problem":50,"code":"(fn [coll] (into #{} (map second (group-by class coll))))","user":"60654263e4b069485764ddc9"},{"code":"(fn [coll]\n   (disj (into\n    (into\n     (into\n      (into #{} \n            (vector (vec (for [x coll :when (keyword? x)] x) ))\n            )\n       (vector (vec (for [x coll :when (number? x)] x)) )\n      )\n       (vector (vec (for [x coll :when (string? x)] x)) )\n     )\n     (vector (vec (for [x coll :when (coll? x)] x)) )\n    )\n         '()\n         )\n   )","problem":50,"user":"4ea31da2535d7eef308072c1"},{"problem":50,"code":"#(vals\n  (reduce (fn [m v]\n            (let [t (type v)\n                  c (m t)]\n              (assoc m t (if c (conj c v) [v])))) {} %))","user":"56baa68ce4b0f26550335947"},{"problem":50,"code":"(fn [col]\n  (let [types (set (map type col))]\n    (map (fn [t] (filter #(= t (type %)) col)) types)))","user":"56602649e4b068f2fe63dc47"},{"code":"(fn [s] (map last (group-by type s)))","problem":50,"user":"4eca7a87535d6d7199dd3705"},{"code":"(fn [input]\n  (loop [in input\n         out #{}]\n         (if (empty? in)\n              out\n              (let [f #(= (type %) (type (first in)))\n                    newblock (filter f in)\n                    whatsleft (remove f in)]\n                (recur whatsleft (conj out newblock))))))","problem":50,"user":"4e6a60cd535d8ccf87e9fed7"},{"code":"(fn tsplit [xs]\n  (vals\n   (reduce\n    (fn [acc, x]\n      (assoc acc (type x)\n        (conj\n         (get acc (type x) [])\n         x\n         )))\n    {}\n    xs)))","problem":50,"user":"51365524e4b04ac1f358dd52"},{"problem":50,"code":"(fn [li]\n  (->> (reduce (fn [out check](update-in out [(type check)] #(conj (or % [] ) check))) {} li)\n\t   (vals)\n       )\n  )","user":"5ec819b4e4b08d0ec38692e2"},{"problem":50,"code":"(fn [pool]\n   (into #{} (vals (group-by #(type %) pool)))\n  )","user":"54eff2bee4b024c67c0cf88d"},{"code":"(fn [c] (vals (reduce #(assoc % (type %2) (conj (% (type %2) []) %2)) {} c)))","problem":50,"user":"4f047542535dcb61093f6bc7"},{"code":"(fn split-by-type [coll]\n  (loop [map {}\n         lst coll]\n\n    (if (empty? lst)\n      (vals map)\n        (do\n          (let [elem (first lst)]\n            (if (contains? map (type elem))\n              (recur (assoc map (type elem) (conj (get map (type elem)) elem)) (rest lst))\n              (recur (assoc map (type elem) [elem]) (rest lst))))))))","problem":50,"user":"52a6ed15e4b0c58976d9ac0a"},{"problem":50,"code":"#(map last (map seq (group-by class %)))","user":"597fa3fbe4b021a7a535fdbf"},{"code":"#(map second\n      (group-by type %))","problem":50,"user":"528410bbe4b0239c8a67adc2"},{"code":"(fn  [lst]\n  (-> (reduce #(assoc %1 (type %2)\n\t\t  (if-let [valvec (get %1 (type %2))]\n\t\t     (conj valvec %2)\n\t\t     [%2])) {} lst) (vals) (set)))","problem":50,"user":"4e6e3a1e535d5021c1a89602"},{"problem":50,"code":"#(->> %\n     (group-by type)\n     vals\n     set)","user":"5c896f46e4b048ec896c5940"},{"problem":50,"code":"(fn [arr]\n   (loop [result []\n          index 0]\n     (if (< index (count arr))\n       (if (= (count result) 0)\n         (recur (conj result [(nth arr index)])\n                (inc index))\n         (let [targetIndex ((fn [arr value]\n                              (loop [resultIndex 0]\n                                (if (< resultIndex (count arr))\n                                  (if (= (type (first (nth arr resultIndex))) (type value))\n                                    resultIndex\n                                    (recur (inc resultIndex))\n                                    )\n                                  resultIndex\n                                  )\n                                )\n                              ) result (nth arr index))]\n           (if (< targetIndex (count result))\n             (recur ((fn [arr n value]\n                       (loop [result []\n                              index 0]\n                         (if (< index (count arr))\n                           (if (= index n)\n                             (recur (conj result value)\n                                    (inc index))\n                             (recur (conj result (nth arr index))\n                                    (inc index))\n                             )\n                           result\n                           )\n                         )\n                       ) result targetIndex (conj (nth result targetIndex) (nth arr index)))\n                    (inc index))\n             (recur (conj result [(nth arr index)])\n                    (inc index))\n             )\n           )\n         )\n       result\n       )\n     )\n   )","user":"5dd1fb19e4b0948ae9d9ad51"},{"code":"#(->> (group-by type %)\n       vec\n       (map second))","problem":50,"user":"5360f043e4b0243289761e3c"},{"code":"(fn [n]\r\n  (reduce\r\n   (fn [l a]\r\n     (if (some #(= (class a) (class (first %))) l)\r\n       (reduce (fn [m b] (conj m (if (= (class a) (class (first b))) (conj b a) b))) #{} l)\r\n       (conj l [a])))\r\n   #{}\r\n   n))","problem":50,"user":"507437c2e4b054001656acd0"},{"code":"(fn mysplittype [lt]\r\n    (let [cls (set (map class lt))]\r\n      (letfn [(rec [cls lt]\r\n  \t   (if (empty? cls)\r\n\t\t     '()\r\n\t\t     (cons\r\n\t\t       (vec (filter #(= (first cls) (class %)) lt))\r\n\t\t       (rec (rest cls) lt))))]\r\n\t     (rec cls lt))))","problem":50,"user":"4e1b2cd9535d04ed9115e7fd"},{"code":"(comp set vals (partial group-by (memfn getClass)))","problem":50,"user":"4ff3df0fe4b0678c553fc355"},{"code":"(fn split-by-type [l]\n   (letfn [(split-with-acc [acc e]\n             (assoc acc (type e) (conj (get acc (type e)) e)))]\n\n     (for [[k v] (reduce split-with-acc {} l)]\n       (reverse v)\n       )))","problem":50,"user":"4fc8ce6ce4b0ee37620e183c"},{"problem":50,"code":"(fn [coll] (vals (reduce (fn [m v] (assoc m (type v) (concat (get m (type v)) [v]))) {} coll)))","user":"5b5e7953e4b0c6492753e6d9"},{"code":"(fn type-split [coll]\n  (if-let [[x & xs] (seq coll)]\n    (let [tx      (type x)\n          matches (filter #(= tx (type %)) coll)\n          rest    (filter #(not (= tx (type %))) xs)]\n      (conj (type-split rest) matches))\n    '()))","problem":50,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":50,"code":"(fn splittype [x] (vals (reduce #(update-in % [(type %2)] concat [%2]) {} x)))","user":"53ecac57e4b0d648e757f4b3"},{"problem":50,"code":"(fn split-by-type [s]\n  (vals\n   (reduce (fn [m v]\n             (update-in m [(class v)]\n                     #(if (nil? %) [v]\n                          (conj % v))))\n           {} s)))","user":"55c68089e4b0e31453f649c4"},{"code":"(fn [s]\n  ((fn [s m]\n     (if (empty? s)\n       (vals m)\n       (let [t (type (first s))]\n         (recur (rest s)\n                (assoc m t\n                  (concat (get m t) [(first s)]))))))\n   s {}))","problem":50,"user":"535d910ae4b04ce2eb3ed2c5"},{"problem":50,"code":"(fn [coll] \n  (vals (group-by #(class %) coll)))","user":"5e724492e4b085ba37836dc7"},{"problem":50,"code":"(fn split [coll]\n  (into #{} (vals (group-by \n    (fn [i]\n      (cond \n        (number? i) :number\n        (string? i) :string\n        (keyword? i) :keyword\n        :else :other))\n    coll))))","user":"5c8cfff8e4b048ec896c5996"},{"code":"(fn split-by-type [coll]\n  (->> coll\n       (group-by type)\n       vals))","problem":50,"user":"4fc6305de4b0ee37620e180b"},{"problem":50,"code":"(fn [s]\n  (map\n   (fn [[a b]] b)\n   (group-by type s)\n   )\n  )","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn splittype [s] (map (fn [x] ((fn findtype [s t] (if (= (type (first s)) t)\n                        (concat [(first s)] (if (> (count (rest s)) 0) (findtype (rest s) t)))\n                        (if (> (count (rest s)) 0)\n                          (findtype (rest s) t)\n                          []))) s x)) ((fn listtypes [s] (loop [l s r #{}] (if (empty? (rest l)) \n                                        (if (not (contains? r (type (first l)))) (conj r (type (first l))) r) \n                                        (recur (rest l) (if (not (contains? r (type (first l)))) (conj r (type (first l))) r)))))\n s)))","problem":50,"user":"4e5e9f6b535d8a8b8723a2d2"},{"problem":50,"code":"(fn typesplit [s & n]\n  (let [preds [number? symbol? keyword? string? char? list? vector? set?]\n        i (if (nil? n) 0 (int (first n)))]\n    (if (not (empty? s))\n      (if (>= i (count preds))\n        (list (list \"unrecognizeds: \" s)) ; Ran out of preds? Return unrecognized.\n        (filter #(not(empty? %))          ; Clear out '()'s... TODO must be a better way?\n                (list* (filter (preds i) s)\n                       (typesplit\n                        (filter #(not((preds i) %)) s)\n                        (+ 1 i)))))\n      nil)))","user":"5674607ae4b05957ce8c6137"},{"problem":50,"code":"(fn group-by-type [coll]\n  (into #{} (vals (group-by type coll))))","user":"59c94a69e4b0a024fb6ae576"},{"problem":50,"code":"(fn [v] (vals (group-by type v)))","user":"55a21f1ce4b0acc240e3151f"},{"code":"#(vals\n  (reduce\n   (fn [r v] (assoc r (class v) (conj (r (class v) []) v)))\n   {} %))","problem":50,"user":"519b7d76e4b02a926d9a436e"},{"problem":50,"code":"(fn [v]\n        (for [x v]\n          (filter #(= (.getClass x) (.getClass %)) v)))","user":"56171eade4b06b1bb2182a0c"},{"code":"(fn [coll] (set (map val (group-by type coll))))","problem":50,"user":"4f43b992e4b0d7d3c9f3fd2c"},{"code":"#(vals\n  (group-by type %))","problem":50,"user":"50611456e4b0dc10a69545a5"},{"code":"#(->> % (group-by class) (map second) set)","problem":50,"user":"530cb5b8e4b02e82168697e0"},{"problem":50,"code":"(fn [xs]\n  (loop [result {} items xs]\n    (if (empty? items)\n      (map (fn [key] (reverse (result key))) (sort (keys result)))\n      (let [item (first items) item-type (str (type item))]\n        (recur (assoc result item-type (conj (result item-type) item)) (rest items))\n      )\n    )\n  )\n)","user":"55d79b87e4b0e31453f64aa8"},{"problem":50,"code":"(fn [sq]\n  (loop [rm      sq\n         res     []]\n    (if (empty? rm)\n      res\n      (let [ctype (type (first rm))]\n      (recur\n  (filter #(not (= ctype (type %))) rm)\n  (conj res (filter #(= ctype (type %)) rm)))))))","user":"574e7be7e4b02ea114799242"},{"code":"(fn [s] (partition-by type (sort-by #(.getName (type %) ) s) ) )","problem":50,"user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [seq]\n  (let [types (set (map type seq))]\n    (map (fn [t] (filter #(= t (type %)) seq))\n         types)))","problem":50,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn [l]\n   (set (vals (reduce\n          (fn [map el] (update-in map [(class el)]\n                                 (fn [x] (if (nil? x) [el] (conj x el)))))\n          {} l))))","problem":50,"user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(comp vals (partial group-by type))","problem":50,"user":"4db8ec47535d1e037afb219d"},{"problem":50,"code":"(fn [sq]\n  (let [map-per-type (reduce (fn [acc v] (assoc acc (type v) (conj (get acc (type v) []) v))) {} sq)]\n    (map #(second %) (seq map-per-type))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":50,"code":"(fn [x]\n  (map (comp reverse val) (reduce (fn [acc item]\n                     (let [type-key (type item)]\n                       (assoc acc type-key (cons item (get acc type-key)))))\n                   {} x)))","user":"5ed875abe4b016b56eae05f2"},{"code":"(fn st [l]\n  (for [x l]\n    (filter #(= (type %) (type x)) l)))","problem":50,"user":"5110b8bae4b04c71fce993f4"},{"problem":50,"code":"(fn [coll]\n  (loop [res {}\n         coll coll]\n    (if (empty? coll)\n      (vals res)\n      (let [elem (first coll)\n            eltype (type elem)\n            sub (get res eltype [])\n            newsub (conj sub elem)\n            newres (assoc res eltype newsub)]\n        (recur newres (rest coll))))))","user":"592334c7e4b0a390037439ee"},{"problem":50,"code":"(fn [coll]\n           (let [compare #(fn [col] (when (= (type (first col)) (type %1)) col))]\n             (reduce\n              (fn [state next]\n                (conj\n                 (filter #(not ((compare next) %)) state)\n                 (conj (or (some (compare next) state) []) next))\n                )\n              [] coll)\n             ))","user":"58db48a5e4b0a4d5acaab679"},{"problem":50,"code":"(fn sbt [coll]\n  (vals (group-by type coll)))","user":"53b39d82e4b047364c0444a6"},{"code":"#(into #{}\n       (vals (group-by class %)))","problem":50,"user":"51933b41e4b0c663c5d86ca2"},{"problem":50,"code":"(fn [l]\n  (let [types (map type l)\n        l-types (map vector types l)\n        init-map (apply hash-map (mapcat #(vector % []) (set types)))\n        mmap (reduce #(assoc %1 (first %2) (conj (%1 (first %2)) (second %2)))      init-map l-types)]\n    (vals mmap)))","user":"5d1e19c4e4b02ea6f0fb69af"},{"code":"(fn [vc] (into #{} (map #(vec (filter (fn [it] (= (type %) (type it))) vc)) vc)))","problem":50,"user":"4e8b73e4535d65386fec2120"},{"problem":50,"code":"(fn [s] \n  (set (partition-by #(str (type %)) (sort-by #(str (type %)) s)))\n)","user":"54524afbe4b0e397800069bc"},{"code":"(fn [seq]\n  (loop [accu {}\n         seq seq]\n    (if (empty? seq)\n      (map (fn [x] (reverse (second x))) accu)\n      (recur\n       (assoc accu (class (first seq)) (cons (first seq) (get accu (class (first seq)))))\n       (rest seq)))))","problem":50,"user":"4e82c062535db62dc21a62cc"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (partition-by type (sort-by #(str(type %)) coll)))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":50,"code":"#(reduce-kv (fn [a k v] (conj a v)) [] (group-by type %))","user":"58c3af4de4b021aa9917ed1b"},{"code":"(fn uno* [l]\n  (loop [l1 l res #{}]\n   (if (empty? l1)  res\n      (let [t (type (first l1))\n            f1 (fn [x] (= (type x) t))]\n       (recur\n         (filter (complement f1) l1)\n         (conj \n          res  (filter f1 l1)))))))","problem":50,"user":"4f04a06d535dcb61093f6bd9"},{"problem":50,"code":"(fn [coll](\n           vals (group-by type coll)\n           ))","user":"546280d8e4b01be26fd746b0"},{"code":"(fn [v]\n  (map second (group-by type v)))","problem":50,"user":"4f7426fde4b044e54cd9a8f5"},{"code":"(fn [coll]\n    (loop [res {}\n           coll coll]\n      (if (seq coll)\n        (let [fst (first coll)\n              cls (class fst)]\n          (recur\n            (assoc res\n                   cls\n                   (conj (vec (res cls)) fst))\n            (rest coll)))\n        (vals res))))","problem":50,"user":"4e5be681535d8a8b8723a2bc"},{"problem":50,"code":"#(for [[k v] (group-by class %)]\n   v)","user":"5defc177e4b093ff717275af"},{"problem":50,"code":"(fn [coll]\n  (into #{} (vals (group-by type coll))))","user":"54edfa10e4b024c67c0cf868"},{"problem":50,"code":"(fn split-by-type [coll]\n  \n  (letfn [(type-assoc [m item] (if (contains? m (type item)) (assoc m (type item) (conj (m (type item)) item)) (assoc m (type item) [item])))]\n  \n    (vals (reduce type-assoc {} coll))\n  \n  )\n)","user":"54a7d707e4b09f271ff37c9b"},{"problem":50,"code":"(fn a [lst]\n    (remove empty? (concat\n    (list (filter number? lst))\n    (list (filter keyword? lst))\n    (list (filter string? lst))\n    (list (filter vector? lst)))))","user":"56fc1bc7e4b07572ad1a88dd"},{"problem":50,"code":"(fn [col]\n  (letfn [(tpmapfn [c] \n            (loop [i 0 v []] \n              (if (< i (count c)) \n                (recur (inc i) (conj v {(type (c i)) (c i)})) \n                v)))]\n    (let [tpmap (tpmapfn col)\n          gpset (into #{} (flatten (map keys tpmap)))\n          gpval (for [i gpset] (map #(% i) tpmap))]\n      (map (partial filter #(not= nil %)) gpval))))","user":"5243e37ae4b076204b44fae3"},{"code":"(fn [s]\n   (partition-by type (sort-by #(str (type %)) s)))","problem":50,"user":"4f301d02e4b0d6649770a072"},{"problem":50,"code":"(fn homotype [a-seq]\n  (vals (group-by type a-seq)))","user":"580d2788e4b0849f6811b730"},{"code":"#(map reverse (vals (loop [r {}\n              c %1]\n             (if (empty? c)\n                 r \n               (recur (assoc r (type (first c)) (conj (get r (type (first c))) (first c))) (rest c))))))","problem":50,"user":"511b810ce4b07ab9ec456182"},{"problem":50,"code":"(fn [s]\n    (loop [s s\n           by-type {}]\n      (if (empty? s) (set (vals by-type))\n          (let [item (first s)\n                item-type (type item)\n                cur-vec (get by-type item-type [])]\n            (recur \n             (rest s)\n             (assoc by-type item-type (conj cur-vec item)))\n            ))))","user":"57fc0719e4b0d3187e900987"},{"code":"(fn [xs]\n  (->>  xs\n      (group-by #(.getClass %) ,)\n      (vals ,)))","problem":50,"user":"4e593dac535d8a8b8723a29c"},{"problem":50,"code":"(fn [coll]\n  ;; seeing the other solutions, I feel dumb.\n    (vals (reduce (fn [acc item] (assoc acc\n                                        (class item)\n                                        (if (contains? acc (class item))\n                                          (conj (acc (class item)) item)\n                                          [item])))\n                  {} coll)))","user":"51b91b08e4b0e871ca4958f8"},{"problem":50,"code":"(fn[coll]\n        (loop [[head & tail] coll res {}]\n          (if (nil? head)\n            (into #{} (vals res))\n            (let [t (type head)]\n              (recur tail \n                     (assoc res t (conj (get res t []) head)))))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":50,"code":"(fn [col] (vals (group-by #(type %) col)))","user":"5ec25800e4b00a66d4a9529b"},{"problem":50,"code":"#(set (map vec (vals (reduce (fn [x y] (let [t (keyword (str (type y)))] \n          (assoc x t (conj (vec (t x)) y)))) {} %))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":50,"code":"(fn split-by-type [coll]\n           (map second (group-by type coll)))","user":"5e3975a3e4b01d43a70e8dd3"},{"problem":50,"code":"(fn [xs] (partition-by (fn [x] (= (type x) (type (first xs)))) (sort-by (fn [x] (-> x type str)) xs)))","user":"53dfd77fe4b0d874e779ae45"},{"code":"#(vec (vals (group-by type %)))","problem":50,"user":"538b1644e4b0640c7a9a58c0"},{"problem":50,"code":"(fn [s] (vals (reduce #(update-in %1 [(class %2)] (fnil conj []) %2) {} s)))","user":"5590e55de4b0277789237676"},{"code":"(fn [s] (into #{} (vals (group-by type s))))","problem":50,"user":"4fa09916e4b0dcca54ed6d4e"},{"problem":50,"code":"(fn [sq]\n  (map second (seq (group-by type sq))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":50,"code":"(fn [sequ]\n  (vals (group-by class sequ)))","user":"5be0b916e4b0ed4b8aab4c8f"},{"code":"(fn [c]\n  (vals (group-by class c)))","problem":50,"user":"4eb27fad535d7eef3080734a"},{"problem":50,"code":"(fn [s]\n  (loop [remaining s table (hash-map)]\n    (if (empty? remaining)\n      (for [kv table] (second kv))\n      (if (contains? table (class (first remaining)))\n        (recur (rest remaining) (update-in table [(class (first remaining))] conj (first remaining)))\n        (recur (rest remaining) (conj table [(class (first remaining)) [(first remaining)]]))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn [xs] (partition-by type (map first (sort-by second (map #(vector (identity %) ((comp str type) %)) xs)))))","problem":50,"user":"513d121fe4b0e544971636a2"},{"code":"(fn [coll]\n    (letfn [(group-coll-by [f coll]\n                           (let [vals (distinct (map f coll))]\n                             (reduce conj [] (map (fn [v] (filter #(= v (f %)) coll))  vals) )))]\n      (group-coll-by type coll)))","problem":50,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":50,"code":"(fn [xs]\n  (loop [acc #{}\n         s xs]\n    (if (seq s)\n        (recur (conj acc (filterv #(= (type (first s)) (type %)) s))\n               (filter #(not= (type (first s)) (type %)) (rest s)))\n        acc)))","user":"51316a63e4b0431ba07e7feb"},{"problem":50,"code":"(fn split-by-type [coll] \n  (->>\n   (reduce (fn [acc el] \n             (if (contains? acc (type el))\n               (assoc acc (type el) (conj (get acc (type el)) el))\n               (assoc acc (type el) [el]))) {} coll)\n   (vals)))","user":"5df75fd8e4b0a607a9a45c92"},{"problem":50,"code":"(fn [xs]\n  (vals\n   (reduce\n    #(let [type-key (type %2)]\n       (assoc %1 type-key (conj (get %1 type-key []) %2)))\n    {} xs)))","user":"54e79094e4b024c67c0cf818"},{"problem":50,"code":"(fn [x] (into #{} (vals (group-by class x))))","user":"53d5d24de4b0e771c302544a"},{"code":"(fn [args]\n  (loop [cur-args args\n         cur-results {}]\n    (if (empty? cur-args)\n      (vals cur-results)\n      (let [arg (first cur-args)]\n        (recur (rest cur-args) (merge-with concat cur-results {(type arg) [arg]}))))))","problem":50,"user":"4f841b23e4b033992c121c29"},{"problem":50,"code":"(fn [sq] (loop [ind 0 res {}] (if (= ind (count sq)) (vals res) (if (contains? res (type (nth sq ind))) (recur (inc ind) (assoc res (type (nth sq ind)) (conj (get res (type (nth sq ind))) (nth sq ind)))) (recur (inc ind) (assoc res (type (nth sq ind)) [(nth sq ind)]))))))","user":"5a527c16e4b05d388ecb6bff"},{"problem":50,"code":"(fn split-type [sqnc]\n  (for [[key value] (group-by type sqnc)]\n    value))","user":"56a3c89ae4b0542e1f8d14cf"},{"problem":50,"code":"(fn [xs] (set (map #(second %) (group-by type xs))))","user":"59ff9424e4b01bb0ae8afd24"},{"problem":50,"code":"(fn [v]\n  ((fn split [v m]\n     (if (empty? v) (vals m)\n         (let [cur (first v)]\n           (split (rest v) (assoc m (type cur) (vec (conj (m (type cur)) cur))))))) v {}))","user":"58f98231e4b0438e51c2cf4c"},{"problem":50,"code":"(fn groupbytest [xs] \n  (vals (group-by type xs)))","user":"59afe4bae4b0e1f4e384c8c0"},{"code":"(fn [s] (map val (group-by class s)))","problem":50,"user":"52655949e4b03e8d9a4a710b"},{"code":"(fn [x] (vals (group-by #(type %) x)))","problem":50,"user":"50d4c626e4b09cc622d65a70"},{"problem":50,"code":"(fn [alist]\n  (partition-by\n   #(count (str (type %)))\n   (sort-by #(count (str (type %))) alist)))","user":"5705e404e4b0b0fb43fd0676"},{"problem":50,"code":";;Now i am creating a map with types as keys and element as values\n;;example map = {int [1 2 3] string [\"siva\" \"sai] coll [[1 2] [2 3]]}\n;;after creating this i just simply asking values of map\n;;then it will shows output '( [1 2 3] [\"siva\" \"sai\"] [[1 2] [2 3]])\n\n(fn split-by-type1 [xcoll]\n  (vals (loop [coll xcoll\n               newmap {}]\n          (if (empty? coll)\n            newmap\n            (recur (next coll) (let [element (first coll)\n                                     mapkey (type element)\n                                     mapval (newmap mapkey)]\n                                 (if (= true  (contains? newmap mapkey))\n                                   (assoc newmap mapkey (conj mapval element))\n                                   (assoc newmap mapkey [element]))))))))","user":"56038f34e4b04bb52996e1bc"},{"code":"(fn [sets] (set (map (fn [[key, val]] (into [] (reverse val)))\n (reduce (fn [y [type, x]] (assoc y type (cons x (y type)))) {} \n        (map (fn [x] [(type x) x]) sets)))))","problem":50,"user":"525dd767e4b0cb4875a45d88"},{"problem":50,"code":"(fn [xs] (filter (complement empty?) (map #(filter % xs) [number? string? keyword? coll?])))","user":"54187e84e4b01498b1a71a1b"},{"problem":50,"code":"(fn [xs]\n   (vals \n     (reduce (fn [m e] \n                 (let [t (type e) \n                       ys (m t [])] \n                  (assoc m t (conj ys e))))\n           {} xs)))","user":"5ce05561e4b0a17bb84e2b08"},{"problem":50,"code":"(fn[l] (vals (group-by type l )))","user":"5ed6030de4b016b56eae05db"},{"code":"(fn split-by-type [coll]\n  (if (empty? coll)\n    []\n    (let [t (type (first coll))\n          a (filter #(= t (type %)) coll)\n          b (filter #(not= t (type %)) coll)]\n      (concat (list a) (split-by-type b)))))","problem":50,"user":"536254a5e4b0243289761e50"},{"problem":50,"code":"(fn [xs] \n  (set (vals (group-by type xs))))","user":"5e41a67be4b01d43a70e8e56"},{"problem":50,"code":"(fn [coll]\n  (vals (group-by type coll))\n  )","user":"56f73913e4b08e7d20b9682d"},{"code":"(fn split-by-type [coll]\n  (vals (reduce (fn [bytype, item]\n                  (update-in bytype\n                             [(type item)]\n                             (fnil #(conj % item) [])))\n                {} coll)))","problem":50,"user":"4dada426c9a9d6ed2a99dc57"},{"problem":50,"code":"(fn [coll]\n  (map second\n    (group-by type coll)))","user":"5a4caa20e4b05d388ecb6b94"},{"code":"(fn [x] (partition-by type (sort #(compare (str (type %1)) (str (type %2))) x)))","problem":50,"user":"50981062e4b04e098a4c7268"},{"problem":50,"code":";(fn sort-by-type [coll]\n;  (set (vals (reduce  (fn [sorted el] \n;                        (let [type (class el)\n;                              type-members (sorted type)\n;                              new-type-members (conj (if type-members type-members []) el)]\n;                          (assoc sorted type new-type-members))) {} coll))))\n\n; #(set (vals (group-by class %)))\n#(-> % ((partial group-by class)) vals set)","user":"59837909e4b021a7a535fe16"},{"problem":50,"code":"(fn [coll]\n   (map (fn [[k v]] v)  (group-by #(type %) coll)))","user":"5ce36e02e4b0a17bb84e2b3e"},{"problem":50,"code":"#(into [] (vals (group-by type %)))","user":"567e6d24e4b0feffd0d18eb4"},{"problem":50,"code":"(fn [c]\n  (let [t-fn (fn type-c [x]\n               (let [t (type x)]\n                 (cond\n                  (= t clojure.lang.Keyword) 1\n                  (= t java.lang.Long) 2\n                  (= t clojure.lang.PersistentVector) 3\n                  (= t java.lang.String) 4)))]\n    ((comp set (partial partition-by t-fn) (partial sort-by t-fn)) c)))","user":"58fc52cee4b0438e51c2cf95"},{"problem":50,"code":"(fn [coll1]\n  (map\n    (fn [pair]\n      (reverse (second pair)))\n    ((fn [c]\n      (reduce \n        #(assoc %1 \n          (type %2) \n          (conj (%1 (type %2)) %2)) \n        {} \n       \tc))\n      coll1)))","user":"5a0ef454e4b04bbd27e6d9fa"},{"code":"(fn\n  [mySeq]\n  (->> \n   mySeq \n   (group-by type)\n   vals\n  )\n)","problem":50,"user":"5162757ee4b03cfa3774b3fe"},{"code":"(fn -split-by-type [s]\n  (vals (group-by class s)))","problem":50,"user":"4ed2a31c535d44c135fd68db"},{"problem":50,"code":"(fn [liste] (vals (group-by type liste)))","user":"556f2009e4b09a3098a52519"},{"code":"(fn [coll]\n        (vals (group-by type coll)))","problem":50,"user":"4e964f4a535dbda64a6f6b42"},{"code":"(fn [xs]\n  (->> xs\n    (reduce #(assoc % (class %2) (conj (% (class %2) []) %2)) {})\n    (vals)))","problem":50,"user":"507a396be4b08327cd804a69"},{"code":"#(set ( vals (group-by type %)))","problem":50,"user":"4f951375e4b0dcca54ed6cc8"},{"problem":50,"code":"#(loop [tps (set (map (fn [x](type x)) %))\n        res []]\n  \t(if (empty? tps) res\n      (recur  (rest tps)\n              (conj res (filter\n                          (fn[x] (= (first tps) (type x)))\n                          % )) )))","user":"57f253a3e4b0511f1d294dea"},{"problem":50,"code":"#(loop [s % m {}] (if (empty? s) (vals m) (recur (rest s) (if (m (-> s first type)) (update-in m [(-> s first type)] conj (first s)) (assoc m (-> s first type) [(first s)])))))","user":"54a1f494e4b09f271ff37c52"},{"problem":50,"code":"(fn type-split [S]\n\t(loop [[x1 & xrest :as X] S, out {}]\n\t\t(if (seq X)\n\t\t\t(let [typ (type x1) cont (get out typ [])]\n\t\t\t\t(recur xrest (conj out [typ (conj cont x1)])))\n\t\t\t(vals out))))","user":"564d02cde4b0284900eef679"},{"code":"(fn splittype [l]  (map (fn [x] (filter #(= (type %)  x  ) l) ) (set (map type l)))         )","problem":50,"user":"4f4be1cae4b03ad3f0c10c81"},{"problem":50,"code":"#(for [ t (set (map type %))]\n   (vec (filter (fn [x] (= t (type x))) %)))","user":"5cbd5b42e4b026601754b9f6"},{"problem":50,"code":"(fn [data]\n   (->> data\n        (reduce (fn [acc val]\n                  (let [type (-> val class str)]\n                    (if (contains? acc type)\n                      (merge acc (hash-map type (conj (get acc type) val)))\n                      (assoc acc type [val]))))\n                {})\n        (vals)\n        (set)))","user":"5adf63a7e4b0837691e92c34"},{"problem":50,"code":"(fn\n  [coll]\n  (->> coll\n       (reduce\n        (fn [acc elem]\n          (update-in\n            acc\n            [(type elem)]\n            (fn [old arg] (conj (or old []) arg))\n            elem))\n        {})\n       (map val)))","user":"59f4c42ce4b0966464fe6ab6"},{"code":"(fn [a]\n  (into #{}\n        (map val\n             (apply (partial merge-with concat)\n                    (map #(hash-map (type %) [%]) a)))))","problem":50,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":50,"code":"(fn [lst]\n  (map\n    (fn [type]\n      (filter (fn [x] (= (class x) type))\n              lst))\n    (distinct (map class lst))))","user":"4e8a170c535d3e98b802328f"},{"problem":50,"code":"(fn [coll]\n  (loop [coll1 coll\n         res  {}]\n    (if (zero? (count coll1))\n      (reduce #(conj %1 (second %2)) [] (seq res))      \n      (let [item      (first coll1)\n            type-item (type item)\n            val       (res type-item)]\n        (if val\n          (recur (drop 1 coll1) (assoc res type-item (conj val item)))\n          (recur (drop 1 coll1) (assoc res type-item [item])))))))","user":"56372c3ce4b0bfe05bf117d1"},{"code":"(fn by-type [s]\n  (if (empty? s) nil\n    (let [head (first s)\n          typ (type head)\n          pred #(= (type %) typ)]\n      (apply list (filter pred s) (by-type (filter (complement pred) s))))))","problem":50,"user":"5119f3d5e4b06c8af0111818"},{"code":"(fn [v]\n   (map second (group-by class v))\n   )","problem":50,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"#(apply concat (map rest (group-by type %)))","problem":50,"user":"537e4259e4b06839e8705e9e"},{"problem":50,"code":"(fn [coll]\n(loop [l coll o {}]\n  (if (empty? l)\n    (set (vals o))\n    (let [f (first l) c (.getClass f)]\n      (recur (rest l) (assoc o c\n                             (if-let [v (get o c)]\n                               (conj v f)\n                               (vector f))))))))","user":"5f86a98be4b0649ffcda4caa"},{"code":"(fn [x] (map \n         (fn [t] (filter #(= (type %1) t) x)) \n           (set (map type x))))","problem":50,"user":"504ffa26e4b0a02f9cffdead"},{"code":"(fn split [seq]\n  (vals (reduce (fn [result-map item]\n            (let [item-type (type item)]\n              (if (contains? result-map item-type)\n                (assoc result-map item-type (conj (get result-map item-type) item))\n                (assoc result-map item-type [item])\n                )))\n          {}\n          seq)))","problem":50,"user":"52d51535e4b09f7907dd133a"},{"problem":50,"code":"(fn [grid]\n   ((fn tsplit [one two three mapped]\n     (let [t (first mapped)]\n       (cond \n        (nil? t) (cond (= 0 (count three)) #{one two}\n                :else #{one two three})\n        (keyword? t) (tsplit (conj one t) two three (rest mapped))\n        (vector? t) (tsplit one two (conj three t) (rest mapped))\n         :else (tsplit one (conj two t) three (rest mapped)))))\n   (vector) (vector) (vector) grid))","user":"53a5c7ffe4b0ef122a8689c4"},{"problem":50,"code":"(fn [s]\n  (let [types (into #{} (map type s))]\n    (map (fn [t] (filter #(= t (type %)) s)) types)))","user":"5e909685e4b0cb016954634d"},{"problem":50,"code":"(fn split-by [coll] (map second (group-by type coll)))","user":"5614fa1de4b05f002753dfbe"},{"problem":50,"code":"(fn [ls] (set (map second (group-by type ls))))","user":"547584d9e4b0c51c1f4d729b"},{"problem":50,"code":"(fn [s] (vals (group-by class s)))","user":"558bdcefe4b0277789237633"},{"problem":50,"code":"(fn [xs]\n  (->> xs\n       (reduce #(let [k (type %2)]\n                  (assoc %1 k (conj (get %1 k []) %2)))\n               {})\n       (vals)))","user":"52d95491e4b09f7907dd13a4"},{"code":"(fn [s] (filter (fn [r] (seq r))((juxt\n  #(filter (fn [v] (keyword? v)) %)\n  #(filter (fn [v] (number? v)) %)\n  #(filter (fn [v] (string? v)) %)\n  #(filter (fn [v] (vector? v)) %)) s)))","problem":50,"user":"5063fe48e4b075d771da6f9e"},{"problem":50,"code":"(fn [s] (map (fn [x] (map second x)) (map second (group-by first (map #(list (type %) %) s)))))","user":"53e76bb2e4b036ad0777e47d"},{"problem":50,"code":"(fn typeSplit [x] (set (vals (group-by type x))))","user":"548f3ee4e4b0e286459a1237"},{"problem":50,"code":"(fn [v]\n  (set (vals (group-by class v))))","user":"5b0b8d29e4b0cc2b61a3bdd7"},{"problem":50,"code":"(fn [xs]\n  (for [t (distinct (map type xs))]\n    (filter #(= t (type %)) xs)))","user":"547ad587e4b0c51c1f4d72ce"},{"problem":50,"code":"(fn [xs]\n\n (into #{} \n\n    (for \n\n      [[k v] (group-by type xs)]\n\n      v)))","user":"57487084e4b009280f9f2b8c"},{"code":"; I did this before I got to the chapter on vals in Programming Clojure.\n(fn [s]\n\t(filter not-empty\n\t\t(for [type [java.lang.String\n\t\t\t\t\tclojure.lang.Keyword\n\t\t\t\t\tjava.lang.Long\n\t\t\t\t\tclojure.lang.PersistentVector]]\n\t\t\t(filter #(= type (class %)) s))\n    )\n)","problem":50,"user":"5201ff99e4b0b2e020a18f26"},{"code":"(fn [ss] \n  (map #(for [x ss\n        :when (= (type x) (type %))]\n    x) ss))","problem":50,"user":"53973e7be4b0b51d73faaee6"},{"problem":50,"code":"#(->> % \n      (group-by (fn [e] (class e)))\n      (vals)\n      )","user":"60471241e4b02d28681c77c9"},{"code":"#(partition-by type (sort (fn [a b] (compare (str (type a))(str (type b)))) %1))","problem":50,"user":"51da52dbe4b02ceefd947763"},{"code":"(fn [f] (map #(vec (last %)) (group-by type f)))","problem":50,"user":"4f15de56535d64f603146448"},{"code":"(fn [l] \n   (remove empty? (map \n    (fn [filt] \n      (filterv filt l)) \n    (list number? string? vector? keyword?))))","problem":50,"user":"52eee533e4b05e3f0be25ecb"},{"code":"#(-> (group-by type %) vals set)","problem":50,"user":"5033a1fbe4b062bc5d7ae155"},{"code":"(fn split-by-type [v]\r\n  (for [[key value] (group-by class v)]\r\n    value))","problem":50,"user":"4f7d25b4e4b06e829148e1ba"},{"problem":50,"code":"(fn [coll]\n  (for [[k v] (group-by type coll)] v))","user":"55c0afa5e4b01b9910ae2a27"},{"code":"#(map (fn[[k v]]v) (group-by class %))","problem":50,"user":"51b41150e4b0f094dd986fac"},{"problem":50,"code":"(fn f [coll]\n  (if (seq coll)\n    (let [t #(= (type (first coll)) (type %))]\n      (cons (filter t coll) (f (remove t coll))))\n    nil))","user":"59d8f23ae4b0ef0a1e9b5c49"},{"code":"(fn [lst] (set (map #(filter (fn [typ] (instance? % typ)) lst) (set (map type lst)))))","problem":50,"user":"508b95a0e4b0be79e5b189c6"},{"code":"#(->> % (group-by type) (map last) set)","problem":50,"user":"5199ca05e4b022efe2b3ba88"},{"problem":50,"code":"(fn part-by-groups [col]\n  (let [col-col (partition-by #(type %) col)]\n    (loop [m {} r col-col]\n    (if (empty? r)\n      (vals m)\n      (let [t (type (first (first r)))]\n       ;(println \"type=\" t \"map=\" m \"r=\" r) \n       (recur (if (contains? m t)\n                (assoc m t (into (get m t) (first r)))\n                (assoc m t (into [] (first r)))\n                )           \n             (rest r))\n      ))\n    ))\n  )","user":"5c9b848fe4b048ec896c5acf"},{"code":"(fn [xs]\r\n            (vals (reduce #(let [t (type %2)]\r\n                             (if (contains? %1 t)\r\n                               (assoc %1 t (conj (%1 t) %2))\r\n                               (assoc %1 t [%2]))\r\n                             ) {} xs)))","problem":50,"user":"4deb529a535d08e6dec9fe04"},{"code":"(fn [c]\n    (vals (group-by class c)))","problem":50,"user":"50fac9e3e4b07934dda8b0d1"},{"code":"(fn sbt [seq] (if (empty? seq) () \r\n  (cons (filter #(= (type %) (type (first seq))) seq)\r\n\t (sbt (filter #(not= (type %) (type (first seq))) seq)))))","problem":50,"user":"4f048f67535dcb61093f6bd3"},{"problem":50,"code":"(fn xx [s]\n  (letfn [(tt [v] (str (type v)))\n          (mymap [k v] (hash-map k [v]))\n          ]\n    (let [types (map tt s)]\n      (vals (apply merge-with concat (map mymap types s))))))","user":"57b35ecbe4b0fbc9809a277e"},{"problem":50,"code":"(fn merger [coll]\n  (->> coll\n       (map #(vector (type %) %))\n       (reduce\n         (fn [res-map [typ val]]\n           (assoc res-map typ\n             (conj (res-map typ []) val)))\n         {})\n       (vals)))","user":"5776e21de4b0979f89651642"},{"problem":50,"code":"(fn [xs]\n  (loop [my-map {}\n         my-xs xs]\n    (if (seq my-xs)\n      (let [val (first my-xs)\n            key (class val)\n            my-list (my-map key [])]\n        (recur (conj my-map {key (conj my-list val)}) (rest my-xs)))\n      (vals my-map))))","user":"540d7dd1e4b0addc1aec6713"},{"code":"(fn splitter [col]\n  (vals(group-by type col)))","problem":50,"user":"4f61be97e4b0defedf855fc5"},{"code":"(fn mt [a] \n(vals (group-by type a))\n)","problem":50,"user":"4e9de526535dbda64a6f6b8e"},{"code":"(fn [seq]\n  (map (fn [a] (map #(nth % 2) a))\n       (partition-by first\n                     (sort (map-indexed #(vector (str (type %2))\n                                                 %1\n                                                 %2)\n                                        seq)))))","problem":50,"user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn [s]\n  (let [vconj (fn [r x]\n                (if (empty? r) [x] (conj r x)))]\n    (loop [m {}\n           s s]\n      (cond\n        (empty? s) (vals m)\n        :else\n          (let [x (first s)]\n            (recur (update-in m [(type x)] vconj x)\n                   (rest s)))))))","problem":50,"user":"4f2b0951e4b0d6649770a045"},{"problem":50,"code":"(fn [a] (vals (reduce #(conj % [(type %2) (concat (% (type %2)) [%2])]) {} a)))","user":"542f574be4b0dad94371f2d0"},{"code":"(letfn [(I [x l] (= (type x) (type (first l))))\n        (M [x s]\n          (cond (empty? s) [[x]]\n                (I x (first s)) (conj (rest s) (conj (first s) x))\n                :else (conj (M x (rest s)) (first s))))]\n  (fn [ls]\n    (loop [ls ls result []]\n      (if (empty? ls) (set result)\n          (recur (rest ls) (M (first ls) result))))))","problem":50,"user":"51a4416ae4b0def3c5c5868c"},{"problem":50,"code":"(fn [-seq]\n  (vals (group-by class -seq)))","user":"5ddb6151e4b0948ae9d9adb0"},{"problem":50,"code":"(fn [coll]\n  (vals \n   (reduce (fn [m [k v]] (update-in m [k] (fnil #(conj % v) []))) \n           {} \n           (map #(vector (type %) %) coll))))","user":"59074b7ce4b047aa04b19951"},{"problem":50,"code":"(fn [xs]\n  (map vec (partition-by type (sort-by #(.toString (type %)) xs))))","user":"5db35f85e4b010eb3c36cd22"},{"code":"(fn [a]\n  (vals (group-by type a)))","problem":50,"user":"525cc137e4b0cb4875a45d46"},{"code":"(fn [c] \r\n  (map\r\n    #(reduce (fn [c x] (conj c (second x))) [] %)\r\n    (vals (group-by first (map #(vector (type %) %) c)))))","problem":50,"user":"4facff22e4b081705acca230"},{"problem":50,"code":"#(set (vals (group-by type  %)))","user":"56504dc2e4b0284900eef6bc"},{"problem":50,"code":"(fn [xs]\n    (vals (group-by type  xs)))","user":"505223fae4b0a561d07d8f17"},{"problem":50,"code":"(fn [coll]\n  (let [x #(str(type %))]\n    (partition-by x (sort-by x coll))))","user":"55933c7ae4b0c79f6e1db938"},{"problem":50,"code":"#(for [[_ value] (group-by class %)]\n   value)","user":"56047160e4b0c80df0ca265d"},{"problem":50,"code":"(fn [& args] (vals (apply group-by type args)))","user":"5492164ee4b0b312c081ff3e"},{"problem":50,"code":"(fn split-types[xs]\n  (vals\n  (reduce\n    (fn [types x]\n      (merge-with into types {(type x) [x]})\n    )\n   \t{}\n    xs\n  ))\n)","user":"5cb0f70ce4b026601754b8c1"},{"problem":50,"code":"#(->> %\n  (group-by type)\n  (vals))","user":"5bd7b8b8e4b0ed4b8aab4bc6"},{"code":"(fn sp[c]\r\n  (vals (group-by #( type %) c))\r\n  )","problem":50,"user":"4e9def6b535dbda64a6f6b8f"},{"problem":50,"code":"(fn [values]\n  (vals (reduce (fn [temp value]\n                  (let [k (class value)\n                        l (get temp k [])new-list (conj l value)]\n                    (assoc temp k new-list)))\n                {}\n                values)))","user":"5463c824e4b01be26fd746c5"},{"code":"(fn [coll]\n  (->> (group-by type coll)\n       vals\n       set))","problem":50,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":50,"code":"(fn [vs] (->> vs (group-by type) (map second)))","user":"5796d3ebe4b039eba2ecb0ee"},{"code":"(fn [l] (partition-by class (sort-by #(str (class %)) l)))","problem":50,"user":"4eb2eae5535d7eef30807351"},{"code":"(fn [ls]\r\n  (loop [an #{} ls ls]\r\n    (if (empty? ls)\r\n      an\r\n      (let [f (first ls)\r\n            fs (filter #(= (type f)\r\n                           (type %)) ls)\r\n            rs (remove #(= (type f)\r\n                           (type %)) ls)]\r\n        (recur (conj an fs) rs)))))","problem":50,"user":"4dd62278535d2dad7130b5c7"},{"problem":50,"code":"#(-> (group-by type %) vals )","user":"5cfee28de4b0cc9c91588185"},{"problem":50,"code":"#((comp (partial apply hash-set) vals) (group-by type %))","user":"56c560ede4b05cc29241eea6"},{"problem":50,"code":"(fn [s] (->> s (sort-by (comp str type)) (partition-by type) (map  #(apply vector %))))","user":"53ced9fee4b00fb29b2212f8"},{"code":"(fn split [coll]\n  (vals (reduce\n    (fn [m n]\n\t  (assoc m (type n) (conj (get m (type n) []) n))\n\t)\n\t{}\n\tcoll)))","problem":50,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [xs]\n    (vals (group-by #(type %) xs))\n  )","problem":50,"user":"52430d3ce4b076204b44faa5"},{"code":"#(vals (reduce \n        (fn [a b] \n          (let [t (type b)] \n            (if (nil? (a t))\n              (assoc a t [b])\n              (assoc a t (conj (a t) b))))) {} %))","problem":50,"user":"511ac2ede4b0c87c59c9670f"},{"code":"(fn [coll]\r\n    (vals (reduce (fn [a b]\r\n                    (update-in a [(type b)] #(conj (vec %1) b))) {} coll)))","problem":50,"user":"4dd61f98535d2dad7130b5c6"},{"problem":50,"code":"(fn [xs]\n (vals (group-by #(type %) xs)))","user":"57ed8315e4b0bfb2137f5b9a"},{"problem":50,"code":"#(loop [rl % tmap (hash-map) ]\n            (let [head-type (type (first rl))]\n              (if (not (empty? rl))\n                (recur (rest rl) (assoc tmap head-type (cons (first rl) (tmap head-type))))\n                (map reverse (vals tmap)))))","user":"5831846ae4b051871117c02c"},{"code":"#(vals (group-by (fn [e] (class e)) %))","problem":50,"user":"516385cee4b055933a9ca02d"},{"problem":50,"code":"(fn group-by-type\n  [xs]\n  (->> xs\n       (group-by type)\n       vals))","user":"5e952e17e4b0fbed045a3807"},{"problem":50,"code":"(fn [coll] (vals\n  (reduce\n     #(assoc %1 (class %2) (conj (get %1 (class %2) []) %2))\n     {}\n     coll)))","user":"53f642e4e4b0db01ade6f9db"},{"code":"(fn f [x]\n  (letfn [(solve [m item]\n  (let [t (type item)]\n    (if (contains? m t)\n      (update-in m [t] #(conj % item))\n      (assoc-in m [t] [item]))))]\n    (vals (reduce solve {} x))))","problem":50,"user":"5302ac7fe4b0d8b024fd3731"},{"code":"(fn [c] (set (vals (loop [col c temp {}] (if (empty? col) temp\r\n          (recur (rest col) \r\n          (if (nil? (temp (type (first col))))\r\n          (assoc temp (type (first col))  (vector (first col) )) (assoc temp (type (first col)) (conj (temp (type (first col))) (first col) ) )     \r\n)))))))","problem":50,"user":"50463347e4b011c5dfee771e"},{"code":"(fn [col]\n  (vals (group-by #(type %) col)))","problem":50,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":50,"code":"(fn [coll] (vals (group-by #(type % ) coll)))","user":"51e7c1f1e4b0a3e081b8cbef"},{"code":"(fn [coll]\r\n  (vals (group-by type coll)))","problem":50,"user":"4dfe65a1535d04ed9115e787"},{"problem":50,"code":"(fn\n   [coll]\n   (map (fn [[_ v]] v) (group-by type coll)))","user":"60631c2ee4b069485764ddbd"},{"problem":50,"code":"(fn [coll]\n  (vals (reduce #(assoc \n             %1 \n             (class %2) \n             (vec (conj (%1 (class %2))\n                   %2))\n             ) {} coll)))","user":"580a0783e4b0a837a8b30d2c"},{"problem":50,"code":"(fn [args]\n  (-> (group-by type args) vals)\n  )","user":"525d490ae4b0cb4875a45d70"},{"code":"#(loop [x %1 y []]\n                  (if-not (empty? x)    \n                                (recur \n                                 \t (filter (fn [u] (not= (class u) (class (first x)))) x) \n                                     (conj y (filter (fn [u] (= (class u) (class (first x)))) x))   \n                                 )            \n                                 y\n                                              ))","problem":50,"user":"5105ed16e4b01150e115ebe2"},{"code":"(fn st [s]\n  (vals (group-by type s)))","problem":50,"user":"4f611127e4b0defedf855fb4"},{"problem":50,"code":"(fn split-by-type\n  [coll]\n  (for [ty (set (map class coll))]\n    (filter #(= (class %) ty) coll)))","user":"56c3aca0e4b05cc29241ee90"},{"problem":50,"code":"(fn [v]\n   (map last (group-by type v)))","user":"51db0d99e4b06aa4d4669a9d"},{"code":"#(for [[key values] (group-by type %)] values)","problem":50,"user":"51ba4482e4b0fe3ecfb4642b"},{"problem":50,"code":"(fn a[x](vals (group-by #(type %) x)))","user":"5fe09d1fe4b05ac5b16ea15b"},{"code":"(fn [col]\n  (loop [result [] init-col col]\n    (prn (str \"init-col:\" init-col ))\n    (prn (str \"result:\" result ))\n    (if(empty? init-col)\n      result\n      (let [tipo (type (first init-col) )]\n        (recur (conj result (filter #(= (type %) tipo ) init-col ) )\n                (remove #(= (type %) tipo ) init-col )\n        )\n      )\n    )\n  )\n)","problem":50,"user":"4e94addc535dbda64a6f6b21"},{"problem":50,"code":"#(remove empty?\n           (list (filter number? %)\n                 (filter keyword? %)\n                 (filter coll? %)\n                 (filter string? %)))","user":"57035ccfe4b08d47c97781ef"},{"code":"#(for [[k v] (group-by type %)]\n     v)","problem":50,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":50,"code":"(fn [s]\n  (vals\n   (reduce\n    (fn [res e]\n      (update-in\n       res\n       [(type e)]\n       #(conj (vec %) e)))\n   {}\n   s)))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(fn [s]\r\n    (loop [c s r #{}]\r\n\t   (if (empty? c)\r\n\t       r\r\n\t       (recur (filter #(not= (class (first c)) (class %)) c)\r\n\t\t      (conj r (filter #(= (class (first c)) (class %)) c))))))","problem":50,"user":"4e821ca5535db62dc21a62c2"},{"code":"(fn [els]\n  (loop [els els\n         r   {}]\n    (if (empty? els)\n      (map reverse (vals r))\n      (recur\n        (rest els)\n        (update-in r [(class (first els))] #(conj % (first els)))))))","problem":50,"user":"50435852e4b034ff00315d22"},{"code":"(fn split-by-type [v]\n  (for [[key value] (group-by class v)]\n    value))","problem":50,"user":"50ae22c3e4b0a40c9cfb08d0"},{"code":"#(->> (group-by class %) (vals) (set))","problem":50,"user":"52016fd3e4b0b2e020a18f10"},{"problem":50,"code":"(fn [x]\n   (map second (group-by class x)\n       ))","user":"50b25edae4b03ea88043355e"},{"code":"(fn [coll]\n   (partition-by #(type %)\n                 (sort\n                  (comparator\n                   (fn [x y]\n                     (let [x (.length (.toString (type x)))\n                           y (.length (.toString (type y)))]\n                       (< x y ))))\n                  coll))\n   )","problem":50,"user":"52b2d16ae4b0c58976d9acf8"},{"code":"(fn split-by-type [lst]\n    (filter not-empty [\n      (filter vector? lst)\n      (filter list? lst)\n      (filter string? lst)\n      (filter symbol? lst)\n      (filter keyword? lst)\n      (filter integer? lst)\n    ])\n)","problem":50,"user":"4ed87228535d10e5ff6f52fa"},{"code":"#(letfn [\n  (split-by-type [s m]\n    (if (empty? s)\n      m\n      (let [f (first s) k (type f)]\n        (recur (rest s) (assoc m k (conj (get m k []) f))))))]\n  (vals (split-by-type % {})))","problem":50,"user":"4e8f4f64535d65386fec2149"},{"problem":50,"code":"(fn [xs]\n  (loop [ys xs mp {}]\n    (if (empty? ys)\n      (vals mp)\n      (let [[y & ys'] ys\n            clazz (class y)\n            zs (find mp clazz)\n            zs' (if (nil? zs)\n                  [y]\n                  (conj (into [] (second zs)) y))\n            mp' (dissoc mp clazz)\n            mp'' (assoc mp' clazz zs')]\n        (recur ys' mp''))))\n  )","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn split- [coll]\n  (vals (group-by type coll)))","problem":50,"user":"4e5eb843535d8a8b8723a2d4"},{"code":"(fn [s]\n      (vals (group-by #(cond (number? %) 1\n                         (string? %) 2\n                         (keyword? %) 3\n                         (vector? %) 4\n                         :else 5)\n                  s))\n    )","problem":50,"user":"5029fccee4b023940c84aa47"},{"problem":50,"code":"(fn mysplit\n  [s]\n  (let [types (distinct (map type s))]\n    (loop [[this-type & remaining-types] types\n           res #{}]\n      (if (nil? this-type)\n        res\n        (recur remaining-types (conj res (filter #(= this-type (type %)) s)))))))","user":"5f5df0bfe4b02876ed9fcfeb"},{"problem":50,"code":"(fn split-by-type\n  [sequence]\n  (let [classes\n        (keys (group-by class sequence))]\n    ;; get a list of the classes of the elements in the sequence, in order of appearance\n    (for [class-type classes]\n      (filter #(= class-type (class %)) sequence))))","user":"55a9e0fee4b0988bba2ad945"},{"problem":50,"code":"(fn answer [x] (vals (group-by type x)))","user":"53ef235de4b0d648e757f4d4"},{"problem":50,"code":"(fn [col] (->> col (group-by type) (map val)))","user":"5f0e8312e4b0f30dddfb5d5b"},{"problem":50,"code":"(fn [col]\n  (->> (sort-by #(str (type %)) col)\n       (partition-by type)))","user":"5d28d935e4b092dab7f59c88"},{"code":"(fn split [x] (filter #(not (empty? %)) (list (filter number? x) (filter keyword? x) (filter vector? x) (filter string? x))))","problem":50,"user":"528b9efee4b0239c8a67aea0"},{"problem":50,"code":"(fn splitTypeX [x] (map #(into (empty x) %) (vals (group-by #(type %) x))))","user":"568820e8e4b0dcc4269f4067"},{"problem":50,"code":"(fn [s] (vals (group-by #(type %) s)))","user":"5cab33e7e4b048ec896c5c48"},{"code":"(fn split-by-type [s]\n  (vals (reduce\n         #(let [ t (type %2)]\n            (assoc %1 t (conj (%1 t []) %2))) {} s)))","problem":50,"user":"4ec28d86535dfed6da9c6dbc"},{"problem":50,"code":"(fn [coll] (vals (reduce #(assoc %1 (type %2) (conj (get %1 (type %2) []) %2)) {} coll)))","user":"53b71b94e4b047364c0444cd"},{"problem":50,"code":"(fn split-at-type [col]\n  (vals (reduce \n         (fn add-to-type-map [type-map element]\n          (let [current-type (type element) type-entry (get type-map current-type []) new-entry (conj type-entry element)] \n            (assoc type-map (type element) new-entry)))\n         {} col)))","user":"6031926ae4b0d5df2af222ac"},{"problem":50,"code":"#(vals\n  (reduce\n   (fn [acc v]\n     (let [t (type v)\n           m (acc t [])]\n       (assoc acc t (conj m v))))\n   {}\n   %))","user":"6051bcfae4b056659d634203"},{"problem":50,"code":"(fn seg [xs]\n  (let [ts (distinct (map type xs))]\n    (map #(filter (fn [x] (= % (type x))) xs) ts)))","user":"59708e38e4b01722bebd4c65"},{"problem":50,"code":"(fn [v]\n  (vals (group-by #(type %) v)))","user":"56d4b22de4b0ea9b8538f7bb"},{"problem":50,"code":"(fn [v] (map second (group-by type v)))","user":"5addadfce4b0837691e92c13"},{"problem":50,"code":"(fn [lst]\n  (let [types (set (map type lst))]\n    (set (map (fn [t] (filter #(= t (type %)) lst))\n              types))))","user":"5733e4aee4b0cd1946bd0ffe"},{"problem":50,"code":"(fn split-by-type-optim\n  [collection]\n  (for [[key value] (group-by class collection)]\n    value))","user":"57596ba7e4b02ea11479931a"},{"code":"(fn [c]\n  (vals (group-by type c)))","problem":50,"user":"4ec12577535dfed6da9c6da8"},{"problem":50,"code":"(fn [list] (vals (group-by #(class %) list)))","user":"598d0dc3e4b02b9968b84d18"},{"problem":50,"code":"(fn [xs]\n  (filter first\n          [(into [] (filter vector? xs))\n           (into [] (filter number? xs))\n           (into [] (filter keyword? xs))\n           (into [] (filter string? xs))]))","user":"54d5fbe9e4b0a52adc2e2014"}]